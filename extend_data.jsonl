{"src": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class e {\n\tstatic final long MOD = (long)1e9+7;\n\tstatic int n;\n\tstatic long s;\n\tstatic long[] fs;\n\tstatic long[] invs;\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tinvs = new long[25];\n\t\tinvs[1] = 1;\n\t\tfor (int i = 2; i < invs.length; ++i)\n\t\t\tinvs[i] = (MOD - (MOD / i) * invs[((int) (MOD % i))] % MOD) % MOD;\n\t\tn = in.nextInt();\n\t\ts = in.nextLong();\n\t\tfs = new long[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfs[i] = in.nextLong();\n\t\tlong ans = genList(0, 1, 0);\n\t\tif(ans < 0) ans += MOD;\n\t\tSystem.out.println(ans);\n\t}\n\tstatic long genList(int idx, long c, long pow) {\n\t\tif(idx == n) {\n\t\t\tpow = s - pow;\n\t\t\tif(pow < 0)\n\t\t\t\treturn 0;\n\t\t\tlong choose = 1;\n\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\tchoose *= (pow+n-1-i) % MOD;\n\t\t\t\tchoose %= MOD;\n\t\t\t\tchoose *= invs[i+1];\n\t\t\t\tchoose %= MOD;\n\t\t\t}\n\t\t\treturn (c * choose) % MOD;\n\t\t}\n\t\tlong ans = 0;\n\t\tans += genList(idx+1, c, pow);\n\t\tans += genList(idx+1, -c, pow+fs[idx]+1);\n\t\treturn ans % MOD;\n\t}\n}", "label": 3}
{"src": "public class Main\n{\n\tstatic long mod=1000000007;\n\tstatic int maxn=30;\n\tstatic long[]f=new long[maxn+1],inv=new long[maxn+1];\n\tstatic void init() {\n\t\tf[0]=1;for(int i=1;i<=maxn;i++)f[i]=f[i-1]*i%mod;\n\t\tfor(int i=0;i<=maxn;i++)inv[i]=mpow(f[i],mod-2);\n\t}\n\tstatic long mpow(long a,long x) {\n\t\tif(x==0)return 1;\n\t\tlong t=mpow(a,x/2);\n\t\tif(x%2==0)return t*t%mod;\n\t\treturn t*t%mod*a%mod;\n\t}\n\tstatic long comb(long a,int b) {\n\t\tlong ans=1;\n\t\tfor(int i=0;i<b;i++) {\n\t\t\tans*=(a-i)%mod;\n\t\t\tans%=mod;\n\t\t}\n\t\tans*=inv[b];ans%=mod;\n\t\treturn (ans+mod)%mod;\n\t}\n\tstatic long ans;\n\tstatic int n;\n\tstatic long[]arr;\n\tstatic void dfs(int cur,long res,int mark) {\n\t\tif(cur==n) {\n\t\t\tans=(ans+mark*comb(res-1,n-1))%mod;\n\t\t\treturn;\n\t\t}\n\t\tif(res>arr[cur]+n)dfs(cur+1,res-arr[cur]-1,-mark);\n\t\tdfs(cur+1,res,mark);\n\t}\n\tpublic static void main(String[] args)\n\t{\n\t\tinit();\n\t\tjava.util.Scanner scan=new java.util.Scanner(System.in);\n\t\tn=scan.nextInt();\n\t\tlong s=scan.nextLong();\n\t\tarr=new long[n];\n\t\tfor(int i=0;i<n;i++)arr[i]=scan.nextLong();\n\t\tdfs(0,s+n,1);\n\t\tSystem.out.println((ans+mod)%mod);\n\t}\n}", "label": 3}
{"src": "import java.util.*;\n\npublic class devuflowers {\n\n\tpublic static long MOD = 1000000007L;\n\n\tpublic static long[] modInv;\n\n\tpublic static void main(String[] args) {\n\n\t\tmodInv = new long[21];\n\t\tmodInv[1] = 1;\n\t\tfor (int i=2; i<=20; i++)\n\t\t\tmodInv[i] = fastModExpo(i, MOD-2);\n\n\t\t// Get n and s.\n\t\tScanner stdin = new Scanner(System.in);\n\t\tint n = stdin.nextInt();\n\t\tlong sum = stdin.nextLong();\n\n\t\t// Read in each individual value.\n\t\tlong[] vals = new long[n];\n\t\tlong total = 0;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tvals[i] = stdin.nextLong();\n\t\t\ttotal += vals[i];\n\t\t}\n\n\t\t// Screen out this case.\n\t\tif (total < sum)\n\t\t\tSystem.out.println(0);\n\n\t\t// Do real work here.\n\t\telse {\n\n\t\t\t// Store subset sums here.\n\t\t\tlong[] subsumplusone = new long[1<<n];\n\n\t\t\tlong res = 0;\n\n\t\t\t// Run I/E here.\n\t\t\tfor (int i=0; i<(1<<n); i++) {\n\n\t\t\t\t// Set up sign for I/E.\n\t\t\t\tint sign = Integer.bitCount(i)%2 == 0 ? 1 : -1;\n\n\t\t\t\t// Set the sum of this subset.\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tint loc = 0;\n\t\t\t\t\twhile ((i & (1<<loc)) == 0) loc++;\n\t\t\t\t\tsubsumplusone[i] = subsumplusone[i-(1<<loc)] + vals[loc] + 1;\n\t\t\t\t}\n\n\t\t\t\t// Add in term.\n\t\t\t\tres = (res + sign*choosewithrep(sum-subsumplusone[i], n) + MOD)%MOD;\n\t\t\t}\n\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\t// Returns n+k-1 choose k-1.\n\tpublic static long choosewithrep(long n, int k) {\n\n\t\tif (n < 0) return 0;\n\n\t\t// Numerator.\n\t\tlong res = 1;\n\t\tfor (int i=1; i<k; i++)\n\t\t\tres = (res * ((n+k-i)%MOD))%MOD;\n\n\t\tfor (int i=2; i<=k-1; i++)\n\t\t\tres = (res*modInv[i])%MOD;\n\n\t\treturn res;\n\t}\n\n\tpublic static long fastModExpo(long base, long exp) {\n\t\tif (exp == 0) return 1L;\n\t\tif (exp%2 == 0) {\n\t\t\tlong tmp = fastModExpo(base, exp/2);\n\t\t\treturn (tmp*tmp)%MOD;\n\t\t}\n\t\treturn (fastModExpo(base, exp-1)*base)%MOD;\n\t}\n}", "label": 3}
{"src": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class e {\n\tstatic final long MOD = (long)1e9+7;\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tlong[] invs = new long[25];\n\t\tinvs[1] = 1;\n\t\tfor (int i = 2; i < invs.length; ++i)\n\t\t\tinvs[i] = (MOD - (MOD / i) * invs[((int) (MOD % i))] % MOD) % MOD;\n\t\tint n = in.nextInt();\n\t\tlong s = in.nextLong();\n\t\tlong[] fs = new long[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfs[i] = in.nextLong();\n\t\tArrayList<Term> ans = new ArrayList<>();\n\t\tArrayList<ArrayList<Term>> eqList = new ArrayList<>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tArrayList<Term> cur = new ArrayList<>();\n\t\t\tcur.add(new Term(1,0));\n\t\t\tcur.add(new Term(-1,fs[i]+1));\n\t\t\teqList.add(cur);\n\t\t}\n\t\tmultiply(ans, eqList, 0, new Term(1, 0));\n\t\tlong sum = 0;\n\t\tfor(Term t : ans) {\n\t\t\tlong pow = s - t.pow;\n\t\t\tif(pow < 0) continue;\n\t\t\tlong choose = 1;\n\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\tchoose *= (pow+n-1-i) % MOD;\n\t\t\t\tchoose %= MOD;\n\t\t\t\tchoose *= invs[i+1];\n\t\t\t\tchoose %= MOD;\n\t\t\t}\n\t\t\tsum += t.c * choose;\n\t\t\tsum %= MOD;\n\t\t}\n\t\tif(sum < 0) sum += MOD;\n\t\tSystem.out.println(sum);\n\t}\n\tstatic void multiply(ArrayList<Term> ans, ArrayList<ArrayList<Term>> list, int idx, Term current) {\n\t\tif(idx == list.size()) {\n\t\t\tans.add(current);\n\t\t\treturn;\n\t\t}\n\t\tfor(Term t : list.get(idx)) {\n\t\t\tTerm nt = new Term((t.c * current.c) % MOD, t.pow + current.pow);\n\t\t\tmultiply(ans, list, idx+1, nt);\n\t\t}\n\t}\n\tstatic class Term {\n\t\tlong c;\n\t\tlong pow;\n\t\tpublic Term(long c, long pow) {\n\t\t\tthis.c = c;\n\t\t\tthis.pow = pow;\n\t\t}\n\t}\n}", "label": 3}
{"src": "import java.util.Scanner;\n\npublic class E {\n\n    static int n;\n    static long MOD = 1_000_000_007;\n    static long LIM = MOD * MOD;\n\n    public static long modPower(long base, long exponent) {\n        long r = 1;\n        while (exponent > 0) {\n            if (exponent % 2 == 1)\n                r = (r * base) % MOD;\n            base = (base * base) % MOD;\n            exponent /= 2;\n        }\n        return r;\n    }\n\n    public static long C(long n, long k) {\n        if (n - k < k)\n            return C(n, n - k);\n        long r = 1;\n        for (long i = n; i > n - k; i--)\n            r = (r * (i % MOD)) % MOD;\n        long d = 1;\n        for (long i = 1; i <= k; i++)\n            d = (d * i) % MOD;\n        return (r * modPower(d, MOD - 2)) % MOD;\n    }\n\n    public static long S(long n, long k) {\n        return C(n + k - 1, k);\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        long k = in.nextLong();\n        long[] f = new long[n];\n        for (int i = 0; i < n; i++)\n            f[i] = in.nextLong();\n        long sum = 0;\n        for (int i = 0; i < 1 << n; i++) {\n            int sign = Integer.bitCount(i) % 2 == 0 ? 1 : -1;\n            long kleft = k;\n            for (int j = 0; j < n; j++)\n                if ((i & 1 << j) != 0)\n                    kleft -= f[j] + 1;\n            if (kleft >= 0) {\n                sum = ((sum + sign * S(n, kleft)) % MOD + MOD) % MOD;\n            }\n        }\n        System.out.println(sum);\n    }\n}\n", "label": 3}
{"src": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class E451 {\n\n\tstatic class Solver {\n\n\t\tint N;\n\t\tlong S, MOD = 1_000_000_007, cookie;\n\t\tlong[] boxes;\n\n\t\tlong modPow(long k, long exp) {\n\t\t\tif (exp == 0)\n\t\t\t\treturn 1;\n\t\t\tif (exp == 1)\n\t\t\t\treturn k;\n\t\t\tlong hs = (k * k) % MOD;\n\t\t\tif ((exp & 1) == 1)\n\t\t\t\treturn (k * modPow(hs, exp / 2)) % MOD;\n\t\t\treturn modPow(hs, exp / 2) % MOD;\n\t\t}\n\n\t\tlong modInv(long k) {\n\t\t\treturn modPow(k, MOD - 2);\n\t\t}\n\n\t\tvoid bakeACookie() {\n\t\t\tlong h = 1;\n\t\t\tfor (int i = 2; i < N; i++) {\n\t\t\t\th *= i;\n\t\t\t\th %= MOD;\n\t\t\t}\n\t\t\tcookie = modInv(h);\n\t\t}\n\n\t\tlong chooseMod(long n, long k) {\n\t\t\tif (n < k)\n\t\t\t\treturn 0;\n\t\t\tif (n == k)\n\t\t\t\treturn 1;\n\t\t\tlong top = 1;\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\ttop *= (n - i) % MOD;\n\t\t\t\ttop %= MOD;\n\t\t\t}\n\t\t\t// if (Math.random() < 0.00001)\n\t\t\t// System.out.println(n + \" \" + k + \" --> \" + top + \", \" + modInv(k) + \" --> \" +\n\t\t\t// ((top * modInv(k)) % MOD));\n\t\t\treturn (top * cookie) % MOD;\n\n\t\t}\n\n\t\t// @SuppressWarnings(\"unchecked\")\n\t\tpublic void solve(int testNumber, Scanner s, PrintWriter out) {\n\n\t\t\tN = s.nextInt();\n\t\t\tbakeACookie();\n\t\t\tS = s.nextLong();\n\t\t\tboxes = new long[N];\n\t\t\tfor (int i = 0; i < N; i++)\n\t\t\t\tboxes[i] = s.nextLong();\n\n\t\t\tlong ways = 0;\n\t\t\tfor (int i = 0; i < 1 << N; i++) {\n\t\t\t\t// overcounting on bits\n\t\t\t\tlong over = 0;\n\t\t\t\tfor (int c = 0; c < N; c++) {\n\t\t\t\t\tif ((i & (1 << c)) > 0)\n\t\t\t\t\t\tover += boxes[c] + 1;\n\t\t\t\t}\n\t\t\t\tif ((Integer.bitCount(i) & 1) == 1)\n\t\t\t\t\tways -= chooseMod(S - over + N - 1, N - 1);\n\t\t\t\telse\n\t\t\t\t\tways += chooseMod(S - over + N - 1, N - 1);\n\t\t\t\t// if (Math.random() < 0.0001)\n\t\t\t\t// out.printf(\"%d choose %d = %d\\n\", S - over + N - 1, N - 1, chooseMod(S - over\n\t\t\t\t// + N - 1, N - 1));\n\n\t\t\t}\n\n\t\t\tout.println(Math.floorMod(ways, MOD));\n\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\n//\t\t Scanner s = new Scanner(\"2 3\\n\" + \"1 3\\n\");\n//\t\t Scanner s = new Scanner(\"2 4\\n\" + \"2 2\\n\");\n//\t\t Scanner s = new Scanner(\"3 5\\n\" + \"1 3 2\\n\");\n//\t\tScanner s = new Scanner(\"20 4385085334307\\n\"\n//\t\t\t\t+ \"273634411136 208521328637 450482376435 844118010709 197241285878 472126475472 2414038897 672334205413 809269727018 409013884362 739986692075 953956651947 462216461906 388007176838 245504550965 527140291750 632844435887 550532123833 757200390348 944901802640\\n\");\n\t\t Scanner s = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tSolver solver = new Solver();\n\t\tsolver.solve(1, s, out);\n\n\t\tout.close();\n\t\ts.close();\n\n\t}\n}\n", "label": 3}
{"src": "//package codeforces;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class E {\n    BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n    PrintWriter writer = new PrintWriter(System.out);\n    StringTokenizer stringTokenizer;\n\n    String next() throws IOException {\n        while (stringTokenizer == null || !stringTokenizer.hasMoreTokens()) {\n            stringTokenizer = new StringTokenizer(reader.readLine());\n        }\n        return stringTokenizer.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    void solve() throws IOException {\n        int n = nextInt();\n        long s = nextLong();\n        long[] f = new long[n];\n        for(int i = 0; i < n; i++) {\n            f[i] = nextLong();\n        }\n        int ans = 0;\n        int inverseFK = 1;\n        for(int i = 1; i < n; i++) {\n            inverseFK = product(inverseFK, inverse(i));\n        }\n        for(int mask = 0; mask < 1 << n; mask++) {\n            long m = s;\n            int bitCount = 0;\n            for(int i = 0; i < n; i++) {\n                if((mask >> i) % 2 == 1) {\n                    bitCount++;\n                    m -= f[i] + 1;\n                }\n            }\n            if(m >= 0) {\n                ans = sum(ans, bitCount % 2 == 0 ? c(m + n - 1, n - 1, inverseFK) : MOD - c(m + n - 1, n - 1, inverseFK));\n            }\n        }\n        writer.println(ans);\n        writer.close();\n    }\n\n    final int MOD = 1000 * 1000 * 1000 + 7;\n\n    int sum(int a, int b) {\n        a += b;\n        return a >= MOD ? a - MOD : a;\n    }\n\n    int product(int a, int b) {\n        return (int)(1l * a * b % MOD);\n    }\n\n    int power(int x, int k) {\n        int ret = 1;\n        while(k > 0) {\n            if(k % 2 == 1) {\n                ret = product(ret, x);\n            }\n            x = product(x, x);\n            k /= 2;\n        }\n        return ret;\n    }\n\n    int inverse(int x) {\n        return power(x, MOD - 2);\n    }\n\n    int c(long n, int k, int inverseFK) {\n        int m = (int)(n % MOD);\n        int ret = 1;\n        for(int i = 0; i < k; i++) {\n            ret = product(ret, m + MOD - i);\n        }\n        ret = product(ret, inverseFK);\n        return ret;\n    }\n\n    public static void main(String[] args) throws IOException {\n        new E().solve();\n    }\n}\n\n\n", "label": 3}
{"src": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class e {\n\tstatic final long MOD = (long)1e9+7;\n\tstatic int n;\n\tstatic long s;\n\tstatic long[] fs;\n\tstatic long[] invs;\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tinvs = new long[25];\n\t\tinvs[1] = 1;\n\t\tfor (int i = 2; i < invs.length; ++i)\n\t\t\tinvs[i] = (MOD - (MOD / i) * invs[((int) (MOD % i))] % MOD) % MOD;\n\t\tn = in.nextInt();\n\t\ts = in.nextLong();\n\t\tfs = new long[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfs[i] = in.nextLong();\n\t\tlong ans = genList(0, 1, 0);\n\t\tif(ans < 0) ans += MOD;\n\t\tSystem.out.println(ans);\n\t}\n\tstatic long genList(int idx, long c, long pow) {\n\t\tif(idx == n) {\n\t\t\tpow = s - pow;\n\t\t\tif(pow < 0)\n\t\t\t\treturn 0;\n\t\t\tpow = pow % MOD;\n\t\t\tlong choose = 1;\n\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\tchoose *= pow+n-1-i;\n\t\t\t\tchoose %= MOD;\n\t\t\t\tchoose *= invs[i+1];\n\t\t\t\tchoose %= MOD;\n\t\t\t}\n\t\t\treturn (c * choose) % MOD;\n\t\t}\n\t\tlong ans = 0;\n\t\tans += genList(idx+1, c, pow);\n\t\tans += genList(idx+1, -c, pow+fs[idx]+1);\n\t\treturn ans % MOD;\n\t}\n}", "label": 3}
{"src": "import java.util.*;\npublic class b {\npublic static void main(String[] args)\n{\n\tScanner input = new Scanner(System.in);\n\tn = input.nextInt();\n\ts = input.nextLong();\n\tdata = new long[n];\n\tinvs = new long[21];\n\tfor(int i = 1; i<=20; i++) invs[i] = invmod(i);\n\tfor(int i = 0; i<n; i++) data[i] = input.nextLong();\n\tlong res = 0;\n\tfor(int i = 0; i<(1<<n); i++)\n\t{\n\t\tlong cur = go(i);\n\t\tif(Integer.bitCount(i)%2 == 1) cur *= -1;\n\t\tres += cur;\n\t\tres %= mod;\n\t}\n\tSystem.out.println((res+mod)%mod);\n}\nstatic long[] invs;\nstatic int n;\nstatic long s;\nstatic long[] data;\nstatic long mod = (long)1e9+7;\nstatic long go(int mask)\n{\n\tlong sum = s;\n\tfor(int i = 0; i<n; i++)\n\t{\n\t\tif((mask & (1<<i)) > 0) sum -= 1 + data[i];\n\t}\n\tif(sum < 0) return 0;\n\tlong num = sum + n - 1;\n\tlong denom = n-1;\n\tlong res = 1;\n\tfor(int i = 0; i<denom; i++)\n\t{\n\t\tres = (res * ((num-i)%mod))%mod;\n\t\tres = (res * invs[i+1])%mod;\n\t}\n\treturn res;\n}\npublic static long[] gcd(long p, long q)\n{\n\tif(q==0) return new long[] {p, 1, 0};\n\tlong[] vals = gcd(q, p%q);\n\treturn new long[] {vals[0], vals[2], vals[1] - (p/q)*vals[2]};\n}\npublic static long invmod(long x)\n{\n\tlong[] vals = gcd(x, mod);\n\tif(vals[0]>1) return -1;\n\tif(vals[1]>0) return vals[1];\n\treturn mod + vals[1];\n}\n}\n", "label": 3}
{"src": "import java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.math.BigInteger;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskE {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int n=in.readInt(), MOD=1000000007;\n        long s=in.readLong(), ret=0;\n        long[] F= IOUtils.readLongArray(in, n), revFac=IntegerUtils.generateReverseFactorials(n, MOD);\n        for (int mask=0; mask<1<<n; mask++) {\n            long used=0;\n            for (int i=0; i<n; i++) if ((mask&(1<<i))>0)  used+=F[i]+1;\n            if (used>s) continue;\n            long s2=s-used, x=revFac[n-1];\n            for (int i=1; i<n; i++) x=(s2+n-i)%MOD*x%MOD;\n            ret=(ret+(Integer.bitCount(mask)%2==0?1:-1)*x+MOD)%MOD;\n        }\n        out.printLine(ret);\n    }\n}\n\nclass InputReader {\n\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public long readLong() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return isWhitespace(c);\n    }\n\n    public static boolean isWhitespace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n    public void printLine(long i) {\n        writer.println(i);\n    }\n\n}\n\nclass IOUtils {\n\n    public static long[] readLongArray(InputReader in, int size) {\n        long[] array = new long[size];\n        for (int i = 0; i < size; i++)\n            array[i] = in.readLong();\n        return array;\n    }\n\n}\n\nclass IntegerUtils {\n\n    public static long[] generateReverse(int upTo, long module) {\n        long[] result = new long[upTo];\n        if (upTo > 1)\n            result[1] = 1;\n        for (int i = 2; i < upTo; i++)\n            result[i] = (module - module / i * result[((int) (module % i))] % module) % module;\n        return result;\n    }\n\n    public static long[] generateReverseFactorials(int upTo, long module) {\n        long[] result = generateReverse(upTo, module);\n        if (upTo > 0)\n            result[0] = 1;\n        for (int i = 1; i < upTo; i++)\n            result[i] = result[i] * result[i - 1] % module;\n        return result;\n    }\n\n}\n\n", "label": 3}
{"src": "/**\n * author: derrick20\n * created: 12/7/20 2:45 PM\n */\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class DevuAndFlowers {\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int N = sc.nextInt();\n        long S = sc.nextLong();\n        long[] f = sc.nextLongs(N);\n\n        /*\n        long[] a = polyExp(new long[]{1, mod - 1}, N);\n        long[][] m = new long[a.length - 1][a.length - 1];\n        for (int i = 0; i < a.length - 1; i++) {\n            m[0][i] = mod - a[i + 1];\n            if (i > 0) {\n                m[i][i - 1] = 1;\n            }\n        }\n        mPow = new long[47][m.length][m.length];\n        mPow[1] = m;\n        for (int k = 2; k < 47; k++) {\n            mPow[k] = matrixMult(mPow[k - 1], mPow[k - 1]);\n        }\n         */\n\n        HashMap<Long, Long> polynomial = new HashMap<>();\n        for (int mask = 0; mask < 1 << N; mask++) {\n            long coeff = 1;\n            long exp = 0;\n            for (int k = 0; k < N; k++) {\n                if (((1 << k) & mask) > 0) {\n                    coeff *= -1;\n                    exp += f[k] + 1;\n                }\n            }\n            polynomial.merge(exp, coeff, Long::sum);\n        }\n//        System.out.println(polynomial.size());\n        long ans = 0;\n        fact = new long[N];\n        fact[0] = 1;\n        for (int i = 1; i < N; i++) {\n            fact[i] = (long) i * (fact[i - 1]) % mod;\n        }\n        for (long exp : polynomial.keySet()) {\n//            System.out.println(\"Solving \" + exp);\n            if (exp <= S) {\n                long coeff = polynomial.get(exp);\n                ASSERT(coeff <= 184756); // at most 20 choose 10\n                if (coeff < 0) coeff += mod;\n                long compl = S - exp;\n//                System.out.println(\"Need to get \" + compl % mod);\n                // We want (n + k - 1) choose n, where we have n - 1 partitions,\n                // and k balls, k = compl, n ~ 20. So this is pretty efficient!\n                long complCoeff = choose(N + compl - 1, N - 1);\n//                System.out.println((N + compl - 1) + \" \" + (N - 1) + \" -> \" + complCoeff);\n\n//                long complCoeff = matrixFastExpo(m, compl)[0][0];\n//                System.out.println(\"Ways to get \" + compl + \" = \" + complCoeff);\n                long amt = (coeff * complCoeff) % mod;\n                ans = (ans + amt) % mod;\n            }\n        }\n        out.println(ans);\n        out.close();\n    }\n\n    static long mod = (long) 1e9 + 7;\n    static long[][][] mPow;\n    static long[] fact;\n\n    static long choose(long n, long k) {\n        ASSERT(k < mod);\n        n %= mod;\n        long ans = fastExpo(fact[(int) k], mod - 2);\n        while (k > 0) {\n            ans = (ans * n) % mod;\n            n--; k--;\n        }\n        return ans;\n    }\n\n    static long fastExpo(long x, long k) {\n        long ans = 1;\n        while (k > 0) {\n            if ((k & 1) > 0) {\n                ans = (ans * x) % mod;\n            }\n            x = (x * x) % mod;\n            k >>= 1;\n        }\n        return ans;\n    }\n\n    static long[] polyMult(long[] a, long[] b) {\n        long[] res = new long[a.length + b.length - 1];\n        for (int p = 0; p < res.length; p++) {\n            for (int i = 0; i < a.length; i++) {\n                int j = p - i;\n                if (j < 0 || j >= b.length) continue;\n                long amt = (a[i] * b[j]) % mod;\n                res[p] = (res[p] + amt) % mod;\n            }\n        }\n        return res;\n    }\n\n    static long[] polyExp(long[] x, long k) {\n        long[] ans = {1};\n        while (k > 0) {\n            if ((k & 1) == 1) {\n                ans = polyMult(ans, x);\n            }\n            x = polyMult(x, x);\n            k >>= 1;\n        }\n        return ans;\n    }\n\n    static long[][] matrixMult(long[][] a, long[][] b) {\n        long[][] res = new long[a.length][b[0].length];\n        for (int i = 0; i < a.length; i++) {\n            for (int j = 0; j < b[0].length; j++) {\n                for (int k = 0; k < a[i].length; k++) {\n                    long amt = (a[i][k] * b[k][j]) % mod;\n                    res[i][j] = (res[i][j] + amt) % mod;\n                }\n            }\n        }\n        return res;\n    }\n\n    static long[][] identity(int n) {\n        long[][] res = new long[n][n];\n        for (int i = 0; i < n; i++) {\n            res[i][i] = 1;\n        }\n        return res;\n    }\n\n    static long[][] matrixFastExpo(long[][] x, long k) {\n        long[][] ans = identity(x.length);\n        int ptr = 1;\n        while (k > 0) {\n            if ((k & 1) == 1) {\n                ans = matrixMult(ans, mPow[ptr]);\n            }\n            ptr++;\n            k >>= 1;\n        }\n        return ans;\n    }\n\n    static class FastScanner {\n        private int BS = 1 << 16;\n        private char NC = (char) 0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n\n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n\n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            } catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n\n        private char getChar() {\n            while (bId == size) {\n                try {\n                    size = in.read(buf);\n                } catch (Exception e) {\n                    return NC;\n                }\n                if (size == -1) return NC;\n                bId = 0;\n            }\n            return (char) buf[bId++];\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public int[] nextInts(int N) {\n            int[] res = new int[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = (int) nextLong();\n            }\n            return res;\n        }\n\n        public long[] nextLongs(int N) {\n            long[] res = new long[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public long nextLong() {\n            cnt = 1;\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            long res = 0;\n            for (; c >= '0' && c <= '9'; c = getChar()) {\n                res = (res << 3) + (res << 1) + c - '0';\n                cnt *= 10;\n            }\n            return neg ? -res : res;\n        }\n\n        public double nextDouble() {\n            double cur = nextLong();\n            return c != '.' ? cur : cur + nextLong() / cnt;\n        }\n\n        public double[] nextDoubles(int N) {\n            double[] res = new double[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextDouble();\n            }\n            return res;\n        }\n\n        public String next() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c > 32) {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c != '\\n') {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        public boolean hasNext() {\n            if (c > 32) return true;\n            while (true) {\n                c = getChar();\n                if (c == NC) return false;\n                else if (c > 32) return true;\n            }\n        }\n    }\n    static void ASSERT(boolean assertion, String message) {\n        if (!assertion) throw new AssertionError(message);\n    }\n    static void ASSERT(boolean assertion) {\n        if (!assertion) throw new AssertionError();\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.lang.*;\nimport static java.lang.Math.*;\nimport java.lang.reflect.*;\nimport java.math.BigInteger;\nimport static java.math.BigInteger.*;\nimport java.security.CodeSource;\nimport java.security.KeyStore;\nimport java.util.*;\nimport static java.util.Arrays.*;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n// https://netbeans.org/kb/73/java/editor-codereference_ru.html#display\n\npublic class Main {\n    \n    final long mod = (long)1e9 + 7;\n    int n;\n    long s;\n    long[] f;\n    long[] invFact = new long[25];\n    {\n        invFact[0] = 1;\n        long f = 1;\n        for (int i = 1; i < invFact.length; i++) {\n            f = (f * i) % mod;\n            invFact[i] = valueOf(f).modInverse(valueOf(mod)).longValue();\n        }\n    }\n    \n    long C( int l, long b ){\n        long ans = 1;\n        for( long x = b-l+1; x <= b; ++x ){\n            ans = (x%mod * ans) % mod;\n        }\n        ans = (ans * invFact[l]) % mod;\n        return ans;\n    }\n\n    void solve(){\n//        for( int n = 0; n <= 10; ++n ){\n//            for (int m = 0; m <= n; m++) {\n//                err.print( \" \" + C(m,n) );\n//            }\n//            err.println();\n//        }\n        \n        n = sc.nextInt();\n        s = sc.nextLong();\n        f = new long[n];\n        for (int i = 0; i < f.length; i++) {\n            f[i] = sc.nextLong();\n        }\n        \n        long ans = 0;\n        for (int msk = 0; msk < (1<<n); msk++) {\n            long curS = s;\n            for (int i = 0; i < n; i++) {\n                if( ((msk>>i)&1) == 1 ){\n                    curS -= f[i] + 1;\n                }\n            }\n            if( 0 <= curS ){\n                long comb = C(n-1, curS+n-1);\n                //err.println( msk +\") \"+ comb );\n                if( Integer.bitCount(msk) % 2 == 0 )\n                    ans = (ans + comb) % mod;\n                else\n                    ans = (ans - comb + mod) % mod;\n            }\n        }\n        ans = (ans%mod + mod) % mod;\n        out.println(ans);\n    }\n\n    \n    \n    \n    \n    //------------------------------------------------------------------//\n    \n    private void run(){\n        err = System.err;\n        boolean oj = true;\n        try {\n            oj = System.getProperty(\"MYLOCAL\") == null;\n        } catch (Exception e) {\n        }\n        \n        if( oj ){\n            sc = new FastScanner(new InputStreamReader(System.in));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n        }\n        else{\n            try {\n                sc = new FastScanner(new FileReader(\"input.txt\"));\n                out = new PrintWriter(new FileWriter(\"output.txt\"));\n            } catch ( IOException e) {\n                MLE();\n            }\n        }\n        solve();\n        \n        out.flush();\n    }\n    \n    FastScanner sc;\n    PrintWriter out;\n    PrintStream err;\n    \n    \n    void MLE(){\n        int[][] arr = new int[1024*1024][];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = new int[1024*1024];\n        }\n    }\n\n\n    class FastScanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(InputStreamReader reader) {\n            br = new BufferedReader(reader);\n            st = new StringTokenizer(\"\");\n        }\n\n        String next() {\n            while( !st.hasMoreElements() )\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException ex) {\n                    MLE();\n                }\n            return st.nextToken();\n        }\n        \n        int nextInt(){ return Integer.parseInt(next());}\n\n        long nextLong() { return Long.parseLong(next()); } \n    }\n\n    public static void main(String[] args){\n        new Main().run();\n    }\n\n}\n", "label": 3}
{"src": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class devuandflowers {\n\t\n\tfinal int MOD = (int) 1e9 + 7;\n\t\n\tpublic int add(long a, long b) {\n\t\treturn (int)((a + b) % MOD);\n\t}\n\t\n\tpublic int sub(long a, long b) {\n\t\treturn (int)((a - b + MOD) % MOD);\n\t}\n\t\n\tpublic int mult(long a, long b) {\n\t\treturn (int)(((a % MOD) * (b % MOD) % MOD));\n\t}\n\t\n\tpublic int power(long n, long k) {\n\t\tint ans = 1;\n\t\twhile(k > 0) {\n\t\t\tif(k % 2 == 0) {\n\t\t\t\tk /= 2;\n\t\t\t\tn = mult(n, n);\n\t\t\t} else {\n\t\t\t\tk--;\n\t\t\t\tans = mult(ans, n);\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic int inv(int n) {\n\t\treturn power(n, MOD - 2);\n\t}\n\t\n\tpublic int choose(long n, long k) {\n\t\tif(n - k > k) {\n\t\t\tk = n - k;\n\t\t}\n\t\tint top = 1;\n\t\tfor(long i = k + 1; i <= n; ++i) {\n\t\t\ttop = mult(top, i);\n\t\t}\n\t\t\n\t\tint bottom = 1;\n\t\tfor(long i = n - k; i >= 1; --i) {\n\t\t\tbottom = mult(bottom, i);\n\t\t}\n\t\t\n\t\treturn mult(top, inv(bottom));\n\t}\n\t\n\tpublic void solve(Scanner in, PrintWriter out) {\n\t\tint n = in.nextInt();\n\t\tlong s = in.nextLong();\n\t\tlong[] a = new long[n];\n\t\tlong tot = 0;\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\ta[i] = in.nextLong();\n\t\t\ttot += a[i];\n\t\t}\n\t\tif(s > tot) {\n\t\t\tout.println(0);\n\t\t\treturn;\n\t\t}\n\t\tif(s == tot) {\n\t\t\tout.println(1);\n\t\t\treturn;\n\t\t}\n\t\t\n//\t\tSystem.out.println(choose(1000000000000L, 20));\n\t\tint ans = 0;\n\t\t\n\t\tfor(int mask = 0; mask < (1 << n); ++mask) {\n\t\t\tlong cursum = s;\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tif((mask & (1<<i)) == 0) continue;\n\t\t\t\tcursum -= a[i] + 1;\n\t\t\t}\n\t\t\tif(cursum < 0) continue;\n\t\t\tif(Integer.bitCount(mask) % 2 == 0) {\n\t\t\t\tans = add(ans, choose(cursum + n - 1, n - 1));\n\t\t\t} else {\n\t\t\t\tans = sub(ans, choose(cursum + n - 1, n - 1));\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(ans);\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tnew devuandflowers().solve(in, out);\n\t\t\n\t\tin.close();\n\t\tout.close();\n\t}\n}\n", "label": 3}
{"src": "/**\n * author: derrick20\n * created: 12/7/20 6:00 PM\n */\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class DevuFlowersPIE {\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int N = sc.nextInt();\n        long S = sc.nextLong();\n        long[] f = sc.nextLongs(N);\n\n        long[] inv = new long[20];\n        invFact = new long[20];\n        invFact[0] = invFact[1] = inv[1] = 1;\n        for (int i = 2; i < 20; i++) {\n            inv[i] = mod - ((mod / i) * inv[(int) mod % i] % mod);\n            invFact[i] = (inv[i] * invFact[i - 1]) % mod;\n        }\n        long[] sum = new long[1 << N];\n        int[] log = new int[29];\n        for (int k = 0; k < 20; k++) {\n            log[(1 << k) % 29] = k;\n        }\n        /*\n        It just happens to work out that x = 2, p = 29 has multiplicative order 28,\n        so that's good enough for this\n         */\n        long ans = choose(S + N - 1, N - 1);\n        for (int mask = 1; mask < 1 << N; mask++) {\n            int elems = Integer.bitCount(mask);\n            long sign = elems % 2 == 0 ? 1 : -1;\n            sum[mask] = sum[mask - (mask & -mask)] + f[log[(mask & -mask) % 29]];\n            long S2 = S - sum[mask] - elems;\n            long amt = (sign * choose(S2 + N - 1, N - 1)) % mod;\n            if (amt < 0) {\n                amt += mod;\n            }\n            ans = (ans + amt) % mod;\n        }\n        out.println(ans);\n        out.close();\n    }\n    static long mod = (long) 1e9 + 7;\n    static long[] invFact;\n\n    static long choose(long n, long k) {\n        if (k > n) return 0;\n        long ans = invFact[(int) k];\n        n %= mod; // KEY BUG\n        while (k > 0) {\n            ans = (ans * n) % mod;\n            n--; k--;\n        }\n        return ans;\n    }\n\n    static class FastScanner {\n        private int BS = 1 << 16;\n        private char NC = (char) 0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n\n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n\n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            } catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n\n        private char getChar() {\n            while (bId == size) {\n                try {\n                    size = in.read(buf);\n                } catch (Exception e) {\n                    return NC;\n                }\n                if (size == -1) return NC;\n                bId = 0;\n            }\n            return (char) buf[bId++];\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public int[] nextInts(int N) {\n            int[] res = new int[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = (int) nextLong();\n            }\n            return res;\n        }\n\n        public long[] nextLongs(int N) {\n            long[] res = new long[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public long nextLong() {\n            cnt = 1;\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            long res = 0;\n            for (; c >= '0' && c <= '9'; c = getChar()) {\n                res = (res << 3) + (res << 1) + c - '0';\n                cnt *= 10;\n            }\n            return neg ? -res : res;\n        }\n\n        public double nextDouble() {\n            double cur = nextLong();\n            return c != '.' ? cur : cur + nextLong() / cnt;\n        }\n\n        public double[] nextDoubles(int N) {\n            double[] res = new double[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextDouble();\n            }\n            return res;\n        }\n\n        public String next() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c > 32) {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c != '\\n') {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        public boolean hasNext() {\n            if (c > 32) return true;\n            while (true) {\n                c = getChar();\n                if (c == NC) return false;\n                else if (c > 32) return true;\n            }\n        }\n    }\n    static void ASSERT(boolean assertion, String message) {\n        if (!assertion) throw new AssertionError(message);\n    }\n    static void ASSERT(boolean assertion) {\n        if (!assertion) throw new AssertionError();\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main {\n\n    public static void main(String[] args) \n    {\t\n        InputStream inputstream = System.in;\n        OutputStream outputstream = System.out;\n        InputReader in = new InputReader(inputstream);\n        OutputWriter out = new OutputWriter(outputstream);\n        mysolver mysol = new mysolver();\n        mysol.solve(in, out);\n        out.close();\n    }\n\n}\n\nclass mysolver {\n\tpublic long mod = 1000000007;\n\tpublic long MOD = 1_000_000_007;\n\tlong inv[] = new long[26];\n    public void solve(InputReader in,OutputWriter out)\n    {\n    \tPrintWriter pout = new PrintWriter(new BufferedOutputStream(System.out));\n    \tint n = in.readInt();\n    \tlong s = Long.parseLong(in.readString());\n    \tlong f[] = new long[n];\n    \tfor(int i=0;i<n;i++)\n    \t\tf[i] = Long.parseLong(in.readString());\n    \tlong ans = 0;\n    \tfor(int i=1;i<=25;i++)\n    \t\tinv[i] = inverse(i);\n    \tfor(int i=0 ;i< 1<<n ; i++)\n    \t{\n    \t\tint bit = Long.bitCount(i);\n    \t\tString str = Long.toBinaryString(i);\n    \t\tstr = (\"00000000000000000000000000000000\").concat(str);\n    \t\tint sign = 0;\n    \t\t\n    \t\tif(bit%2==0)\n    \t\t\tsign = 1;\n    \t\telse\n    \t\t\tsign = -1;\n    \t\t\n    \t\tchar[] ch = str.toCharArray();\n    \t\tlong val = s;\n    \t\tfor(int j=ch.length-1;j>ch.length-n-1;j--)\n    \t\t{\n    \t\t\tif(ch[j]=='1')\n    \t\t\t{\n    \t\t\t\tval = val - f[ch.length-1-j]-1;\n    \t\t\t}\n    \t\t}\n    \t\tval = val+n-1;\n    \t\tif(val < 0)\n    \t\t\tcontinue;\n    \t\tans = ans + sign * C(val,n-1);\n    \t\tans = ans%mod;\n    \t\t//System.out.println(ans);\n    \t}\n    \twhile(ans < 0)\n    \t\tans = ans+mod;\n    \tSystem.out.println(ans);\n    \tpout.close();\n    }\n    \n    public long C(long n, long k) {\n        long r = 1;\n        for (long i = n; i > n - k; i--)\n            r = (r * (i % MOD)) % MOD;\n        long d = 1;\n        for (long i = 1; i <= k; i++)\n            d = (d * i) % MOD;\n        return (r * inverse(d)) % MOD;\n    }\n    \n    public long inverse(long a)\n    {\n    \tlong val = mod-2;\n    \tlong ans = 1;\n    \tlong mul = a;\n    \twhile(val!=0)\n    \t{\n    \t\tif(val%2==1)\n    \t\t{\n    \t\t\tans = (ans*mul)%mod;\n    \t\t}\n    \t\tmul = (mul*mul)%mod;\n    \t\tval = val/2;\n    \t}\n    \treturn ans;\n    }\n}\nclass InputReader {\n \n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n \n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n \n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n \n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n \n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n \n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return isWhitespace(c);\n    }\n \n    public static boolean isWhitespace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n \n    public String next() {\n        return readString();\n    }\n \n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n}\n \nclass OutputWriter {\n    private final PrintWriter writer;\n \n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n \n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n \n    public void close() {\n        writer.close();\n    }\n \n    public void printLine(int i) {\n        writer.println(i);\n    }\n}\n \nclass IOUtils {\n \n    public static void readIntArrays(InputReader in, int[]... arrays) {\n        for (int i = 0; i < arrays[0].length; i++) {\n            for (int j = 0; j < arrays.length; j++)\n                arrays[j][i] = in.readInt();\n        }\n    }\n \n    }", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.SortedSet;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * #\n * \n * @author pttrung\n */\npublic class E_Round_258_Div2 {\n\n\tpublic static long MOD = 1000000007;\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\t// PrintWriter out = new PrintWriter(new FileOutputStream(new File(\n\t\t// \"output.txt\")));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tScanner in = new Scanner();\n\t\tint n = in.nextInt();\n\t\tlong s = in.nextLong();\n\t\tlong[] data = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdata[i] = in.nextLong();\n\t\t}\n\t\tlong result = cal(s, data);\n\t\t\n\t\tout.println(result);\n\t\tout.close();\n\t}\n\n\tpublic static long cal(long need, long[] data) {\n\t\t// System.out.println(\"CALL \" + need + \" \" + total);\n\n\t\tlong result = 0;\n\t\tfor (int i = 0; i < (1 << data.length); i++) {\n\t\t\tlong v = need;\n\t\t\tfor (int j = 0; j < data.length; j++) {\n\t\t\t\tif (((1 << j) & i) != 0) {\n\t\t\t\t\tv -= (data[j] + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v >= 0) {\n\t\t\t\tresult += (Integer.bitCount(i) % 2 == 0 ? 1 : -1)\n\t\t\t\t\t\t* numberOfWay(v, data.length);\n\t\t\t\tresult = (result + MOD) % MOD;\n\t\t\t}\n\t\t}\n\t\t// System.out.println(result + \" \" + need + \" \" + total + \" \" +\n\t\t// data.length);\n\n\t\treturn result;\n\t}\n\n\tpublic static long numberOfWay(long v, int n) {\n\t\tif (v == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tlong x = 1;\n\t\tfor (long i = v + n - 1; i > v; i--) {\n\t\t\tx *= (i % MOD);\n\t\t\tx %= MOD;\n\t\t}\n\t\tlong y = 1;\n\t\tfor (long i = 2; i < n; i++) {\n\t\t\ty *= i;\n\t\t\ty %= MOD;\n\t\t}\n\t\tBigInteger result = BigInteger\n\t\t\t\t.valueOf(x)\n\t\t\t\t.multiply(\n\t\t\t\t\t\tBigInteger.valueOf(y).modInverse(\n\t\t\t\t\t\t\t\tBigInteger.valueOf(MOD)))\n\t\t\t\t.mod(BigInteger.valueOf(MOD));\n\t\treturn result.longValue();\n\t}\n\n\tpublic static int[] KMP(String val) {\n\t\tint i = 0;\n\t\tint j = -1;\n\t\tint[] result = new int[val.length() + 1];\n\t\tresult[0] = -1;\n\t\twhile (i < val.length()) {\n\t\t\twhile (j >= 0 && val.charAt(j) != val.charAt(i)) {\n\t\t\t\tj = result[j];\n\t\t\t}\n\t\t\tj++;\n\t\t\ti++;\n\t\t\tresult[i] = j;\n\t\t}\n\t\treturn result;\n\n\t}\n\n\tpublic static boolean nextPer(int[] data) {\n\t\tint i = data.length - 1;\n\t\twhile (i > 0 && data[i] < data[i - 1]) {\n\t\t\ti--;\n\t\t}\n\t\tif (i == 0) {\n\t\t\treturn false;\n\t\t}\n\t\tint j = data.length - 1;\n\t\twhile (data[j] < data[i - 1]) {\n\t\t\tj--;\n\t\t}\n\t\tint temp = data[i - 1];\n\t\tdata[i - 1] = data[j];\n\t\tdata[j] = temp;\n\t\tArrays.sort(data, i, data.length);\n\t\treturn true;\n\t}\n\n\tpublic static int digit(long n) {\n\t\tint result = 0;\n\t\twhile (n > 0) {\n\t\t\tn /= 10;\n\t\t\tresult++;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic static double dist(long a, long b, long x, long y) {\n\t\tdouble val = (b - a) * (b - a) + (x - y) * (x - y);\n\t\tval = Math.sqrt(val);\n\t\tdouble other = x * x + a * a;\n\t\tother = Math.sqrt(other);\n\t\treturn val + other;\n\n\t}\n\n\tpublic static class Point implements Comparable<Point> {\n\n\t\tint x, y;\n\n\t\tpublic Point(int start, int end) {\n\t\t\tthis.x = start;\n\t\t\tthis.y = end;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tint hash = 5;\n\t\t\thash = 47 * hash + this.x;\n\t\t\thash = 47 * hash + this.y;\n\t\t\treturn hash;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (obj == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (getClass() != obj.getClass()) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tfinal Point other = (Point) obj;\n\t\t\tif (this.x != other.x) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this.y != other.y) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Point o) {\n\t\t\treturn x - o.x;\n\t\t}\n\t}\n\n\tpublic static class FT {\n\n\t\tlong[] data;\n\n\t\tFT(int n) {\n\t\t\tdata = new long[n];\n\t\t}\n\n\t\tpublic void update(int index, long value) {\n\t\t\twhile (index < data.length) {\n\t\t\t\tdata[index] += value;\n\t\t\t\tindex += (index & (-index));\n\t\t\t}\n\t\t}\n\n\t\tpublic long get(int index) {\n\t\t\tlong result = 0;\n\t\t\twhile (index > 0) {\n\t\t\t\tresult += data[index];\n\t\t\t\tindex -= (index & (-index));\n\t\t\t}\n\t\t\treturn result;\n\n\t\t}\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t}\n\t\treturn gcd(b, a % b);\n\t}\n\n\tpublic static long pow(long a, long b) {\n\t\tif (b == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (b == 1) {\n\t\t\treturn a;\n\t\t}\n\t\tlong val = pow(a, b / 2);\n\t\tif (b % 2 == 0) {\n\t\t\treturn val * val % MOD;\n\t\t} else {\n\t\t\treturn val * (val * a % MOD) % MOD;\n\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic Scanner() throws FileNotFoundException {\n\t\t\t// System.setOut(new PrintStream(new\n\t\t\t// BufferedOutputStream(System.out), true));\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t// br = new BufferedReader(new InputStreamReader(new\n\t\t\t// FileInputStream(new File(\"input.txt\"))));\n\t\t}\n\n\t\tpublic String next() {\n\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tst = null;\n\t\t\ttry {\n\t\t\t\treturn br.readLine();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t}\n\n\t\tpublic boolean endLine() {\n\t\t\ttry {\n\t\t\t\tString next = br.readLine();\n\t\t\t\twhile (next != null && next.trim().isEmpty()) {\n\t\t\t\t\tnext = br.readLine();\n\t\t\t\t}\n\t\t\t\tif (next == null) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tst = new StringTokenizer(next);\n\t\t\t\treturn st.hasMoreTokens();\n\t\t\t} catch (Exception e) {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t}\n\t}\n}\n", "label": 3}
{"src": "import java.util.Map;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Set;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Mahmoud Aladdin <aladdin3>\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskE {\n\n    public static final Long MOD = (long)(1e9 + 7);\n\n    public void solve(int testNumber, InputReader jin, OutputWriter jout) {\n        int n = jin.int32();\n        long s = jin.int64();\n\n        long[] f = new long[n];\n        long[] inv = new long[1 + (n << 1)];\n\n        Polynomial p = new Polynomial();\n        p.add(0, 1);\n\n        for(int i = 0; i < n; i++) {\n            f[i] = jin.int64();\n            inv[2 * i + 1] = modpow(2 * i + 1, MOD - 2, MOD);\n            inv[2 * i + 2] = modpow(2 * i + 2, MOD - 2, MOD);\n            Polynomial temp = new Polynomial();\n            temp.add(0, 1);\n            temp.add(f[i] + 1, -1);\n            p = Polynomial.multiply(p, temp);\n        }\n\n        long ans = 0;\n        Iterator<Long> it = p.iterPowers();\n        while(it.hasNext()) {\n            long power = it.next();\n            long coeff = (p.getTerm(power) + MOD) % MOD;\n            long rem = s - power;\n            if(rem >= 0) {\n                long temp = comb(n + rem - 1, rem, inv) * coeff;\n                ans = (ans % MOD + temp % MOD) % MOD;\n            }\n        }\n        jout.println(ans);\n    }\n\n    private long comb(long n, long r, long[] inv) {\n        if(r > n) return 0;\n        if(n - r < r) r = n - r;\n        n %= MOD;\n        long ans = 1;\n        for(int i = 0; i < r; i++) {\n            ans = (ans * (n - i)) % MOD;\n            ans = (ans * inv[i + 1]) % MOD;\n        }\n        return ans;\n    }\n\n    private long modpow(long a, long b, long mod) {\n        long res = 1;\n        while (b > 0) {\n            if (b % 2 == 1) {\n                res = (res * a) % mod;\n            }\n            a = (a * a) % mod;\n            b >>= 1;\n        }\n        return res;\n    }\n}\n\nclass Polynomial {\n    Map<Long, Long> terms;\n    public static long MOD = Long.MAX_VALUE;\n\n    public Polynomial() {\n        terms = new HashMap<Long, Long>();\n    }\n\n    public Iterator<Long> iterPowers() {\n        return terms.keySet().iterator();\n    }\n\n    public Long getTerm(Long power) {\n        if(terms.containsKey(power))\n            return terms.get(power);\n        return 0L;\n    }\n\n    public void add(long power, long value) {\n        long oldVal = terms.containsKey(power)? terms.get(power) : 0;\n        terms.put(power, oldVal + value);\n    }\n\n    public static Polynomial multiply(Polynomial p1, Polynomial p2) {\n        Polynomial result = new Polynomial();\n        for(Long pow1: p1.terms.keySet()) {\n            long val1 = p1.terms.get(pow1);\n            for(Long pow2: p2.terms.keySet()) {\n                long val2 = p2.terms.get(pow2);\n                result.add(pow1 + pow2, (val1 * val2) % MOD);\n            }\n        }\n        return result;\n    }\n}\n\nclass InputReader {\n    private static final int bufferMaxLength = 1024;\n    private InputStream in;\n    private byte[] buffer;\n    private int currentBufferSize;\n    private int currentBufferTop;\n    private static final String tokenizers = \" \\t\\r\\f\\n\";\n    \n    public InputReader(InputStream stream) {\n        this.in = stream;\n        buffer = new byte[bufferMaxLength];\n        currentBufferSize = 0;\n        currentBufferTop = 0;\n    }\n    \n    private boolean refill() {\n        try {\n            this.currentBufferSize = this.in.read(this.buffer);\n            this.currentBufferTop = 0;\n        } catch(Exception e) {}\n        return this.currentBufferSize > 0;\n    }\n    \n    \n    private Byte readChar() {\n        if(currentBufferTop < currentBufferSize) {\n            return this.buffer[this.currentBufferTop++];\n        } else {\n            if(!this.refill()) {\n                return null;\n            } else {\n                return readChar();\n            }\n        }\n    }\n\n    public String token()  {\n        StringBuffer tok = new StringBuffer();\n        Byte first;\n        while((first = readChar()) != null && (tokenizers.indexOf((char) first.byteValue()) != -1));\n        if(first == null) return null;\n        tok.append((char)first.byteValue());\n        while((first = readChar()) != null && (tokenizers.indexOf((char) first.byteValue()) == -1)) {\n            tok.append((char)first.byteValue());\n        }\n        return tok.toString();\n    }\n    \n    public Integer int32() throws NumberFormatException {\n        String tok = token();\n        return tok == null? null : Integer.parseInt(tok);\n    }\n\n    public Long int64() throws NumberFormatException {\n        String tok = token();\n        return tok == null? null : Long.parseLong(tok);\n    }\n\n    }\n\nclass OutputWriter {\n    private final int bufferMaxOut = 1024;\n    private PrintWriter out;\n    private StringBuilder output;\n    private boolean forceFlush = false;\n\n    public OutputWriter(OutputStream outStream) {\n        out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outStream)));\n        output = new StringBuilder(2 * bufferMaxOut);\n    }\n\n    public OutputWriter(Writer writer) {\n        forceFlush = true;\n        out = new PrintWriter(writer);\n        output = new StringBuilder(2 * bufferMaxOut);\n    }\n\n    private void autoFlush() {\n        if(forceFlush || output.length() >= bufferMaxOut) {\n            flush();\n        }\n    }\n\n    public void print(Object... tokens) {\n        for(int i = 0; i < tokens.length; i++) {\n            if(i != 0) output.append(' ');\n            output.append(tokens[i]);\n        }\n        autoFlush();\n    }\n\n    public void println(Object... tokens) {\n        print(tokens);\n        output.append('\\n');\n        autoFlush();\n    }\n\n    public void flush() {\n        out.print(output);\n        output.setLength(0);\n    }\n\n    public void close() {\n        flush();\n        out.close();\n    }\n}\n\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static final long MOD = (long) (1e9 + 7);\n\tpublic static long[] fac, inv, a;\n\tpublic static final int MAX = 20;\n\tpublic static long M;\n\tpublic static int N;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tfac = new long[MAX + 1];\n\t\tinv = new long[MAX + 1];\n\t\tfac[0] = 1;\n\t\tinv[0] = 1;\n\t\tfor (int i = 1; i <= MAX; i++) {\n\t\t\tfac[i] = (fac[i - 1] * i) % MOD;\n\t\t\tinv[i] = qpow(fac[i], MOD - 2, MOD);\n\t\t}\n\t\tBufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(f.readLine());\n\t\tN = Integer.parseInt(st.nextToken());\n\t\tM = Long.parseLong(st.nextToken());\n\t\ta = new long[N];\n\t\tst = new StringTokenizer(f.readLine());\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\ta[i] = Long.parseLong(st.nextToken());\n\t\t}\n\t\tSystem.out.println(solve());\n\t}\n\n\tpublic static long solve() {\n\t\tlong res = C(N + M - 1, N - 1);\n\t\tfor (int x = 1; x < 1 << N; x++) {\n\t\t\tlong t = N + M;\n\t\t\tint p = 0;\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (((x >> i) & 1) == 1) {\n\t\t\t\t\tp++;\n\t\t\t\t\tt -= a[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tt -= (p + 1);\n\t\t\tif (p % 2 == 1) {\n\t\t\t\tres = (res + MOD - C(t, N - 1)) % MOD;\n\t\t\t} else {\n\t\t\t\tres = (res + C(t, N - 1)) % MOD;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static long C(long y, int x) {\n\t\tif (y < 0 || x < 0 || y < x)\n\t\t\treturn 0;\n\t\ty %= MOD;\n\t\tif (y == 0 || x == 0)\n\t\t\treturn 1;\n\t\tlong res = inv[x];\n\t\tfor (int i = 0; i < x; i++) {\n\t\t\tres = res * (y - i) % MOD;\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static long qpow(long a, long b, long p) {\n\t\tlong res = 1 % p;\n\t\tfor (; b > 0; b >>= 1) {\n\t\t\tif ((b & 1) == 1) {\n\t\t\t\tres *= a;\n\t\t\t\tres %= p;\n\t\t\t}\n\t\t\ta *= a;\n\t\t\ta %= p;\n\t\t}\n\t\treturn res;\n\t}\n}\n", "label": 3}
{"src": "import java.util.List;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tFastPrinter out = new FastPrinter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskE {\n\n    static final int MOD = 1000000007;\n\n    static int mul(int a, int b) {\n        return (int) ((long) a * b % MOD);\n    }\n\n    static int[] REV;\n    static {\n        REV = new int[25];\n        for (int i = 1; i < REV.length; i++) {\n            REV[i] = MathUtils.modPow(i, MOD - 2, MOD);\n        }\n    }\n\n    static int f(long n_, int k) {\n        --k;\n        n_ += k;\n        if (k > n_ || k < 0 || n_ < 0) return 0;\n        int ans = 1;\n        int n = (int) (n_ % MOD + MOD);\n        for (int i = 0; i < k; i++) {\n            ans = mul(ans, (n - i));\n            ans = mul(ans, REV[i + 1]);\n        }\n        return ans;\n    }\n\n    public void solve(int testNumber, FastScanner in, FastPrinter out) {\n        int n = in.nextInt();\n        long s = in.nextLong();\n        long[] f = new long[n];\n        for (int i = 0; i < n; i++) {\n            f[i] = in.nextLong();\n        }\n        int ans = 0;\n        for (int mask = 0; mask < 1 << n; mask++) {\n            long cs = 0;\n            for (int i = 0; i < n; i++) {\n                if (((mask >> i) & 1) == 1) {\n                    cs += f[i] + 1;\n                }\n            }\n            if (cs > s) {\n                continue;\n            }\n            if ((Integer.bitCount(mask) & 1) == 1) {\n                ans -= f(s - cs, n);\n                if (ans < 0) ans += MOD;\n            } else {\n                ans += f(s - cs, n);\n                if (ans >= MOD) ans -= MOD;\n            }\n        }\n        out.println(ans);\n    }\n}\n\nclass MathUtils {\n\n\n    public static int modPow(int a, int b, int mod) {\n        int ret = 1;\n        a = (a % mod + mod) % mod;\n        while (b > 0) {\n            if ((b & 1) == 1) {\n                ret = (int) ((long) ret * a % mod);\n            }\n            a = (int) ((long) a * a % mod);\n            b >>= 1;\n        }\n        return ret;\n    }\n\n    }\n\nclass FastScanner extends BufferedReader {\n\n    public FastScanner(InputStream is) {\n        super(new InputStreamReader(is));\n    }\n\n    public int read() {\n        try {\n            int ret = super.read();\n//            if (isEOF && ret < 0) {\n//                throw new InputMismatchException();\n//            }\n//            isEOF = ret == -1;\n            return ret;\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    public String next() {\n        StringBuilder sb = new StringBuilder();\n        int c = read();\n        while (isWhiteSpace(c)) {\n            c = read();\n        }\n        if (c < 0) {\n            return null;\n        }\n        while (c >= 0 && !isWhiteSpace(c)) {\n            sb.appendCodePoint(c);\n            c = read();\n        }\n        return sb.toString();\n    }\n\n    static boolean isWhiteSpace(int c) {\n        return c >= 0 && c <= 32;\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isWhiteSpace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int ret = 0;\n        while (c >= 0 && !isWhiteSpace(c)) {\n            if (c < '0' || c > '9') {\n                throw new NumberFormatException(\"digit expected \" + (char) c\n                        + \" found\");\n            }\n            ret = ret * 10 + c - '0';\n            c = read();\n        }\n        return ret * sgn;\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public String readLine() {\n        try {\n            return super.readLine();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    }\n\nclass FastPrinter extends PrintWriter {\n\n    public FastPrinter(OutputStream out) {\n        super(out);\n    }\n\n    public FastPrinter(Writer out) {\n        super(out);\n    }\n\n\n}\n\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DevuAndFlowers solver = new DevuAndFlowers();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DevuAndFlowers {\n        long MOD = (long) (1e9) + 7;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            Poly p = new Poly();\n            int N = in.nextInt();\n            long s = in.nextLong();\n            for (int i = 0; i < N; i++) {\n                if (N == 1) {\n                    long a = in.nextLong();\n                    if (a >= s) {\n                        out.println(1);\n                    } else {\n                        out.println(0);\n                    }\n                    return;\n                }\n                p.mult(in.nextLong() + 1);\n            }\n            long inv = 1;\n            for (int i = 1; i <= N - 1; i++) {\n                inv *= i;\n                inv %= MOD;\n            }\n            inv = MathUtils.inverse(inv, MOD);\n            long res = 0;\n            for (long l : p.poly.keySet()) {\n                long i = s - l;\n                if (i < 0) {\n                    continue;\n                } else {\n                    long num = 1;\n                    for (long j = N + i - 1; j >= i + 1; j--) {\n                        num *= j % MOD;\n                        num %= MOD;\n                    }\n                    num *= inv;\n                    num %= MOD;\n                    num *= p.poly.get(l);\n                    num %= MOD;\n                    res += num;\n                    if (res >= MOD) {\n                        res -= MOD;\n                    }\n                    if (res < 0) {\n                        res += MOD;\n                    }\n                }\n            }\n            out.println(res);\n        }\n\n        class Poly {\n            HashMap<Long, Long> poly;\n\n            Poly() {\n                poly = new HashMap<>();\n                poly.put(0L, 1L);\n            }\n\n            void mult(long i) {\n                HashMap<Long, Long> toAdd = new HashMap<>();\n                for (long l : poly.keySet()) {\n                    toAdd.putIfAbsent(l + i, 0L);\n                    toAdd.replace(l + i, -poly.get(l));\n                }\n                for (long l : toAdd.keySet()) {\n                    poly.putIfAbsent(l, 0L);\n                    long next = poly.get(l) + toAdd.get(l);\n                    if (next < 0) {\n                        next += MOD;\n                    }\n                    if (next >= MOD) {\n                        next -= MOD;\n                    }\n                    poly.replace(l, next);\n                }\n            }\n\n        }\n\n    }\n\n    static class MathUtils {\n        public static long inverse(long a, long mod) {\n            long[] inv = extended_gcd(a, mod);\n            if (inv[0] != 1) {\n                return 0;\n            } else {\n                return (inv[1] + 2 * mod) % mod;\n            }\n        }\n\n        public static long[] extended_gcd(long a, long b) {\n            //three numbers, first is gcd, second is x, third is y\n            if (a == 0) {\n                return new long[]{b, 0, 1};\n            }\n            long[] next = extended_gcd(b % a, a);\n            long tempX = next[1];\n            next[1] = next[2] - (b / a) * next[1];\n            next[2] = tempX;\n            return next;\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.BufferedInputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashSet;\nimport java.util.InputMismatchException;\nimport java.util.Set;\n\npublic class Main\n{\t\n\tprivate final int MOD = (int)(1e9 + 7);\n\t\n\tpublic long quickMod(long x, long p)\n\t{\n\t\tlong ans = 1;\n\t\tx %= MOD;\n\t\twhile(p > 0)\n\t\t{\n\t\t\tif(1 == p % 2)\n\t\t\t{\n\t\t\t\tans = ans * x % MOD;\n\t\t\t}\n\t\t\tp >>= 1;\n\t\t\tx = x * x % MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic long cnm(long n, long m)\n\t{\n\t\tif(n < m)\n\t\t{\n\t\t\treturn 0;\n\t\t}\n\t\tif(m > n - m)\n\t\t{\n\t\t\tm = n - m;\n\t\t}\n\t\tlong a = 1, b = 1;\n\t\tfor(long i = 0;i < m;++i)\n\t\t{\n\t\t\ta = a * (n - i) % MOD;\n\t\t\tb = b * (i + 1) % MOD;\n\t\t}\n\t\treturn a * quickMod(b, MOD - 2) % MOD;\n\t}\n\t\n\tpublic long lucas(long n, long m)\n\t{\n\t\tlong ans = 1;\n\t\twhile(n > 0 && m > 0)\n\t\t{\n\t\t\tlong a = n % MOD, b = m % MOD;\n\t\t\tif(a < b)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tans = ans * cnm(a, b) % MOD;\n\t\t\tn /= MOD;\n\t\t\tm /= MOD;\n\t\t}\n\t\treturn ans;\n\t}\n\t\n\tpublic void foo()\n\t{\n\t\tMyScanner scan = new MyScanner();\n\t\tint n = scan.nextInt();\n\t\tlong s = scan.nextLong();\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;++i)\n\t\t{\n\t\t\ta[i] = scan.nextLong();\n\t\t}\n\t\tlong ans = 0;\n\t\tint m = 1 << n;\n\t\tfor(int i = 0;i < m;++i)\n\t\t{\n\t\t\tint sign = 1;\n\t\t\tlong sum = s;\n\t\t\tfor(int j = 0;j < n;++j)\n\t\t\t{\n\t\t\t\tif((i & (1 << j)) > 0)\n\t\t\t\t{\n\t\t\t\t\tsum -= a[j] + 1;\n\t\t\t\t\tsign *= -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sum >= 0)\n\t\t\t{\n\t\t\t\tans += sign * lucas(sum + n - 1, n - 1);\n\t\t\t\tans %= MOD;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println((ans + MOD) % MOD);\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tnew Main().foo();\n\t}\n\t\n\tclass MyScanner\n\t{\n\t    private byte[] buf = new byte[1024];\n\t    private int curChar;\n\t    private int numChars;\n\t    BufferedInputStream bis = new BufferedInputStream(System.in);\n\n\t    public int read() \n\t    {\n\t        if (-1 == numChars)\n\t        {\n\t        \tthrow new InputMismatchException();\n\t        }\n\t        if (curChar >= numChars)\n\t        {\n\t            curChar = 0;\n\t            try \n\t            {\n\t                numChars = bis.read(buf);\n\t            }\n\t            catch (IOException e)\n\t            {\n\t                throw new InputMismatchException();\n\t            }\n\t            if (numChars <= 0)\n\t            {\n\t            \treturn -1;\n\t            }\n\t        }\n\t        return buf[curChar++];\n\t    }\n\n\t    public int nextInt() \n\t    {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t        {\n\t        \tc = read();\n\t        }\n\t        int sgn = 1;\n\t        if (c == '-') \n\t        {\n\t            sgn = -1;\n\t            c = read();\n\t        }\n\t        int res = 0;\n\t        do \n\t        {\n\t            if (c < '0' || c > '9')\n\t            {\n\t            \tthrow new InputMismatchException();\n\t            }\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\t    \n\t    public long nextLong() \n\t    {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t        {\n\t        \tc = read();\n\t        }\n\t        int sgn = 1;\n\t        if (c == '-') \n\t        {\n\t            sgn = -1;\n\t            c = read();\n\t        }\n\t        long res = 0;\n\t        do \n\t        {\n\t            if (c < '0' || c > '9')\n\t            {\n\t            \tthrow new InputMismatchException();\n\t            }\n\t            res *= 10;\n\t            res += c - '0';\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\t    \n\t    public String next()\n\t    {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t        {\n\t        \tc = read();\n\t        }\n\t        StringBuilder res = new StringBuilder();\n\t        do \n\t        {\n\t            res.appendCodePoint(c);\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res.toString();\n\t    }\n\n\t    private boolean isSpaceChar(int c) \n\t    {\n\t        return ' ' == c || '\\n' == c || '\\r' == c || '\\t' == c || -1 == c;\n\t    }\n\t}\n}", "label": 3}
{"src": "//package round258;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class E {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tlong s = nl();\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\tint mod = 1000000007;\n\t\tlong ret = 0;\n\t\tfor(int i = 0;i < 1<<n;i++){ // used\n\t\t\tlong sum = 0;\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(i<<31-j<0)sum += a[j]+1;\n\t\t\t}\n\t\t\tlong rem = s-sum;\n\t\t\tif(rem < 0)continue;\n\t\t\tlong val = 1;\n\t\t\tlong N = rem+n-1, R = n-1;\n\t\t\tfor(int j = 1;j <= R;j++){\n\t\t\t\tval = val * ((N-j+1)%mod) % mod * invl(j, mod) % mod;\n\t\t\t}\n\t\t\tif(Integer.bitCount(i) % 2 == 0){\n\t\t\t\tret += val;\n\t\t\t}else{\n\t\t\t\tret += mod-val;\n\t\t\t}\n\t\t}\n\t\tout.println(ret%mod);\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0){\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new E().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "label": 3}
{"src": "import java.util.Scanner;\n\n\npublic class cf258e {\nstatic int mod=1000000007;\nstatic long a[];\nstatic long b[];\nprivate static long gao(long x,int r)\n{\n    long y=1;\n    while(r>0)\n    {\n        if(r%2!=0)\n        {\n            y=y*x%mod;\n            r--;\n        }\n        else\n        {\n            x=x*x%mod;\n            r/=2;\n        }\n    }\n    return y;\n}\npublic static void main(String[] args) {\n    Scanner scanner=new Scanner(System.in);\n    int n=scanner.nextInt();\n    long s=scanner.nextLong();\n    a=new long[50];\n    for(int i=1;i<=n;i++)\n    {\n        a[i]=scanner.nextLong();        \n    }\n    b=new long [50];\n    for(int i=1;i<=40;i++)\n    {\n        b[i]=gao(i,mod-2);\n    }\n    long sum=0;\n    for(int i=0;i<(1<<n);i++)\n    {\n        int p=0;\n        long ns=s;\n        for(int j=0;j<n;j++)\n        {\n            if(((i>>j)&1)>0)\n            {\n                p++;\n                ns-=(a[j+1]+1);\n            }\n        }\n        if(ns<0)\n            continue;\n        long y=1;\n        for(int k=1;k<=n-1;k++)\n        {\n            y=y*b[k]%mod;\n            y=(y*((ns+n-k)%mod))%mod;\n        }\n        if(p%2==0)\n        {\n            sum=(sum+y)%mod;\n        }\n        else {\n            sum=(sum-y+mod)%mod;\n        }\n                    \n    }\n    System.out.println(sum);\n    \n}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.util.concurrent.*;\n\npublic final class devu_and_flowers\n{\n    static BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\tstatic FastScanner sc=new FastScanner(br);\n    static PrintWriter out=new PrintWriter(System.out);\n\tstatic Random rnd=new Random();\n\tstatic long mod=(long)(1e9+7);\n\t\n\tstatic long C(long n,long diff)\n\t{\n\t\tlong ret=1,upper=n+diff-1;\n\t\t\n\t\tfor(long x=upper;x>diff;x--)\n\t\t{\n\t\t\tlong now=x%mod;\n\t\t\t\t\n\t\t\tret=(ret*now)%mod;\n\t\t}\n\t\t\n\t\treturn (ret*pow(fact(n-1),mod-2))%mod;\n\t}\n\t\n\tstatic long fact(long n)\n\t{\n\t\tlong ret=1;\n\t\t\n\t\tfor(long i=1;i<=n;i++)\t\n\t\t{\n\t\t\tret=(ret*i)%mod;\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tstatic long pow(long a,long b)\n\t{\n\t\tlong x=1,y=a;\n\t\t\n\t\twhile(b>0)\n\t\t{\n\t\t\tif(b%2==1)\n\t\t\t{\n\t\t\t\tx=(x*y)%mod;\n\t\t\t}\n\t\t\t\n\t\t\ty=(y*y)%mod;b=b/2;\n\t\t}\n\t\t\n\t\treturn x;\n\t}\n\t\n\tstatic Map<Long,Long> merge(Map<Long,Long> m1,long now)\n\t{\t\n\t\tMap<Long,Long> m2=new HashMap<>(),ret=new HashMap<>();\n\t\t\n\t\tm2.put(0L,1L);m2.put(now,(-1L+mod)%mod);\n\t\t\n\t\tfor(Map.Entry<Long,Long> en1:m1.entrySet())\n\t\t{\n\t\t\tfor(Map.Entry<Long,Long> en2:m2.entrySet())\n\t\t\t{\n\t\t\t\tlong add=en1.getKey()+en2.getKey(),mul=(en1.getValue()*en2.getValue())%mod;\n\t\t\t\t\n\t\t\t\tret.put(add,(ret.getOrDefault(add,0L)+mul)%mod);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n    public static void main(String args[]) throws Exception\n    {\n\t\tint n=sc.nextInt();long s=sc.nextLong();\n\t\t\n\t\tlong[] a=new long[n];\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\ta[i]=sc.nextLong();\n\t\t}\n\t\t\n\t\t// 1-x^a[i]+1..\n\t\t\n\t\tMap<Long,Long> m1=new HashMap<>();m1.put(0L,1L);\n\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tm1=merge(m1,a[i]+1);\n\t\t}\n\t\t\n\t\tlong res=0;\n\t\t\n\t\tfor(Map.Entry<Long,Long> en:m1.entrySet())\n\t\t{\t\n\t\t\tlong curr=en.getKey();\n\t\t\t\n\t\t\tif(curr<=s)\n\t\t\t{\n\t\t\t\tlong diff=s-curr;\n\t\t\t\t\n\t\t\t\tlong now=C(n,diff);\n\t\t\t\n\t\t\t\tlong mul=(en.getValue()*now)%mod;\n\t\t\t\t\n\t\t\t\tres=(res+mul)%mod;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(res);out.close();\n    }\n\t\n\tprivate static class Pair\n\t{\n\t\tlong pow,cof;\n\t\t\n\t\tpublic Pair(long pow,long cof)\n\t\t{\n\t\t\tthis.pow=pow;this.cof=cof;\n\t\t}\n\t}\n}\nclass FastScanner\n{\n    BufferedReader in;\n    StringTokenizer st;\n\n    public FastScanner(BufferedReader in) {\n        this.in = in;\n    }\n\t\n    public String nextToken() throws Exception {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\t\n\tpublic String next() throws Exception {\n\t\treturn nextToken().toString();\n\t}\n\t\n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n}", "label": 3}
{"src": "//package round258;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\npublic class E2 {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tlong s = nl();\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\tint mod = 1000000007;\n\t\tlong ret = 0;\n\t\t\n\t\tlong invf = 1;\n\t\tfor(int j = 1;j <= n-1;j++){\n\t\t\tinvf = invf * j % mod;\n\t\t}\n\t\tinvf = invl(invf, mod);\n\t\t\n\t\tfor(int i = 0;i < 1<<n;i++){ // used\n\t\t\tlong sum = 0;\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(i<<31-j<0)sum += a[j]+1;\n\t\t\t}\n\t\t\tlong rem = s-sum;\n\t\t\tif(rem < 0)continue;\n\t\t\tlong val = 1;\n\t\t\tlong N = rem+n-1, R = n-1;\n\t\t\tN = N%mod;\n\t\t\tfor(int j = 1;j <= R;j++){\n\t\t\t\tval = val * (N--) % mod;\n\t\t\t}\n\t\t\tif(Integer.bitCount(i) % 2 == 0){\n\t\t\t\tret += val;\n\t\t\t}else{\n\t\t\t\tret += mod-val;\n\t\t\t}\n\t\t}\n\t\tret = ret%mod*invf%mod;\n\t\tout.println(ret);\n\t}\n\t\n\tpublic static long invl(long a, long mod) {\n\t\tlong b = mod;\n\t\tlong p = 1, q = 0;\n\t\twhile (b > 0){\n\t\t\tlong c = a / b;\n\t\t\tlong d;\n\t\t\td = a;\n\t\t\ta = b;\n\t\t\tb = d % b;\n\t\t\td = p;\n\t\t\tp = q;\n\t\t\tq = d - c * q;\n\t\t}\n\t\treturn p < 0 ? p + mod : p;\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new E2().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.text.*;\nimport java.io.*;\nimport java.math.*;\npublic class code5 {\n\tInputStream is;\n\tPrintWriter out;\n\tstatic long mod=pow(10,9)+7;\n\tstatic int dx[]={0,0,1,-1},dy[]={1,-1,0,0};\n \tvoid solve() throws Exception\n\t{\n \t\tint n=ni();\n \t\tlong sum=nl();\n \t\tlong a[]=nl(n);\n \t\tlong ans=ncr(sum+n-1,n-1);\n \t\tfor(int i=1;i<(1<<n);i++)\n \t\t{\n \t\t\tlong temp=0,count=0;\n \t\t\tfor(int j=0;j<n;j++)\n \t\t\t{\n \t\t\t\tif((i&(1<<j))!=0)\n \t\t\t\t{\n \t\t\t\t\tcount++;\n \t\t\t\t\ttemp+=(a[j]+1);\n \t\t\t\t}\n \t\t\t}\n \t\t\tif(count%2==0)\n \t\t\t{\n \t\t\t\tans+=(ncr(sum-temp+n-1,n-1));\n \t\t\t\tans%=mod;\n \t\t\t}else {\n \t\t\t\tans=(ans-ncr(sum-temp+n-1,n-1)+mod)%mod;\n \t\t\t}\n \t\t}\n \t\tout.print(ans%mod);\n\t}\n \tlong ncr(long n,long r)\n \t{\n \t\tlong nom=1;\n \t\tif(n<0||n<r)\n \t\t\treturn 0;\n \t\tfor(long i=n;i>=(n-r+1);i--)\n \t\t{\n \t\t\tnom*=(i%mod);\n \t\t\tnom%=mod;\n \t\t}\n \t\tlong dom=1;\n \t\tfor(long i=r;i>=1;i--)\n \t\t{\n \t\t\tdom*=(i%mod);\n \t\t\tdom%=mod;\n \t\t}\n \t\treturn (nom*pow(dom,mod-2,mod))%mod;\n \t}\n \t/*void take(int n)\n \t{\n \t\tal=new ArrayList[n];\n \t\tfor(int i=0;i<n;i++)\n \t\t\tal[i]=new ArrayList<Integer>();\n \t\tfor(int i=0;i<n-1;i++)\n \t\t{\n \t\t\tint x=ni()-1;\n \t\t\tint y=ni()-1;\n \t\t\tal[x].add(y);\n \t\t\tal[y].add(x);\n \t\t}\n \t}*/\n \t\n \tint check(long n)\n \t{\n \t\tint count=0;\n \t\twhile(n!=0)\n \t\t{\n \t\t\tif(n%10!=0)\n \t\t\t\tbreak;\n \t\t\tn/=10;\n \t\t\tcount++;\n \t\t}\n \t\treturn count;\n \t}\n\tpublic static int count(int x)\n\t{\n\t\tint num=0;\n\t\twhile(x!=0)\n\t\t{\n\t\t\tx=x&(x-1);\n\t\t\tnum++;\n\t\t}\n\t\treturn num;\n\t}\n\tstatic long d, x, y;\n\tvoid extendedEuclid(long A, long B) {\n\t    if(B == 0) {\n\t        d = A;\n\t        x = 1;\n\t        y = 0;\n\t    }\n\t    else {\n\t        extendedEuclid(B, A%B);\n\t        long temp = x;\n\t        x = y;\n\t        y = temp - (A/B)*y;\n\t    }\n\t}\n\tlong modInverse(long A,long M) //A and M are coprime\n\t{\n\t    extendedEuclid(A,M);\n\t    return (x%M+M)%M;    //x may be negative\n\t}\n\tpublic static void mergeSort(int[] arr, int l ,int r){\n\t\tif((r-l)>=1){\n\t\t\tint mid = (l+r)/2;\n\t\t\tmergeSort(arr,l,mid);\n\t\t\tmergeSort(arr,mid+1,r);\n\t\t\tmerge(arr,l,r,mid);\n\t\t}\n\t}\n\tpublic static void merge(int arr[], int l, int r, int mid){\n\t\tint n1 = (mid-l+1), n2 = (r-mid);\n\t\tint left[] = new int[n1];\n\t\tint right[] = new int[n2];\n\t\tfor(int i =0 ;i<n1;i++) left[i] = arr[l+i];\n\t\tfor(int i =0 ;i<n2;i++) right[i] = arr[mid+1+i];\n\t\tint i =0, j =0, k = l;\n\t\twhile(i<n1 && j<n2){\n\t\t\tif(left[i]>right[j]){\n\t\t\t\tarr[k++] = right[j++];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tarr[k++] = left[i++];\n\t\t\t}\n\t\t}\n\t\twhile(i<n1) arr[k++] = left[i++];\n\t\twhile(j<n2) arr[k++] = right[j++];\n\t}\n\tpublic static void mergeSort(long[] arr, int l ,int r){\n\t\tif((r-l)>=1){\n\t\t\tint mid = (l+r)/2;\n\t\t\tmergeSort(arr,l,mid);\n\t\t\tmergeSort(arr,mid+1,r);\n\t\t\tmerge(arr,l,r,mid);\n\t\t}\n\t}\n\tpublic static void merge(long arr[], int l, int r, int mid){\n\t\tint n1 = (mid-l+1), n2 = (r-mid);\n\t\tlong left[] = new long[n1];\n\t\tlong right[] = new long[n2];\n\t\tfor(int i =0 ;i<n1;i++) left[i] = arr[l+i];\n\t\tfor(int i =0 ;i<n2;i++) right[i] = arr[mid+1+i];\n\t\tint i =0, j =0, k = l;\n\t\twhile(i<n1 && j<n2){\n\t\t\tif(left[i]>right[j]){\n\t\t\t\tarr[k++] = right[j++];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tarr[k++] = left[i++];\n\t\t\t}\n\t\t}\n\t\twhile(i<n1) arr[k++] = left[i++];\n\t\twhile(j<n2) arr[k++] = right[j++];\n\t}\n\t static class Pair implements Comparable<Pair>{\n\t\t \n\t       int x,y,k;\n\t       int i,dir;\n\t\tPair (int xx,int yy){\n\t\t\tthis.x=xx;\n\t\t\tthis.y=yy;\n\t\t}   \n\t\tpublic int compareTo(Pair o) {\n\t\t\tif(this.x!=o.x)\n\t\t\t\treturn this.x-o.x;\n\t\t\treturn this.y-o.y;\n\t\t}\n\t \n\t\tpublic String toString(){\n\t\t\treturn x+\" \"+y+\" \"+k+\" \"+i;}\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (o instanceof Pair) {\n\t\t\t\tPair p = (Pair)o;\n\t\t\t\treturn p.x == x && p.y == y;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tpublic int hashCode() {\n\t\t\treturn new Long(x).hashCode()*31 + new Long(y).hashCode() ;\n\t\t}\n\t} \n\t    \n\t    public static boolean isPal(String s){\n\t        for(int i=0, j=s.length()-1;i<=j;i++,j--){\n\t                if(s.charAt(i)!=s.charAt(j)) return false;\n\t        }\n\t        return true;\n\t    }\n\t    public static String rev(String s){\n\t\t\tStringBuilder sb=new StringBuilder(s);\n\t\t\tsb.reverse();\n\t\t\treturn sb.toString();\n\t    }\n\t    \n\t    public static long gcd(long x,long y){\n\t\tif(y==0)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn gcd(y,x%y);\n\t    }\n\t    \n\t    public static int gcd(int x,int y){\n\t    \tif(y==0) \n\t    \t\treturn x; \n\t    \treturn gcd(y,x%y);\n\t    }\n\t    \n\t    public static long gcdExtended(long a,long b,long[] x){\n\t        \n\t        if(a==0){\n\t            x[0]=0;\n\t            x[1]=1;\n\t            return b;\n\t        }\n\t        long[] y=new long[2];\n\t        long gcd=gcdExtended(b%a, a, y);\n\t        \n\t        x[0]=y[1]-(b/a)*y[0];\n\t        x[1]=y[0];\n\t        \n\t        return gcd;\n\t    }\n\t    \n\t    public static int abs(int a,int b){\n\t\treturn (int)Math.abs(a-b);\n\t    }\n\t \n\t    public static long abs(long a,long b){\n\t\treturn (long)Math.abs(a-b);\n\t    }\n\t    \n\t    public static int max(int a,int b){\n\t\tif(a>b)\n\t\t\treturn a;\n\t\telse\n\t\t\treturn b;\n\t    }\n\t \n\t    public static int min(int a,int b){\n\t\tif(a>b)\n\t\t\treturn b;\n\t\telse \n\t\t\treturn a;\n\t    }\n\t    \n\t    public static long max(long a,long b){\n\t\tif(a>b)\n\t\t\treturn a;\n\t\telse\n\t\t\treturn b;\n\t    }\n\t \n\t    public static long min(long a,long b){\n\t\tif(a>b)\n\t\t\treturn b;\n\t\telse \n\t\t\treturn a;\n\t    }\n\t \n\t    public static long pow(long n,long p,long m){\n\t\t long  result = 1;\n\t\t  if(p==0)\n\t\t    return 1;\n\t\tif (p==1)\n\t\t    return n;\n\t\twhile(p!=0)\n\t\t{\n\t\t    if(p%2==1)\n\t\t        result *= n;\n\t\t    if(result>=m)\n\t\t    result%=m;\n\t\t    p >>=1;\n\t\t    n*=n;\n\t\t    if(n>=m)\n\t\t    n%=m;\n\t\t}\n\t\treturn result;\n\t    }\n\t    \n\t    public static long pow(long n,long p){\n\t\tlong  result = 1;\n\t\t  if(p==0)\n\t\t    return 1;\n\t\tif (p==1)\n\t\t    return n;\n\t\twhile(p!=0)\n\t\t{\n\t\t    if(p%2==1)\n\t\t        result *= n;\t    \n\t\t    p >>=1;\n\t\t    n*=n;\t    \n\t\t}\n\t\treturn result;\n\t    }\n\t    public static void debug(Object... o) {\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t\t}\n\t    void run() throws Exception {\n\t\t\tis = System.in;\n\t\t\tout = new PrintWriter(System.out);\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t   \n\t    public static void main(String[] args) throws Exception {\n\t\t\tnew Thread(null, new Runnable() {\n\t\t\t\tpublic void run() {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tnew code5().run();\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}, \"1\", 1 << 26).start();\n\t\t\t\n\t    \t//new code5().run();\n\t\t}\n\t    private byte[] inbuf = new byte[1024];\n\t\tpublic int lenbuf = 0, ptrbuf = 0;\n\t \n\t\tprivate int readByte() {\n\t\t\tif (lenbuf == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (ptrbuf >= lenbuf) {\n\t\t\t\tptrbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn inbuf[ptrbuf++];\n\t\t}\n\t \n\t\tprivate boolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\t \n\t\tprivate int skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && isSpaceChar(b));\n\t\t\treturn b;\n\t\t}\n\t \n\t\tprivate double nd() {\n\t\t\treturn Double.parseDouble(ns());\n\t\t}\n\t \n\t\tprivate char nc() {\n\t\t\treturn (char) skip();\n\t\t}\n\t \n\t\tprivate String ns() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t \n\t\tprivate char[] ns(int n) {\n\t\t\tchar[] buf = new char[n];\n\t\t\tint b = skip(), p = 0;\n\t\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t\t}\n\t \n\t\tprivate char[][] nm(int n, int m) {\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = ns(m);\n\t\t\treturn map;\n\t\t}\n\t \n\t\tprivate int[] na(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = ni();\n\t\t\treturn a;\n\t\t}\n\t\tprivate long[] nl(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nl();\n\t\t\treturn a;\n\t\t}\n\t \n\t\tprivate int ni() {\n\t\t\tint num = 0, b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t \n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t \n\t\tprivate long nl() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t \n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t \n}", "label": 3}
{"src": "// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF451E extends PrintWriter {\n\tCF451E() { super(System.out, true); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF451E o = new CF451E(); o.main(); o.flush();\n\t}\n\n\tstatic final int MD = 1000000007;\n\tint d_, x_, y_;\n\tvoid gcd_(int a, int b) {\n\t\tif (b == 0) {\n\t\t\td_ = a;\n\t\t\tx_ = 1; y_ = 0;\n\t\t} else {\n\t\t\tgcd_(b, a % b);\n\t\t\tint t = x_ - a / b * y_; x_ = y_; y_ = t;\n\t\t}\n\t}\n\tint[] inv;\n\tvoid init(int n) {\n\t\tinv = new int[n];\n\t\tfor (int k = 1; k < n; k++) {\n\t\t\tgcd_(k, MD);\n\t\t\tif (x_ < 0)\n\t\t\t\tx_ += MD;\n\t\t\tinv[k] = x_;\n\t\t}\n\t}\n\tlong ch(long n, int k) {\n\t\treturn k == 0 ? 1 : ch(n - 1, k - 1) * (n % MD) % MD * inv[k] % MD;\n\t}\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tinit(n);\n\t\tlong s = sc.nextLong();\n\t\tlong[] ff  = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tff[i] = sc.nextLong();\n\t\tint ans = 0;\n\t\tfor (int b = 0; b < 1 << n; b++) {\n\t\t\tint k = 0;\n\t\t\tlong t = s;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tif ((b & 1 << i) != 0) {\n\t\t\t\t\tk++;\n\t\t\t\t\tt -= ff[i] + 1;\n\t\t\t\t}\n\t\t\tif (t >= 0) {\n\t\t\t\tint cnt = (int) ch(t + n - 1, n - 1);\n\t\t\t\tans = (k % 2 == 0 ? ans + cnt : ans - cnt) % MD;\n\t\t\t}\n\t\t}\n\t\tif (ans < 0)\n\t\t\tans += MD;\n\t\tprintln(ans);\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class CODEFORCES {\n\tprivate InputStream is;\n\tprivate PrintWriter out;\n\n\tlong fact[] = new long[21];\n\tlong mod = (long) 1e9 + 7;\n\tlong fi[] = new long[21];\n\n\tlong pow(long a, long b) {\n\t\tlong ans = 1;\n\t\tif (a == 0)\n\t\t\treturn 0;\n\t\twhile (b > 0) {\n\t\t\tif ((b & 1) == 1)\n\t\t\t\tans = (ans * a) % mod;\n\t\t\ta = (a * a) % mod;\n\t\t\tb >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tlong ni;\n\n\tlong nCr(long a) {\n\t\tlong ans = 1;\n\t\tlong mi = Math.min(a, ni - 1);\n\t\tlong ma = mi;\n\t\twhile (mi-- > 0)\n\t\t\tans = (ans * ((ni + (--a)) % mod)) % mod;\n\t\treturn (ans * fi[(int) ma]) % mod;\n\t}\n\n\tvoid solve() {\n\t\tint n = ni();\n\t\tni = n;\n\t\tlong s = nl();\n\t\tlong val[] = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tval[i] = nl();\n\t\tfact[0] = 1;\n\t\tfi[0] = pow(fact[0], mod - 2);\n\t\tfor (int i = 1; i <= 20; i++) {\n\t\t\tfact[i] = (fact[i - 1] * i) % mod;\n\t\t\tfi[i] = pow(fact[i], mod - 2);\n\t\t}\n\t\tHashMap<Long, Long> map = new HashMap<Long, Long>();\n\t\tmap.put((long) 0, (long) 1);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tHashMap<Long, Long> tmp = new HashMap<Long, Long>();\n\t\t\tfor (long p : map.keySet())\n\t\t\t\ttmp.put(p, map.get(p));\n\t\t\tfor (long p : map.keySet()) {\n\t\t\t\tlong add = p + val[i] + 1;\n\t\t\t\tif (add > s)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (tmp.containsKey(add))\n\t\t\t\t\ttmp.put(add, (mod + tmp.get(add) - map.get(p)) % mod);\n\t\t\t\telse\n\t\t\t\t\ttmp.put(add, mod - map.get(p));\n\t\t\t}\n\t\t\tmap = tmp;\n\t\t}\n\t\tlong ans = 0;\n\t\tfor (long a : map.keySet()) {\n\t\t\t// out.println(a + \" \" + map.get(a));\n\t\t\tans = (ans + nCr(s - a) * map.get(a) % mod) % mod;\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tvoid soln() throws Exception {\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew CODEFORCES().soln();\n\t}\n\n\t// To Get Input\n\t// Some Buffer Methods\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tprivate void tr(Object... o) {\n\t\tif (!oj)\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Task451E {\n\n\tprivate static final long MOD = 1000000007;\n\t\n\tprivate FastScanner in;\n\tprivate PrintWriter out;\n\n\tprivate long inverseNMinusOneFactorial;\n\tprivate long nMinusOne;\n\n\tpublic Task451E(InputStream in, OutputStream out) {\n\t\tthis.in = new FastScanner(in);\n\t\tthis.out = new PrintWriter(out);\n\t}\n\n\tpublic void solve() throws IOException {\n\t\tint n = nextInt();\n\t\tlong s = nextLong();\n\t\tlong f[] = new long[n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tf[i] = nextLong();\n\t\t}\n\t\tpreCalc(n);\n\t\tlong result = 0;\n\t\tmask:\n\t\tfor (int mask = 0; mask < (1 << n); ++mask) {\n\t\t\tlong restS = s;\n\t\t\tboolean subtract = false;\n\t\t\tfor (int bit = 0; bit < n; ++bit) {\n\t\t\t\tif (((1 << bit) & mask) != 0) {\n\t\t\t\t\trestS -= f[bit] + 1;\n\t\t\t\t\tif (restS < 0) {\n\t\t\t\t\t\tcontinue mask;\n\t\t\t\t\t}\n\t\t\t\t\tsubtract = !subtract;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (subtract) {\n\t\t\t\tresult = (result + (MOD - c(restS))) % MOD;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = (result + c(restS)) % MOD;\n\t\t\t}\n\t\t}\n\t\tout.println(result);\n\t}\n\t\n\tprivate void preCalc(int n) {\n\t\tlong factorial = 1;\n\t\tfor (int i = 1; i < n; ++i) {\n\t\t\tfactorial = (factorial * i) % MOD;\n\t\t}\n\t\tnMinusOne = n - 1;\n\t\tinverseNMinusOneFactorial = powerMod(factorial, MOD - 2);\n\t}\n\n\tprivate long powerMod(long n, long power) {\n\t\tlong result = 1;\n\t\tn = n % MOD;\n\t\tfor (int bit = 1; bit <= power; bit <<= 1) {\n\t\t\tif ((power & bit) != 0) {\n\t\t\t\tresult = (result * n) % MOD;\n\t\t\t}\n\t\t\tn = (n * n) % MOD;\n\t\t}\n\t\treturn result;\n\t}\n\n\tpublic long c(long restS) {\n\t\tlong result = 1;\n\t\tfor (long i = restS + 1; i <= (restS + nMinusOne); ++i) {\n\t\t\tresult = (result * (i % MOD)) % MOD;\n\t\t}\n\t\treturn (result * inverseNMinusOneFactorial) % MOD;\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner(InputStream stream) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(in.next());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(in.next());\n\t}\n\n\t\n\tpublic static void main(String[] arg) {\n\t\tnew Task451E(System.in, System.out).run();\n\t}\n}\n\n", "label": 3}
{"src": "import java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.*;\n\npublic class DevuAndFlowers {\n\n\tstatic long mod = 1000000007;\n\tstatic long modInv[];\n\tstatic int N;\n\tstatic long S;\n\tstatic long f[];\n\tstatic long fact[];\n\tpublic static void main(String[] args) {\n\t\tJS in = new JS();\n\t\tN = in.nextInt();\n\t\tS = in.nextLong();\n\t\tf = new long[N];\n\t\tfact = new long[1000000];\n\t\tfact[0]=1;\n\t\tfact[1]=1;\n\t\tfor(int i = 2; i < 1000000; i++) fact[i] = (fact[i-1]*i)%mod;\n\t\tfor(int i = 0; i < N; i++) f[i] = in.nextLong();\n\t\tmodInv = new long[N+1];\n\t\tfor(int i = 0; i <= N; i++) modInv[i] = pow(i, mod-2);\n\t\t\n\t\tlong ans = 0;\n\t\tfor(int i = 0; i < (1<<N); i++) {\n\t\t\tlong over = S;\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif((i & (1<<j)) > 0) {\n\t\t\t\t\tover -= f[j]+1;\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(over < 0) continue;\n\t\t\tlong v = sumTo(over, N);\n\t\t\tlong vs = c(over+N-1, N-1, mod);\n\t\t\tif(Integer.bitCount(i)%2==1) ans -= vs;\n\t\t\telse ans += vs;\n\t\t\twhile(ans < 0) ans+=mod;\n\t\t\twhile(ans >= mod)ans-=mod;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic long sumTo(long sum, long n) {\n\t\treturn choose(sum+n-1, n-1);\n\t}\n\tstatic long choose(long n, long k) {\n\t\tlong prev = 1;\n\t\tfor(int c = 1; c <= k; c++)\n\t\t\tprev = (((prev*(n-c+1))%mod)*modInv[c])%mod;\n\t\treturn prev;\n\t}\n\tstatic long c(long n, long k, long p) {\n\t\tif(cf(n,p) > cf(k,p) + cf(n-k,p)) return 0;\n\t\tlong ans = 1;\n\t\tfor(long i = n-k+1; i <= n; i++) {\n\t\t\tans = ((ans%mod)*(i%mod))%mod;\n\t\t}\n\t\tans = ((ans%mod)*inverse(fact[(int)k],mod))%mod;\n\t\treturn ans;\n\t}\n\tstatic long inverse(long n, long p) {\n\t\treturn pow(n, p-2);\n\t}\n\tstatic long cf(long n, long p) {\n\t\tlong k = 0;\n\t\twhile(n >= p) {\n\t\t\tk+=n/p;\n\t\t\tn/=p;\n\t\t}\n\t\treturn k;\n\t}\n\t\n\t\n\tstatic long pow(long base, long power) {\n\t\tif(power == 0) return 1;\n\t\tif(power == 1) return base;\n\t\tif((power%2)==0) {\n\t\t\tlong r = pow(base, power/2);\n\t\t\treturn (r*r)%mod;\n\t\t}\n\t\telse {\n\t\t\treturn (base * pow(base,power-1))%mod;\n\t\t}\n\t}\n\n\t\n\tstatic class JS{\n\t\tpublic int BS = 1<<16;\n\t\tpublic char NC = (char)0;\n\t\tbyte[] buf = new byte[BS];\n\t\tint bId = 0, size = 0;\n\t\tchar c = NC;\n\t\tdouble num = 1;\n\t\tBufferedInputStream in;\n\t\t\n\t\tpublic JS() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\t\t\n\t\tpublic JS(String s) throws FileNotFoundException {\n\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t}\n\t\t\n\t\tpublic char nextChar(){\n\t\t\twhile(bId==size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t}catch(Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(size==-1)return NC;\n\t\t\t\tbId=0;\n\t\t\t}\n\t\t\treturn (char)buf[bId++];\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\tnum=1;\n\t\t\tboolean neg = false;\n\t\t\tif(c==NC)c=nextChar();\n\t\t\tfor(;(c<'0' || c>'9'); c = nextChar()) {\n\t\t\t\tif(c=='-')neg=true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(; c>='0' && c <='9'; c=nextChar()) {\n\t\t\t\tres = (res<<3)+(res<<1)+c-'0';\n\t\t\t\tnum*=10;\n\t\t\t}\n\t\t\treturn neg?-res:res;\n\t\t}\n\t\t\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c!='.' ? cur:cur+nextLong()/num;\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c>32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\t\t\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c!='\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif(c>32)return true;\n\t\t\twhile(true) {\n\t\t\t\tc=nextChar();\n\t\t\t\tif(c==NC)return false;\n\t\t\t\telse if(c>32)return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int []nia(int n){\n\t\t\tint r[] = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) r[i] = nextInt();\n\t\t\treturn r;\n\t\t}\n\t\tpublic double []nda(int n){\n\t\t\tdouble r[] = new double[n];\n\t\t\tfor(int i = 0; i < n; i++) r[i] = nextDouble();\n\t\t\treturn r;\n\t\t}\n\t\tpublic long []nla(int n){\n\t\t\tlong r[] = new long[n];\n\t\t\tfor(int i = 0; i < n; i++) r[i] = nextLong();\n\t\t\treturn r;\n\t\t}\n\t}\n\t\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main{\n    FastScanner in;\n    PrintWriter out;\n\n    public long mod = 1000000000+7;\n    long[] fact;\n\n    public long bin_pow(long d, long step) {\n        if (step == 0) return 1;\n        if (step == 1) return d % mod;\n        long x = bin_pow(d, step/2);\n        x = (x * x) % mod;\n        if (step % 2 == 1)\n            x = (x * d) % mod;\n        return x;\n    }\n\n    public long bC(int n, int k) {\n        long res = fact[n];\n        res *= bin_pow(fact[k], mod-2);\n        res %= mod;\n        res *= bin_pow(fact[n-k], mod-2);\n        res %= mod;\n        return res;\n    }\n\n    public long C(long n, int k) {\n        if (n <= k)\n            return bC((int)n, k);\n\n        long res = 1;\n        for (int p = 0; p < k ; p++) {\n            res *= (n-p) % mod;\n            res %= mod;\n        }\n\n        res *= bin_pow(fact[k], mod-2);\n        res %= mod;\n\n        return res;\n    }\n\n    public void solve()\n    {\n        int n = in.nextInt();\n        long s = in.nextLong();\n        long[] f = new long[n];\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            f[i] = in.nextLong();\n            sum += f[i];\n        }\n\n        fact = new long[n+10];\n        fact[0] = 1;\n        for (int i = 1; i < n+10; i++) {\n            fact[i] = i * fact[i-1];\n            fact[i] %= mod;\n        }\n\n\n        long ans = 0;\n        long sg;\n        for(int mask = 0; mask < (1<<n); mask++) {\n            int cnt = 0;\n            sum = s;\n            for (int i = 0; i < n; i++)\n            if ((mask >> i) % 2 == 1)\n            {\n                cnt++;\n                sum -= f[i]+1;\n            }\n\n            if (sum < 0) continue;\n\n            if (cnt % 2 == 1)\n                sg = -1;\n            else\n                sg = 1;\n\n            long tmp_ans = 0;\n\n            tmp_ans = C(sum + n - 1, n - 1);\n\n            ans += sg * tmp_ans;\n            ans += 2*mod;\n            ans %= mod;\n        }\n\n\n        out.println(ans);\n    }\n\n    public void run()\n    {\n        in = new FastScanner();\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n\n    public static void main(String[] args) {\n        new Main().run();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}", "label": 3}
{"src": "/**\n * author: derrick20\n * created: 12/7/20 6:00 PM\n */\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class DevuFlowersPIE {\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int N = sc.nextInt();\n        long S = sc.nextLong();\n        long[] f = sc.nextLongs(N);\n\n        long[] inv = new long[20];\n        invFact = new long[20];\n        invFact[0] = invFact[1] = inv[1] = 1;\n        for (int i = 2; i < 20; i++) {\n            inv[i] = mod - ((mod / i) * inv[(int) mod % i] % mod);\n            invFact[i] = (inv[i] * invFact[i - 1]) % mod;\n        }\n        long[] sum = new long[1 << N];\n        int[] log = new int[29];\n        for (int k = 0; k < 20; k++) {\n            log[(1 << k) % 29] = k;\n        }\n        /*\n        It just happens to work out that x = 2, p = 29 has multiplicative order 28,\n        so that's good enough for this\n         */\n        long ans = choose(S + N - 1, N - 1);\n        for (int mask = 1; mask < 1 << N; mask++) {\n            int elems = Integer.bitCount(mask);\n            long sign = (elems & 1) == 0 ? 1 : -1;\n            sum[mask] = sum[mask ^ (mask & -mask)] + f[log[(mask & -mask) % 29]];\n            long S2 = S - sum[mask] - elems;\n            long amt = (sign * choose(S2 + N - 1, N - 1)) % mod;\n            if (amt < 0) {\n                amt += mod;\n            }\n            ans = (ans + amt) % mod;\n        }\n        out.println(ans);\n        out.close();\n    }\n    static long mod = (long) 1e9 + 7;\n    static long[] invFact;\n\n    static long choose(long n, long k) {\n        if (k > n) return 0;\n        long ans = invFact[(int) k];\n        n %= mod; // KEY BUG\n        while (k > 0) {\n            ans = (ans * n) % mod;\n            n--; k--;\n        }\n        return ans;\n    }\n\n    static class FastScanner {\n        private int BS = 1 << 16;\n        private char NC = (char) 0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n\n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n\n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            } catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n\n        private char getChar() {\n            while (bId == size) {\n                try {\n                    size = in.read(buf);\n                } catch (Exception e) {\n                    return NC;\n                }\n                if (size == -1) return NC;\n                bId = 0;\n            }\n            return (char) buf[bId++];\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public int[] nextInts(int N) {\n            int[] res = new int[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = (int) nextLong();\n            }\n            return res;\n        }\n\n        public long[] nextLongs(int N) {\n            long[] res = new long[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public long nextLong() {\n            cnt = 1;\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            long res = 0;\n            for (; c >= '0' && c <= '9'; c = getChar()) {\n                res = (res << 3) + (res << 1) + c - '0';\n                cnt *= 10;\n            }\n            return neg ? -res : res;\n        }\n\n        public double nextDouble() {\n            double cur = nextLong();\n            return c != '.' ? cur : cur + nextLong() / cnt;\n        }\n\n        public double[] nextDoubles(int N) {\n            double[] res = new double[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextDouble();\n            }\n            return res;\n        }\n\n        public String next() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c > 32) {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c != '\\n') {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        public boolean hasNext() {\n            if (c > 32) return true;\n            while (true) {\n                c = getChar();\n                if (c == NC) return false;\n                else if (c > 32) return true;\n            }\n        }\n    }\n    static void ASSERT(boolean assertion, String message) {\n        if (!assertion) throw new AssertionError(message);\n    }\n    static void ASSERT(boolean assertion) {\n        if (!assertion) throw new AssertionError();\n    }\n}", "label": 3}
{"src": "import java.awt.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.List;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\n\n\npublic class E implements Runnable{\n\n    // SOLUTION!!!\n    // HACK ME PLEASE IF YOU CAN!!!\n    // PLEASE!!!\n    // PLEASE!!!\n    // PLEASE!!!\n\n    private final static Random rnd = new Random();\n    private final static String fileName = \"\";\n\n    final static long MODULO = 1000 * 1000 * 1000 + 7;\n\n    long inverseNMinus1Factorial;\n\n    private void solve() {\n        int n = readInt();\n        long s = readLong();\n\n        long[] f = readLongArray(n);\n\n        Map<Long, Long> coeffs = new HashMap<>();\n        coeffs.put(0L, 1L);\n\n        class Pair {\n            long power, coeff;\n\n            public Pair(long power, long coeff) {\n                this.power = power;\n                this.coeff = coeff;\n            }\n        }\n\n        for (long size : f) {\n            List<Pair> coeffEntries = new ArrayList<>();\n            for (Map.Entry<Long, Long> coeffEntry : coeffs.entrySet()) {\n                long power = coeffEntry.getKey();\n                long coeff = coeffEntry.getValue();\n\n                long nextPower = power + size + 1;\n                coeffEntries.add(\n                    new Pair(\n                        nextPower, -coeff\n                    )\n                );\n            }\n\n            for (Pair coeffEntry : coeffEntries) {\n                coeffs.put(coeffEntry.power,\n                        add(coeffs.getOrDefault(coeffEntry.power, 0L), coeffEntry.coeff)\n                );\n            }\n        }\n\n        long nMinus1Factorial = multSequence(1, n - 1);\n        this.inverseNMinus1Factorial = inverse(nMinus1Factorial);\n\n        long answer = 0;\n        for (Map.Entry<Long, Long> coeffEntry : coeffs.entrySet()) {\n            long power = coeffEntry.getKey();\n            long coeff = coeffEntry.getValue();\n\n            if (s >= power) {\n                long need = s - power;\n                answer = add(answer, mult(binom(n + need - 1, need), coeff));\n            }\n        }\n\n        out.println(answer);\n    }\n\n    long multSequence(long start, long end) {\n        long res = 1;\n        for (long i = start; i <= end; ++i) {\n            res = mult(res, i);\n        }\n\n        return res;\n    }\n\n    long inverse(long x) {\n        return binpow(x, MODULO - 2);\n    }\n\n    long binpow(long base, long power) {\n        if (power == 0) return 1;\n\n        if ((power & 1) == 0) {\n            long half = binpow(base, power >> 1);\n            return mult(half, half);\n        } else {\n            long prev = binpow(base, power - 1);\n            return mult(prev, base);\n        }\n    }\n\n    long binom(long n, long k) {\n        return mult(\n                multSequence(k + 1, n),\n                inverseNMinus1Factorial\n        );\n    }\n\n    long add(long a, long b) {\n        return ((a % MODULO + b % MODULO) % MODULO + MODULO) % MODULO;\n    }\n\n    long mult(long a, long b) {\n        return (a % MODULO) * (b % MODULO) % MODULO;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private final static boolean FIRST_INPUT_STRING = false;\n    private final static boolean MULTIPLE_TESTS = true;\n    private final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n    private final static int MAX_STACK_SIZE = 128;\n\n    private final static boolean OPTIMIZE_READ_NUMBERS = true;\n\n    /////////////////////////////////////////////////////////////////////\n\n    public void run(){\n        try{\n            timeInit();\n            Locale.setDefault(Locale.US);\n\n            init();\n\n            if (ONLINE_JUDGE) {\n                solve();\n            } else {\n                do {\n                    try {\n                        timeInit();\n                        solve();\n                        time();\n\n                        out.println();\n                    } catch (NumberFormatException e) {\n                        break;\n                    } catch (NullPointerException e) {\n                        if (FIRST_INPUT_STRING) break;\n                        else throw e;\n                    }\n                } while (MULTIPLE_TESTS);\n            }\n\n            out.close();\n            time();\n        }catch (Exception e){\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private BufferedReader in;\n    private OutputWriter out;\n    private StringTokenizer tok = new StringTokenizer(\"\");\n\n    public static void main(String[] args){\n        new Thread(null, new E(), \"\", MAX_STACK_SIZE * (1L << 20)).start();\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private void init() throws FileNotFoundException{\n        Locale.setDefault(Locale.US);\n\n        if (ONLINE_JUDGE){\n            if (fileName.isEmpty()) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new OutputWriter(System.out);\n            } else {\n                in = new BufferedReader(new FileReader(fileName + \".in\"));\n                out = new OutputWriter(fileName + \".out\");\n            }\n        }else{\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new OutputWriter(\"output.txt\");\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    private long timeBegin;\n\n    private void timeInit() {\n        this.timeBegin = System.currentTimeMillis();\n    }\n\n    private void time(){\n        long timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    private void debug(Object... objects){\n        if (ONLINE_JUDGE){\n            for (Object o: objects){\n                System.err.println(o.toString());\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private String delim = \" \";\n\n    private String readLine() {\n        try {\n            return in.readLine();\n        } catch (IOException e) {\n            throw new RuntimeIOException(e);\n        }\n    }\n\n    private String readString() {\n        try {\n            while(!tok.hasMoreTokens()){\n                tok = new StringTokenizer(readLine());\n            }\n\n            return tok.nextToken(delim);\n        } catch (NullPointerException e) {\n            return null;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////\n\n    private final char NOT_A_SYMBOL = '\\0';\n\n    private char readChar() {\n        try {\n            int intValue = in.read();\n\n            if (intValue == -1){\n                return NOT_A_SYMBOL;\n            }\n\n            return (char) intValue;\n        } catch (IOException e) {\n            throw new RuntimeIOException(e);\n        }\n    }\n\n    private char[] readCharArray() {\n        return readLine().toCharArray();\n    }\n\n    private char[][] readCharField(int rowsCount) {\n        char[][] field = new char[rowsCount][];\n        for (int row = 0; row < rowsCount; ++row) {\n            field[row] = readCharArray();\n        }\n\n        return field;\n    }\n\n    /////////////////////////////////////////////////////////////////\n\n    private long optimizedReadLong() {\n        int sign = 1;\n        long result = 0;\n        boolean started = false;\n        while (true) {\n            try {\n                int j = in.read();\n                if (-1 == j) {\n                    if (started) return sign * result;\n                    throw new NumberFormatException();\n                }\n\n                if (j == '-') {\n                    if (started) throw new NumberFormatException();\n                    sign = -sign;\n                }\n\n                if ('0' <= j && j <= '9') {\n                    result = result * 10 + j - '0';\n                    started = true;\n                } else if (started) {\n                    return sign * result;\n                }\n            } catch (IOException e) {\n                throw new RuntimeIOException(e);\n            }\n        }\n    }\n\n    private int readInt() {\n\n        if (!OPTIMIZE_READ_NUMBERS) {\n            return Integer.parseInt(readString());\n        } else {\n            return (int) optimizedReadLong();\n        }\n    }\n\n    private int[] readIntArray(int size) {\n        int[] array = new int[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readInt();\n        }\n\n        return array;\n    }\n\n    private int[] readSortedIntArray(int size) {\n        Integer[] array = new Integer[size];\n\n        for (int index = 0; index < size; ++index) {\n            array[index] = readInt();\n        }\n        Arrays.sort(array);\n\n        int[] sortedArray = new int[size];\n        for (int index = 0; index < size; ++index) {\n            sortedArray[index] = array[index];\n        }\n\n        return sortedArray;\n    }\n\n    private int[] readIntArrayWithDecrease(int size) {\n        int[] array = readIntArray(size);\n\n        for (int i = 0; i < size; ++i) {\n            array[i]--;\n        }\n\n        return array;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n\n    private int[][] readIntMatrix(int rowsCount, int columnsCount) {\n        int[][] matrix = new int[rowsCount][];\n\n        for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n            matrix[rowIndex] = readIntArray(columnsCount);\n        }\n\n        return matrix;\n    }\n\n    private int[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) {\n        int[][] matrix = new int[rowsCount][];\n\n        for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n            matrix[rowIndex] = readIntArrayWithDecrease(columnsCount);\n        }\n\n        return matrix;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n\n    private long readLong() {\n        if (!OPTIMIZE_READ_NUMBERS) {\n            return Long.parseLong(readString());\n        } else {\n            return optimizedReadLong();\n        }\n    }\n\n    private long[] readLongArray(int size) {\n        long[] array = new long[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readLong();\n        }\n\n        return array;\n    }\n\n    ////////////////////////////////////////////////////////////////////\n\n    private double readDouble() {\n        return Double.parseDouble(readString());\n    }\n\n    private double[] readDoubleArray(int size) {\n        double[] array = new double[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readDouble();\n        }\n\n        return array;\n    }\n\n    ////////////////////////////////////////////////////////////////////\n\n    private BigInteger readBigInteger() {\n        return new BigInteger(readString());\n    }\n\n    private BigDecimal readBigDecimal() {\n        return new BigDecimal(readString());\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private Point readPoint() {\n        int x = readInt();\n        int y = readInt();\n        return new Point(x, y);\n    }\n\n    private Point[] readPointArray(int size) {\n        Point[] array = new Point[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readPoint();\n        }\n\n        return array;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    @Deprecated\n    private List<Integer>[] readGraph(int vertexNumber, int edgeNumber) {\n        @SuppressWarnings(\"unchecked\")\n        List<Integer>[] graph = new List[vertexNumber];\n\n        for (int index = 0; index < vertexNumber; ++index){\n            graph[index] = new ArrayList<>();\n        }\n\n        while (edgeNumber-- > 0){\n            int from = readInt() - 1;\n            int to = readInt() - 1;\n\n            graph[from].add(to);\n            graph[to].add(from);\n        }\n\n        return graph;\n    }\n\n    private static class GraphBuilder {\n\n        final int size;\n        final List<Integer>[] edges;\n\n        static GraphBuilder createInstance(int size) {\n            List<Integer>[] edges = new List[size];\n            for (int v = 0; v < size; ++v) {\n                edges[v] = new ArrayList<>();\n            }\n\n            return new GraphBuilder(edges);\n        }\n\n        private GraphBuilder(List<Integer>[] edges) {\n            this.size = edges.length;\n            this.edges = edges;\n        }\n\n        public void addEdge(int from, int to) {\n            addDirectedEdge(from, to);\n            addDirectedEdge(to, from);\n        }\n\n        public void addDirectedEdge(int from, int to) {\n            edges[from].add(to);\n        }\n\n        public int[][] build() {\n            int[][] graph = new int[size][];\n            for (int v = 0; v < size; ++v) {\n                List<Integer> vEdges = edges[v];\n                graph[v] = castInt(vEdges);\n            }\n\n            return graph;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class IntIndexPair {\n\n        static Comparator<IntIndexPair> increaseComparator = new Comparator<E.IntIndexPair>() {\n\n            @Override\n            public int compare(E.IntIndexPair indexPair1, E.IntIndexPair indexPair2) {\n                int value1 = indexPair1.value;\n                int value2 = indexPair2.value;\n\n                if (value1 != value2) return value1 - value2;\n\n                int index1 = indexPair1.index;\n                int index2 = indexPair2.index;\n\n                return index1 - index2;\n            }\n        };\n\n        static Comparator<IntIndexPair> decreaseComparator = new Comparator<E.IntIndexPair>() {\n\n            @Override\n            public int compare(E.IntIndexPair indexPair1, E.IntIndexPair indexPair2) {\n                int value1 = indexPair1.value;\n                int value2 = indexPair2.value;\n\n                if (value1 != value2) return -(value1 - value2);\n\n                int index1 = indexPair1.index;\n                int index2 = indexPair2.index;\n\n                return index1 - index2;\n            }\n        };\n\n        int value, index;\n\n        IntIndexPair(int value, int index) {\n            super();\n            this.value = value;\n            this.index = index;\n        }\n\n        int getRealIndex() {\n            return index + 1;\n        }\n    }\n\n    private IntIndexPair[] readIntIndexArray(int size) {\n        IntIndexPair[] array = new IntIndexPair[size];\n\n        for (int index = 0; index < size; ++index) {\n            array[index] = new IntIndexPair(readInt(), index);\n        }\n\n        return array;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class OutputWriter extends PrintWriter {\n\n        final int DEFAULT_PRECISION = 12;\n\n        private int precision;\n        private String format, formatWithSpace;\n\n        {\n            precision = DEFAULT_PRECISION;\n\n            format = createFormat(precision);\n            formatWithSpace = format + \" \";\n        }\n\n        OutputWriter(OutputStream out) {\n            super(out);\n        }\n\n        OutputWriter(String fileName) throws FileNotFoundException {\n            super(fileName);\n        }\n\n        int getPrecision() {\n            return precision;\n        }\n\n        void setPrecision(int precision) {\n            precision = max(0, precision);\n            this.precision = precision;\n\n            format = createFormat(precision);\n            formatWithSpace = format + \" \";\n        }\n\n        String createFormat(int precision){\n            return \"%.\" + precision + \"f\";\n        }\n\n        @Override\n        public void print(double d){\n            printf(format, d);\n        }\n\n        void printWithSpace(double d){\n            printf(formatWithSpace, d);\n        }\n\n        void printAll(double...d){\n            for (int i = 0; i < d.length - 1; ++i){\n                printWithSpace(d[i]);\n            }\n\n            print(d[d.length - 1]);\n        }\n\n        @Override\n        public void println(double d){\n            printlnAll(d);\n        }\n\n        void printlnAll(double... d){\n            printAll(d);\n            println();\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class RuntimeIOException extends RuntimeException {\n\n        /**\n         *\n         */\n        private static final long serialVersionUID = -6463830523020118289L;\n\n        RuntimeIOException(Throwable cause) {\n            super(cause);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    //////////////// Some useful constants and functions ////////////////\n    /////////////////////////////////////////////////////////////////////\n\n    private static final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    private static final int[][] steps8 = {\n            {-1, 0}, {1, 0}, {0, -1}, {0, 1},\n            {-1, -1}, {1, 1}, {1, -1}, {-1, 1}\n    };\n\n    private static boolean checkCell(int row, int rowsCount, int column, int columnsCount) {\n        return checkIndex(row, rowsCount) && checkIndex(column, columnsCount);\n    }\n\n    private static boolean checkIndex(int index, int lim){\n        return (0 <= index && index < lim);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static boolean checkBit(int mask, int bit){\n        return (mask & (1 << bit)) != 0;\n    }\n    private static boolean checkBit(long mask, int bit){\n        return (mask & (1L << bit)) != 0;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static long getSum(int[] array) {\n        long sum = 0;\n        for (int value: array) {\n            sum += value;\n        }\n\n        return sum;\n    }\n\n    private static Point getMinMax(int[] array) {\n        int min = array[0];\n        int max = array[0];\n\n        for (int index = 0, size = array.length; index < size; ++index, ++index) {\n            int value = array[index];\n\n            if (index == size - 1) {\n                min = min(min, value);\n                max = max(max, value);\n            } else {\n                int otherValue = array[index + 1];\n\n                if (value <= otherValue) {\n                    min = min(min, value);\n                    max = max(max, otherValue);\n                } else {\n                    min = min(min, otherValue);\n                    max = max(max, value);\n                }\n            }\n        }\n\n        return new Point(min, max);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static int[] getPrimes(int n) {\n        boolean[] used = new boolean[n];\n        used[0] = used[1] = true;\n\n        int size = 0;\n        for (int i = 2; i < n; ++i) {\n            if (!used[i]) {\n                ++size;\n                for (int j = 2 * i; j < n; j += i) {\n                    used[j] = true;\n                }\n            }\n        }\n\n        int[] primes = new int[size];\n        for (int i = 0, cur = 0; i < n; ++i) {\n            if (!used[i]) {\n                primes[cur++] = i;\n            }\n        }\n\n        return primes;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n\n    private static long gcd(long a, long b) {\n        return (a == 0 ? b : gcd(b % a, a));\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class MultiSet<ValueType> {\n\n        public static <ValueType> MultiSet<ValueType> createMultiSet() {\n            Map<ValueType, Integer> multiset = new HashMap<>();\n            return new MultiSet<>(multiset);\n        }\n\n        private final Map<ValueType, Integer> multiset;\n        private int size;\n\n        public MultiSet(Map<ValueType, Integer> multiset) {\n            this.multiset = multiset;\n            this.size = 0;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public void inc(ValueType value) {\n            int count = get(value);\n            multiset.put(value, count + 1);\n\n            ++size;\n        }\n\n        public void dec(ValueType value) {\n            int count = get(value);\n            if (count == 0) return;\n\n            if (count == 1) multiset.remove(value);\n            else multiset.put(value, count - 1);\n\n            --size;\n        }\n\n        public int get(ValueType value) {\n            Integer count = multiset.get(value);\n            return (count == null ? 0 : count);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class IdMap<KeyType> extends HashMap<KeyType, Integer> {\n\n        /**\n         *\n         */\n        private static final long serialVersionUID = -3793737771950984481L;\n\n        public IdMap() {\n            super();\n        }\n\n        int getId(KeyType key) {\n            Integer id = super.get(key);\n            if (id == null) {\n                super.put(key, id = size());\n            }\n\n            return id;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static int[] castInt(List<Integer> list) {\n        int[] array = new int[list.size()];\n        for (int i = 0; i < array.length; ++i) {\n            array[i] = list.get(i);\n        }\n\n        return array;\n    }\n\n    private static long[] castLong(List<Long> list) {\n        long[] array = new long[list.size()];\n        for (int i = 0; i < array.length; ++i) {\n            array[i] = list.get(i);\n        }\n\n        return array;\n    }\n}\n\n", "label": 3}
{"src": "import java.text.DecimalFormat;\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class Main {\n\tstatic long mod = 1000000007;\n\tstatic double eps = 1e-9;\n\tstatic double PI = Math.acos(-1.0);\n\t\n\tlong[] f = new long[30];\n\tlong powmod(long a, long b) {\n\t\tlong ans = 1;\n\t    while(b > 0) {\n\t        if(b % 2 == 1) ans = ans * a % mod;\n\t        a = a * a % mod;\n\t        b = b / 2;\n\t    }\n\t    return ans;\n\t}\n\n\tlong C(long n, long m) {\n\t    if(n-m < m) m = n - m;\n\t    long up = 1, down = 1;\n\t    for(int i=0; i<m; i++) {\n\t        up = up * (n-i) % mod;\n\t        down = down * (i+1) % mod;\n\t    }\n\t    up = up * powmod(down, mod - 2) % mod;\n\t    return up;\n\t}\n\n\tlong Lucas(long n, long m) {\n\t    if(m == 0) return 1;\n\t    return C(n%mod, m%mod) * Lucas(n/mod, m/mod) % mod;\n\t}\n\n\tlong gao(long x, long y) {\n\t    if(x < 0) return 0;\n\t    if(x == 0 || y == 1) return 1;\n\t    return Lucas(x+y-1, y-1);\n\t}\n\t\n\tvoid work() {\n\t\twhile(cin.hasNext()) {\n\t\t\tlong n, S;\n\t\t\tn = cin.nextLong();\n\t\t\tS = cin.nextLong();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tf[i] = cin.nextLong();\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t    for(int dp=0; dp<(1<<n); dp++) {\n\t\t        long flag = 1;\n\t\t        long s = S;\n\t\t        for(int j=0; j<n; j++) if( (dp&(1<<j)) != 0){\n\t\t            flag *= -1;\n\t\t            s -= f[j] + 1;\n\t\t        }\n\t\t        ans = (ans + flag * gao(s, n) + mod) % mod;\n\t\t    }\n\t\t    out.println(ans);\n\t\t}\n\t\tout.close();\n\t}\t\n\tMain() {\n\t\tout = new PrintWriter(System.out);\n\t\tcin = new Scanner(System.in);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain wo = new Main();\n\t\two.work();\n\t}\n\t//out.println(df.format(3.1415));\n\tDecimalFormat df=new DecimalFormat(\"0.00\");\n\tpublic Scanner cin;\n\tpublic PrintWriter out;\n}\n \n\t  \t\t\t  \t \t\t\t  \t\t\t\t\t\t\t \t \t\t", "label": 3}
{"src": "import java.util.Scanner;\n\npublic class Solution {\n\n    private static final long MOD = 1000000007;\n    private static long FACT[] = new long[25];\n\n    private static long modPow(long a, long x, long m) {\n        long res = 1;\n        while (x > 0) {\n            if (x % 2 != 0) {\n                res = (res * a) % m;\n            }\n            a = (a * a) % m;\n            x /= 2;\n        }\n        return res % m;\n    }\n\n    private static long modInverse(long a, long p) {\n        // p doit \u00eatre premier\n        return modPow(a, p - 2, p);\n    }\n\n    private static long nCr(long n, int r) {\n        if (n < r) return 0;\n        long ret = 1;\n        for (long x = n; x >= n - r + 1; x--) {\n            ret = (ret * (x % MOD)) % MOD;\n        }\n        ret = (ret * modInverse(FACT[r], MOD)) % MOD;\n        return ret;\n    }\n\n    public static void main(String[] args) {\n        FACT[0] = 1;\n        for (int i = 1; i < 25; i++) {\n            FACT[i] = (FACT[i - 1] * i) % MOD;\n        }\n\n        Scanner in = new Scanner(System.in);\n        int n;\n        long s, N;\n        n = in.nextInt();\n        s = in.nextLong();\n        long f[] = new long[n];\n        for (int i = 0; i < n; i++) {\n            f[i] = in.nextLong();\n        }\n\n        N = 1 << n;\n\n        long res = 0;\n        for (int i = 0; i < N; i++) {\n            long count = 0;\n            int p = 0;\n            for (int j = 0; j < n; j++) {\n                if ((i & (1 << j)) > 0) {\n                    count += f[j] + 1;\n                    p++;\n                }\n            }\n            if (count > s) continue;\n            long C = nCr(s + n - 1 - count, n - 1);\n            if (p % 2 == 1) C = -C;\n            res = (res + C) % MOD;\n            if (res < 0) res += MOD;\n        }\n\n        System.out.println(res);\n    }\n}\n", "label": 3}
{"src": "import java.io.BufferedInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.util.*;\n\npublic class DevuAndFlowers {\n\n\tstatic long mod = 1000000007;\n\tstatic long modInv[];\n\tstatic int N;\n\tstatic long S;\n\tstatic long f[];\n\tstatic long fact[];\n\tpublic static void main(String[] args) {\n\t\tJS in = new JS();\n\t\tN = in.nextInt();\n\t\tS = in.nextLong();\n\t\tf = new long[N];\n\t\tfor(int i = 0; i < N; i++) f[i] = in.nextLong();\n\t\tmodInv = new long[N+5];\n\t\tfor(int i = 0; i <= N+4; i++) modInv[i] = pow(i, mod-2);\n\t\t\n\t\tlong ans = 0;\n\t\tfor(int i = 0; i < (1<<N); i++) {\n\t\t\tlong over = S;\n\t\t\tfor(int j = 0; j < N; j++) {\n\t\t\t\tif((i & (1<<j)) > 0) {\n\t\t\t\t\tover -= f[j]+1;\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(over < 0) continue;\n\t\t\tlong v = sumTo(over, N);\n\t\t\tif(Integer.bitCount(i)%2==1) ans -= v;\n\t\t\telse ans += v;\n\t\t\twhile(ans < 0) ans+=mod;\n\t\t\twhile(ans >= mod)ans-=mod;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic long sumTo(long sum, long n) {\n\t\treturn choose(sum+n-1, n-1);\n\t}\n\tstatic long choose(long n, long k) {\n\t\tlong prev = 1;\n\t\tfor(int c = 1; c <= k; c++)\n\t\t\tprev = (((prev*(n%mod-c+1))%mod)*modInv[c])%mod;\n\t\twhile(prev < 0) prev += mod;\n\t\twhile(prev >= mod) prev -= mod;\n\t\treturn prev;\n\t}\n\t\n\tstatic long pow(long base, long power) {\n\t\tif(power == 0) return 1;\n\t\tif(power == 1) return base;\n\t\tif((power%2)==0) {\n\t\t\tlong r = pow(base, power/2);\n\t\t\treturn (r*r)%mod;\n\t\t}\n\t\telse {\n\t\t\treturn (base * pow(base,power-1))%mod;\n\t\t}\n\t}\n\n\t\n\tstatic class JS{\n\t\tpublic int BS = 1<<16;\n\t\tpublic char NC = (char)0;\n\t\tbyte[] buf = new byte[BS];\n\t\tint bId = 0, size = 0;\n\t\tchar c = NC;\n\t\tdouble num = 1;\n\t\tBufferedInputStream in;\n\t\t\n\t\tpublic JS() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\t\t\n\t\tpublic JS(String s) throws FileNotFoundException {\n\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t}\n\t\t\n\t\tpublic char nextChar(){\n\t\t\twhile(bId==size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t}catch(Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tif(size==-1)return NC;\n\t\t\t\tbId=0;\n\t\t\t}\n\t\t\treturn (char)buf[bId++];\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\tnum=1;\n\t\t\tboolean neg = false;\n\t\t\tif(c==NC)c=nextChar();\n\t\t\tfor(;(c<'0' || c>'9'); c = nextChar()) {\n\t\t\t\tif(c=='-')neg=true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(; c>='0' && c <='9'; c=nextChar()) {\n\t\t\t\tres = (res<<3)+(res<<1)+c-'0';\n\t\t\t\tnum*=10;\n\t\t\t}\n\t\t\treturn neg?-res:res;\n\t\t}\n\t\t\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c!='.' ? cur:cur+nextLong()/num;\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c>32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\t\t\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c!='\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif(c>32)return true;\n\t\t\twhile(true) {\n\t\t\t\tc=nextChar();\n\t\t\t\tif(c==NC)return false;\n\t\t\t\telse if(c>32)return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int []nia(int n){\n\t\t\tint r[] = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) r[i] = nextInt();\n\t\t\treturn r;\n\t\t}\n\t\tpublic double []nda(int n){\n\t\t\tdouble r[] = new double[n];\n\t\t\tfor(int i = 0; i < n; i++) r[i] = nextDouble();\n\t\t\treturn r;\n\t\t}\n\t\tpublic long []nla(int n){\n\t\t\tlong r[] = new long[n];\n\t\t\tfor(int i = 0; i < n; i++) r[i] = nextLong();\n\t\t\treturn r;\n\t\t}\n\t}\n\t\n}\n", "label": 3}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.Set;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Praveen Dhinwa\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tCodeforcesE solver = new CodeforcesE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass CodeforcesE {\n    long f[] = new long[22];\n    int n;\n    HashMap<Long, Long> map;\n    private long mod = (long) 1e9 + 7;\n    long inv[] = new long[55];\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        pre();\n        //System.out.println(\"h \" + comb(5, 3));\n        n = in.nextInt();\n        long s = in.nextLong();\n        map = new HashMap<Long, Long>();\n        for (int i = 0; i < n; i++) {\n            f[i] = in.nextLong();\n        }\n        gen(0, 0, 1);\n        long ans = 0;\n        for (long power: map.keySet()) {\n            //System.out.println(power);\n            long coeff = map.get(power);\n            long rem = s - power;\n            if (rem >= 0) {\n                ans += comb(n + rem - 1, rem) * coeff;\n                ans %= mod;\n            }\n        }\n        out.println(ans);\n    }\n\n    private void pre() {\n        for (int i = 1; i <= 50; i++) {\n            inv[i] = modpow(i, mod - 2, mod);\n        }\n    }\n\n    private long modpow(long a, long b, long mod) {\n        long res = 1;\n        while (b > 0) {\n            if (b % 2 == 1) {\n                res = (res * a) % mod;\n            }\n            a = (a * a) % mod;\n            b >>= 1;\n        }\n        return res;\n    }\n\n    private long comb(long n, long r) {\n        if (r > n)\n            return 0;\n        if (n - r < r)\n            r = n - r;\n        n %= mod;\n        long ans = 1;\n        for (int i = 0; i < r; i++) {\n            ans = (ans * (n - i)) % mod;\n            ans = (ans * inv[i + 1]) % mod;\n        }\n        return ans;\n    }\n\n    private void gen(int id, long power, long coeff) {\n        if (id == n) {\n            long val = 0;\n            if (map.containsKey(power)) {\n                val = map.get(power);\n                map.remove(power);\n            }\n            val += coeff;\n            if (val >= mod)\n                val -= mod;\n            map.put(power, val);\n        } else {\n            gen(id + 1, power, coeff);\n            long ncoeff = coeff * -1;\n            if (ncoeff < 0)\n                ncoeff += mod;\n            gen(id + 1, power + f[id] + 1, ncoeff);\n        }\n    }\n}\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n}\n", "label": 3}
{"src": "/**\n * author: derrick20\n * created: 12/7/20 6:00 PM\n */\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class DevuFlowersPIE {\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        \n        int N = sc.nextInt();\n        long S = sc.nextLong();\n        long[] f = sc.nextLongs(N);\n\n        long[] inv = new long[21];\n        invFact = new long[21];\n        invFact[0] = invFact[1] = inv[1] = 1;\n        for (int i = 2; i <= 20; i++) {\n            inv[i] = mod - ((mod / i) * inv[(int) mod % i] % mod);\n            invFact[i] = (inv[i] * invFact[i - 1]) % mod;\n        }\n//        System.out.println(Arrays.toString(inv));\n//        System.out.println(Arrays.toString(invFact));\n        long ans = 0;\n        for (int mask = 0; mask < 1 << N; mask++) {\n            long sign = 1;\n            long S2 = S;\n            for (int k = 0; k < N; k++) {\n                if (((1 << k) & mask) > 0) {\n                    sign *= -1;\n                    S2 -= f[k] + 1;\n                }\n            }\n            long amt = (sign * choose(S2 + N - 1, N - 1)) % mod;\n            if (amt < 0) {\n                amt += mod;\n            }\n//            System.out.println(amt);\n            ans = (ans + amt) % mod;\n        }\n        out.println(ans);\n        out.close();\n    }\n    static long mod = (long) 1e9 + 7;\n    static long[] invFact;\n\n    static long choose(long n, long k) {\n        if (k > n) return 0;\n        long ans = invFact[(int) k];\n        n %= mod; // KEY BUG\n        while (k > 0) {\n            ans = (ans * n) % mod;\n            n--; k--;\n        }\n        return ans;\n    }\n\n    static class FastScanner {\n        private int BS = 1 << 16;\n        private char NC = (char) 0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n\n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n\n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            } catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n\n        private char getChar() {\n            while (bId == size) {\n                try {\n                    size = in.read(buf);\n                } catch (Exception e) {\n                    return NC;\n                }\n                if (size == -1) return NC;\n                bId = 0;\n            }\n            return (char) buf[bId++];\n        }\n\n        public int nextInt() {\n            return (int) nextLong();\n        }\n\n        public int[] nextInts(int N) {\n            int[] res = new int[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = (int) nextLong();\n            }\n            return res;\n        }\n\n        public long[] nextLongs(int N) {\n            long[] res = new long[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n\n        public long nextLong() {\n            cnt = 1;\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            long res = 0;\n            for (; c >= '0' && c <= '9'; c = getChar()) {\n                res = (res << 3) + (res << 1) + c - '0';\n                cnt *= 10;\n            }\n            return neg ? -res : res;\n        }\n\n        public double nextDouble() {\n            double cur = nextLong();\n            return c != '.' ? cur : cur + nextLong() / cnt;\n        }\n\n        public double[] nextDoubles(int N) {\n            double[] res = new double[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextDouble();\n            }\n            return res;\n        }\n\n        public String next() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c > 32) {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        public String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c != '\\n') {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n\n        public boolean hasNext() {\n            if (c > 32) return true;\n            while (true) {\n                c = getChar();\n                if (c == NC) return false;\n                else if (c > 32) return true;\n            }\n        }\n    }\n    static void ASSERT(boolean assertion, String message) {\n        if (!assertion) throw new AssertionError(message);\n    }\n    static void ASSERT(boolean assertion) {\n        if (!assertion) throw new AssertionError();\n    }\n}", "label": 3}
{"src": "import java.awt.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.List;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\n\n\npublic class E implements Runnable{\n\n    // SOLUTION!!!\n    // HACK ME PLEASE IF YOU CAN!!!\n    // PLEASE!!!\n    // PLEASE!!!\n    // PLEASE!!!\n\n    private final static Random rnd = new Random();\n    private final static String fileName = \"\";\n\n    final static long MODULO = 1000 * 1000 * 1000 + 7;\n\n    long inverseNMinus1Factorial;\n\n    private void solve() {\n        int n = readInt();\n        long s = readLong();\n\n        long[] f = readLongArray(n);\n\n        Map<Long, Long> coeffs = new HashMap<>();\n        coeffs.put(0L, 1L);\n\n        for (long size : f) {\n            Map<Long, Long> nextCoeffs = new HashMap<>(coeffs);\n            for (Map.Entry<Long, Long> coeffEntry : coeffs.entrySet()) {\n                long power = coeffEntry.getKey();\n                long coeff = coeffEntry.getValue();\n\n                long nextPower = power + size + 1;\n                nextCoeffs.put(nextPower,\n                        add(nextCoeffs.getOrDefault(nextPower, 0L), -coeff)\n                );\n            }\n\n            coeffs = nextCoeffs;\n        }\n\n        long nMinus1Factorial = multSequence(1, n - 1);\n        this.inverseNMinus1Factorial = inverse(nMinus1Factorial);\n\n        long answer = 0;\n        for (Map.Entry<Long, Long> coeffEntry : coeffs.entrySet()) {\n            long power = coeffEntry.getKey();\n            long coeff = coeffEntry.getValue();\n\n            if (s >= power) {\n                long need = s - power;\n                answer = add(answer, mult(binom(n + need - 1, need), coeff));\n            }\n        }\n\n        out.println(answer);\n    }\n\n    long multSequence(long start, long end) {\n        long res = 1;\n        for (long i = start; i <= end; ++i) {\n            res = mult(res, i);\n        }\n\n        return res;\n    }\n\n    long inverse(long x) {\n        return binpow(x, MODULO - 2);\n    }\n\n    long binpow(long base, long power) {\n        if (power == 0) return 1;\n\n        if ((power & 1) == 0) {\n            long half = binpow(base, power >> 1);\n            return mult(half, half);\n        } else {\n            long prev = binpow(base, power - 1);\n            return mult(prev, base);\n        }\n    }\n\n    long binom(long n, long k) {\n        return mult(\n                multSequence(k + 1, n),\n                inverseNMinus1Factorial\n        );\n    }\n\n    long add(long a, long b) {\n        return ((a % MODULO + b % MODULO) % MODULO + MODULO) % MODULO;\n    }\n\n    long mult(long a, long b) {\n        return (a % MODULO) * (b % MODULO) % MODULO;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private final static boolean FIRST_INPUT_STRING = false;\n    private final static boolean MULTIPLE_TESTS = true;\n    private final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n    private final static int MAX_STACK_SIZE = 128;\n\n    private final static boolean OPTIMIZE_READ_NUMBERS = true;\n\n    /////////////////////////////////////////////////////////////////////\n\n    public void run(){\n        try{\n            timeInit();\n            Locale.setDefault(Locale.US);\n\n            init();\n\n            if (ONLINE_JUDGE) {\n                solve();\n            } else {\n                do {\n                    try {\n                        timeInit();\n                        solve();\n                        time();\n\n                        out.println();\n                    } catch (NumberFormatException e) {\n                        break;\n                    } catch (NullPointerException e) {\n                        if (FIRST_INPUT_STRING) break;\n                        else throw e;\n                    }\n                } while (MULTIPLE_TESTS);\n            }\n\n            out.close();\n            time();\n        }catch (Exception e){\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private BufferedReader in;\n    private OutputWriter out;\n    private StringTokenizer tok = new StringTokenizer(\"\");\n\n    public static void main(String[] args){\n        new Thread(null, new E(), \"\", MAX_STACK_SIZE * (1L << 20)).start();\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private void init() throws FileNotFoundException{\n        Locale.setDefault(Locale.US);\n\n        if (ONLINE_JUDGE){\n            if (fileName.isEmpty()) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new OutputWriter(System.out);\n            } else {\n                in = new BufferedReader(new FileReader(fileName + \".in\"));\n                out = new OutputWriter(fileName + \".out\");\n            }\n        }else{\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new OutputWriter(\"output.txt\");\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    private long timeBegin;\n\n    private void timeInit() {\n        this.timeBegin = System.currentTimeMillis();\n    }\n\n    private void time(){\n        long timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    private void debug(Object... objects){\n        if (ONLINE_JUDGE){\n            for (Object o: objects){\n                System.err.println(o.toString());\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private String delim = \" \";\n\n    private String readLine() {\n        try {\n            return in.readLine();\n        } catch (IOException e) {\n            throw new RuntimeIOException(e);\n        }\n    }\n\n    private String readString() {\n        try {\n            while(!tok.hasMoreTokens()){\n                tok = new StringTokenizer(readLine());\n            }\n\n            return tok.nextToken(delim);\n        } catch (NullPointerException e) {\n            return null;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////\n\n    private final char NOT_A_SYMBOL = '\\0';\n\n    private char readChar() {\n        try {\n            int intValue = in.read();\n\n            if (intValue == -1){\n                return NOT_A_SYMBOL;\n            }\n\n            return (char) intValue;\n        } catch (IOException e) {\n            throw new RuntimeIOException(e);\n        }\n    }\n\n    private char[] readCharArray() {\n        return readLine().toCharArray();\n    }\n\n    private char[][] readCharField(int rowsCount) {\n        char[][] field = new char[rowsCount][];\n        for (int row = 0; row < rowsCount; ++row) {\n            field[row] = readCharArray();\n        }\n\n        return field;\n    }\n\n    /////////////////////////////////////////////////////////////////\n\n    private long optimizedReadLong() {\n        int sign = 1;\n        long result = 0;\n        boolean started = false;\n        while (true) {\n            try {\n                int j = in.read();\n                if (-1 == j) {\n                    if (started) return sign * result;\n                    throw new NumberFormatException();\n                }\n\n                if (j == '-') {\n                    if (started) throw new NumberFormatException();\n                    sign = -sign;\n                }\n\n                if ('0' <= j && j <= '9') {\n                    result = result * 10 + j - '0';\n                    started = true;\n                } else if (started) {\n                    return sign * result;\n                }\n            } catch (IOException e) {\n                throw new RuntimeIOException(e);\n            }\n        }\n    }\n\n    private int readInt() {\n\n        if (!OPTIMIZE_READ_NUMBERS) {\n            return Integer.parseInt(readString());\n        } else {\n            return (int) optimizedReadLong();\n        }\n    }\n\n    private int[] readIntArray(int size) {\n        int[] array = new int[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readInt();\n        }\n\n        return array;\n    }\n\n    private int[] readSortedIntArray(int size) {\n        Integer[] array = new Integer[size];\n\n        for (int index = 0; index < size; ++index) {\n            array[index] = readInt();\n        }\n        Arrays.sort(array);\n\n        int[] sortedArray = new int[size];\n        for (int index = 0; index < size; ++index) {\n            sortedArray[index] = array[index];\n        }\n\n        return sortedArray;\n    }\n\n    private int[] readIntArrayWithDecrease(int size) {\n        int[] array = readIntArray(size);\n\n        for (int i = 0; i < size; ++i) {\n            array[i]--;\n        }\n\n        return array;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n\n    private int[][] readIntMatrix(int rowsCount, int columnsCount) {\n        int[][] matrix = new int[rowsCount][];\n\n        for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n            matrix[rowIndex] = readIntArray(columnsCount);\n        }\n\n        return matrix;\n    }\n\n    private int[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) {\n        int[][] matrix = new int[rowsCount][];\n\n        for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n            matrix[rowIndex] = readIntArrayWithDecrease(columnsCount);\n        }\n\n        return matrix;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n\n    private long readLong() {\n        if (!OPTIMIZE_READ_NUMBERS) {\n            return Long.parseLong(readString());\n        } else {\n            return optimizedReadLong();\n        }\n    }\n\n    private long[] readLongArray(int size) {\n        long[] array = new long[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readLong();\n        }\n\n        return array;\n    }\n\n    ////////////////////////////////////////////////////////////////////\n\n    private double readDouble() {\n        return Double.parseDouble(readString());\n    }\n\n    private double[] readDoubleArray(int size) {\n        double[] array = new double[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readDouble();\n        }\n\n        return array;\n    }\n\n    ////////////////////////////////////////////////////////////////////\n\n    private BigInteger readBigInteger() {\n        return new BigInteger(readString());\n    }\n\n    private BigDecimal readBigDecimal() {\n        return new BigDecimal(readString());\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private Point readPoint() {\n        int x = readInt();\n        int y = readInt();\n        return new Point(x, y);\n    }\n\n    private Point[] readPointArray(int size) {\n        Point[] array = new Point[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readPoint();\n        }\n\n        return array;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    @Deprecated\n    private List<Integer>[] readGraph(int vertexNumber, int edgeNumber) {\n        @SuppressWarnings(\"unchecked\")\n        List<Integer>[] graph = new List[vertexNumber];\n\n        for (int index = 0; index < vertexNumber; ++index){\n            graph[index] = new ArrayList<>();\n        }\n\n        while (edgeNumber-- > 0){\n            int from = readInt() - 1;\n            int to = readInt() - 1;\n\n            graph[from].add(to);\n            graph[to].add(from);\n        }\n\n        return graph;\n    }\n\n    private static class GraphBuilder {\n\n        final int size;\n        final List<Integer>[] edges;\n\n        static GraphBuilder createInstance(int size) {\n            List<Integer>[] edges = new List[size];\n            for (int v = 0; v < size; ++v) {\n                edges[v] = new ArrayList<>();\n            }\n\n            return new GraphBuilder(edges);\n        }\n\n        private GraphBuilder(List<Integer>[] edges) {\n            this.size = edges.length;\n            this.edges = edges;\n        }\n\n        public void addEdge(int from, int to) {\n            addDirectedEdge(from, to);\n            addDirectedEdge(to, from);\n        }\n\n        public void addDirectedEdge(int from, int to) {\n            edges[from].add(to);\n        }\n\n        public int[][] build() {\n            int[][] graph = new int[size][];\n            for (int v = 0; v < size; ++v) {\n                List<Integer> vEdges = edges[v];\n                graph[v] = castInt(vEdges);\n            }\n\n            return graph;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class IntIndexPair {\n\n        static Comparator<IntIndexPair> increaseComparator = new Comparator<E.IntIndexPair>() {\n\n            @Override\n            public int compare(E.IntIndexPair indexPair1, E.IntIndexPair indexPair2) {\n                int value1 = indexPair1.value;\n                int value2 = indexPair2.value;\n\n                if (value1 != value2) return value1 - value2;\n\n                int index1 = indexPair1.index;\n                int index2 = indexPair2.index;\n\n                return index1 - index2;\n            }\n        };\n\n        static Comparator<IntIndexPair> decreaseComparator = new Comparator<E.IntIndexPair>() {\n\n            @Override\n            public int compare(E.IntIndexPair indexPair1, E.IntIndexPair indexPair2) {\n                int value1 = indexPair1.value;\n                int value2 = indexPair2.value;\n\n                if (value1 != value2) return -(value1 - value2);\n\n                int index1 = indexPair1.index;\n                int index2 = indexPair2.index;\n\n                return index1 - index2;\n            }\n        };\n\n        int value, index;\n\n        IntIndexPair(int value, int index) {\n            super();\n            this.value = value;\n            this.index = index;\n        }\n\n        int getRealIndex() {\n            return index + 1;\n        }\n    }\n\n    private IntIndexPair[] readIntIndexArray(int size) {\n        IntIndexPair[] array = new IntIndexPair[size];\n\n        for (int index = 0; index < size; ++index) {\n            array[index] = new IntIndexPair(readInt(), index);\n        }\n\n        return array;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class OutputWriter extends PrintWriter {\n\n        final int DEFAULT_PRECISION = 12;\n\n        private int precision;\n        private String format, formatWithSpace;\n\n        {\n            precision = DEFAULT_PRECISION;\n\n            format = createFormat(precision);\n            formatWithSpace = format + \" \";\n        }\n\n        OutputWriter(OutputStream out) {\n            super(out);\n        }\n\n        OutputWriter(String fileName) throws FileNotFoundException {\n            super(fileName);\n        }\n\n        int getPrecision() {\n            return precision;\n        }\n\n        void setPrecision(int precision) {\n            precision = max(0, precision);\n            this.precision = precision;\n\n            format = createFormat(precision);\n            formatWithSpace = format + \" \";\n        }\n\n        String createFormat(int precision){\n            return \"%.\" + precision + \"f\";\n        }\n\n        @Override\n        public void print(double d){\n            printf(format, d);\n        }\n\n        void printWithSpace(double d){\n            printf(formatWithSpace, d);\n        }\n\n        void printAll(double...d){\n            for (int i = 0; i < d.length - 1; ++i){\n                printWithSpace(d[i]);\n            }\n\n            print(d[d.length - 1]);\n        }\n\n        @Override\n        public void println(double d){\n            printlnAll(d);\n        }\n\n        void printlnAll(double... d){\n            printAll(d);\n            println();\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class RuntimeIOException extends RuntimeException {\n\n        /**\n         *\n         */\n        private static final long serialVersionUID = -6463830523020118289L;\n\n        RuntimeIOException(Throwable cause) {\n            super(cause);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    //////////////// Some useful constants and functions ////////////////\n    /////////////////////////////////////////////////////////////////////\n\n    private static final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    private static final int[][] steps8 = {\n            {-1, 0}, {1, 0}, {0, -1}, {0, 1},\n            {-1, -1}, {1, 1}, {1, -1}, {-1, 1}\n    };\n\n    private static boolean checkCell(int row, int rowsCount, int column, int columnsCount) {\n        return checkIndex(row, rowsCount) && checkIndex(column, columnsCount);\n    }\n\n    private static boolean checkIndex(int index, int lim){\n        return (0 <= index && index < lim);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static boolean checkBit(int mask, int bit){\n        return (mask & (1 << bit)) != 0;\n    }\n    private static boolean checkBit(long mask, int bit){\n        return (mask & (1L << bit)) != 0;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static long getSum(int[] array) {\n        long sum = 0;\n        for (int value: array) {\n            sum += value;\n        }\n\n        return sum;\n    }\n\n    private static Point getMinMax(int[] array) {\n        int min = array[0];\n        int max = array[0];\n\n        for (int index = 0, size = array.length; index < size; ++index, ++index) {\n            int value = array[index];\n\n            if (index == size - 1) {\n                min = min(min, value);\n                max = max(max, value);\n            } else {\n                int otherValue = array[index + 1];\n\n                if (value <= otherValue) {\n                    min = min(min, value);\n                    max = max(max, otherValue);\n                } else {\n                    min = min(min, otherValue);\n                    max = max(max, value);\n                }\n            }\n        }\n\n        return new Point(min, max);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static int[] getPrimes(int n) {\n        boolean[] used = new boolean[n];\n        used[0] = used[1] = true;\n\n        int size = 0;\n        for (int i = 2; i < n; ++i) {\n            if (!used[i]) {\n                ++size;\n                for (int j = 2 * i; j < n; j += i) {\n                    used[j] = true;\n                }\n            }\n        }\n\n        int[] primes = new int[size];\n        for (int i = 0, cur = 0; i < n; ++i) {\n            if (!used[i]) {\n                primes[cur++] = i;\n            }\n        }\n\n        return primes;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n\n    private static long gcd(long a, long b) {\n        return (a == 0 ? b : gcd(b % a, a));\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class MultiSet<ValueType> {\n\n        public static <ValueType> MultiSet<ValueType> createMultiSet() {\n            Map<ValueType, Integer> multiset = new HashMap<>();\n            return new MultiSet<>(multiset);\n        }\n\n        private final Map<ValueType, Integer> multiset;\n        private int size;\n\n        public MultiSet(Map<ValueType, Integer> multiset) {\n            this.multiset = multiset;\n            this.size = 0;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public void inc(ValueType value) {\n            int count = get(value);\n            multiset.put(value, count + 1);\n\n            ++size;\n        }\n\n        public void dec(ValueType value) {\n            int count = get(value);\n            if (count == 0) return;\n\n            if (count == 1) multiset.remove(value);\n            else multiset.put(value, count - 1);\n\n            --size;\n        }\n\n        public int get(ValueType value) {\n            Integer count = multiset.get(value);\n            return (count == null ? 0 : count);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class IdMap<KeyType> extends HashMap<KeyType, Integer> {\n\n        /**\n         *\n         */\n        private static final long serialVersionUID = -3793737771950984481L;\n\n        public IdMap() {\n            super();\n        }\n\n        int getId(KeyType key) {\n            Integer id = super.get(key);\n            if (id == null) {\n                super.put(key, id = size());\n            }\n\n            return id;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static int[] castInt(List<Integer> list) {\n        int[] array = new int[list.size()];\n        for (int i = 0; i < array.length; ++i) {\n            array[i] = list.get(i);\n        }\n\n        return array;\n    }\n\n    private static long[] castLong(List<Long> list) {\n        long[] array = new long[list.size()];\n        for (int i = 0; i < array.length; ++i) {\n            array[i] = list.get(i);\n        }\n\n        return array;\n    }\n}\n\n", "label": 3}
{"src": "import java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.Scanner;\nimport java.util.Vector;\npublic class Main {\n\tstatic final long mod=1000000007;\n\tpublic static void main(String[] args) {\n\t\tlong a[]=new long[20];\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tlong s=sc.nextLong();\n\t\tfor(int i=0;i<n;i++)\n\t\t\t\ta[i]=sc.nextLong();\n\t\tint len=(1<<n);\n\t\tlong ans=0;\n\t\tfor(int i=0;i<len;i++){\n\t\t\tlong x=s;\n\t\t\tint flag=1;\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tif(((i>>j)&1)==1){\n\t\t\t\t\tflag*=-1;\n\t\t\t\t\tx-=a[j]+1;\n\t\t\t\t}\n\t\t\tif(x<0)\n\t\t\t\tcontinue;\n\t\t\tans=(ans+flag*lucas(x+n-1,n-1))%mod;\n\t\t\tans=(ans+mod)%mod;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\tstatic long lucas(long a,long b){\n\t\tif(b==0)\n\t\t\treturn 1;\n\t\treturn getc(a%mod,b%mod)*lucas(a/mod,b/mod)%mod;\n\t}\n\tstatic long getc(long a,long b){\n\t\tif(a<b)\n\t\t\treturn 0;\n\t\tlong ans=1;\n\t\tfor(long i=a-b+1;i<=a;i++)\n\t\t\tans=ans*i%mod;\n\t\tlong t=1;\n\t\tfor(long i=1;i<=b;i++)\n\t\t\tt=t*i%mod;\n\t\treturn ans*qpow(t,mod-2)%mod;\n\t}\n\tstatic long qpow(long a,long b){\n\t\tlong ans=1;\n\t\twhile(b!=0){\n\t\t\tif((b&1)==1){\n\t\t\t\tans=a*ans%mod;\n\t\t\t}\n\t\t\ta=a*a%mod;\n\t\t\tb>>=1;\n\t\t}\n\t\treturn ans;\n\t}\n}", "label": 3}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\t\n\t// ArrayList<Integer> lis = new ArrayList<Integer>();\n\t// ArrayList<String> lis = new ArrayList<String>();\n\t//  PriorityQueue<P> que = new PriorityQueue<P>();\n\t// PriorityQueue<Integer> que = new PriorityQueue<Integer>();\n\t//  Stack<Integer> que = new Stack<Integer>();\n    //\tstatic long sum=0;\n\t// 1000000007 (10^9+7)\n\tstatic int mod = 1000000007;\n\t//static int mod = 1000000009,r=0; ArrayList<Integer> l[]= new ArrayList[n];\n   // static int dx[]={1,-1,0,0};\n//\tstatic int dy[]={0,0,1,-1};\n//\tstatic int dx[]={1,-1,0,0,1,1,-1,-1};\n//  static int dy[]={0,0,1,-1,1,-1,1,-1};\n\t//static Set<Integer> set = new HashSet<Integer>();p\n\t\npublic  static void main(String[] args)   throws Exception, IOException{\n   //String line=\"\"; throws Exception, IOException\n   //(line=br.readLine())!=null\n\t//Scanner sc =new Scanner(System.in);\n\t// !!caution!! int long //  \n\tReader sc = new Reader(System.in);\n\n\n //,a=sc.nextInt(),b=sc.nextInt();\n \t int n=sc.nextInt();\n    long f[]=new long[n],s=sc.nextLong()+n-1;\n     \n\tfor (int i = 0; i <n ; i++){\n\t\tf[i]=sc.nextLong();\n\t}\n\n\tlong a[]=new long [2];\n\tlong d[]=new long[22];\n      d[0]++;\n\n\tfor (int i = 1; i <=20 ; i++){\n\t\td[i]=exGCD(i, mod)[1];d[i]+=mod; d[i]%=mod;\n\t\td[i]*=d[i-1];\n        d[i]%=mod;\n\t}\n\t\n\t//db(d);\n\t\n\tlong r=0;\n\t\n\tfor(int i=0,c=1;i<1<<n;i++){\n\t  long \tx=s,k=0;\n\t    for(int t=0;t<n;t++){\n\t    \tif( bit(i,t) ){ k++;  x-=f[t]+1;      }\n\t    }\n\t   if( k%2==0 )c=1 ; else c=-1;\n\t   if(x<0)continue; \n\t    x%=mod;\n\t  r+=c*com( x,n-1,d[n-1] );\n\t  r+=mod;\n\t  r%=mod;\n\t // db(i,x,r);\n\t}\n\t\n\t\n\tSystem.out.println(r);\n\n}\n\nstatic boolean bit(int x,int k){\n\t// weather k-th bit (from right) be one or zero\n\treturn  ( 0 < ( (x>>k) & 1 )  )  ? true:false;\n}\n   \nstatic long com( long n, int m ,long d) {//beware n<m\ufffdI\n\t\n\tif( n<m )return 0;\n\t\t\n  long r=1;\n\t for(int i=0;i<m;i++){\n\t\t r*=n--; r%=mod;\n\t }\n\n\t r*=d; r%=mod;\n\treturn r;\n}\n\n static long[] exGCD(long a, long b)\n{\n\tif(a == 0 || b == 0)return null;\n\tint as = Long.signum(a);\n\tint bs = Long.signum(b);\n\ta = Math.abs(a); b = Math.abs(b);\n\tlong p = 1, q = 0, r = 0, s = 1;\n\twhile(b > 0){\n\t\tlong c = a / b;\n\t\tlong d;\n\t\td = a; a = b; b = d % b;\n\t\td = p; p = q; q = d - c * q;\n\t\td = r; r = s; s = d - c * s;\n\t}\n\t// can be minus! \n\treturn new long[]{a, p * as, r * bs};\n}\n\nstatic void db(Object... os){\n    System.err.println(Arrays.deepToString(os));\n\n}\n\n}\n\n\n  /* \n   * class P implements Comparable<P>{\n//\t\timplements Comparable<Pair>\n\t\tint id; long d;\n\t\tP(int id,long d){\n\t\t\tthis.id=id;\n\t\t\tthis.d=d;\n\t\t} \n\t\tpublic int compareTo(P x){\n\t\t   \t return  0<=d-x.d?1:-1 ;  //ascend\n\t\t   }\n\t \n }\n\n\n\nclass Pair implements Comparable<Pair>{\n//\timplements Comparable<Pair>\n\tint a,b;\n\tPair(int a,int b){\n\t\tthis.a=a;\n\t\tthis.b=b;\n\t} \n\tpublic int compareTo(Pair x){\n\t   \t return a-x.a; //descend\n\t   }\n}*/\n\nclass Reader\n{ \n\tprivate BufferedReader x;\n\tprivate StringTokenizer st;\n\t\n\tpublic Reader(InputStream in)\n\t{\n\t\tx = new BufferedReader(new InputStreamReader(in));\n\t\tst = null;\n\t}\n\tpublic String nextString() throws IOException\n\t{\n\t\twhile( st==null || !st.hasMoreTokens() )\n\t\t\tst = new StringTokenizer(x.readLine());\n\t\treturn st.nextToken();\n\t}\n\tpublic int nextInt() throws IOException\n\t{\n\t\treturn Integer.parseInt(nextString());\n\t}\n\tpublic long nextLong() throws IOException\n\t{\n\t\treturn Long.parseLong(nextString());\n\t}\n\tpublic double nextDouble() throws IOException\n\t{\n\t\treturn Double.parseDouble(nextString());\n\t}\n}\n", "label": 3}
{"src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class e {\n\tstatic final long MOD = (long)1e9+7;\n\tpublic static void main(String[] args) {\n\t\tlong[] invs = new long[300];\n\t\tinvs[1] = 1;\n\t\tfor (int i = 2; i < invs.length; ++i)\n\t\t\tinvs[i] = (MOD - (MOD / i) * invs[((int) (MOD % i))] % MOD) % MOD;\n\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tlong s = in.nextLong();\n\t\tlong[] fs = new long[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfs[i] = in.nextLong();\n\t\tArrayList<Term> ans = new ArrayList<>();\n\t\tans.add(new Term(1, 0));\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tArrayList<Term> cur = new ArrayList<>();\n\t\t\tcur.add(new Term(1,0));\n\t\t\tcur.add(new Term(-1,fs[i]+1));\n\t\t\tans = multiply(ans, cur);\n\t\t}\n\t\tCollections.sort(ans);\n//\t\tSystem.out.println(ans);\n\t\tlong sum = 0;\n\t\tfor(Term t : ans) {\n\t\t\tlong pow = s - t.pow;\n\t\t\tif(pow < 0) continue;\n\t\t\tlong choose = 1;\n\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\tchoose *= (pow+n-1-i) % MOD;\n\t\t\t\tchoose %= MOD;\n\t\t\t\tchoose *= invs[i+1];\n\t\t\t\tchoose %= MOD;\n//\t\t\t\tSystem.out.println(\" * \" + (pow-i) + \" / \" + (i+1));\n\t\t\t}\n//\t\t\tSystem.out.println(\"(\" + (pow+n-1) + \" choose \" + (n-1) + \") = \" + choose);\n\t\t\tsum += t.c * choose;\n\t\t\tsum %= MOD;\n\t\t}\n\t\tif(sum < 0) sum += MOD;\n\t\tSystem.out.println(sum);\n\t}\n\tstatic ArrayList<Term> multiply(ArrayList<Term> eq1, ArrayList<Term> eq2) {\n\t\tArrayList<Term> ans = new ArrayList<>();\n\t\tfor(Term t1 : eq1) {\n\t\t\tfor(Term t2 : eq2) {\n\t\t\t\tans.add(new Term((t1.c * t2.c) % MOD, t1.pow + t2.pow));\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\tstatic class Term implements Comparable<Term>{\n\t\tlong c;\n\t\tlong pow;\n\t\tpublic Term(long c, long pow) {\n\t\t\tthis.c = c;\n\t\t\tthis.pow = pow;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Term o) {\n\t\t\treturn Long.compare(pow, o.pow);\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn c + \"x^(\" + pow + \")\";\n\t\t}\n\t}\n}\n", "label": 3}
{"src": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class e {\n\tstatic final long MOD = (long)1e9+7;\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tlong[] invs = new long[25];\n\t\tinvs[1] = 1;\n\t\tfor (int i = 2; i < invs.length; ++i)\n\t\t\tinvs[i] = (MOD - (MOD / i) * invs[((int) (MOD % i))] % MOD) % MOD;\n\t\tint n = in.nextInt();\n\t\tlong s = in.nextLong();\n\t\tlong[] fs = new long[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfs[i] = in.nextLong();\n\t\tArrayList<Term> ans = new ArrayList<>();\n\t\tans.add(new Term(1, 0));\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tArrayList<Term> cur = new ArrayList<>();\n\t\t\tcur.add(new Term(1,0));\n\t\t\tcur.add(new Term(-1,fs[i]+1));\n\t\t\tans = multiply(ans, cur);\n\t\t}\n\t\tlong sum = 0;\n\t\tfor(Term t : ans) {\n\t\t\tlong pow = s - t.pow;\n\t\t\tif(pow < 0) continue;\n\t\t\tlong choose = 1;\n\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\tchoose *= (pow+n-1-i) % MOD;\n\t\t\t\tchoose %= MOD;\n\t\t\t\tchoose *= invs[i+1];\n\t\t\t\tchoose %= MOD;\n\t\t\t}\n\t\t\tsum += t.c * choose;\n\t\t\tsum %= MOD;\n\t\t}\n\t\tif(sum < 0) sum += MOD;\n\t\tSystem.out.println(sum);\n\t}\n\tstatic ArrayList<Term> multiply(ArrayList<Term> eq1, ArrayList<Term> eq2) {\n\t\tArrayList<Term> ans = new ArrayList<>();\n\t\tfor(Term t1 : eq1)\n\t\t\tfor(Term t2 : eq2)\n\t\t\t\tans.add(new Term((t1.c * t2.c) % MOD, t1.pow + t2.pow));\n\t\treturn ans;\n\t}\n\tstatic class Term {\n\t\tlong c;\n\t\tlong pow;\n\t\tpublic Term(long c, long pow) {\n\t\t\tthis.c = c;\n\t\t\tthis.pow = pow;\n\t\t}\n\t}\n}\n", "label": 3}
{"src": "import java.awt.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.List;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\n\n\npublic class E implements Runnable{\n\n    // SOLUTION!!!\n    // HACK ME PLEASE IF YOU CAN!!!\n    // PLEASE!!!\n    // PLEASE!!!\n    // PLEASE!!!\n\n    private final static Random rnd = new Random();\n    private final static String fileName = \"\";\n\n    final static long MODULO = 1000 * 1000 * 1000 + 7;\n\n    long inverseNMinus1Factorial;\n\n    void generate(long[] f, Map<Long, Long> coeffs, int index, long power, long coeff) {\n        if (index == f.length) {\n            coeffs.put(\n                    power,\n                    add(coeffs.getOrDefault(power, 0L), coeff)\n            );\n        } else {\n            generate(f, coeffs, index + 1, power, coeff);\n            generate(f, coeffs, index + 1, power + f[index] + 1, -coeff);\n        }\n    }\n\n    private void solve() {\n        int n = readInt();\n        long s = readLong();\n\n        long[] f = readLongArray(n);\n\n        Map<Long, Long> coeffs = new HashMap<>();\n\n        generate(f, coeffs, 0, 0, 1);\n\n        long nMinus1Factorial = multSequence(1, n - 1);\n        this.inverseNMinus1Factorial = inverse(nMinus1Factorial);\n\n        long answer = 0;\n        for (Map.Entry<Long, Long> coeffEntry : coeffs.entrySet()) {\n            long power = coeffEntry.getKey();\n            long coeff = coeffEntry.getValue();\n\n            if (s >= power) {\n                long need = s - power;\n                answer = add(answer, mult(binom(n + need - 1, need), coeff));\n            }\n        }\n\n        out.println(answer);\n    }\n\n    long multSequence(long start, long end) {\n        long res = 1;\n        for (long i = start; i <= end; ++i) {\n            res = mult(res, i);\n        }\n\n        return res;\n    }\n\n    long inverse(long x) {\n        return binpow(x, MODULO - 2);\n    }\n\n    long binpow(long base, long power) {\n        if (power == 0) return 1;\n\n        if ((power & 1) == 0) {\n            long half = binpow(base, power >> 1);\n            return mult(half, half);\n        } else {\n            long prev = binpow(base, power - 1);\n            return mult(prev, base);\n        }\n    }\n\n    long binom(long n, long k) {\n        return mult(\n                multSequence(k + 1, n),\n                inverseNMinus1Factorial\n        );\n    }\n\n    long add(long a, long b) {\n        return ((a % MODULO + b % MODULO) % MODULO + MODULO) % MODULO;\n    }\n\n    long mult(long a, long b) {\n        return (a % MODULO) * (b % MODULO) % MODULO;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private final static boolean FIRST_INPUT_STRING = false;\n    private final static boolean MULTIPLE_TESTS = true;\n    private final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n    private final static int MAX_STACK_SIZE = 128;\n\n    private final static boolean OPTIMIZE_READ_NUMBERS = true;\n\n    /////////////////////////////////////////////////////////////////////\n\n    public void run(){\n        try{\n            timeInit();\n            Locale.setDefault(Locale.US);\n\n            init();\n\n            if (ONLINE_JUDGE) {\n                solve();\n            } else {\n                do {\n                    try {\n                        timeInit();\n                        solve();\n                        time();\n\n                        out.println();\n                    } catch (NumberFormatException e) {\n                        break;\n                    } catch (NullPointerException e) {\n                        if (FIRST_INPUT_STRING) break;\n                        else throw e;\n                    }\n                } while (MULTIPLE_TESTS);\n            }\n\n            out.close();\n            time();\n        }catch (Exception e){\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private BufferedReader in;\n    private OutputWriter out;\n    private StringTokenizer tok = new StringTokenizer(\"\");\n\n    public static void main(String[] args){\n        new Thread(null, new E(), \"\", MAX_STACK_SIZE * (1L << 20)).start();\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private void init() throws FileNotFoundException{\n        Locale.setDefault(Locale.US);\n\n        if (ONLINE_JUDGE){\n            if (fileName.isEmpty()) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new OutputWriter(System.out);\n            } else {\n                in = new BufferedReader(new FileReader(fileName + \".in\"));\n                out = new OutputWriter(fileName + \".out\");\n            }\n        }else{\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new OutputWriter(\"output.txt\");\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    private long timeBegin;\n\n    private void timeInit() {\n        this.timeBegin = System.currentTimeMillis();\n    }\n\n    private void time(){\n        long timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    private void debug(Object... objects){\n        if (ONLINE_JUDGE){\n            for (Object o: objects){\n                System.err.println(o.toString());\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private String delim = \" \";\n\n    private String readLine() {\n        try {\n            return in.readLine();\n        } catch (IOException e) {\n            throw new RuntimeIOException(e);\n        }\n    }\n\n    private String readString() {\n        try {\n            while(!tok.hasMoreTokens()){\n                tok = new StringTokenizer(readLine());\n            }\n\n            return tok.nextToken(delim);\n        } catch (NullPointerException e) {\n            return null;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////\n\n    private final char NOT_A_SYMBOL = '\\0';\n\n    private char readChar() {\n        try {\n            int intValue = in.read();\n\n            if (intValue == -1){\n                return NOT_A_SYMBOL;\n            }\n\n            return (char) intValue;\n        } catch (IOException e) {\n            throw new RuntimeIOException(e);\n        }\n    }\n\n    private char[] readCharArray() {\n        return readLine().toCharArray();\n    }\n\n    private char[][] readCharField(int rowsCount) {\n        char[][] field = new char[rowsCount][];\n        for (int row = 0; row < rowsCount; ++row) {\n            field[row] = readCharArray();\n        }\n\n        return field;\n    }\n\n    /////////////////////////////////////////////////////////////////\n\n    private long optimizedReadLong() {\n        int sign = 1;\n        long result = 0;\n        boolean started = false;\n        while (true) {\n            try {\n                int j = in.read();\n                if (-1 == j) {\n                    if (started) return sign * result;\n                    throw new NumberFormatException();\n                }\n\n                if (j == '-') {\n                    if (started) throw new NumberFormatException();\n                    sign = -sign;\n                }\n\n                if ('0' <= j && j <= '9') {\n                    result = result * 10 + j - '0';\n                    started = true;\n                } else if (started) {\n                    return sign * result;\n                }\n            } catch (IOException e) {\n                throw new RuntimeIOException(e);\n            }\n        }\n    }\n\n    private int readInt() {\n\n        if (!OPTIMIZE_READ_NUMBERS) {\n            return Integer.parseInt(readString());\n        } else {\n            return (int) optimizedReadLong();\n        }\n    }\n\n    private int[] readIntArray(int size) {\n        int[] array = new int[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readInt();\n        }\n\n        return array;\n    }\n\n    private int[] readSortedIntArray(int size) {\n        Integer[] array = new Integer[size];\n\n        for (int index = 0; index < size; ++index) {\n            array[index] = readInt();\n        }\n        Arrays.sort(array);\n\n        int[] sortedArray = new int[size];\n        for (int index = 0; index < size; ++index) {\n            sortedArray[index] = array[index];\n        }\n\n        return sortedArray;\n    }\n\n    private int[] readIntArrayWithDecrease(int size) {\n        int[] array = readIntArray(size);\n\n        for (int i = 0; i < size; ++i) {\n            array[i]--;\n        }\n\n        return array;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n\n    private int[][] readIntMatrix(int rowsCount, int columnsCount) {\n        int[][] matrix = new int[rowsCount][];\n\n        for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n            matrix[rowIndex] = readIntArray(columnsCount);\n        }\n\n        return matrix;\n    }\n\n    private int[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) {\n        int[][] matrix = new int[rowsCount][];\n\n        for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n            matrix[rowIndex] = readIntArrayWithDecrease(columnsCount);\n        }\n\n        return matrix;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n\n    private long readLong() {\n        if (!OPTIMIZE_READ_NUMBERS) {\n            return Long.parseLong(readString());\n        } else {\n            return optimizedReadLong();\n        }\n    }\n\n    private long[] readLongArray(int size) {\n        long[] array = new long[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readLong();\n        }\n\n        return array;\n    }\n\n    ////////////////////////////////////////////////////////////////////\n\n    private double readDouble() {\n        return Double.parseDouble(readString());\n    }\n\n    private double[] readDoubleArray(int size) {\n        double[] array = new double[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readDouble();\n        }\n\n        return array;\n    }\n\n    ////////////////////////////////////////////////////////////////////\n\n    private BigInteger readBigInteger() {\n        return new BigInteger(readString());\n    }\n\n    private BigDecimal readBigDecimal() {\n        return new BigDecimal(readString());\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private Point readPoint() {\n        int x = readInt();\n        int y = readInt();\n        return new Point(x, y);\n    }\n\n    private Point[] readPointArray(int size) {\n        Point[] array = new Point[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readPoint();\n        }\n\n        return array;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    @Deprecated\n    private List<Integer>[] readGraph(int vertexNumber, int edgeNumber) {\n        @SuppressWarnings(\"unchecked\")\n        List<Integer>[] graph = new List[vertexNumber];\n\n        for (int index = 0; index < vertexNumber; ++index){\n            graph[index] = new ArrayList<>();\n        }\n\n        while (edgeNumber-- > 0){\n            int from = readInt() - 1;\n            int to = readInt() - 1;\n\n            graph[from].add(to);\n            graph[to].add(from);\n        }\n\n        return graph;\n    }\n\n    private static class GraphBuilder {\n\n        final int size;\n        final List<Integer>[] edges;\n\n        static GraphBuilder createInstance(int size) {\n            List<Integer>[] edges = new List[size];\n            for (int v = 0; v < size; ++v) {\n                edges[v] = new ArrayList<>();\n            }\n\n            return new GraphBuilder(edges);\n        }\n\n        private GraphBuilder(List<Integer>[] edges) {\n            this.size = edges.length;\n            this.edges = edges;\n        }\n\n        public void addEdge(int from, int to) {\n            addDirectedEdge(from, to);\n            addDirectedEdge(to, from);\n        }\n\n        public void addDirectedEdge(int from, int to) {\n            edges[from].add(to);\n        }\n\n        public int[][] build() {\n            int[][] graph = new int[size][];\n            for (int v = 0; v < size; ++v) {\n                List<Integer> vEdges = edges[v];\n                graph[v] = castInt(vEdges);\n            }\n\n            return graph;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class IntIndexPair {\n\n        static Comparator<IntIndexPair> increaseComparator = new Comparator<E.IntIndexPair>() {\n\n            @Override\n            public int compare(E.IntIndexPair indexPair1, E.IntIndexPair indexPair2) {\n                int value1 = indexPair1.value;\n                int value2 = indexPair2.value;\n\n                if (value1 != value2) return value1 - value2;\n\n                int index1 = indexPair1.index;\n                int index2 = indexPair2.index;\n\n                return index1 - index2;\n            }\n        };\n\n        static Comparator<IntIndexPair> decreaseComparator = new Comparator<E.IntIndexPair>() {\n\n            @Override\n            public int compare(E.IntIndexPair indexPair1, E.IntIndexPair indexPair2) {\n                int value1 = indexPair1.value;\n                int value2 = indexPair2.value;\n\n                if (value1 != value2) return -(value1 - value2);\n\n                int index1 = indexPair1.index;\n                int index2 = indexPair2.index;\n\n                return index1 - index2;\n            }\n        };\n\n        int value, index;\n\n        IntIndexPair(int value, int index) {\n            super();\n            this.value = value;\n            this.index = index;\n        }\n\n        int getRealIndex() {\n            return index + 1;\n        }\n    }\n\n    private IntIndexPair[] readIntIndexArray(int size) {\n        IntIndexPair[] array = new IntIndexPair[size];\n\n        for (int index = 0; index < size; ++index) {\n            array[index] = new IntIndexPair(readInt(), index);\n        }\n\n        return array;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class OutputWriter extends PrintWriter {\n\n        final int DEFAULT_PRECISION = 12;\n\n        private int precision;\n        private String format, formatWithSpace;\n\n        {\n            precision = DEFAULT_PRECISION;\n\n            format = createFormat(precision);\n            formatWithSpace = format + \" \";\n        }\n\n        OutputWriter(OutputStream out) {\n            super(out);\n        }\n\n        OutputWriter(String fileName) throws FileNotFoundException {\n            super(fileName);\n        }\n\n        int getPrecision() {\n            return precision;\n        }\n\n        void setPrecision(int precision) {\n            precision = max(0, precision);\n            this.precision = precision;\n\n            format = createFormat(precision);\n            formatWithSpace = format + \" \";\n        }\n\n        String createFormat(int precision){\n            return \"%.\" + precision + \"f\";\n        }\n\n        @Override\n        public void print(double d){\n            printf(format, d);\n        }\n\n        void printWithSpace(double d){\n            printf(formatWithSpace, d);\n        }\n\n        void printAll(double...d){\n            for (int i = 0; i < d.length - 1; ++i){\n                printWithSpace(d[i]);\n            }\n\n            print(d[d.length - 1]);\n        }\n\n        @Override\n        public void println(double d){\n            printlnAll(d);\n        }\n\n        void printlnAll(double... d){\n            printAll(d);\n            println();\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class RuntimeIOException extends RuntimeException {\n\n        /**\n         *\n         */\n        private static final long serialVersionUID = -6463830523020118289L;\n\n        RuntimeIOException(Throwable cause) {\n            super(cause);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    //////////////// Some useful constants and functions ////////////////\n    /////////////////////////////////////////////////////////////////////\n\n    private static final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    private static final int[][] steps8 = {\n            {-1, 0}, {1, 0}, {0, -1}, {0, 1},\n            {-1, -1}, {1, 1}, {1, -1}, {-1, 1}\n    };\n\n    private static boolean checkCell(int row, int rowsCount, int column, int columnsCount) {\n        return checkIndex(row, rowsCount) && checkIndex(column, columnsCount);\n    }\n\n    private static boolean checkIndex(int index, int lim){\n        return (0 <= index && index < lim);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static boolean checkBit(int mask, int bit){\n        return (mask & (1 << bit)) != 0;\n    }\n    private static boolean checkBit(long mask, int bit){\n        return (mask & (1L << bit)) != 0;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static long getSum(int[] array) {\n        long sum = 0;\n        for (int value: array) {\n            sum += value;\n        }\n\n        return sum;\n    }\n\n    private static Point getMinMax(int[] array) {\n        int min = array[0];\n        int max = array[0];\n\n        for (int index = 0, size = array.length; index < size; ++index, ++index) {\n            int value = array[index];\n\n            if (index == size - 1) {\n                min = min(min, value);\n                max = max(max, value);\n            } else {\n                int otherValue = array[index + 1];\n\n                if (value <= otherValue) {\n                    min = min(min, value);\n                    max = max(max, otherValue);\n                } else {\n                    min = min(min, otherValue);\n                    max = max(max, value);\n                }\n            }\n        }\n\n        return new Point(min, max);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static int[] getPrimes(int n) {\n        boolean[] used = new boolean[n];\n        used[0] = used[1] = true;\n\n        int size = 0;\n        for (int i = 2; i < n; ++i) {\n            if (!used[i]) {\n                ++size;\n                for (int j = 2 * i; j < n; j += i) {\n                    used[j] = true;\n                }\n            }\n        }\n\n        int[] primes = new int[size];\n        for (int i = 0, cur = 0; i < n; ++i) {\n            if (!used[i]) {\n                primes[cur++] = i;\n            }\n        }\n\n        return primes;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n\n    private static long gcd(long a, long b) {\n        return (a == 0 ? b : gcd(b % a, a));\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class MultiSet<ValueType> {\n\n        public static <ValueType> MultiSet<ValueType> createMultiSet() {\n            Map<ValueType, Integer> multiset = new HashMap<>();\n            return new MultiSet<>(multiset);\n        }\n\n        private final Map<ValueType, Integer> multiset;\n        private int size;\n\n        public MultiSet(Map<ValueType, Integer> multiset) {\n            this.multiset = multiset;\n            this.size = 0;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public void inc(ValueType value) {\n            int count = get(value);\n            multiset.put(value, count + 1);\n\n            ++size;\n        }\n\n        public void dec(ValueType value) {\n            int count = get(value);\n            if (count == 0) return;\n\n            if (count == 1) multiset.remove(value);\n            else multiset.put(value, count - 1);\n\n            --size;\n        }\n\n        public int get(ValueType value) {\n            Integer count = multiset.get(value);\n            return (count == null ? 0 : count);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class IdMap<KeyType> extends HashMap<KeyType, Integer> {\n\n        /**\n         *\n         */\n        private static final long serialVersionUID = -3793737771950984481L;\n\n        public IdMap() {\n            super();\n        }\n\n        int getId(KeyType key) {\n            Integer id = super.get(key);\n            if (id == null) {\n                super.put(key, id = size());\n            }\n\n            return id;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static int[] castInt(List<Integer> list) {\n        int[] array = new int[list.size()];\n        for (int i = 0; i < array.length; ++i) {\n            array[i] = list.get(i);\n        }\n\n        return array;\n    }\n\n    private static long[] castLong(List<Long> list) {\n        long[] array = new long[list.size()];\n        for (int i = 0; i < array.length; ++i) {\n            array[i] = list.get(i);\n        }\n\n        return array;\n    }\n}\n\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author aryssoncf\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            try {\n                int n = in.readInt();\n                long s = in.readLong();\n                long[] f = in.readLongArray(n);\n                MiscUtils.increaseByOne(f);\n                long res = 0;\n                for (int mask = 0; mask < (1 << n); mask++) {\n                    long k = 0;\n                    int sign = 1;\n                    for (int i = 0; i < n; i++) {\n                        if (((mask >> i) & 1) == 1) {\n                            k += f[i];\n                            sign *= -1;\n                        }\n                    }\n                    if (k > s) {\n                        continue;\n                    }\n                    long rem = s - k, coef = IntegerUtils.binomialCoefficient(rem + n - 1, rem, MiscUtils.MOD7);\n                    res = IntegerUtils.trueMod(res + sign * coef, MiscUtils.MOD7);\n                }\n                out.printLine(res);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n    static class MiscUtils {\n        public static final int MOD7 = (int) (1e9 + 7);\n\n        public static void increaseByOne(long[]... arrays) {\n            for (long[] array : arrays) {\n                for (int i = 0; i < array.length; i++) {\n                    array[i]++;\n                }\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public long[] readLongArray(int size) {\n            long[] array = new long[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readLong();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class IntegerUtils {\n        private static long _x;\n        private static long _y;\n\n        public static long trueMod(long a, long b) {\n            a %= b;\n            a += b;\n            a %= b;\n            return a;\n        }\n\n        public static long factorial(int n, long mod) {\n            long result = 1;\n            for (int i = 2; i <= n; i++) {\n                result = result * i % mod;\n            }\n            return result % mod;\n        }\n\n        public static long reverse(long number, long modulo) {\n            extGcd(number, modulo);\n            return trueMod(_x, modulo);\n        }\n\n        private static long extGcd(long a, long b) {\n            if (a == 0) {\n                _x = 0;\n                _y = 1;\n                return b;\n            }\n            long d = extGcd(b % a, a);\n            long nx = _y - (b / a) * _x;\n            //noinspection SuspiciousNameCombination\n            _y = _x;\n            _x = nx;\n            return d;\n        }\n\n        public static long binomialCoefficient(long n, long m, long mod) {\n            if (m < 0 || m > n) {\n                return 0;\n            }\n            if (2 * m > n) {\n                m = n - m;\n            }\n            long result = 1;\n            for (long i = n - m + 1; i <= n; i++) {\n                result = result * (i % mod) % mod;\n            }\n            return result * reverse(factorial((int) m, mod), mod) % mod;\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Main().run();\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st = new StringTokenizer(\"\");\n\n\tprivate void run() throws IOException {\n\t\tif (new File(\"input.txt\").exists())\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\telse\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tif (new File(\"output.txt\").exists())\n\t\t\tout = new PrintWriter(\"output.txt\");\n\t\telse\n\t\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tfinal int maxn = 22;\n\tfinal int p = 1000 * 1000 * 1000 + 7;\n\n\tint n;\n\tlong s;\n\tlong f[] = new long[maxn];\n\tlong ans;\n\n\tlong inv[] = new long[maxn];\n\tlong finv[] = new long[maxn];\n\n\tTreeMap<Long, Long> polynom = new TreeMap<>();\n\n\tvoid rec(int index, long a, long pow) {\n\t\tif (index == n) {\n\t\t\tif (polynom.containsKey(pow))\n\t\t\t\tpolynom.put(pow, (polynom.get(pow) + a) % p);\n\t\t\telse\n\t\t\t\tpolynom.put(pow, a);\n\t\t} else {\n\t\t\trec(index + 1, a, pow);\n\t\t\trec(index + 1, (p - a) % p, pow + f[index] + 1);\n\t\t}\n\t}\n\n\tlong getC(long n, int m) {\n\t\tn %= p;\n\t\tlong c = 1;\n\t\tfor (long i = n - m + 1; i <= n; i++)\n\t\t\tc = (c * i) % p;\n\t\tc = (c * finv[m]) % p;\n\t\treturn c;\n\t}\n\n\tvoid precalc() {\n\t\tinv[1] = 1;\n\t\tfor (int i = 2; i < maxn; i++)\n\t\t\tinv[i] = (p - ((p / i) * inv[p % i]) % p) % p;\n\t\tfinv[0] = 1;\n\t\tfor (int i = 1; i < maxn; i++)\n\t\t\tfinv[i] = (finv[i - 1] * inv[i]) % p;\n\t}\n\n\tvoid solve() throws IOException {\n\t\tprecalc();\n\t\tn = nextInt();\n\t\ts = nextLong();\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tf[i] = nextLong();\n\n\t\trec(0, 1, 0);\n\t\tans = 0;\n\t\tfor (long pow : polynom.keySet()) {\n\t\t\tlong k = s - pow;\n\t\t\tif (k >= 0) {\n\t\t\t\tlong c = getC(n + k - 1, n - 1);\n\t\t\t\t// System.err.println(k + \" \" + c);\n\t\t\t\tans = (ans + c * polynom.get(pow)) % p;\n\t\t\t}\n\t\t}\n\n\t\tout.println(ans);\n\t}\n\n\tString nextLine() throws IOException {\n\t\tst = new StringTokenizer(\"\");\n\t\treturn in.readLine();\n\t}\n\n\tString nextToken() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tboolean EOF() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString str = in.readLine();\n\t\t\tif (str == null)\n\t\t\t\treturn true;\n\t\t\tst = new StringTokenizer(str);\n\t\t}\n\t\treturn false;\n\t}\n\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.lang.*;\nimport static java.lang.Math.*;\nimport java.lang.reflect.*;\nimport java.math.BigInteger;\nimport static java.math.BigInteger.*;\nimport java.security.CodeSource;\nimport java.security.KeyStore;\nimport java.util.*;\nimport static java.util.Arrays.*;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n// https://netbeans.org/kb/73/java/editor-codereference_ru.html#display\n\npublic class Main {\n    \n    final long mod = (long)1e9 + 7;\n    int n;\n    long s;\n    long[] f;\n    long[] invFact = new long[1000];\n    {\n        invFact[0] = 1;\n        long f = 1;\n        for (int i = 1; i < invFact.length; i++) {\n            f = (f * i) % mod;\n            invFact[i] = valueOf(f).modInverse(valueOf(mod)).longValue();\n        }\n    }\n    \n    long C( int l, long b ){\n        long ans = 1;\n        for( long x = b-l+1; x <= b; ++x ){\n            ans = (x%mod * ans) % mod;\n        }\n        ans = (ans * invFact[l]) % mod;\n        return ans;\n    }\n\n    void solve(){\n        for( int n = 0; n <= 10; ++n ){\n            for (int m = 0; m <= n; m++) {\n                err.print( \" \" + C(m,n) );\n            }\n            err.println();\n        }\n        \n        n = sc.nextInt();\n        s = sc.nextLong();\n        f = new long[n];\n        for (int i = 0; i < f.length; i++) {\n            f[i] = sc.nextLong();\n        }\n        \n        long ans = 0;\n        for (int msk = 0; msk < (1<<n); msk++) {\n            long curS = s;\n            for (int i = 0; i < n; i++) {\n                if( ((msk>>i)&1) == 1 ){\n                    curS -= f[i] + 1;\n                }\n            }\n            if( 0 <= curS ){\n                long comb = C(n-1, curS+n-1);\n                //err.println( msk +\") \"+ comb );\n                if( Integer.bitCount(msk) % 2 == 0 )\n                    ans = (ans + comb) % mod;\n                else\n                    ans = (ans - comb + mod) % mod;\n            }\n        }\n        ans = (ans%mod + mod) % mod;\n        out.println(ans);\n    }\n\n    \n    \n    \n    \n    //------------------------------------------------------------------//\n    \n    private void run(){\n        err = System.err;\n        boolean oj = true;\n        try {\n            oj = System.getProperty(\"MYLOCAL\") == null;\n        } catch (Exception e) {\n        }\n        \n        if( oj ){\n            sc = new FastScanner(new InputStreamReader(System.in));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n        }\n        else{\n            try {\n                sc = new FastScanner(new FileReader(\"input.txt\"));\n                out = new PrintWriter(new FileWriter(\"output.txt\"));\n            } catch ( IOException e) {\n                MLE();\n            }\n        }\n        solve();\n        \n        out.flush();\n    }\n    \n    FastScanner sc;\n    PrintWriter out;\n    PrintStream err;\n    \n    \n    void MLE(){\n        int[][] arr = new int[1024*1024][];\n        for (int i = 0; i < arr.length; i++) {\n            arr[i] = new int[1024*1024];\n        }\n    }\n\n\n    class FastScanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(InputStreamReader reader) {\n            br = new BufferedReader(reader);\n            st = new StringTokenizer(\"\");\n        }\n\n        String next() {\n            while( !st.hasMoreElements() )\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException ex) {\n                    MLE();\n                }\n            return st.nextToken();\n        }\n        \n        int nextInt(){ return Integer.parseInt(next());}\n\n        long nextLong() { return Long.parseLong(next()); } \n    }\n\n    public static void main(String[] args){\n        new Main().run();\n    }\n\n}\n", "label": 3}
{"src": "/*\n     * Code Author: Akshay Miterani\n     * DA-IICT\n     */\n    import java.io.*;\n    import java.util.*;\n    \n     \n    public class MainY {\n     \n    \tstatic double eps=(double)1e-6;\n    \tstatic long mod=(int)1e9+7;\n    \tstatic boolean f=true;\n    \tpublic static void main(String args[]){\n    \t\tInputReader in = new InputReader(System.in);\n    \t\tOutputStream outputStream = System.out;\n    \t\tPrintWriter out = new PrintWriter(outputStream);\n    \t\t//----------My Code Starts Here----------\n    \t\tlong n=in.nextLong();\n    \t\tif(n%2==0){\n    \t\t\tSystem.out.println(\"2\");\n    \t\t}\n    \t\telse{\n    \t\t\tSystem.out.println(\"1\");\n    \t\t}\n    \t\tout.close();\n    \t\t//---------------The End------------------\n    \t}\n    \tstatic double modulo(double a,int b) {\n    \t    double x=1;\n    \t    \t    double y=a;\n    \t    \t    while(b > 0){\n    \t    \t        if(b%2 == 1){\n    \t    \t            x=(x*y);\n    \t    \t        }\n    \t    \t        y = (y*y); // squaring the base\n    \t    \t        b /= 2;\n    \t    \t    }\n    \t    \t    return x;\n    \t    }\n    \tstatic class Pair implements Comparable<Pair>{\n    \t\tint r1=-1;\n    \t\tint r2=-1;\n    \t\tint extra=0;\n\t\t\t@Override\n\t\t\tpublic int compareTo(Pair arg0) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\treturn 0;\n\t\t\t}\n    \t}\n    \t\n    \tstatic class InputReader {\n    \t    public BufferedReader reader;\n    \t    public StringTokenizer tokenizer;\n     \n    \t    public InputReader(InputStream inputstream) {\n    \t      reader = new BufferedReader(new InputStreamReader(inputstream));\n    \t      tokenizer = null;\n    \t    }\n    \t    \n    \t    public String nextLine(){\n    \t    \tString fullLine=null;\n    \t    \twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n    \t            try {\n    \t              fullLine=reader.readLine();\n    \t            } catch (IOException e) {\n    \t              throw new RuntimeException(e);\n    \t            }\n    \t            return fullLine;\n    \t          }\n    \t          return fullLine;\n    \t    }\n    \t\tpublic String next() {\n    \t      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n    \t        try {\n    \t          tokenizer = new StringTokenizer(reader.readLine());\n    \t        } catch (IOException e) {\n    \t          throw new RuntimeException(e);\n    \t        }\n    \t      }\n    \t      return tokenizer.nextToken();\n    \t    }\n    \t\tpublic long nextLong() {\n    \t\t      return Long.parseLong(next());\n    \t\t    }\n    \t    public int nextInt() {\n    \t      return Integer.parseInt(next());\n    \t    }\n    \t  }\n    } ", "label": 0}
{"src": "\n// template : secondThread\n\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.util.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.util.Collections;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.util.LinkedList;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.logging.SimpleFormatter;\n\nimport static java.lang.String.*;\n\n\npublic   class main2 {\n\n\n\n\n    public static void main(String[] args) {\n        try {\n\n\n            PrintWriter fop = new PrintWriter(System.out);\n            FastScanner fsca = new FastScanner();\n\n            long l = fsca.nextLong();\n            if (l%2 == 0)\n                fop.println(2);\n            else\n                fop.println(1);\n\n\n\n\n\n\n\n\n            fop.flush();\n            fop.close();\n        }\n        catch (Exception e){\n            return;\n        }\n\n\n\n    }\n    /*-----------------------------------------------------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n    static void sieve(int n){\n        boolean[] flag = new boolean[n] ;\n\n        for (int i=2 ; i*i<n ; i++){\n            if (flag[i])\n                continue;\n            else\n                for (int j= i*i ; j<=n ; j+= i){\n                    flag[j] = true;\n                }\n        }\n\n\n    }\n    static int gcd(int a , int b){\n        if (b > a){\n            int tenp = b ;\n            b = a ;\n            a = tenp ;\n        }\n        int temp = 0 ;\n        while (b != 0){\n            a %= b ;\n            temp = b ;\n            b = a ;\n            a = temp ;\n        }\n        return a ;\n    }\n\n    static long gcd1( long a , long b){\n        if (b > a){\n            long tenp = b ;\n            b = a ;\n            a = tenp ;\n        }\n        long temp = 0 ;\n        while (b != 0){\n            a %= b ;\n            temp = b ;\n            b = a ;\n            a = temp ;\n        }\n        return a ;\n    }\n\n\n    static final Random random=new Random();\n\n    static void ruffleSort(int[] a) {\n        int n=a.length;//shuffle, then sort\n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n), temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n\n\n\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        int[] readArray(int n) {\n            int[] a=new int[n];\n            for (int i=0; i<n; i++) a[i]=nextInt();\n            return a;\n        }\n        long[] readLongArray(int n){\n            long[] a = new long[n];\n            for (int i=0 ; i<n ; i++)\n                a[i] = nextLong() ;\n            return a ;\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n\n\n\n\n\n}\n\n\n\n\n", "label": 0}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author anand.oza\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        RGame solver = new RGame();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class RGame {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long n = in.nextLong();\n            n %= 2;\n            if (n == 1) {\n                out.println(1);\n            } else {\n                out.println(2);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class CFR {\n\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n    void solve() throws IOException {\n        long n = nextLong();\n        if(n % 2 == 0) {\n            out(2);\n        }\n        else {\n            out(1);\n        }\n    }\n\n    void shuffle(long[] a) {\n        int n = a.length;\n        for(int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            long tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n\n    private void outln(Object o) {\n        System.out.println(o);\n    }\n    private void out(Object o) {\n        System.out.print(o);\n    }\n    public CFR() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n    public static void main(String[] args) throws IOException {\n        new CFR();\n    }\n\n    public long[] nextLongArr(int n) throws IOException{\n        long[] res = new long[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextLong();\n        return res;\n    }\n    public int[] nextIntArr(int n) throws IOException {\n        int[] res = new int[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextInt();\n        return res;\n    }\n    public String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return null;\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextString() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            eof = true;\n            return null;\n        }\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class Main {\n\tstatic long n;\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tn=Long.parseLong(br.readLine());\n\t\tlong res=n%2;\n\t\tif (res==0) res=2;\n\t\tSystem.out.println(res);\n\t}\n}\n", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\t\n    public static void main(String[] args) {\n    \t\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n        \tlong n = in.nextLong();\n        \tif(n % 2 == 0){\n        \t\tout.println(2);\n        \t}\n        \telse{\n        \t\tout.println(1);\n        \t}\n        \t/*double a = in.nextDouble();\n        \tdouble b = in.nextDouble();\n        \tdouble c = in.nextDouble();\n        \t\n        \tdouble s = Math.sqrt(b * b - 4 * a * c);\n        \tif(a == 0){\n        \t\tout.println( -c / b);\n        \t}\n        \telse{\n        \t\tout.println((s - b) / (2 * a));\n            \tout.println((-s - b) / (2 * a));\n        \t}*/\n        \t\n           \n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n}", "label": 0}
{"src": "\nimport java.util.Scanner;\n\n/**\n * Feb 18, 2016 | 5:55:42 PM\n * <pre>\n * <u>Description</u>\n *\n * </pre>\n *\n * @author Essiennta Emmanuel (colourfulemmanuel@gmail.com)\n */\npublic class ProblemR{\n    \n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        long n = sc.nextLong();\n        System.out.println((n & 1) == 1 ? 1 : 2);\n        sc.close();\n    }\n}\n", "label": 0}
{"src": "import java.util.*;\n\n/**\n * Created by Askar on 03.07.2017\n */\n\npublic class task1 {\n    public static void main (String args[]) {\n        Scanner in = new Scanner(System.in);\n\n        long qq = in.nextLong();\n\n        System.out.println(qq%2==1?1:2);\n\n    }\n}", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.Vector;\nimport javafx.util.Pair;\n\n/**\n *\n * @author Ahmad\n */\npublic class JavaApplication1 {\n\n    \n    public static void main (String[] args) throws IOException, Exception {\n       FastReader console = new FastReader();\n       long n = console.nextLong(); \n       if (n%2==0){\n           System.out.println(\"2\");\n       }\n       else {\n           System.out.println(\"1\");\n       }\n }\n}\nclass FastReader {\n\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}\n", "label": 0}
{"src": "import java.io.*;\n\n\npublic class Main {\n    int[] fac = new int[10];\n    private StreamTokenizer in;\n    private PrintWriter out;\n\n    public static void main(String[] args) throws IOException {\n        //long time = System.currentTimeMillis();\n\n        new Main().run();\n        //time = System.currentTimeMillis() - time;\n        //System.out.println(time + \" ms\");\n\n    }\n\n\n    private void run() throws IOException {\n        //in = new StreamTokenizer(new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\"))));\n        //BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));\n        //out = new PrintWriter(new File(\"output.txt\"));\n\n        //in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(new OutputStreamWriter(System.out));\n\n/*\n        int n = nextInt();\n        long res = 0;\n\n        for (int i = 5; i <= 7; i++) {\n            long m = n, acc = 1;\n            for (int j = 0; j < i; j++) {\n                acc *= m--;\n            }\n            res += acc / factorial(i);\n        }\n        out.print(res);\n*/\n        out.print(Long.parseLong(reader.readLine()) % 2 == 1 ? 1 : 2);\n\n        out.flush();\n\n    }\n\n\n    int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    double binpow(double a, int n) {\n        if (n == 0)\n            return 1;\n        if (n % 2 == 1)\n            return binpow(a, n - 1) * a;\n        else {\n            double b = binpow(a, n / 2);\n            return b * b;\n        }\n    }\n\n    long binpow(int a, int n) {\n        if (n == 0)\n            return 1;\n        if (n % 2 == 1)\n            return binpow(a, n - 1) * a;\n        else {\n            long b = binpow(a, n / 2);\n            return b * b;\n        }\n    }\n\n    private int factorial(int n) {\n        if (n == 0)\n            return 1;\n        if (n == 1)\n            return 1;\n\n        if (fac[n] == 0)\n            fac[n] = n * factorial(n - 1);\n        return fac[n];\n    }\n\n\n}", "label": 0}
{"src": "import java.util.Scanner;\n\n/**\n *\n * @author Hai Dang Tran\n */\npublic class P630R {\n\n    public static void main(String[] args) {\n        long n = new Scanner(System.in).nextLong();\n        System.out.println(2 - n % 2);\n    }\n\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class R {\npublic static void main(String[] args) {\n\tScanner in = new Scanner(System.in);\n\tlong n = in.nextLong();\n\tSystem.out.println(n%2==0?2:1);\n}\n}\n", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\n\npublic class R {\n\n\tstatic StringTokenizer st;\n\tstatic BufferedReader br;\n\tstatic PrintWriter pw;\n\tpublic static void main(String[] args) throws IOException {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\tpw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\t\tlong n = nextLong();\n\t\tif (n % 2==1)\n\t\t\tSystem.out.println(1);\n\t\telse\n\t\t\tSystem.out.println(2);\n\t\tpw.close();\n\t}\n\tprivate static int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\tprivate static long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\tprivate static double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\tprivate static String next() throws IOException {\n\t\twhile (st==null || !st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(br.readLine());\n\t\treturn st.nextToken();\n\t}\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class task16 {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner (System.in);\n\t\tlong n = sc.nextLong();\n\t\tif(n % 2 == 0 ){\n\t\t\tSystem.out.println(\"2\"); \n\t\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"1\");\n\t\t}\n\t\t}\n}", "label": 0}
{"src": "/**\n * Created by wobwab on 8/12/2016.\n */\nimport java.util.*;\npublic class CF630R {\n    public static void main(String[] agrs)\n    {\n        Scanner sc = new Scanner(System.in);\n        System.out.print(2-sc.nextLong()%2);\n    }\n}\n", "label": 0}
{"src": "import java.util.*;\n\npublic class game630Rtry {\n\n\tpublic static void main(String[] args) {\n\tScanner kbd = new Scanner (System.in);\n\tlong n = kbd.nextLong();\n\tif(n % 2 == 0 ){\n\t\tSystem.out.println(\"2\"); }\n\telse{\n\t\tSystem.out.println(\"1\");\n\t}\n\t}\n}", "label": 0}
{"src": "\n/**\n *\n * @author sarthak\n */\n\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\n\n\n\npublic class ExpeEduRnd_R {\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\nstatic class P {\n\n        private int x, y;\n\n        public P(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int hashCode() {\n            return (x * 31) ^ y;\n        }\n\n        public boolean equals(Object o) {\n            if (o instanceof P) {\n                P other = (P) o;\n                return (x == other.x && y == other.y);\n            }\n            return false;\n        }\n    }\n\n    public static void main(String[] args){\n         \n    FastScanner s = new FastScanner(System.in);\n  \n    long n=s.nextLong();\n    if(n%2==0)System.out.println(2);\n    else System.out.println(1);\n    \n    \n    \n    }\n\n\n}\n", "label": 0}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author ATailouloute\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        QuickScanner in = new QuickScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskR solver = new TaskR();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskR {\n        public void solve(int testNumber, QuickScanner in, PrintWriter out) {\n            long n = in.nextLong();\n            long ans = n & 1;\n            if (ans == 0) ans = 2;\n            out.println(ans);\n        }\n\n    }\n\n    static class QuickScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        InputStream is;\n\n        public QuickScanner(InputStream stream) {\n            is = stream;\n            br = new BufferedReader(new InputStreamReader(stream), 32768);\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n    }\n}\n\n", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class Main \n{\n\tpublic static void main(String[] args) \n\t{\n\t\tInputReader in = new InputReader();\n//\t\tScanner in=new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\twhile(in.hasNext())\n\t\t{\n\t\t\tlong n=in.nextLong();\n\t\t\tif(n%2==1)\n\t\t\t\tout.println(\"1\");\n\t\t\telse \n\t\t\t\tout.println(\"2\");\n\t\t}\n\t\tout.close();\n\t}\n}\n\nclass node\n{\n\tArrayList<Integer> v=new ArrayList<Integer>();\n\tnode(){}\n\tvoid push(Integer a)\n\t{\n\t\tv.add(a);\n\t}\n}\n\nclass InputReader \n{\n\tBufferedReader buf;\n\tStringTokenizer tok;\n\tInputReader() \n\t{\n\t\tbuf = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tboolean hasNext() \n\t{\n\t\twhile (tok == null || !tok.hasMoreElements()) \n\t\t{\n\t\t\ttry \n\t\t\t{\n\t\t\t\ttok = new StringTokenizer(buf.readLine());\n\t\t\t} \n\t\t\tcatch (Exception e) \n\t\t\t{\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tString next() \n\t{\n\t\tif (hasNext())\n\t\t\treturn tok.nextToken();\n\t\treturn null;\n\t}\n\n\tint nextInt() \n\t{\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() \n\t{\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() \n\t{\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tBigInteger nextBigInteger() \n\t{\n\t\treturn new BigInteger(next());\n\t}\n\n\tBigDecimal nextBigDecimal() \n\t{\n\t\treturn new BigDecimal(next());\n\t}\n}", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\npublic class R {\n\t\n\tpublic static boolean naive_simulate(final int n, boolean[][] board, int player){\t\n\t\tfor(int y = 0; y < n; y++){\n\t\t\tfor(int x = 0; x < n; x++){\n\t\t\t\tif(x != 0     && board[y][x - 1]){ continue; }\n\t\t\t\tif(y != 0     && board[y - 1][x]){ continue; }\n\t\t\t\tif(x != n - 1 && board[y][x + 1]){ continue; }\n\t\t\t\tif(y != n - 1 && board[y + 1][x]){ continue; }\n\t\t\t\tif(board[y][x]){ continue; }\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tboard[y][x] = true;\n\t\t\t\tfinal boolean result = naive_simulate(n, board, 1 - player);\n\t\t\t\t\n\t\t\t\tif(player == 0  && result){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(player == 1 && !result){\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tboard[y][x]\t= false;\t\t\t\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn (player == 0 ? false : true);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\ttry (final Scanner sc = new Scanner(System.in)) {\n\t\t\tfinal long n = sc.nextLong();\n\t\t\t\n\t\t\t//System.out.println(naive_simulate((int)(n), new boolean[(int)(n)][(int)(n)], 0));\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(n % 2 == 1 ? 1 : 2);\n\t\t}\n\t}\n\n\tpublic static class Scanner implements Closeable {\n\t\tprivate BufferedReader br;\n\t\tprivate StringTokenizer tok;\n\n\t\tpublic Scanner(InputStream is) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(is));\n\t\t}\n\n\t\tprivate void getLine() {\n\t\t\ttry {\n\t\t\t\twhile (!hasNext()) {\n\t\t\t\t\ttok = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t} catch (IOException e) { /* ignore */\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean hasNext() {\n\t\t\treturn tok != null && tok.hasMoreTokens();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tgetLine();\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic void close() {\n\t\t\ttry {\n\t\t\t\tbr.close();\n\t\t\t} catch (IOException e) { /* ignore */\n\t\t\t}\n\t\t}\n\t}\n}\n", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class ProblemR {\n\n\tpublic static void main(String[] args) {\n\t\tInputReader in = new InputReader();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n\t\tnew ProblemR().solve(in, out);\n\n\t\tout.close();\n\t}\n\n\tpublic void solve(InputReader in, PrintWriter out) {\n\t\tlong n = in.nextLong() % 2;\n\t\t\n\t\tout.println(n == 1 ? 1 : 2);\n\t}\n\n\tstatic class InputReader {\n\t\tpublic BufferedReader br;\n\t\tpublic StringTokenizer st;\n\n\t\tpublic InputReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}\n", "label": 0}
{"src": "import java.util.*;\n\n/**\n *\n * @author Fran\n */\npublic class Main {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        long l;\n        Scanner sc=new Scanner(System.in);\n        l=sc.nextLong();\n        \n        if(l%2!=0)System.out.println(\"1\");\n        else System.out.println(\"2\");\n\n    }\n    \n}\n// 1508893845081\n", "label": 0}
{"src": "\nimport java.util.Scanner;\n\npublic class P7 {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tString s = in.nextLine();\n\t\tchar last = s.charAt(s.length()-1);\n\t\tint n = last - '0';\n\t\tif (n%2 == 1) {\n\t\t\tSystem.out.println(\"1\");\n\t\t} else {\n\t\t\tSystem.out.println(\"2\");\n\t\t}\n\t}\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class Game {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tlong n = in.nextLong();\n\t\t\n\t\tSystem.out.println(2 - (n % 2));\n\t}\n}\n", "label": 0}
{"src": "import java.util.*;\npublic class game\n{\n    public static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n        long n;\n             n=sc.nextLong();\n            if(n%2==0)\n                System.out.println(\"2\");\n            else\n                System.out.println(\"1\");\n    }\n}", "label": 0}
{"src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Ideone\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tlong a;\n\t\tScanner in=new Scanner(System.in);\n\t\ta=in.nextLong();\n\t\tSystem.out.print(a % 2 == 0 ? 2 : 1);\n\t}\n}", "label": 0}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.text.*;\npublic class Main {\n    static long mod = 1000_000_007;\n    static long mod1 = 998244353;\n    static boolean fileIO = true;\n    static boolean memory = true;\n    static FastScanner f;\n    static PrintWriter pw;\n    static double eps = (double)1e-6;\n    static int oo = (int)1e7;\n\n    public static void solve() throws Exception {\n        long n = f.nl();\n        pn(n % 2 == 0 ? 2 : 1);\n    }\n \n    public static void main(String[] args)throws Exception {\n        if(memory) new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();System.exit(1);}}}, \"\", 1 << 28).start();\n        else new Main().run();\n    }\n        \n/******************************END OF MAIN PROGRAM*******************************************/\n    void run()throws Exception {\n        if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n            f = new FastScanner(\"\");\n            pw = new PrintWriter(System.out);\n        }\n        else {\n            f = new FastScanner();\n            pw = new PrintWriter(System.out);\n            //fw = new FileWriter(\"!out.txt\");\n        }\n        //pre();\n        int t = 1;\n        int tt = 1;\n        while(t --> 0) {\n            //fw.write(\"Case #\" + (tt++) + \": \");\n            //fw.write(\"\\n\");\n            solve();\n        }\n        pw.flush(); \n        pw.close();\n        //fw.close();  \n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastScanner(String str) throws Exception {\n            try {\n                br = new BufferedReader(new FileReader(\"!a.txt\"));\n            }\n            catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n \n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n \n        public String next()throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n \n        public int ni() throws IOException {return Integer.parseInt(next());}\n \n        public long nl() throws IOException {return Long.parseLong(next());}\n \n        public String nextLine() throws IOException {return br.readLine();}\n \n        public double nd() throws IOException {return Double.parseDouble(next());}\n \n    }\n \n    public static void pn(Object... o) {for(int i = 0; i < o.length; ++i) pw.print(o[i] + (i + 1 < o.length ? \" \": \"\\n\"));}\n    public static void p(Object... o) {for(int i = 0; i < o.length; ++i) pw.print(o[i] + (i + 1 < o.length ? \" \" : \"\"));}\n    public static void pni(Object... o) {for(Object obj : o) pw.print(oo + \" \"); pw.println(); pw.flush();}\n    public static int gcd(int a,int b){if(b==0)return a;else{return gcd(b,a%b);}}\n    public static long gcd(long a,long b){if(b==0l)return a;else{return gcd(b,a%b);}}\n    public static long lcm(long a,long b){return (a*b/gcd(a,b));}\n    public static long pow(long a,long b){long res=1;while(b>0){if((b&1)==1)res=res*a;b>>=1;a=a*a;}return res;}\n    public static int pow(int a,int b){int res=1;while(b>0){if((b&1)==1)res=res*a;b>>=1;a=a*a;}return res;}\n    public static long mpow(long a,long b, long m){long res=1;while(b>0){if((b&1)==1)res=((res%m)*(a%m))%m;b>>=1;a=((a%m)*(a%m))%m;}return res;}\n    public static long mul(long a , long b , long mod){return ((a%mod)*(b%mod)%mod);}\n    public static long adp(long a , long b){return ((a%mod)+(b%mod)%mod);}\n    public static int dig(long a){int cnt=0;while(a>0){a/=10;++cnt;}return Math.max(1,cnt);}\n    public static int dig(int a){int cnt=0;while(a>0){a/=10;++cnt;}return Math.max(1,cnt);}\n    public static boolean isPrime(long n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(long i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}\n    public static boolean isPrime(int n){if(n<=1)return false;if(n<=3)return true;if(n%2==0||n%3==0)return false;for(int i=5;i*i<=n;i=i+6)if(n%i==0||n%(i+2)==0)return false;return true;}\n    public static HashSet<Long> factors(long n){HashSet<Long> hs=new HashSet<Long>();for(long i=1;i<=(long)Math.sqrt(n);i++){if(n%i==0){hs.add(i);hs.add(n/i);}}return hs;}\n    public static HashSet<Integer> factors(int n){HashSet<Integer> hs=new HashSet<Integer>();for(int i=1;i<=(int)Math.sqrt(n);i++){if(n%i==0){hs.add(i);hs.add(n/i);}}return hs;}\n    public static HashSet<Long> pf(long n){HashSet<Long> ff=factors(n);HashSet<Long> ans=new HashSet<Long>();for(Long i:ff)if(isPrime(i))ans.add(i);return ans;}\n    public static HashSet<Integer> pf(int n){HashSet<Integer> ff=factors(n);HashSet<Integer> ans=new HashSet<Integer>();for(Integer i:ff)if(isPrime(i))ans.add(i);return ans;}\n    public static int gnv(char c){return Character.getNumericValue(c);}\n    public static void sort(int[] a){ArrayList<Integer> l=new ArrayList<>();for(int i:a)l.add(i);Collections.sort(l);for(int i=0;i<a.length;++i)a[i]=l.get(i);}\n    public static void sort(long[] a){ArrayList<Long> l=new ArrayList<>();for(long i:a)l.add(i);Collections.sort(l);for(int i=0;i<a.length;++i)a[i]=l.get(i);}\n    public static void sort(ArrayList<Integer> a){Collections.sort(a);}\n}", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class CF {\n\n\tpublic static void main(String args[]){\n\t\tScanner sc=new Scanner(System.in);\n\t\tlong n=sc.nextLong();\n\t\tSystem.out.printf(\"%d\\n\",n%2==0 ? 2:1);\n\t\tsc.close();\n\t}\n\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        long n,m;\n        n = sc.nextLong();\n        m=2-(n%2);\n        System.out.println(m);\n    }\n    \n}\n// 1536799544273\n", "label": 0}
{"src": "import javafx.scene.shape.SVGPath;\nimport jdk.nashorn.internal.ir.WhileNode;\n\nimport java.util.Arrays;\nimport java.util.Scanner;\n\nimport static java.lang.Math.sqrt;\n\npublic class Main {\n\n    public static void main(String[] args) {\n\n        Scanner scanner = new Scanner(System.in);\n\n        long  a;\n        a= scanner.nextLong();\n        if(a%2==0){\n            System.out.println(\"2\");\n        }\n        else{\n            System.out.println(\"1\");\n        }\n\n\n\n\n\n       }\n}\n", "label": 0}
{"src": "import java.util.Scanner;\npublic class bullshit {\n  public static void main(String[] args) {\n    Scanner sc=new Scanner(System.in);\n    long l=sc.nextLong();\n    System.out.println(l%2==0?2:1);\n  }\n  // so hard much wow\n}", "label": 0}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\n/**\n * Created by peacefrog on 2/18/16.\n * 11:43 PM\n */\npublic class Task_R {\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tPrintWriter out;\n\tlong timeBegin, timeEnd;\n\n\tpublic void runIO() throws IOException {\n\t\ttimeBegin = System.currentTimeMillis();\n\n\t\tInputStream inputStream;\n\t\tOutputStream outputStream;\n\n\t\tif (ONLINE_JUDGE) {\n\t\t\tinputStream = System.in;\n\t\t\tReader.init(inputStream);\n\t\t\toutputStream = System.out;\n\n\t\t\tout = new PrintWriter(outputStream);\n\t\t} else {\n\t\t\tinputStream = new FileInputStream(\"/home/peacefrog/Dropbox/IdeaProjects/Problem Solving/input\");\n\t\t\tReader.init(inputStream);\n\t\t\tout = new PrintWriter(System.out);\n\t\t}\n\t\tsolve();\n\t\tout.flush();\n\t\tout.close();\n\t\ttimeEnd = System.currentTimeMillis();\n\t\tSystem.err.println(\"Time = \" + (timeEnd - timeBegin));\n\t}\n\n\t/*\n\t * Start Solution Here\n\t */\n\n\tprivate void solve() throws IOException {\n\t\tlong n = Reader.nextLong();\n\t\tif(n%2==1 )out.println(1);\n\t\telse out.println(2);\n\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Task_R().runIO();\n\t}\n\n\tstatic class Reader {\n\t\tstatic BufferedReader reader;\n\t\tstatic StringTokenizer tokenizer;\n\n\t\t/**\n\t\t * call this method to initialize reader for InputStream\n\t\t */\n\t\tstatic void init(InputStream input) {\n\t\t\treader = new BufferedReader(new InputStreamReader(input));\n\t\t\ttokenizer = new StringTokenizer(\"\");\n\t\t}\n\n\t\t/**\n\t\t * get next word\n\t\t */\n\t\tstatic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tstatic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn \"\";\n\t\t}\n\n\t\tstatic int nextChar() throws IOException {\n\t\t\treturn reader.read();\n\t\t}\n\n\t\tstatic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tstatic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tstatic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tstatic long[] nextLongArray(int n) throws IOException {\n\t\t\tlong[] arr = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLong();\n\t\t\t}\n\n\t\t\treturn arr;\n\t\t}\n\n\t\tstatic int[] nextIntArray(int n) throws IOException {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t}\n}", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.HashMap;\nimport java.util.Arrays;\n public class Primes{\n    \n    static class FastScanner{\n        BufferedReader s;\n        StringTokenizer st;\n        \n        \n        public FastScanner(){\n            st = new StringTokenizer(\"\");\n            s = new BufferedReader(new InputStreamReader(System.in));\n            \n        }\n        \n        public FastScanner(File f) throws FileNotFoundException{\n            st = new StringTokenizer(\"\");\n            s = new BufferedReader (new FileReader(f));\n        }\n        \n        public int nextInt() throws IOException{\n            if(st.hasMoreTokens())\n                return Integer.parseInt(st.nextToken());\n            else{\n                st = new StringTokenizer(s.readLine());\n                return nextInt();\n            }\n        }\n        \n        public double nextDouble() throws IOException{\n            if(st.hasMoreTokens())\n                return Double.parseDouble(st.nextToken());\n            else{\n                st = new StringTokenizer(s.readLine());\n                return nextDouble();\n            }\n        }\n        \n        public long nextLong() throws IOException{\n            if(st.hasMoreTokens())\n                return Long.parseLong(st.nextToken());\n            else{\n                st = new StringTokenizer(s.readLine());\n                return nextLong();\n            }\n        }\n        \n        public String nextString() throws IOException{\n            if(st.hasMoreTokens())\n                return st.nextToken();\n            else{\n                st = new StringTokenizer(s.readLine());\n                return nextString();\n            }\n            \n        }\n        \n        public String readLine() throws IOException{\n            return s.readLine();\n        }\n        \n        public void close() throws IOException{\n            s.close();\n        }\n        \n    }      //Fastscanner class end\n    \n   static FastScanner in=new FastScanner();\n   static PrintWriter ww=new PrintWriter(new OutputStreamWriter(System.out));\n   public static void main(String args[])throws IOException\n   {\n   //Main ob=new Main();\n   Primes ob=new Primes();\n   ob.solve();\n   ww.close();\n   }\n   \n   public void solve()throws IOException\n   {\n    long n =in.nextLong();\n    if(n%2!=0)\n          System.out.println(\"1\");\n    else\n         System.out.println(\"2\");\t\n   }\n }", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\tprivate static Scanner cin = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tlong n = cin.nextLong() ;\n\t\tSystem.out.println(2 - n % 2);\n\t}\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\n\npublic class Main {\n\n\n    public static void main(String[] args) {\n        System.out.println(new Scanner(System.in).nextLong()%2 == 0?2:1);\n            \n}\n            \n            \n        }\n// 1536805216026\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class Game {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner input = new Scanner(System.in);\n\t\tString s = input.next();\n\t\tint n = Integer.parseInt(String.valueOf(s.charAt(s.length()-1)));\n\t\tif(n % 2 == 0){\n\t\t\tSystem.out.println(2);\n\t\t}else{\n\t\t\tSystem.out.println(1);\n\t\t}\n\t}\n\n}\n", "label": 0}
{"src": "import java.io.*;\n\npublic class DomX{\n    \n    public static void main(String[] args) throws Exception{\n    \n        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));\n    \n        long n = Long.parseLong(read.readLine());\n        \n            System.out.println((n*n) % 2 == 0 ? 2 : 1);\n    }\n}", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class D {\npublic static void main(String[] args) {\n\tScanner sc=new Scanner(System.in);\n\tlong n=sc.nextLong();\nSystem.out.println(n%2==0?\"2\":\"1\");\n}\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\n/**\n * Created by mmaikovych on 18.02.16.\n */\npublic class ERR_R {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        long n = input.nextLong();\n        System.out.println(2 - n%2);\n    }\n}\n", "label": 0}
{"src": "/* package whatever; // don't place package name! */\n \nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n \n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class bbg\n{\n\tpublic static int result;\n \npublic static ArrayList<Integer> [] graph;\n \npublic static int[]cats;\n \npublic static int vizitat[];\npublic static int x;\n//public static HashMap<String, Integer> map2;\n \n \n\tpublic static void main (String[] args) throws java.lang.Exception\n{\n \nScanner input=new Scanner(System.in);\n \nHashMap<Integer, Integer> contor1= new HashMap<Integer, Integer>();\nHashMap<Integer, Integer> contor2= new HashMap<Integer, Integer>();\n\n\nHashMap<Integer, Integer> map= new HashMap<Integer, Integer>();\nHashMap<Integer, Integer> map2= new HashMap<Integer, Integer>();\nHashMap<String, Integer> combinari= new HashMap<String, Integer>();\n \n \n\t\t\n\t\t\n\t\t\n\t\tLong n=input.nextLong();\n\t\tif(n%2l==0l) System.out.println(2);\n\t\telse System.out.println(1);\n}\n\t\t\n\t\t\n\t\t\n\t\t}\n\t\t\n\t\t\n\t\t", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class R630 {\n    public static void main(String... xxx){\n        Scanner sc = new Scanner(System.in);\n        long n = sc.nextLong();\n        System.out.println((n%2 == 0) ? 2 : 1);\n    }\n}\n", "label": 0}
{"src": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\n/**\n *\n * @author esteban\n */\npublic class Competencia_D {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        \n    Scanner sc= new Scanner(System.in);\n    BigInteger A = sc.nextBigInteger();\n     BigInteger B = new BigInteger(\"2\");\n   BigInteger C= new BigInteger(\"0\");\n    if(A.mod(B).equals(C))\n            System.out.println(\"2\");\n    else\n            System.out.println(\"1\");\n    \n}\n    \n}\n", "label": 0}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskR solver = new TaskR();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskR {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            long n = in.readLong();\n            out.printLine(n % 2 == 0 ? 2 : 1);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "label": 0}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    public static void main(String[] args) throws IOException{\n        (new Main()).myCode();\n    }\n    public void myCode() throws IOException {\n        Input(\"\");\n        Output(\"\");\n        splitLine();\n        long n = getLong();\n        output.println(2 - (n & 1));\n        close();\n    }\n    /*=================================================================================================================*\n     * Data IO\n     */\n    BufferedReader input;\n    PrintWriter output;\n    StringTokenizer token;\n    public void Input (String name) throws IOException {\n        if (name != \"\"){\n            input = new BufferedReader(new FileReader(name));\n        } else {\n            input = new BufferedReader(new InputStreamReader(System.in));\n        }\n    }\n    public void Output (String name) throws IOException {\n        if (name != \"\"){\n            output = new PrintWriter(new BufferedWriter(new FileWriter(name)));\n        } else {\n            output = new PrintWriter(System.out);\n        }\n    }\n    public String getLine () throws IOException {\n        return input.readLine();\n    }\n    public void splitLine () throws IOException {\n        token = new StringTokenizer(getLine());\n    }\n    public long getLong () throws IOException {\n        return Long.parseLong(token.nextToken());\n    }\n    public int getInt () throws IOException {\n        return Integer.parseInt(token.nextToken());\n    }\n    public String getStr () throws IOException {\n        return token.nextToken();\n    }\n    public char getChar () throws IOException {\n        return token.nextToken().charAt(0);\n    }\n    public void close () throws IOException {\n        if (input != null) {\n            input.close();\n        }\n        if (output != null) {\n            output.close();\n        }\n    }\n    /*================================================================================================================*/\n}", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class Game {\n\n\tpublic static void main(String[] args) {\n\t\tScanner s=new Scanner(System.in);\n\t\tlong n=s.nextLong();\n\t\tif((2-(n%2))==1){\n\t\t\tSystem.out.println(\"1\");\n\t\t}\n\t\telse if((2-(n%2))==2){\n\t\t\tSystem.out.println(\"2\");\n\t\t}\n\t}\n}", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class R {\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader bf= new BufferedReader(new InputStreamReader(System.in));\n\t\tlong x= Long.parseLong(bf.readLine());\n\t\tif(x%2==1)\n\t\t\tSystem.out.println(\"1\");\n\t\telse\n\t\t\tSystem.out.println(\"2\");\n\t}\n\n}\n", "label": 0}
{"src": "\nimport java.util.Scanner;\n\n\n/**\n * Created by JUSTIN on 11/23/17.\n */\npublic class BeautifulNumber {\n    public static void main (String args[]){\n        Scanner s = new Scanner(System.in);\n        long meme = s.nextLong();\n        if (meme % 2 == 0) { //l\n            System.out.println(2);\n        }\n        else {\n            System.out.println(1);\n        }\n    }\n\n\n\n\n}\n\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tSystem.out.print(2-scan.nextLong()%2);\n\t\t\n\t}\n\n}\n", "label": 0}
{"src": "//package com.krakn.CF.R630;\n\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        long n = sc.nextLong();\n\n        if (n % 2 == 0) {\n            System.out.println(2);\n        } else {\n            System.out.println(1);\n        }\n    }\n}\n", "label": 0}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class CF630R{ \n  public static int index;\n  public static void main(String[] args)throws IOException, Exception {\n    InputReader in = new InputReader(System.in);\n    PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n    long n = in.nextLong();\n    \n    if( n % 2 == 0) pw.println(\"2\");\n    else pw.println(\"1\");\n    \n\n    \n    pw.close();\n  }\n  \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n    \n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n    \n    public String next() {\n  \n      try {\n        while (tokenizer == null || !tokenizer.hasMoreTokens())\n          tokenizer = new StringTokenizer(reader.readLine());\n      } catch (IOException e) {\n        return null;\n      }\n      \n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine() {\n      String line = null;\n      try {\n        tokenizer = null;\n        line =  reader.readLine();\n      } catch (IOException e) {\n        throw new RuntimeException(e);\n      }\n      return line;\n    }\n    \n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n    \n    public double nextDouble() {\n      return Double.parseDouble(next());\n    }\n    \n    public long nextLong() {\n      return Long.parseLong(next());\n    }\n    public boolean hasNext(){\n      try {\n        while (tokenizer == null || !tokenizer.hasMoreTokens())\n          tokenizer = new StringTokenizer(reader.readLine());\n      } \n      catch (Exception e) {\n        return false;\n      }\n     \n    return true; \n    \n    }\n  }\n}", "label": 0}
{"src": "/*\n * For the brave souls who get this far: You are the chosen ones,\n * the valiant knights of programming who toil away, without rest,\n * fixing our most awful code. To you, true saviors, kings of men,\n * I say this: never gonna give you up, never gonna let you down,\n * never gonna run around and desert you. Never gonna make you cry,\n * never gonna say goodbye. Never gonna tell a lie and hurt you.\n * \n * And Logic is the strongest weapon. \n *\n */\n//package Coding;\n\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class Coding {\n\n    private static InputStream stream;\n    private static byte[] buf = new byte[1024];\n    private static int curChar;\n    private static int numChars;\n    private static SpaceCharFilter filter;\n    private static PrintWriter pw;\n    private static int infi = (int) 1e9;\n    //private static final int N = 1234567;\n    //private static final double MOD = 1e9 + 7;\n    //Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n    public static int soln() {\n        long man = nL();\n        //khy...\n        pw.println(man % 2 == 0 ? 2 : 1);\n        return 0;\n    }\n\n    public static void main(String[] args) throws FileNotFoundException {\n        InputReader(System.in);\n        //pw = new PrintWriter(new FileOutputStream(\"ans.txt\"));\n        pw = new PrintWriter(System.out);\n        soln();\n        pw.close();\n    }\n\n    /*\n     *********************************************************************************************\n     */\n    public static void InputReader(InputStream stream1) {\n        stream = stream1;\n    }\n\n    private static boolean isWhitespace(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    private static boolean isEndOfLine(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n    private static int read() {\n        if (numChars == -1) {\n            throw new InputMismatchException();\n        }\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0) {\n                return -1;\n            }\n        }\n        return buf[curChar++];\n    }\n\n    private double nD() {\n        return Double.parseDouble(nS());\n    }\n\n    private static int nI() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9') {\n                throw new InputMismatchException();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    private static long nL() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            if (c < '0' || c > '9') {\n                throw new InputMismatchException();\n            }\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    private static String nS() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    private static String nLi() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndOfLine(c));\n        return res.toString();\n    }\n\n    private static boolean isSpaceChar(int c) {\n        if (filter != null) {\n            return filter.isSpaceChar(c);\n        }\n        return isWhitespace(c);\n    }\n\n    private interface SpaceCharFilter {\n\n        public boolean isSpaceChar(int ch);\n    }\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class R {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println(new Scanner(System.in).nextLong()%2 == 0?2:1);\n\t}\n\n}", "label": 0}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    static final String FILE = \"\";\n\n    public void solve() {\n        out.print((in.nextLong() - 1) % 2 + 1);\n    }\n\n    public void run() {\n        if (FILE.equals(\"\")) {\n            in = new FastScanner(System.in);\n            out = new PrintWriter(System.out);\n        } else {\n            try {\n                in = new FastScanner(new FileInputStream(FILE +\n                        \".in\"));\n                out = new PrintWriter(new FileOutputStream(FILE +\n                        \".out\"));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n        solve();\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        (new Main()).run();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public float nextFloat() {\n            return Float.parseFloat(next());\n        }\n    }\n\n    class Pair<A extends Comparable<A>, B extends Comparable<B>>\n            implements Comparable<Pair<A, B>> {\n        public A a;\n        public B b;\n\n        public Pair(A a, B b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Pair<A, B> o) {\n            if (o == null || o.getClass() != getClass())\n                return 1;\n            int cmp = a.compareTo(o.a);\n            if (cmp == 0)\n                return b.compareTo(o.b);\n            return cmp;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Pair<?, ?> pair = (Pair<?, ?>) o;\n\n            if (a != null ? !a.equals(pair.a) : pair.a != null) return\n                    false;\n            return !(b != null ? !b.equals(pair.b) : pair.b != null);\n        }\n    }\n\n    class PairInt extends Pair<Integer, Integer> {\n        public PairInt(Integer u, Integer v) {\n            super(u, v);\n        }\n    }\n\n    class PairLong extends Pair<Long, Long> {\n        public PairLong(Long u, Long v) {\n            super(u, v);\n        }\n    }\n\n}", "label": 0}
{"src": "import java.util.*;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        long n= in.nextLong();\n        System.out.println((long)2 - Math.floorMod(n,2));\n    }\n}", "label": 0}
{"src": "\nimport java.util.Scanner;\n\n/**\n *\n * @author Mohammad Hadi\n */\npublic class G630 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        long n = in.nextLong();\n        System.out.println(n % 2 == 1 ? 1 : 2);\n    }\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class Game {\n\n\tpublic static void main(String[] args) {\n\t\tSystem.out.println((new Scanner(System.in).nextLong() % 2 == 1)? \"1\":\"2\");\n\t}\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class water {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        long n = input.nextLong();\n        \n        if (n%2==0){\n            System.out.println(2);\n        }else {\n            System.out.println(1);\n        }\n    }\n}", "label": 0}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.awt.*;\nimport java.math.*;\n\npublic class R{\n\n\n\n\tpublic static void main(String[] args){\n\t\t//long t= System.currentTimeMillis();\n\t\tScanner in = new Scanner(System.in);\n\t\tlong n= in.nextLong(); //points\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tif(n==1)\n\t\t\tSystem.out.println(1);\n\t\telse\n\t\t\tSystem.out.println((n+1)%2 +1);\n\t\t\n\n\t\n\t\t//wetShark(list);\n\n\n\t\t//System.out.println(Arrays.toString(list));\n\t}\n}", "label": 0}
{"src": "import java.util.*;\npublic class CodeForces\n{\n    \n    public static void main(String[] args)\n\t{\n            \n            Scanner in = new Scanner(System.in);\n            long n = in.nextLong();\n            if(n%2 == 1) System.out.println(1);\n            else System.out.println(2);\n        }\n\n\n}", "label": 0}
{"src": "import java.util.*;\n\npublic class game2 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong n = sc.nextLong();\n\t\tSystem.out.println((n+1)%2+1);\n\n\t}\n\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class r {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tlong n = sc.nextLong();\n\t\tif (n%2==0) System.out.println(2);\n\t\telse System.out.println(1);\n\n\t}\n\n}\n", "label": 0}
{"src": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package tcpc.geometrie;\n\nimport java.math.BigInteger;\nimport java.util.Scanner;\n\n/**\n *\n * @author marouen\n */\npublic class Main {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        \n        Scanner sc = new Scanner(System.in);\n        \n        BigInteger n = sc.nextBigInteger();\n        \n        if (n.getLowestSetBit()==0)\n            System.out.println(\"1\");\n        else System.out.println(\"2\");\n        \n        \n    }\n    \n}\n", "label": 0}
{"src": "\timport java.io.BufferedReader;\n\timport java.io.IOException;\n\timport java.io.InputStreamReader;\n\timport java.util.ArrayList;\n\timport java.util.Arrays;\n\timport java.util.Collections;\n\timport java.util.Comparator;\n\timport java.util.HashMap;\n\timport java.util.HashSet;\n\timport java.util.LinkedList;\n\timport java.util.List;\n\timport java.util.Map;\n\timport java.util.PriorityQueue;\n\timport java.util.Queue;\n\timport java.util.Random;\n\timport java.util.Set;\n\timport java.util.Stack;\n\t\n\tpublic class test {\n\t\tpublic static void main(String[] args) throws InterruptedException {\n\t\t\t//new careercup().run();\n\t\t\t//new CC().run();\n\t\t\t//System.out.println(Integer.MAX_VALUE);\n\t\t\ttry{\n\t\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tlong n = Long.parseLong(br.readLine());\n\t\t\t\tint  r = (n%2 == 1) ? 1 : 2;\n\t\t\t\tSystem.out.println(r);\n\t\t\t}catch(IOException io){\n\t\t\t\tio.printStackTrace();\n\t\t\t}\n\t\t}\n\t\t\n\t\n\t}\n", "label": 0}
{"src": "import java.util.*;\nimport java.io.*;\npublic class codeforces\n{\n    public static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n        long n=sc.nextLong();\n        if(n%2==1)\n        System.out.println(1);\n        else\n        System.out.println(2);\n    }\n}", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class CF630R {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tString n = scan.next();\n\t\tint last = Integer.valueOf(n.charAt(n.length()-1));\n\t\tif (last*last % 2 == 0) System.out.println(2);\n\t\telse System.out.println(1);\n\t}\n}\n", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.Scanner;\n\npublic class justForFun {\n\n\tstatic long n;\n\tstatic Scanner sc=new Scanner(System.in);\n\tstatic StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n\tstatic PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tn = sc.nextLong();\n\t\tif(n%2==0){\n\t\t\tn=2;\n\t\t}else{\n\t\t\tn=1;\n\t\t}\n\t\tout.println(n);\n\t\tout.flush();\n\t}\n\n\tstatic int nextInt() throws IOException {\n\t\tin.nextToken();\n\t\treturn (int) in.nval;\n\t}\n\n\tstatic double nextDouble() throws IOException {\n\t\tin.nextToken();\n\t\treturn in.nval;\n\t}\n\n\tstatic long nextLong() throws IOException {\n\t\tin.nextToken();\n\t\treturn (long) in.nval;\n\t}\n\n}", "label": 0}
{"src": "import java.util.*;\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\twhile(input.hasNext()) {\n\t\t\tlong n = input.nextLong();\n\t\t\tif(n%2==1) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.out.println(2);\n\t\t\t}\n\t\t}\n\t}\n}\n", "label": 0}
{"src": "/*\n * The MIT License\n *\n * Copyright 2016 Mouad NACIRI <mouadnaciri1@gmail.com>.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.IOException;\nimport java.util.StringTokenizer;\n\n/**\n *\n * @author NACIRI Mouad <mouadnaciri1@gmail.com>\n * @version 1.5.1\n */\n\npublic class MainA {\n    /* VIP, DON'T TOUCH!! */\n    static StringTokenizer ST;\n    static BufferedReader IN;\n    static BufferedWriter OUT;\n    static {\n        IN = new BufferedReader(new InputStreamReader(System.in));\n        OUT = new BufferedWriter(new OutputStreamWriter(System.out));\n    }\n    \n    public static void main(String[] args) throws IOException {\n        ll();\n        char[] x = n().toCharArray();\n        int i = x[x.length - 1] - '0';\n        \n        if((i & 1) == 0) {\n            pl(\"2\");\n        } else {\n            pl(\"1\");\n        }\n        cAll();\n    }\n    \n    //IO stuff...\n    static void ll() throws IOException { ST = new StringTokenizer(nlnt()); }\n    static void ll(String del) throws IOException { ST = new StringTokenizer(nlnt(), del); }\n    static void ll(String s, String del) throws IOException { ST = new StringTokenizer(s, del); }\n    static void ll(String s, char c) throws IOException { ST = new StringTokenizer(s); }\n    \n    static int tlen() { return ST.countTokens(); }\n    static boolean hn() { return ST.hasMoreTokens(); }\n    static String n() throws IOException { return ST.nextToken(); }\n    static String nln() throws IOException {\n        String l;\n        while((l = IN.readLine()) != null && l.trim().length() == 0) {}\n        return l;\n    }\n    static String nlnt() throws IOException {\n        String l;\n        while((l = IN.readLine()) != null && (l = l.trim()).length() == 0) {}\n        return l;\n    }\n    static boolean nbl() throws IOException { return Boolean.parseBoolean(ST.nextToken()); }\n    static byte nb() throws IOException { return Byte.parseByte(ST.nextToken()); }\n    static byte nb(int radix) throws IOException { return Byte.parseByte(ST.nextToken(), radix); }\n    static double nd() throws IOException { return Double.parseDouble(ST.nextToken()); }\n    static float nf() throws IOException { return Float.parseFloat(ST.nextToken()); }\n    static int ni() throws IOException { return Integer.parseInt(ST.nextToken()); }\n    static int ni(int radix) throws IOException { return Integer.parseInt(ST.nextToken(), radix); }\n    static long nl() throws IOException { return Long.parseLong(ST.nextToken()); }\n    static long nl(int radix) throws IOException { return Long.parseLong(ST.nextToken(), radix); }\n    static short ns() throws IOException { return Short.parseShort(ST.nextToken()); }\n    static short ns(int radix) throws IOException { return Short.parseShort(ST.nextToken(), radix); }\n    \n    static void p(String s) throws IOException { OUT.write(s); }\n    static void p(char c) throws IOException { OUT.write(c); }\n    static void p(char s[]) throws IOException { OUT.write(s); }\n    static void pl(String s) throws IOException { OUT.write(s); OUT.newLine(); }\n    static void pl(char c) throws IOException { OUT.write(c); OUT.newLine(); }\n    static void pl(char s[]) throws IOException { OUT.write(s); OUT.newLine(); }\n    static void pl() throws IOException { OUT.newLine(); }\n    static void cAll() throws IOException { IN.close(); OUT.close(); }\n    \n}", "label": 0}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.BigInteger;\nimport java.util.Map.Entry;\n\nimport static java.lang.Math.*;\n\npublic class Solution extends PrintWriter {\n\n\tvoid run() {\n\t\tlong n = nextLong();\n\n\t\tprintln(2 - (n % 2));\n\n\t}\n\n\tlong lcm(long a, long b) {\n\t\treturn a / gcd(a, b) * b;\n\t}\n\n\tlong gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\n\tint[][] nextMatrix(int n, int m) {\n\t\tint[][] matrix = new int[n][m];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tfor (int j = 0; j < m; j++)\n\t\t\t\tmatrix[i][j] = nextInt();\n\t\treturn matrix;\n\t}\n\n\tString next() {\n\t\twhile (!tokenizer.hasMoreTokens())\n\t\t\ttokenizer = new StringTokenizer(nextLine());\n\t\treturn tokenizer.nextToken();\n\t}\n\n\tboolean hasNext() {\n\t\twhile (!tokenizer.hasMoreTokens()) {\n\t\t\tString line = nextLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\ttokenizer = new StringTokenizer(line);\n\t\t}\n\t\treturn true;\n\t}\n\n\tint[] nextArray(int n) {\n\t\tint[] array = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarray[i] = nextInt();\n\t\t}\n\t\treturn array;\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tString nextLine() {\n\t\ttry {\n\t\t\treturn reader.readLine();\n\t\t} catch (IOException err) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic Solution(OutputStream outputStream) {\n\t\tsuper(outputStream);\n\t}\n\n\tstatic BufferedReader reader;\n\tstatic StringTokenizer tokenizer = new StringTokenizer(\"\");\n\tstatic Random rnd = new Random();\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tSolution solution = new Solution(System.out);\n\t\treader = new BufferedReader(new InputStreamReader(System.in));\n\t\tsolution.run();\n\t\tsolution.close();\n\t\treader.close();\n\t}\n}", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class Igra {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner (System.in);\n\t\tlong n = in.nextLong();\n\t\tif(n % 2 == 0 ){\n\t\t\tSystem.out.println(\"2\"); \n\t\t\t}\n\t\telse{\n\t\t\tSystem.out.println(\"1\");\n\t\t}\n\t}\n}", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String args[]) {\n\t\tInputStream intputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(intputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskR solver = new TaskR();\n\t\tsolver.solve(in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskR {\n\t\tpublic void solve(InputReader in, PrintWriter out) {\n\t\t\tlong n = in.nextLong();\n\t\t\tif (n % 2 == 0) out.println(2);\n\t\t\telse out.println(1);\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}", "label": 0}
{"src": "\nimport java.util.Scanner;\npublic class Main {\n\n \n    public static void main(String[] args) {long n;\n      Scanner s =new Scanner(System.in);\n      n=s.nextLong();\n      if(n%2==0){\n          System.out.println(\"2\");\n      }else System.out.println(\"1\");\n    }\n    \n}", "label": 0}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------\n\npublic class a{ \n     static int[] count,count1,count2;\n     static Node[] nodes;\n     static long[] arr;\n     static int[] dp;\n     static char[] ch,ch1;\n     static long[] darr,farr;\n     static char[][] mat,mat1;\n     static boolean[][] vis;\n     static long x,h;\n     static long maxl;\n     static double dec;\n     static long mx = (long)1e10;\n     static String s;\n     static long minl;\n     static int start_row;\n     static int start_col;     \n     static int end_row;     \n     static int end_col;     \n     static long mod = 998244353;\n     // static int minl = -1;\n     // static long n;\n     static int n,n1,n2,q,r1,c1,r2,c2;\n     static long a;\n     static long b;\n     static long c;\n     static long d;\n     static long y,z;\n     static int m;\n     static long k;\n     static FastScanner sc;\n     static String[] str,str1;\n     static Set<Long> set,set1,set2;\n     static SortedSet<Long> ss;\n     static List<Integer> list,list1,list2,list3;\n     static PriorityQueue<Integer> pq,pq1;\n     static LinkedList<Node> ll;\n     static Map<Integer,List<Integer>> map;\n     static Map<Integer,Integer> map1;\n     static StringBuilder sb,sb1,sb2;\n     static int index;\n     static long ans;\n     static int[] dx = {0,-1,0,1,-1,1,-1,1};\n     static int[] dy = {-1,0,1,0,-1,-1,1,1};\n\n     // public static void solve(){\n\n     //    FastScanner sc = new FastScanner();\n     //    // int t = sc.nextInt();\n     //    int t = 1;\n     //    for(int tt = 0 ; tt < t ; tt++){\n     //        long n = sc.nextLong();\n     //        int m = sc.nextInt();\n     //        Set<Integer> rows = new HashSet<>();\n     //        Set<Integer> cols = new HashSet<>();\n\n     //        sb = new StringBuilder();\n     //        // map = new HashMap<>();\n     //        for(int i = 1 ; i <= m ; i++){\n     //            int l = sc.nextInt();\n     //            int r = sc.nextInt();\n     //            rows.add(l);\n     //            cols.add(r);\n     //            sb.append((n-rows.size()) * (n-cols.size()) +\" \");               \n     //        }\n\n     //        System.out.println(sb);\n     //    }\n        \n        \n     // }\n\n     //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<-------------------\n\n     public static void solve(){\n\n        if(a%2 == 0){\n            System.out.println(\"2\");\n        }\n        else\n            System.out.println(\"1\");\n        \n     }\n        \n     public static void main(String[] args) {\n\n            sc = new FastScanner();\n            // Scanner sc = new Scanner(System.in);\n            // int t = sc.nextInt();\n            int t = 1;\n            // int l = 1;\n            while(t > 0){\n                \n                // n = sc.nextInt();\n                // n = sc.nextLong();\n                // k = sc.nextLong();\n                a = sc.nextLong();\n                // b = sc.nextLong();\n                // c = sc.nextLong();\n                // d = sc.nextLong();\n\n                // x = sc.nextLong();\n                // y = sc.nextLong();\n                \n                // n = sc.nextLong();\n                // n = sc.nextInt();\n                // n1 = sc.nextInt();\n\n                // m = sc.nextInt();\n                // q = sc.nextInt();\n\n                // k = sc.nextLong();\n                // s = sc.next();\n\n                // ch = sc.next().toCharArray();\n                // ch1 = sc.next().toCharArray();\n\n                // arr = new long[n];\n                // for(int i = 0 ; i < n ; i++){\n                //     arr[i] = sc.nextLong();\n                // }\n                // x = sc.nextLong();\n                // y = sc.nextLong();\n                // ch = sc.next().toCharArray();\n                // m = n;\n                // darr = new long[n];\n                // for(int i = 0 ; i < n ; i++){\n                //     darr[i] = sc.nextLong();\n                // }\n\n                // farr = new int[n];\n                // for(int i = 0; i < n ; i++){\n                //     farr[i] = sc.nextInt();\n                // }\n\n                // mat = new int[n][n];\n                // for(int i = 0 ; i < n ; i++){\n                //     for(int j = 0 ;  j < n ; j++){\n                //         mat[i][j] = sc.nextInt();\n                //     }\n                // }\n\n                // m = n;\n                // mat = new char[n][m];\n                // for(int i = 0 ; i < n ; i++){\n                //     String s = sc.next();\n                //     for(int j = 0 ; j < m ; j++){\n                //         mat[i][j] = s.charAt(j);\n                //     }\n                // }\n\n                // str = new String[n];\n                // for(int i = 0 ; i < n ; i++)\n                //     str[i] = sc.next();\n\n                // nodes = new Node[n];\n                // for(int i = 0 ; i < n ;i++)\n                //     nodes[i] = new Node(sc.nextInt(),sc.nextInt());\n\n                // System.out.println(solve()?\"YES\":\"NO\");\n                 solve();       \n                 // System.out.println(solve());\n                 t -= 1;\n            }\n\n     }\n\n     // public static dfs(int i){\n\n     //    if(count[i] == 1)\n     //        return;\n     //    list = map.get(i);\n     //    for(Integer j : list){\n     //        if(j == i)\n     //            continue;\n     //        dfs(j);\n     //    }\n     // }\n\n    public static int log(long n,long base){\n\n         if(n == 0 || n == 1)\n             return 0;\n\n         if(n == base)\n             return 1;\n\n         double num = Math.log(n);\n         double den = Math.log(base);\n\n         if(den == 0)\n             return 0;\n\n         return (int)(num/den);\n     }\n\n    public static boolean isPrime(long n) { \n    // Corner cases \n        if (n <= 1)  \n            return false; \n\n        if (n <= 3)  \n            return true; \n      \n        // This is checked so that we can skip  \n        // middle five numbers in below loop \n        if (n%2 == 0 || n%3 == 0) \n            return false; \n      \n        for (int i=5; i*i<=n; i=i+6) \n            if (n%i == 0 || n%(i+2) == 0) \n               return false; \n      \n        return true; \n    } \n\n     public static long gcd(long a,long b){\n\n        if(b%a == 0){\n            return a;\n        }\n        return gcd(b%a,a);\n\n     }\n\n     public static void swap(int i,int j){\n         char temp = ch[j];\n         ch[j] = ch[i];\n         ch[i] = temp;\n     } \n\n    static final Random random=new Random();\n    \n    static void ruffleSort(long[] a) {\n        int n=a.length;//shuffle, then sort \n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            long temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static class Node{\n        Integer first;\n        Integer second;\n        Node(Integer f,Integer s){\n            this.first = f;\n            this.second = s;\n        }\n    }\n\n     static class FastScanner {\n\n                BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n                StringTokenizer st=new StringTokenizer(\"\");\n                String next() {\n                        while (!st.hasMoreTokens())\n                                try {\n                                        st=new StringTokenizer(br.readLine());\n                                } catch (IOException e) {\n                                        e.printStackTrace();\n                                }\n                        return st.nextToken();\n                }\n                \n                int nextInt() {\n                        return Integer.parseInt(next());\n                }\n                int[] readArray(int n) {\n                        int[] a=new int[n];\n                        for (int i=0; i<n; i++) a[i]=nextInt();\n                        return a;\n                }\n                long nextLong() {\n                        return Long.parseLong(next());\n                }\n        }\n\n}", "label": 0}
{"src": "import java.util.*;\npublic class Tests {\n\n\tpublic static void main(String[] args) {\n\tScanner in = new Scanner (System.in);\n\tlong n = in.nextLong();\n\tif(n%2 == 0 ){\n\t\tSystem.out.println(\"2\"); }\n\telse{\n\t\tSystem.out.println(\"1\");\n\t}\n\t}\n}", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\nScanner sc=new Scanner(System.in);\nlong d=sc.nextLong();\nif (d%2==0)\n\tSystem.out.print(2);\nelse\n\tSystem.out.print(1);\n\t}\n\n}\n", "label": 0}
{"src": "import java.util.*;\nimport java.math.*;\n\npublic class Task630R {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        BigInteger n = new BigInteger(s.next());\n        System.out.println( n.mod(new BigInteger(\"2\")).intValue() != 0 ? \"1\" : \"2\");\n    }\n}\n\n", "label": 0}
{"src": "import java.util.*;\npublic class Game\n{\npublic static void main(String[] args)\n{\nScanner sc = new Scanner(System.in);\nlong n = sc.nextLong();\nif(n % 2 == 0)\n{\n    System.out.println(2);\n}\nelse\n{\n    System.out.println(1);\n}\n}\n}", "label": 0}
{"src": "import java.util.Scanner;\n\n/**\n * Created by raiym on 2/18/16.\n */\npublic class G {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String n = sc.next();\n        int m = Integer.parseInt(n.charAt(n.length() - 1) + \"\");\n        if (m % 2 == 1) {\n            System.out.println(1);\n        } else {\n            System.out.println(2);\n        }\n\n    }\n}\n", "label": 0}
{"src": "import java.util.*;\npublic class game {\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tlong x=sc.nextLong();\n\t\tif(x%2==0)\n\t\t{\n\t\t\tSystem.out.println(\"2\");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.println(\"1\");\n\t\t}\n\t}\n}\n", "label": 0}
{"src": "/**\n * @(#)Game.java\n *\n *\n * @author\n * @version 1.00 2016/8/24\n */\nimport java.util.*;\npublic class Game {\n    public static void main(String[] args) {\n    \tScanner kbd = new Scanner(System.in);\n    \tlong n = kbd.nextLong();\n    \t\tif(n%2==0){\n    \t\t\tint x=2;\n    \t\t\tSystem.out.println(x);\n    \t\t}\n    \t\telse{\n    \t\t\tint x=1;\n    \t\t\tSystem.out.println(x);\n    \t}\n    }\n}\n", "label": 0}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.text.*;\n\npublic class Main{\n    //SOLUTION BEGIN\n    //Into the Hardware Mode\n    void pre() throws Exception{}\n    void solve(int TC) throws Exception{\n\n        int N = ni(), K = ni();\n        int[] A = new int[2+N], B = new int[2+K];\n        for(int i = 1; i<= N; i++)A[i] = ni();\n        for(int i = 1; i<= K; i++)B[i] = ni();\n        A[0] = -((int)1e9+N+1);\n        A[N+1] = ((int)1e9+N+1);\n        B[0] = 0;\n        B[K+1] = N+1;\n        Arrays.sort(B);\n        boolean good = true;\n        for(int i = 1; i<= K+1; i++)\n            good &= A[B[i]]-A[B[i-1]]-1 >= B[i]-B[i-1]-1;\n        if(good){\n            int ans = 0;\n            for(int i = 1; i<= K+1; i++)ans += B[i]-B[i-1]+1 - lis(A, B[i-1], B[i]);\n            pn(ans);\n        }else pn(-1);\n    }\n    int lis(int[] A, int l, int r){\n        for(int i = l; i<= r; i++)A[i] -= i;\n        ConvexSet set = new ConvexSet();\n        int max = 0;\n        for(int i = l; i <= r; i++){\n            Long key = set.floorKey(A[i]);\n            long length = 1;\n            if(key != null)length = 1+set.get(key);\n            else if(i > l)continue;\n            set.put(A[i], length);\n            max = Math.max(max, (int)length);\n        }\n        int ans = (int)((long)set.get(A[r]));\n        for(int i = l; i<= r; i++)A[i] += i;\n        return ans;\n    }\n    class ConvexSet{\n        TreeMap<Long, Long> map;\n        public ConvexSet(){\n            map = new TreeMap<>();\n        }\n        void put(long key, long val){\n            Map.Entry<Long, Long> e;\n            if((e = map.floorEntry(key))!=null && e.getValue()>=val)return;\n            while(!map.isEmpty() && (e=  map.ceilingEntry(key))!=null && e.getValue()<=val)map.remove(e.getKey());\n            map.put(key, val);\n        }\n        Long get(long k){return map.get(k);}\n        Long floorKey(long k){return map.floorKey(k);}\n    }\n    //SOLUTION END\n    void hold(boolean b)throws Exception{if(!b)throw new Exception(\"Hold right there, Sparky!\");}\n    void exit(boolean b){if(!b)System.exit(0);}\n    static void dbg(Object... o){System.err.println(Arrays.deepToString(o));}\n    final long IINF = (long)1e17;\n    final int INF = (int)1e9+2;\n    DecimalFormat df = new DecimalFormat(\"0.00000000000\");\n    double PI = 3.141592653589793238462643383279502884197169399, eps = 1e-8;\n    static boolean multipleTC = false, memory = false, fileIO = false;\n    FastReader in;PrintWriter out;\n    void run() throws Exception{\n        long ct = System.currentTimeMillis();\n        if (fileIO) {\n            in = new FastReader(\"\");\n            out = new PrintWriter(\"\");\n        } else {\n            in = new FastReader();\n            out = new PrintWriter(System.out);\n        }\n        //Solution Credits: Taranpreet Singh\n        int T = multipleTC? ni():1;\n        pre();\n        for (int t = 1; t <= T; t++) solve(t);\n        out.flush();\n        out.close();\n        System.err.println(System.currentTimeMillis() - ct);\n    }\n    public static void main(String[] args) throws Exception{\n        if(memory)new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();System.exit(1);}}}, \"1\", 1 << 28).start();\n        else new Main().run();\n    }\n    int[][] make(int n, int e, int[] from, int[] to, boolean f){\n        int[][] g = new int[n][];int[]cnt = new int[n];\n        for(int i = 0; i< e; i++){\n            cnt[from[i]]++;\n            if(f)cnt[to[i]]++;\n        }\n        for(int i = 0; i< n; i++)g[i] = new int[cnt[i]];\n        for(int i = 0; i< e; i++){\n            g[from[i]][--cnt[from[i]]] = to[i];\n            if(f)g[to[i]][--cnt[to[i]]] = from[i];\n        }\n        return g;\n    }\n    int[][][] makeS(int n, int e, int[] from, int[] to, boolean f){\n        int[][][] g = new int[n][][];int[]cnt = new int[n];\n        for(int i = 0; i< e; i++){\n            cnt[from[i]]++;\n            if(f)cnt[to[i]]++;\n        }\n        for(int i = 0; i< n; i++)g[i] = new int[cnt[i]][];\n        for(int i = 0; i< e; i++){\n            g[from[i]][--cnt[from[i]]] = new int[]{to[i], i, 0};\n            if(f)g[to[i]][--cnt[to[i]]] = new int[]{from[i], i, 1};\n        }\n        return g;\n    }\n    int find(int[] set, int u){return set[u] = (set[u] == u?u:find(set, set[u]));}\n    int digit(long s){int ans = 0;while(s>0){s/=10;ans++;}return ans;}\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}\n    void p(Object... o){for(Object oo:o)out.print(oo+\" \");}\n    void pn(Object... o){for(Object oo:o)out.print(oo+\" \");out.println();}\n    void pni(Object... o){for(Object oo:o)out.print(oo+\" \");out.println();out.flush();}\n    String n()throws Exception{return in.next();}\n    String nln()throws Exception{return in.nextLine();}\n    int ni()throws Exception{return Integer.parseInt(in.next());}\n    long nl()throws Exception{return Long.parseLong(in.next());}\n    double nd()throws Exception{return Double.parseDouble(in.next());}\n\n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        String next() throws Exception{\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    throw new Exception(e.toString());\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() throws Exception{\n            String str;\n            try{\n                str = br.readLine();\n            }catch (IOException e){\n                throw new Exception(e.toString());\n            }\n            return str;\n        }\n    }\n}\n", "label": 3}
{"src": "// Main Code at the Bottom\nimport java.util.*;\nimport java.io.*; \npublic class Main{\n\t//Fast IO class\n    static class FastReader {\n        BufferedReader br; \n        StringTokenizer st; \n        public FastReader() {\n        \tboolean env=System.getProperty(\"ONLINE_JUDGE\") != null;\n        \tif(!env) {\n        \t\ttry {\n\t\t\t\t\tbr=new BufferedReader(new FileReader(\"src\\\\input.txt\"));\n\t\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n        \t}\n        \telse br = new BufferedReader(new InputStreamReader(System.in)); \n        } \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) {\n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n        int nextInt() {\n            return Integer.parseInt(next()); \n        } \n        long nextLong() {\n            return Long.parseLong(next()); \n        } \n        double nextDouble() {\n            return Double.parseDouble(next()); \n        } \n        String nextLine() {\n            String str = \"\"; \n            try {\n                str = br.readLine(); \n            } \n            catch (IOException e) {\n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }     \n    static long MOD=1000000000+7;\n    //debug\n    static void debug(Object... o) {\n        System.out.println(Arrays.deepToString(o));\n    }\n    // Pair\n    static class pair{\n    \tlong x,y;\n    \tpair(long a,long b){\n    \t\tthis.x=a;\n    \t\tthis.y=b;\n    \t}\n    \tpublic boolean equals(Object obj) {\n    \t\tif(obj == null || obj.getClass()!= this.getClass()) return false;\n            pair p = (pair) obj;\n            return (this.x==p.x && this.y==p.y);\n        }\n    \tpublic int hashCode() {\n            return Objects.hash(x,y);\n        }\n    }\n    static FastReader sc=new FastReader();\n    static PrintWriter out=new PrintWriter(System.out);  \n    //Global variables and functions\n    static int n,k,a[],inf=Integer.MAX_VALUE;\n    static int solve(int l,int r) {\n    \tint res=0,extra=0;\n    \tint min=-1,max=-1;\n    \tif(l==-1) {\n    \t\textra++;\n    \t\tl++;\n    \t\tmin=-inf/2;\n    \t}\n    \telse min=a[l]-l;\n    \tif(r>=n) {\n    \t\textra++;\n    \t\tr--;\n    \t\tmax=inf/2;\n    \t}\n    \telse max=a[r]-r;\n    \tArrayList<Integer> tmp=new ArrayList<>();\n    \tfor(int i=l;i<=r;i++) {\n    \t\tif(a[i]-i>=min && a[i]-i<=max) tmp.add(a[i]-i);\n    \t}\n    \tint lis=findLIS(tmp);\n    \tif(extra>=1) lis+=extra;\n    \treturn lis;\n    }\n    static int findLIS(ArrayList<Integer> arr) {\n    \tint n=arr.size(),ans=1;\n    \tint dp[]=new int[n+1];\n    \tArrays.fill(dp, inf);\n    \tdp[0]=-inf;\n    \tfor(int i=0;i<n;i++) {\n    \t\tint l=0,r=n,idx=-1;\n    \t\twhile(l<=r) {\n    \t\t\tint mid=l+(r-l)/2;\n    \t\t\tif(dp[mid]<=arr.get(i)) {\n    \t\t\t\tidx=mid;\n    \t\t\t\tl=mid+1;\n    \t\t\t}\n    \t\t\telse r=mid-1;\n    \t\t}\n    \t\tdp[idx+1]=Math.min(dp[idx+1], arr.get(i));\n    \t\tans=Math.max(ans, idx+1);\n    \t}\n    \treturn ans;\n    }\n    //Main function(The main code starts from here)\n    public static void main (String[] args) throws java.lang.Exception {\n    \tint test=1;\n    \t//test=sc.nextInt();\n    \twhile(test-->0) { \n    \t\tn=sc.nextInt();k=sc.nextInt();\n    \t\ta=new int[n];\n    \t\tfor(int i=0;i<n;i++) a[i]=sc.nextInt();\n    \t\tint prev=-1,ok=1,ans=0;\n    \t\tfor(int i=0;i<k;i++) {\n    \t\t\tint cur=sc.nextInt()-1;\n    \t\t\tint val=solve(prev,cur);\n    \t\t\tif(val<2) {\n    \t\t\t\tok=0;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t\tans+=(cur-prev+1)-val;\n    \t\t\tprev=cur;\n    \t\t}\n    \t\tans+=(n-prev+1)-solve(prev,n);\n    \t\tout.println(ok==1?ans:-1);\n    \t}\t\n        out.flush();\n        out.close();\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class MarketingScheme {\n    public static void main(String[] args) throws IOException {\n        // InputStream inputStream = new FileInputStream(\"input.txt\");\n        // OutputStream outputStream = new FileOutputStream(\"output.txt\");\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    static class TaskA {\n        long mod = (long)(1000000007);\n        long fact[];\n        int depth[];\n        int parentTable[][];\n        int degree[];\n        ArrayList<Integer> leaves;\n        int max = Integer.MIN_VALUE;\n        int min = Integer.MAX_VALUE;\n        int diam = 0;\n\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) throws IOException {\n            while(testNumber-->0){\n                int n = in.nextInt();\n                int k = in.nextInt();\n                int a[] = new int[n];\n                int b[] = new int[k];\n                for(int i=0;i<n;i++)\n                    a[i] = in.nextInt();\n                for(int i=0;i<k;i++)\n                    b[i] = in.nextInt();\n\n                // int start = Integer.MIN_VALUE;\n                // int end = Integer.MAX_VALUE;\n\n                boolean possible = true;\n\n                int ans = 0;\n                for(int i=0;i<=k;i++){\n                    int start = Integer.MIN_VALUE;\n                    int end = Integer.MAX_VALUE;\n\n                    int sPos = -1;\n                    int ePos = n;\n\n                    if(i > 0){\n                        start = a[b[i-1]-1];\n                        sPos = b[i-1]-1;\n                    }\n                    if(i != k){\n                        end = a[b[i]-1];\n                        ePos = b[i]-1;\n                    }\n\n                    // System.out.println(start + \" \" + end + \" \" + sPos + \" \" + ePos);\n\n                    if((long)end-(long)start >= (long)ePos-sPos);\n                    else\n                        possible = false;\n                    \n                    if(!possible)\n                        break;\n                    ans += find(a , start , end , sPos , ePos);\n\n                }\n                if(!possible)\n                    out.println(-1);\n                else\n                    out.println(ans);\n            }\n        }\n\n        public int find(int a[] , int min , int max , int sPos , int ePos){\n            ArrayList<Integer> x = new ArrayList<>();\n            // boolean possible = true;\n            for(int i=sPos+1;i<ePos;i++){\n                if((min + (i-sPos) <= a[i]) && (a[i]+(ePos-i) <= max)){\n                    x.add(a[i] - (i-sPos));\n                }\n            }\n            // System.out.println(x);\n            int lis = lengthOfLIS(x);\n            return ePos-sPos-1 - lis;\n\n        }\n\n        public int lengthOfLIS(ArrayList<Integer> nums) {\n            ArrayList<Integer> ans = new ArrayList<>();\n            for(int i=0;i<nums.size();i++){\n                int x = nums.get(i);\n                int pos = lower(ans , x+1);\n                if(pos == ans.size())\n                    ans.add(x);\n                else\n                    ans.set(pos , x);\n                // System.out.println(ans);\n            }\n            return ans.size();\n        }\n        \n        public int lower(ArrayList<Integer> a , int x){\n            if(a.size() == 0)\n                return 0;\n            if(a.get(a.size()-1) < x)\n                return a.size();\n            int l = 0;\n            int r = a.size()-1;\n            while(l<=r){\n                int mid = (l+r)>>1;\n                if(a.get(mid)>=x && (mid<1 || a.get(mid-1)<x))\n                    return mid;\n                else if(a.get(mid) < x)\n                    l = mid+1;\n                else\n                    r = mid-1;\n            }\n            return -1;\n        }\n\n        public Node left(Node x){\n            if(x == null || x.empty)\n                return x;\n            Node y = left(x.left);\n            x.left = y;\n            return y;\n        }\n\n        public Node right(Node x){\n            if(x == null || x.empty)\n                return x;\n            Node y = right(x.right);\n            x.right = y;\n            return y;\n        }\n\n        class Node{\n            int val;\n            Node left;\n            Node right;\n            boolean empty;\n            public Node(int val){\n                this.val = val;\n                left = null;\n                right = null;\n                empty = true;\n            }\n        }\n\n        public Node add(int a[] , int start , int end){\n            if(start>end)\n                return null;\n            int mid = (start+end)>>1;\n            Node root = new Node(a[mid]);\n            root.left = add(a , start , mid-1);\n            root.right = add(a ,mid+1 , end);\n            return root;\n        }\n\n        public void dfs(ArrayList<ArrayList<int[]>> a , int index , int parent , int val , int visited[]){\n            if(index == a.size()-1){\n                max = Math.max(max , val);\n                return;\n            }\n            visited[index] = 1;\n            for(int i=0;i<a.get(index).size();i++){\n                int u = index;\n                int v = a.get(index).get(i)[0];\n                int speed = a.get(index).get(i)[1];\n                if(visited[v] == 1){\n                    if(v == a.size()-1){\n                        max = Math.max(max , Math.min(speed , val));\n                    }\n                    continue;\n                }\n                dfs(a , v , u , Math.min(val , speed) , visited);\n            }\n        }\n\n        class Pair{\n            int u;\n            int v;\n            int speed;\n            public Pair(int u , int v , int speed){\n                this.u = u;\n                this.v = v;\n                this.speed = speed;\n            }\n        }\n\n        public void add(HashMap<Integer , ArrayList<Integer>> m , int x , int y){\n            if(!m.containsKey(x))\n                m.put(x , new ArrayList<>());\n            ArrayList<Integer> a = m.get(x);\n            a.add(y);\n        }\n\n        public void dfs(ArrayList<ArrayList<Integer>> a , int index , int parent , int size[]){\n            size[index] = 1;\n            depth[index] = 1+depth[parent];\n            for(int i=0;i<a.get(index).size();i++){\n                if(a.get(index).get(i) == parent)\n                    continue;\n                dfs(a , a.get(index).get(i) , index , size);\n                size[index] += size[a.get(index).get(i)];\n            }\n        }\n\n        public int distance(ArrayList<ArrayList<Integer>> a , int u , int v){\n            return depth[u]+depth[v] - 2*depth[lca(a , u , v)];\n        }\n\n        public int lca(ArrayList<ArrayList<Integer>> a , int u , int v){\n            if(depth[v]<depth[u]){\n                int x = u;\n                u = v;\n                v = x;\n            }\n            int diff = depth[v] - depth[u];\n            for(int i=0;i<parentTable[v].length;i++){\n                // checking whether the ith bit is set in the diff variable\n                if(((diff>>i)&1) == 1)\n                    v = parentTable[v][i];\n            }\n            if(v == u)\n                return v;\n            for(int i=parentTable[v].length-1;i>=0;i--){\n                if(parentTable[u][i] != parentTable[v][i]){\n                    v = parentTable[v][i];\n                    u = parentTable[u][i];\n                }\n            }\n            return parentTable[u][0];\n        }\n        \n\n        public int[][] multiply(int a[][] , int b[][]){\n            int c[][] = new int[a.length][b[0].length];\n            for(int i=0;i<a.length;i++){\n                for(int j=0;j<b[0].length;j++){\n                    for(int k=0;k<b.length;k++)\n                        c[i][j] += a[i][k]*b[k][j];\n                }\n            }\n            return c;\n        }\n\n        public int[][] multiply(int a[][] , int b[][] , int mod){\n            int c[][] = new int[a.length][b[0].length];\n            for(int i=0;i<a.length;i++){\n                for(int j=0;j<b[0].length;j++){\n                    for(int k=0;k<b.length;k++){\n                        c[i][j] += a[i][k]*b[k][j];\n                        c[i][j]%=mod;\n                    }\n                }\n            }\n            return c;\n        }\n\n        public int[][] pow(int a[][] , long b){\n            int res[][] = new int[a.length][a[0].length];\n            for(int i=0;i<a.length;i++)\n                res[i][i] = 1;\n            while(b>0){\n                if((b&1) == 1)\n                    res = multiply(res , a , 10);\n                a = multiply(a , a , 10);\n                b>>=1;\n            }\n            return res;\n        }\n\n        \n\n        // for the min max problems\n        public void build(int lookup[][] , int arr[], int n) { \n            for (int i = 0; i < n; i++) \n                lookup[i][0] = arr[i]; \n            for (int j = 1; (1 << j) <= n; j++) { \n                for (int i = 0; (i + (1 << j) - 1) < n; i++) { \n                    if (lookup[i][j - 1] > lookup[i + (1 << (j - 1))][j - 1]) \n                        lookup[i][j] = lookup[i][j - 1]; \n                    else\n                        lookup[i][j] = lookup[i + (1 << (j - 1))][j - 1]; \n                } \n            } \n        }\n        public int query(int lookup[][] , int L, int R) { \n            int j = (int)(Math.log(R - L + 1)/Math.log(2)); \n            if (lookup[L][j] >= lookup[R - (1 << j) + 1][j]) \n                return lookup[L][j]; \n            else\n                return lookup[R - (1 << j) + 1][j]; \n        }\n\n        // for printing purposes\n        public void print1d(int a[] , PrintWriter out){\n            for(int i=0;i<a.length;i++)\n                out.print(a[i] + \" \");\n            out.println();\n        }\n        public void print1d(long a[] , PrintWriter out){\n            for(int i=0;i<a.length;i++)\n                out.print(a[i] + \" \");\n            out.println();\n        }\n        public void print2d(int a[][] , PrintWriter out){\n            for(int i=0;i<a.length;i++){\n                for(int j=0;j<a[i].length;j++)\n                    out.print(a[i][j] + \" \");\n                out.println();\n            }\n            // out.println();\n        }\n        public void print2d(long a[][] , PrintWriter out){\n            for(int i=0;i<a.length;i++){\n                for(int j=0;j<a[i].length;j++)\n                    out.print(a[i][j] + \" \");\n                out.println();\n            }\n            // out.println();\n        }\n\n\n        public void sieve(int a[]){\n            a[0] = a[1] = 1;\n            int i;\n            for(i=2;i*i<=a.length;i++){\n                if(a[i] != 0)\n                    continue;\n                a[i] = i;\n                for(int k = (i)*(i);k<a.length;k+=i){\n                    if(a[k] != 0)\n                        continue;\n                    a[k] = i;\n                }\n            }\n        }\n\n        public long nCrPFermet(int n , int r , long p){\n            if(r==0)\n                return 1l;\n            // long fact[] = new long[n+1];\n            // fact[0] = 1;\n            // for(int i=1;i<=n;i++)\n            //     fact[i] = (i*fact[i-1])%p;\n            long modInverseR = pow(fact[r] , p-2 , p);\n            long modInverseNR = pow(fact[n-r] , p-2 , p);\n            long w = (((fact[n]*modInverseR)%p)*modInverseNR)%p;\n            return w;\n        }\n        public long pow(long a, long b, long m) {\n            a %= m;\n            long res = 1;\n            while (b > 0) {\n                long x = b&1;\n                if (x == 1)\n                    res = res * a % m;\n                a = a * a % m;\n                b >>= 1;\n            }\n            return res;\n        }\n        public long pow(long a, long b) {\n            long res = 1;\n            while (b > 0) {\n                long x = b&1;\n                if (x == 1)\n                    res = res * a;\n                a = a * a;\n                b >>= 1;\n            }\n            return res;\n        }\n        public void sortedArrayToBST(TreeSet<Integer> a , int start, int end) { \n            if (start > end) {\n                return;\n            }\n            int mid = (start + end) / 2;\n            a.add(mid);\n            sortedArrayToBST(a, start, mid - 1);\n            sortedArrayToBST(a, mid + 1, end); \n        }\n        class Combine{\n            int value;\n            int delete;\n            Combine(int val , int delete){\n                this.value = val;\n                this.delete = delete;\n            }\n        }\n        class Sort2 implements Comparator<Combine>{\n            public int compare(Combine a , Combine b){\n                if(a.value > b.value)\n                    return 1;\n                else if(a.value == b.value && a.delete>b.delete)\n                    return 1;\n                else if(a.value == b.value && a.delete == b.delete)\n                    return 0;\n                return -1;\n            }\n        }\n        public int lowerLastBound(ArrayList<Integer> a , int x){\n            int l = 0;\n            int r = a.size()-1;\n            if(a.get(l)>=x)\n                return -1;\n            if(a.get(r)<x)\n                return r;\n            int mid = -1;\n            while(l<=r){\n                mid = (l+r)/2;\n                if(a.get(mid) == x && a.get(mid-1)<x)\n                    return mid-1;\n                else if(a.get(mid)>=x)\n                    r = mid-1;\n                else if(a.get(mid)<x && a.get(mid+1)>=x)\n                    return mid;\n                else if(a.get(mid)<x && a.get(mid+1)<x)\n                    l = mid+1;\n            }\n            return mid;\n        }\n        public int upperFirstBound(ArrayList<Integer> a , int x){\n            int l = 0;\n            int r = a.size()-1;\n            if(a.get(l)>x)\n                return l;\n            if(a.get(r)<=x)\n                return r+1;\n            int mid = -1;\n            while(l<=r){\n                mid = (l+r)/2;\n                if(a.get(mid) == x && a.get(mid+1)>x)\n                    return mid+1;\n                else if(a.get(mid)<=x)\n                    l = mid+1;\n                else if(a.get(mid)>x && a.get(mid-1)<=x)\n                    return mid;\n                else if(a.get(mid)>x && a.get(mid-1)>x)\n                    r = mid-1;\n            }\n            return mid;\n        }\n        public int lowerLastBound(long a[] , long x){\n            int l = 0;\n            int r = a.length-1;\n            if(a[l]>=x)\n                return -1;\n            if(a[r]<x)\n                return r;\n            int mid = -1;\n            while(l<=r){\n                mid = (l+r)/2;\n                if(a[mid] == x && a[mid-1]<x)\n                    return mid-1;\n                else if(a[mid]>=x)\n                    r = mid-1;\n                else if(a[mid]<x && a[mid+1]>=x)\n                    return mid;\n                else if(a[mid]<x && a[mid+1]<x)\n                    l = mid+1;\n            }\n            return mid;\n        }\n        public int upperFirstBound(long a[] , long x){\n            int l = 0;\n            int r = a.length-1;\n            if(a[l]>x)\n                return l;\n            if(a[r]<=x)\n                return r+1;\n            int mid = -1;\n            while(l<=r){\n                mid = (l+r)/2;\n                if(a[mid] == x && a[mid+1]>x)\n                    return mid+1;\n                else if(a[mid]<=x)\n                    l = mid+1;\n                else if(a[mid]>x && a[mid-1]<=x)\n                    return mid;\n                else if(a[mid]>x && a[mid-1]>x)\n                    r = mid-1;\n            }\n            return mid;\n        }\n        public long log(float number , int base){\n            return (long) Math.ceil((Math.log(number) / Math.log(base)) + 1e-9);\n        }\n        public long gcd(long a , long b){\n            if(a<b){\n                long c = b;\n                b = a;\n                a = c;\n            }\n            while(b!=0){\n                long c = a;\n                a = b;\n                b = c%a;\n            }\n            return a;\n        }\n        public long[] gcdEx(long p, long q) {\n            if (q == 0)\n                return new long[] { p, 1, 0 };\n            long[] vals = gcdEx(q, p % q);\n            long d = vals[0];\n            long a = vals[2];\n            long b = vals[1] - (p / q) * vals[2];\n            // 0->gcd 1->xValue 2->yValue\n            return new long[] { d, a, b };\n        }\n        public void sievePhi(int a[]){\n            a[0] = 0;\n            a[1] = 1;\n            for(int i=2;i<a.length;i++)\n                a[i] = i-1;\n            for(int i=2;i<a.length;i++)\n                for(int j = 2*i;j<a.length;j+=i)\n                    a[j] -= a[i];\n        }\n        public void lcmSum(long a[]){\n            int sievePhi[] = new int[(int)1e6 + 1];\n            sievePhi(sievePhi);\n            a[0] = 0;\n            for(int i=1;i<a.length;i++)\n                for(int j = i;j<a.length;j+=i)\n                    a[j] += (long)i*sievePhi[i];\n        }\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\npublic class MainClass\n{\n    static BIT BIT;\n    public static void main(String[] args)throws IOException\n    {\n        Reader in = new Reader();\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int[] A = new int[n];\n        ArrayList<Integer> D = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n        {\n            A[i] = in.nextInt() - i;\n            D.add(A[i]);\n        }\n        int[] B = new int[k + 2];\n        for (int j = 1; j <= k; j++)\n        {\n            B[j] = in.nextInt() - 1;\n        }\n        B[0] = -1;\n        B[k + 1] = n;\n        for (int i=1;i<B.length - 2;i++)\n        {\n            if (A[B[i]] > A[B[i + 1]])\n                NO();\n        }\n        int ans = 0;\n        if (k == 0)\n        {\n            System.out.println(lis(D));\n            System.exit(0);\n        }\n        for (int i=0;i<B.length - 1;i++)\n        {\n            ArrayList<Integer> C = new ArrayList<>();\n            for (int j=B[i] + 1;j < B[i + 1];j++)\n            {\n                if ((i == 0 && A[j] <= A[B[i + 1]]) || (i == B.length - 2 && A[j] >= A[B[i]]) || (i > 0 && i < B.length - 2 && A[j] >= A[B[i]] && A[j] <= A[B[i + 1]]))\n                    C.add(A[j]);\n                else\n                    ans++;\n            }\n            ans += lis(C);\n        }\n        System.out.println(ans);\n    }\n    public static int lis (ArrayList<Integer> A)\n    {\n        int n = A.size();\n        BIT = new BIT(n + 10);\n        ArrayList<Integer> B = (ArrayList<Integer>) A.clone();\n        Collections.sort(B);\n        ArrayList<Integer> C = new ArrayList<>();\n        for (int i : A)\n            C.add(Collections.binarySearch(B, i) + 1);\n        int ans = 0;\n        for (int i : C)\n        {\n            int res = 1;\n            res = Math.max(res, BIT.sum(i) + 1);\n            BIT.update(i, res);\n            ans = Math.max(ans, res);\n        }\n        return A.size() - ans;\n    }\n    public static void NO()\n    {\n        System.out.println(\"-1\");\n        System.exit(0);\n    }\n}\nclass BIT\n{\n    int size;\n    int[] table;\n    public BIT(int size)\n    {\n        table = new int[size];\n        this.size = size;\n    }\n\n    void update(int i, int delta)\n    {\n        while (i < size)\n        {\n            table[i] = Math.max(table[i], delta);\n            i += Integer.lowestOneBit(i);\n        }\n    }\n\n    int sum(int i)\n    {\n        int sum = 0;\n        while (i > 0)\n        {\n            sum = Math.max(table[i], sum);\n            i -= Integer.lowestOneBit(i);\n        }\n        return sum;\n    }\n}\nclass Reader\n{\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader()\n    {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException\n    {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String readLine() throws IOException\n    {\n        byte[] buf = new byte[64]; // line length\n        int cnt = 0, c;\n        while ((c = read()) != -1)\n        {\n            if (c == '\\n')\n                break;\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int nextInt() throws IOException\n    {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do\n        {\n            ret = ret * 10 + c - '0';\n        }  while ((c = read()) >= '0' && c <= '9');\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public long nextLong() throws IOException\n    {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public double nextDouble() throws IOException\n    {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n\n        if (c == '.')\n        {\n            while ((c = read()) >= '0' && c <= '9')\n            {\n                ret += (c - '0') / (div *= 10);\n            }\n        }\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException\n    {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1)\n            buffer[0] = -1;\n    }\n\n    private byte read() throws IOException\n    {\n        if (bufferPointer == bytesRead)\n            fillBuffer();\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException\n    {\n        if (din == null)\n            return;\n        din.close();\n    }\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Main {\n    static class Scan {\n        private byte[] buf=new byte[1024];\n        private int index;\n        private InputStream in;\n        private int total;\n        public Scan()\n        {\n            in=System.in;\n        }\n        public int scan()throws IOException\n        {\n            if(total<0)\n            throw new InputMismatchException();\n            if(index>=total)\n            {\n                index=0;\n                total=in.read(buf);\n                if(total<=0)\n                return -1;\n            }\n            return buf[index++];\n        }\n        public int scanInt()throws IOException\n        {\n            int integer=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n))\n            {\n                if(n>='0'&&n<='9')\n                {\n                    integer*=10;\n                    integer+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            return neg*integer;\n        }\n        public double scanDouble()throws IOException\n        {\n            double doub=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n)&&n!='.')\n            {\n                if(n>='0'&&n<='9')\n                {\n                    doub*=10;\n                    doub+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            if(n=='.')\n            {\n                n=scan();\n                double temp=1;\n                while(!isWhiteSpace(n))\n                {\n                    if(n>='0'&&n<='9')\n                    {\n                        temp/=10;\n                        doub+=(n-'0')*temp;\n                        n=scan();\n                    }\n                    else throw new InputMismatchException();\n                }\n            }\n            return doub*neg;\n        }\n        public String scanString()throws IOException\n        {\n            StringBuilder sb=new StringBuilder();\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            while(!isWhiteSpace(n))\n            {\n                sb.append((char)n);\n                n=scan();\n            }\n            return sb.toString();\n        }\n        private boolean isWhiteSpace(int n)\n        {\n            if(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n            return true;\n            return false;\n        }\n    }\n    \n    public static void sort(int arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(int arr[],int l1,int r1,int l2,int r2) {\n        int tmp[]=new int[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    \n    public static void sort(long arr[],int l,int r) {    //sort(arr,0,n-1);\n        if(l==r) {\n            return;\n        }\n        int mid=(l+r)/2;\n        sort(arr,l,mid);\n        sort(arr,mid+1,r);\n        merge(arr,l,mid,mid+1,r);\n    }\n    public static void merge(long arr[],int l1,int r1,int l2,int r2) {\n        long tmp[]=new long[r2-l1+1];\n        int indx1=l1,indx2=l2;\n        //sorting the two halves using a tmp array\n        for(int i=0;i<tmp.length;i++) {\n            if(indx1>r1) {\n                tmp[i]=arr[indx2];\n                indx2++;\n                continue;\n            }\n            if(indx2>r2) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            if(arr[indx1]<arr[indx2]) {\n                tmp[i]=arr[indx1];\n                indx1++;\n                continue;\n            }\n            tmp[i]=arr[indx2];\n            indx2++;\n        }\n        //Copying the elements of tmp into the main array\n        for(int i=0,j=l1;i<tmp.length;i++,j++) {\n            arr[j]=tmp[i];\n        }\n    }\n    public static void main(String args[]) throws IOException {\n        Scan input=new Scan();\n        int n=input.scanInt();\n        int k=input.scanInt();\n        int arr[]=new int[n+2];\n        boolean brr[]=new boolean[n+2];\n        for(int i=1;i<n+1;i++) {\n            arr[i]=input.scanInt();\n        }\n        arr[0]=Integer.MIN_VALUE/2;\n        arr[n+1]=Integer.MAX_VALUE/2;\n        for(int i=0;i<k;i++) {\n            brr[input.scanInt()]=true;\n        }\n        brr[0]=brr[brr.length-1]=true;\n//        for(int i=0;i<arr.length;i++) {\n//            System.out.println(i+\" \"+arr[i]+\" \"+brr[i]);\n//        }\n        int prev=0,ans=0,strt,end;\n        for(int i=1;i<arr.length;i++) {\n            if(!brr[i]) {\n                continue;\n            }\n            if(arr[i]-arr[prev]<i-prev) {\n                System.out.println(-1);\n                return;\n            }\n            strt=prev;\n            end=i;\n            ArrayList<Integer> arrli=new ArrayList<>();\n            for(int j=strt+1;j<end;j++) {\n                if(arr[j]>=arr[strt]+j-strt && arr[j]<=arr[end]-(end-j)) {\n                    arrli.add(arr[j]-(arr[strt]+j-strt));\n                }\n            }\n            int tmp=LongestIncreasingSubsequenceLength(arrli,arrli.size());\n//            System.out.println(prev+\" \"+i+\" \"+tmp);\n            ans+=(end-strt-1)-tmp;\n            prev=i;\n        }\n        System.out.println(ans);\n    }\n    \n    \n    \n    static int LongestIncreasingSubsequenceLength(ArrayList<Integer> A, int size) \n    { \n        if(A.size()==0) {\n            return 0;\n        }\n        // Add boundary case, when array size is one \n  \n        int[] tailTable = new int[size]; \n        int len; // always points empty slot \n  \n        tailTable[0] = A.get(0); \n        len = 1; \n        for (int i = 1; i < size; i++) { \n            if (A.get(i) < tailTable[0]) \n                // new smallest value \n                tailTable[0] = A.get(i); \n  \n            else if (A.get(i) >= tailTable[len - 1]) \n                // A[i] wants to extend largest subsequence \n                tailTable[len++] = A.get(i); \n  \n            else\n                // A[i] wants to be current end candidate of an existing \n                // subsequence. It will replace ceil value in tailTable \n                tailTable[CeilIndex(tailTable, -1, len - 1, A.get(i))] = A.get(i); \n        } \n  \n        return len; \n    } \n    \n    \n    static int CeilIndex(int A[], int l, int r, int key) \n    { \n        while (r - l > 1) { \n            int m = l + (r - l) / 2; \n            if (A[m] > key) \n                r = m; \n            else\n                l = m; \n        } \n  \n        return r; \n    } \n}\n", "label": 3}
{"src": "//package edu97;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\n// What's the smallest input?\n// Check * for int/long overflow.\n// Check / for accidental rounding.\n// Are you using doubles? Can you avoid it?\n// Never compare after taking mod.\n// Mod the final result.\n// Initialize globals in solve() unless they are independent of the problem input.\n// Check for local/global name conflicts (n?).\n// Check initial values for max/min (not Integer.MIN_VALUE for long).\npublic class E {\n    static Random rand;\n    static boolean MULTIPLE_CASES = false;\n    static boolean CONSTRUCTIVE = false;\n    static long MOD = (long) 1e9 + 7;\n    static long BIG = (long) 2e9 + 10;\n\n    public static void solve(Reader in, PrintWriter out) {\n        int n = in.ni(), k = in.ni();\n        int[] arr = in.nis(n);\n        int[] b = in.nis(k);\n\n        // check whether feasible\n        boolean ok = true;\n        for (int i = 1; i < k; i++) {\n            // needs to be enough room between the two values\n            int valuesInBetween = b[i] - b[i-1] - 1;\n            int spaces = arr[b[i]-1] - arr[b[i-1]-1] - 1;\n\n            if (valuesInBetween > spaces) {\n                ok = false;\n                break;\n            }\n        }\n\n        if (!ok) {\n            out.println(-1);\n            return;\n        }\n\n        int totalChanged = 0;\n        for (int i = 0; i <= k; i++) {\n            int l = i == 0 ? 0 : b[i-1];\n            int r = i == k ? n - 1 : b[i] - 2;\n            int min = i == 0 ? Integer.MIN_VALUE : arr[b[i-1]-1]+1;\n            int max = i == k ? Integer.MAX_VALUE : arr[b[i]-1]-1;\n\n            int best = r - l + 1;\n            int[] subSeqs = new int[r - l + 2];\n            Arrays.fill(subSeqs, Integer.MAX_VALUE);\n            subSeqs[0] = Integer.MIN_VALUE;\n            for (int j = l; j <= r; j++) {\n                // longest increasing subsequence length\n                boolean feasible = min + j - l <= arr[j] && max - (r - j) >= arr[j];\n                if (feasible) {\n                    int finalJ = j;\n                    int index = binarySearchHighest(0, subSeqs.length-1, mid -> subSeqs[mid] <= arr[finalJ] - finalJ);\n                    subSeqs[index+1] = arr[j] - j;\n                    best = Math.min(best, r - l + 1 - (index + 1));\n                }\n            }\n            totalChanged += best;\n        }\n\n        out.println(totalChanged);\n    }\n\n    public static void main(String[] args) throws IOException {\n        Reader in = null;\n        PrintWriter out = null;\n        for (String arg : args) {\n            if (arg.startsWith(\"input\")) {\n                in = new Reader(arg);\n            } else if (arg.startsWith(\"output\")) {\n                out = new PrintWriter(new FileWriter(arg));\n            }\n        }\n        if (in == null) in = new Reader();\n        if (out == null) out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        if (MULTIPLE_CASES) {\n            int tests = in.ni();\n            for (int t = 0; t < tests; t++) {\n                solve(in, out);\n            }\n        } else {\n            solve(in, out);\n        }\n\n        out.flush();\n    }\n\n    static class Tester {\n        public static void main(String[] args) throws IOException {\n            Validator validator = new Validator();\n\n            File currentDir = new File(\".\");\n            long before;\n            long after;\n            for (File inputFile : Arrays.stream(currentDir.listFiles())\n                    .sorted(Comparator.comparing(File::getName))\n                    .collect(Collectors.toList())) {\n                if (!inputFile.getName().startsWith(\"input\")\n                        || inputFile.getName().contains(\"sight\")\n                        || inputFile.getName().contains(\"big\")) continue;\n                System.out.println(\"Test file: \" + inputFile.getName());\n\n                before = System.nanoTime();\n                String outputFileName = \"output\" + inputFile.getName().substring(5);\n                E.main(new String[]{inputFile.getName(), outputFileName});\n                after = System.nanoTime();\n\n                File outputFile = new File(outputFileName);\n                if (!outputFile.exists()) {\n                    throw new IllegalStateException(\"Missing output file \" + outputFile);\n                }\n\n                // TODO if verifier is implemented, remove this\n                if (CONSTRUCTIVE) {\n                    System.out.println(\"INPUT:\");\n                    printFile(inputFile);\n                    System.out.printf(\"\\nOUTPUT: (%d milliseconds)\\n\", (after - before) / 1000000L);\n                    printFile(outputFile);\n                    continue;\n                }\n\n                if (validator.validate(inputFile, outputFile)) {\n                    System.out.printf(\"OK (%d milliseconds)\\n\", (after - before) / 1000000L);\n                } else {\n                    System.out.println(\"FAILED\");\n                    System.out.println(\"\\nInput: \");\n                    printFile(inputFile);\n                    System.out.println(\"\\nIncorrect Output: \");\n                    printFile(outputFile);\n                    return;\n                }\n            }\n            System.out.println(\"\\n-----------------\\n\");\n\n            File sightTestInput = new File(\"input-sight\");\n            if (sightTestInput.exists()) {\n                System.out.println(\"Running sight test... Input:\");\n                printFile(sightTestInput);\n                before = System.nanoTime();\n                System.out.println(\"\\nOutput: \");\n                E.main(new String[]{\"input-sight\"});\n                after = System.nanoTime();\n                System.out.printf(\"(%d milliseconds)\\n\", (after - before) / 1000000L);\n                System.out.println(\"\\n-----------------\\n\");\n            }\n\n            File bigTestInput = new File(\"input-big\");\n            if (bigTestInput.exists()) {\n                System.out.println(\"Running big test...\");\n                before = System.nanoTime();\n                E.main(new String[]{\"input-big\"});\n                after = System.nanoTime();\n                System.out.printf(\"(%d milliseconds)\\n\", (after - before) / 1000000L);\n            }\n        }\n\n        static void printFile(File file) throws FileNotFoundException {\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            reader.lines().forEach(System.out::println);\n        }\n    }\n\n    static class Validator {\n        boolean validate(File inputFile, File outputFile) throws IOException {\n            File expectedOutputFile = new File(\"expected-output\" + inputFile.getName().substring(5));\n            if (CONSTRUCTIVE || !expectedOutputFile.exists()) {\n                return validateManual(inputFile, outputFile);\n            }\n            return areSame(outputFile, expectedOutputFile);\n        }\n\n        private boolean validateManual(File inputFile, File outputFile) throws IOException {\n            if (CONSTRUCTIVE) {\n                // Validate output against input\n                Reader inputReader = new Reader(inputFile.getName());\n                Reader outputReader = new Reader(outputFile.getName());\n\n                // TODO implement manual validation\n\n                throw new IllegalStateException(\"Missing expected output file\");\n            } else {\n                File naiveOutput = new File(\"naive-\" + outputFile.getName());\n                Naive.main(new String[]{inputFile.getName(), naiveOutput.getName()});\n\n                return areSame(outputFile, naiveOutput);\n            }\n        }\n\n        private boolean areSame(File file1, File file2) throws IOException {\n            BufferedReader reader1 = new BufferedReader(new FileReader(file1));\n            BufferedReader reader2 = new BufferedReader(new FileReader(file2));\n\n            String line1;\n            while ((line1 = reader1.readLine()) != null) {\n                String line2 = reader2.readLine();\n                if (line2 == null) line2 = \"\"; // ok if one has an extra newline\n                if (!line1.trim().equals(line2.trim())) {\n                    return false;\n                }\n            }\n            String line2;\n            while ((line2 = reader2.readLine()) != null) {\n                if (!line2.trim().isEmpty()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Naive {\n        public static void solveNaive(Reader in, PrintWriter out) {\n            throw new IllegalStateException(\"missing expected output file\");\n        }\n\n        public static void main(String[] args) throws IOException {\n            Reader in = null;\n            PrintWriter out = null;\n            for (String arg : args) {\n                if (arg.startsWith(\"input\")) {\n                    in = new Reader(arg);\n                } else if (arg.startsWith(\"naive-output\")) {\n                    out = new PrintWriter(new FileWriter(arg));\n                }\n            }\n            if (in == null) in = new Reader();\n            if (out == null) out = new PrintWriter(new OutputStreamWriter(System.out));\n\n            int tests = in.ni();\n            for (int t = 0; t < tests; t++) {\n                solveNaive(in, out);\n            }\n\n            out.flush();\n            out.close();\n        }\n    }\n\n    static boolean isPowerOfTwo(int x) {\n        return x > 0 & (x & (x - 1)) == 0;\n    }\n\n    static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    static void ruffleSort(int[] a) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {\n            int oi = rand.nextInt(n), temp = a[oi];\n            a[oi] = a[i];\n            a[i] = temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static void ruffleSort(long[] a) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {\n            int oi = rand.nextInt(n);\n            long temp = a[oi];\n            a[oi] = a[i];\n            a[i] = temp;\n        }\n        Arrays.sort(a);\n    }\n\n    ///////////////////////////////////\n    //////////   FAST PAIR   //////////\n    ///////////////////////////////////\n\n    // Works on -1e9 <= x, y <= 1e9\n    static long pair(int x, int y) {\n        x = (int) BIG / 2 - x;\n        y = (int) BIG / 2 - y;\n        return x * BIG + y;\n    }\n\n    static int x(long pair) {\n        return (int) BIG / 2 - (int) (pair / BIG);\n    }\n\n    static int y(long pair) {\n        return (int) BIG / 2 - (int) (pair % BIG);\n    }\n\n    static String str(long pair) {\n        return String.format(\"(%d, %d)\", x(pair), y(pair));\n    }\n\n    ///////////////////////////////////\n    ////////// BINARY SEARCH //////////\n    ///////////////////////////////////\n\n    // return highest in range that still returns true\n    // T T T F F F F\n    // invariant:\n    // -    indicator(min) = true\n    // -    indicator(max+1) = false\n    static int binarySearchHighest(int min, int max, Function<Integer, Boolean> indicator) {\n        int a = min;\n        int b = max;\n        while (a != b) {\n            int mid = (a % 2 != b % 2) ? 1 + (a + b) / 2 : (a + b) / 2;\n            if (indicator.apply(mid)) {\n                a = mid;\n            } else {\n                b = mid - 1;\n            }\n        }\n        return a;\n    }\n\n    // return lowest in range that still returns true\n    // F F F F T T T\n    // invariant:\n    // -    indicator(min-1) = false\n    // -    indicator(max) = true\n    static int binarySearchLowest(int min, int max, Function<Integer, Boolean> indicator) {\n        int a = min;\n        int b = max;\n        while (a != b) {\n            int mid = (a + b) / 2;\n            if (indicator.apply(mid)) {\n                b = mid;\n            } else {\n                a = mid + 1;\n            }\n        }\n        return a;\n    }\n\n    static void insist(boolean bool) {\n        if (!bool) throw new IllegalStateException();\n    }\n\n    static class Reader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public Reader() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        public Reader(String fileName) throws FileNotFoundException {\n            reader = new BufferedReader(new FileReader(fileName));\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(next());\n        }\n\n        public long nl() {\n            return Long.parseLong(next());\n        }\n\n        public int[] nis(int n) {\n            int[] out = new int[n];\n            for (int i = 0; i < n; i++) {\n                out[i] = ni();\n            }\n            return out;\n        }\n\n        public long[] nls(int n) {\n            long[] out = new long[n];\n            for (int i = 0; i < n; i++) {\n                out[i] = nl();\n            }\n            return out;\n        }\n    }\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class tr0 {\n\tstatic PrintWriter out;\n\tstatic StringBuilder sb;\n\tstatic long mod = (long) 1e9 + 7;\n\tstatic long inf = (long) 1e16;\n\tstatic int n, k, l;\n\tstatic ArrayList<Integer>[] ad;\n\tstatic int[][] memo;\n\tstatic boolean vis[];\n\tstatic long[] f, inv, ncr[];\n\tstatic HashMap<Integer, Integer> hm;\n\tstatic int[] a;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tn = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\ta = new int[n + 2];\n\t\tboolean[] here = new boolean[n + 2];\n\t\there[0] = true;\n\t\there[n + 1] = true;\n\t\ta[0] = -2000000000;\n\t\ta[n + 1] = 2000000000;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\ta[i] = sc.nextInt();\n\t\tint ans = 0;\n\t\tif (k != 0) {\n\t\t\tint[] idc = new int[k];\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tidc[i] = sc.nextInt();\n\t\t\t\there[idc[i]] = true;\n\t\t\t}\n\t\t\tfor (int i = 1; i < k; i++) {\n\t\t\t\tint x = a[idc[i]];\n\t\t\t\tint y = a[idc[i - 1]];\n\t\t\t\tif (x <= y || x - y < idc[i] - idc[i - 1]) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l = 0;\n\t\tfor (int i = 1; i < a.length; i++)\n\t\t\tif (here[i]) {\n\t\t\t\tans += solve1(l, i);\n\t\t\t\tl = i;\n\t\t\t}\n\t\tSystem.out.println(ans);\n\t\tout.close();\n\t}\n\n\tstatic int solve1(int l, int r) {\n\t\tint ans = 0;\n\t\tArrayList<Integer> ar = new ArrayList<>();\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tint v = a[i] - i;\n\t\t\tif (v < a[l] - l)\n\t\t\t\tcontinue;\n\t\t\tint num = a[i] - i;\n\t\t\tint best = 0;\n\t\t\tif (ar.isEmpty()) {\n\t\t\t\tbest = 1;\n\t\t\t\tar.add(num);\n\t\t\t} else if (ar.get(ar.size() - 1) <= num) {\n\t\t\t\tbest = ar.size() + 1;\n\t\t\t\tar.add(num);\n\t\t\t} else {\n\t\t\t\tint lo = 0;\n\t\t\t\tint hi = ar.size() - 1;\n\t\t\t\twhile (lo <= hi) {\n\t\t\t\t\tint mid = (lo + hi) >> 1;\n\t\t\t\t\tif (ar.get(mid).intValue() > num) {\n\t\t\t\t\t\thi = mid - 1;\n\t\t\t\t\t\tbest = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlo = mid + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tar.set(best, num);\n\t\t\t\tbest++;\n\t\t\t}\n\t\t\tif (i == r)\n\t\t\t\tans = best;\n\t\t}\n\t\treturn r - l + 1 - ans;\n\t}\n\n\tstatic int solve(int l, int r) {\n\t\tint ans = 0;\n\t\tint len = r - l + 1;\n\t\tFenwickTree ft = new FenwickTree(len + 3);\n\t\tTreeSet<Integer> ts = new TreeSet<>();\n\t\tfor (int i = l; i <= r; i++)\n\t\t\tts.add(a[i] - i);\n\n\t\tHashMap<Integer, Integer> hm = new HashMap<>();\n\t\tint id = 2;\n\t\twhile (!ts.isEmpty())\n\t\t\thm.put(ts.pollFirst(), id++);\n\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tint v = a[i] - i;\n\t\t\tif (v < a[l] - l || a[r] - r < v)\n\t\t\t\tcontinue;\n\t\t\tint num = hm.get(a[i] - i);\n\t\t\tint best = ft.rsq(num);\n\t\t\tft.point_update(num, best + 1);\n\t\t\tif (i == r)\n\t\t\t\tans = best + 1;\n\t\t}\n\n\t\treturn r - l + 1 - ans;\n\t}\n\n\tpublic static class FenwickTree { // one-based DS\n\n\t\tint ni;\n\t\tint[] ft;\n\n\t\tFenwickTree(int size) {\n\t\t\tni = size;\n\t\t\tft = new int[ni + 1];\n\t\t}\n\n\t\tint rsq(int b) // O(log n)\n\t\t{\n\t\t\tint max = 0;\n\t\t\twhile (b > 0) {\n\t\t\t\tmax = Math.max(max, ft[b]);\n\t\t\t\tb -= b & -b;\n\t\t\t} // min?\n\t\t\treturn max;\n\t\t}\n\n\t\tvoid point_update(int k, int val) // O(log n), update = increment\n\t\t{\n\t\t\twhile (k <= ni) {\n\t\t\t\tft[k] = Math.max(val, ft[k]);\n\t\t\t\tk += k & -k;\n\t\t\t} // min?\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int[] nextArrInt(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextArrLong(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "label": 3}
{"src": "// Don't place your source in a package\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*; \n \n /*\n \n 6666666666666\t\t\t 6666666666666                     \n 6\t\t\t\t\t\t 6  \t\t\t\t\t\t\t\t\t\t\t   \t\t\t\n 6\t\t\t\t\t\t 6                                      \n 6\t\t\t\t\t\t 6                                      \n 6\t\t\t\t\t\t 6                                       \n 6                       6                                                 \n 6666666666666           6666666666666                     \n 6\t\t     6           6\t\t     6\n 6\t\t\t 6\t         6\t\t\t 6 \n 6\t\t\t 6           6\t\t\t 6\n 6\t\t     6\t         6\t\t     6\t\n 6666666666666           6666666666666\n \n \n */\n \n \n \n \n \n// Please name your class Main\npublic class Main {\n\t\n\t//static StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n \n    /*static int read() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n    static String readString() throws IOException {\n        in.nextToken();\n        return in.sval;\n\t}*/\n\t\n\t\n\tstatic Scanner in = new Scanner(System.in);\n\t\n\tpublic static void main (String[] args) throws java.lang.Exception {\n\t    \n\t\t//InputReader in = new InputReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n \n\t\tint T=1;\n\t\t\n\t\tfor(int t=0;t<T;t++){\n\t\t\tint n=Int();\n\t\t\tint k=Int();\n\t\t\tlong A[]=new long[n];\n\t\t\tList<Integer>list=new ArrayList<>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tA[i]=Int();\n\t\t\t}\n\t\t\tfor(int j=0;j<k;j++){\n\t\t\t\tint x=Int()-1;\n\t\t\t\tlist.add(x);\n\t\t\t}\n\t\t\tSolution sol=new Solution();\n\t\t\tsol.solution(A,list);\n\t\t}\n \n\t\tout.flush();\n\t}\n\t\n\t\n\t\n\tpublic static long Long(){\n\t\treturn in.nextLong();\n\t}\n\tpublic static int Int(){\n\t\treturn in.nextInt();\n\t}\n\tpublic static String Str(){\n\t\treturn in.next();\n\t}\n}\n \nclass Solution{\n\t//constant variable\n\tfinal int MAX=Integer.MAX_VALUE;\n\tfinal int MIN=Integer.MIN_VALUE;\n\t//Set<Integer>adjecent[];\n\t//////////////////////////////\n \n\tpublic void fastprint(PrintWriter out,String s){\n\t\tout.print(s);\n\t}\n\t\n\tpublic void fastprintln(PrintWriter out,String s){\n\t\tout.println(s);\n\t}\n\n\n\t\n\tpublic void solution(long A[],List<Integer>list){\n\t\tlist.add(-1);\n\t\tlist.add(A.length);\n\t\tCollections.sort(list);\n\t\tint res=0;\n\t\t\n\t\tfor(int i=1;i<list.size();i++){\n\t\t\tint cur=list.get(i);int pre=list.get(i-1);\n\t\t\tlong B[]=new long[cur-pre+1];\n\t\t\tint index=0;\n\t\t\tfor(int j=pre;j<=cur;j++){\n\t\t\t\tB[index]=get1(A,j);\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tif(B[B.length-1]-B[0]+1<B.length){\n\t\t\t\tmsg(\"-1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tres+=lis(B);\n\t\t}\n\t\tmsg(res+\"\");\n\t\t\n\t}\n\t\n\tpublic long get1(long A[],int i){\n\t\tif(i<0)return -1500000000;\n\t\tif(i>=A.length)return 1500000000;\n\t\treturn A[i];\n\t}\n\t\n\t\n\tpublic int lis(long A[]){//longest increase subsequence\n\t\t//print1(A);\n\t\tint N=A.length;\n\t\tint res=0;\n\t\tlong dp[]=new long[N];\n\t\tArrays.fill(dp,2000000000);\n\t\t\n\t\tfor(int i=0;i<A.length;i++){\n\t\t\tA[i]-=i;\n\t\t}\n\t\t\n\t\tdp[0]=A[0];\n\t\t\n\t\tfor(int i=1;i<A.length;i++){\n\t\t\tif(A[i]>A[A.length-1]||A[i]<A[0])continue;\n\t\t\tbin(dp,A[i]);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<dp.length;i++){\n\t\t\tif(dp[i]!=2000000000)res=i+1;\n\t\t}\n\t\t//print1(A);\n\t\t//print1(dp);\n\t\t//msg((N-res)+\"\");\n\t\t//msg(\"\");\n\t\treturn N-res;\n\t}\n\t\n\tpublic void bin(long dp[],long v){\n\t\tint l=0,r=dp.length-1;\n\t\tint index=-1;\n\t\twhile(l<=r){\n\t\t\tint mid=l+(r-l)/2;\n\t\t\tif(dp[mid]>v){\n\t\t\t\tindex=mid;\n\t\t\t\tr=mid-1;\n\t\t\t}else{\n\t\t\t\tl=mid+1;\n\t\t\t}\n\t\t}\n\t\tdp[index]=v;\n\t\t\n\t}\n\n\n \n \n \n \n\tpublic void sort(int A[]){\n\t\tArrays.sort(A);\n\t}\n\t\n\tpublic void swap(int A[],int l,int r){\n\t\tint t=A[l];\n\t\tA[l]=A[r];\n\t\tA[r]=t;\n\t}\n\t\n \n\t\n\t\n\tpublic long C(long fact[],int i,int j){ // C(20,3)=20!/(17!*3!)\n\t\t// take   a/b     where a=20!  b=17!*3!\n\t\tif(j>i)return 0;\n\t\tif(j==0)return 1;\n\t\tlong mod=1000000007;\n\t\tlong a=fact[i];\n\t\tlong b=((fact[i-j]%mod)*(fact[j]%mod))%mod;\n\t\tBigInteger B= BigInteger.valueOf(b);\n\t\tlong binverse=B.modInverse(BigInteger.valueOf(mod)).longValue();\n\t\treturn ((a)*(binverse%mod))%mod;\n\t}\n\t\n\tpublic long gcd(long a, long b) \n    { \n        if (a == 0) \n            return b; \n          \n        return gcd(b%a, a); \n    } \n\t\n\t \n\t\n\t//map operation\n\tpublic void put(Map<Integer,Integer>map,int i){\n\t\tif(!map.containsKey(i))map.put(i,0);\n\t\tmap.put(i,map.get(i)+1);\n\t}\n\t\n\tpublic void delete(Map<Integer,Integer>map,int i){\n\t\tmap.put(i,map.get(i)-1);\n\t\tif(map.get(i)==0)map.remove(i);\n\t}\n \n \n \n \n \n\t\n \n \n\t/*public void tarjan(int p,int r){\n\t\tif(cut)return;\n\t\tList<Integer>childs=adjecent[r];\n\t\tdis[r]=low[r]=time;\n\t\ttime++;\n\t\t\n\t\t//core for tarjan\n\t\tint son=0;\n\t\tfor(int c:childs){\n\t\t\tif(ban==c||c==p)continue;\n\t\t\tif(dis[c]==-1){\n\t\t\t\tson++;\n\t\t\t\ttarjan(r,c);\n\t\t\t\tlow[r]=Math.min(low[r],low[c]);\n\t\t\t\tif((r==root&&son>1)||(low[c]>=dis[r]&&r!=root)){\n\t\t\t\t\tcut=true;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(c!=p){\n\t\t\t\t\tlow[r]=Math.min(low[r],dis[c]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}*/\n\t\n\t\n \n\t\n\t//helper function I would use\n\tpublic void remove(Map<Integer,Integer>map,int i){\n\t\tmap.put(i,map.get(i)-1);\n\t\tif(map.get(i)==0)map.remove(i);\n\t}\n\t\n\t\n\t\n\tpublic void ascii(String s){\n\t\tfor(char c:s.toCharArray()){\n\t\t\tSystem.out.print((c-'a')+\"  \");\n\t\t}\n\t\tmsg(\"\");\n\t}\n\t\n\tpublic int flip(int i){\n\t\tif(i==0)return 1;\n\t\telse return 0;\n\t}\n\t\n\tpublic boolean[] primes(int n){\n\t\tboolean A[]=new boolean[n+1];\n\t\tfor(int i=2;i<=n;i++){\n\t\t\tif(A[i]==false){\n\t\t\t\tfor(int j=i+i;j<=n;j+=i){\n\t\t\t\t\tA[j]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn A;\n\t}\n\t\n\tpublic void msg(String s){\n\t\tSystem.out.println(s);\n\t}\n\t\n\tpublic void msg1(String s){\n\t\tSystem.out.print(s);\n\t}\n\t\n\tpublic int[] kmpPre(String p){\n\t\tint pre[]=new int[p.length()];\n\t\tint l=0,r=1;\n\t\twhile(r<p.length()){\n\t\t\tif(p.charAt(l)==p.charAt(r)){\n\t\t\t\tpre[r]=l+1;\n\t\t\t\tl++;r++;\n\t\t\t}else{\n\t\t\t\tif(l==0)r++;\n\t\t\t\telse l=pre[l-1];\n\t\t\t}\n\t\t}\n\t\treturn pre;\n\t}\n\t\n\tpublic boolean isP(String s){\n\t\tint l=0,r=s.length()-1;\n\t\twhile(l<r){\n\t\t\tif(s.charAt(l)!=s.charAt(r))return false;\n\t\t\tl++;r--;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic int find(int nums[],int x){//union find => find method\n\t\tif(nums[x]==x)return x;\n\t\tint root=find(nums,nums[x]);\n\t\tnums[x]=root;\n\t\treturn root;\n\t}\n\t\n \n\t\n\tpublic int get(int A[],int i){\n\t\tif(i<0||i>=A.length)return 0;\n\t\treturn A[i];\n\t}\n\tpublic int[] copy1(int A[]){\n\t\tint a[]=new int[A.length];\n\t\tfor(int i=0;i<a.length;i++)a[i]=A[i];\n\t\treturn a;\n\t}\n\t\n\t\n\tpublic void print1(int A[]){\n\t\tfor(long i:A)System.out.print(i+\"  \");\n\t\tSystem.out.println();\n\t}\n\tpublic void print2(int A[][]){\n\t\tfor(int i=0;i<A.length;i++){\n\t\t\tfor(int j=0;j<A[0].length;j++){\n\t\t\t\tSystem.out.print(A[i][j]+\"   \");\n\t\t\t}System.out.println();\n\t\t}\n\t}\n\t\n\tpublic int min(int a,int b){\n\t\treturn Math.min(a,b);\n\t}\n\t\n\t\n\tpublic int[][] matrixdp(int[][] grid) {\n        if(grid.length==0)return new int[][]{};\n        int res[][]=new int[grid.length][grid[0].length];\n        for(int i=0;i<grid.length;i++){\n            for(int j=0;j<grid[0].length;j++){\n                res[i][j]=grid[i][j]+get(res,i-1,j)+get(res,i,j-1)-get(res,i-1,j-1);\n            }\n        }\n        return res;\n    }\n    \n    public int get(int grid[][],int i,int j){\n        if(i<0||j<0||i>=grid.length||j>=grid[0].length)return 0;\n        return grid[i][j];\n    }\n\t\n\tpublic int[] suffixArray(String s){\n\t\tint n=s.length();\n\t\tSuffix A[]=new Suffix[n];\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tA[i]=new Suffix(i,s.charAt(i)-'a',0);\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i==n-1){\n\t\t\t\tA[i].next=-1;\n\t\t\t}else{\n\t\t\t\tA[i].next=A[i+1].rank;\n\t\t\t}\n\t\t}\n\t\tArrays.sort(A);\n\t\t\n\t\tfor(int len=4;len<A.length*2;len<<=1){\n\t\t\tint in[]=new int[A.length];\n\t\t\tint rank=0;\n\t\t\tint pre=A[0].rank;\n\t\t\tA[0].rank=rank;\n\t\t\tin[A[0].index]=0;\n\t\t\tfor(int i=1;i<A.length;i++){//rank for the first two letter\n\t\t\t\tif(A[i].rank==pre&&A[i].next==A[i-1].next){\n\t\t\t\t\tpre=A[i].rank;\n\t\t\t\t\tA[i].rank=rank;\n\t\t\t\t}else{\n\t\t\t\t\tpre=A[i].rank;\n\t\t\t\t\tA[i].rank=++rank;\n\t\t\t\t}\n\t\t\t\tin[A[i].index]=i;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<A.length;i++){\n\t\t\t\tint next=A[i].index+len/2;\n\t\t\t\tif(next>=A.length){\n\t\t\t\t\tA[i].next=-1;\n\t\t\t\t}else{\n\t\t\t\t\tA[i].next=A[in[next]].rank;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tArrays.sort(A);\n\t\t}\n\t\t\n\t\t\n\t\tint su[]=new int[A.length];\n\t\tfor(int i=0;i<su.length;i++){\n\t\t\tsu[i]=A[i].index;\n\t\t}\n\t\treturn su;\n\t}\n\t\n}\n \n//suffix array Struct\nclass Suffix implements Comparable<Suffix>{\n\tint index;\n\tint rank;\n\tint next;\n\tpublic Suffix(int i,int rank,int next){\n\t\tthis.index=i;\n\t\tthis.rank=rank;\n\t\tthis.next=next;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Suffix other) {\n\t\tif(this.rank==other.rank){\n\t\t\treturn this.next-other.next;\n\t\t}\n\t\treturn this.rank-other.rank;\n\t}\n\t\n\tpublic String toString(){\n\t\treturn this.index+\"   \"+this.rank+\"   \"+this.next+\"  \";\n\t}\n}\n \n \n \nclass Wrapper implements Comparable<Wrapper>{\n\tint spf;int cnt;\n\tpublic Wrapper(int spf,int cnt){\n\t\tthis.spf=spf;\n\t\tthis.cnt=cnt;\n\t}\n\t\t\n\t@Override\n\tpublic int compareTo(Wrapper other) {\n\t\treturn this.spf-other.spf;\n\t}\n}\n \n \n \n    class Node{//what the range would be for that particular node\n\t\tboolean state=false;\n        int l=0,r=0;\n\t\tint ll=0,rr=0;\n        public Node(boolean state){\n            this.state=state;\n        }\n    }\n\t\n\t\n\t\n\t\n\tclass Seg1{\n\t\t\tint A[];\n\t\t\tpublic Seg1(int A[]){\n\t\t\t\tthis.A=A;\n\t\t\t}\n\t\t\t\n\t\t\tpublic void update(int left,int right,int val,int s,int e,int id){\n\t\t\t\tif(left<0||right<0||left>right)return;\n\t\t\t\tif(left==s&&right==e){\n\t\t\t\t\t\n\t\t\t\t\tA[id]+=val;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tint mid=s+(e-s)/2; //[s,mid] [mid+1,e]\n\t\t\t\t\n\t\t\t\tif(left>=mid+1){\n\t\t\t\t\tupdate(left,right,val,mid+1,e,id*2+2);\n\t\t\t\t}else if(right<=mid){\n\t\t\t\t\tupdate(left,right,val,s,mid,id*2+1);\n\t\t\t\t}else{\n\t\t\t\t\tupdate(left,mid,val,s,mid,id*2+1);\n\t\t\t\t\tupdate(mid+1,right,val,mid+1,e,id*2+2);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tpublic int query(int i,int add,int s,int e,int id){\n\t\t\t\t\n\t\t\t\tif(s==e&&i==s){\n\t\t\t\t\treturn A[id]+add;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint mid=s+(e-s)/2; //[s,mid] [mid+1,e]\n\t\t\t\t\n\t\t\t\tif(i>=mid+1){\n\t\t\t\t\treturn query(i,A[id]+add,mid+1,e,id*2+2);\n\t\t\t\t}else{\n\t\t\t\t\treturn query(i,A[id]+add,s,mid,id*2+1);\n\t\t\t\t}\n\t\t\t}\n\t}\n \n \n\t class MaxFlow{\n\t\t\n \n\t\t  public static List<Edge>[] createGraph(int nodes) {\n\t\t\tList<Edge>[] graph = new List[nodes];\n\t\t\tfor (int i = 0; i < nodes; i++)\n\t\t\t  graph[i] = new ArrayList<>();\n\t\t\treturn graph;\n\t\t  }\n \n\t\t  public static void addEdge(List<Edge>[] graph, int s, int t, int cap) {\n\t\t\tgraph[s].add(new Edge(t, graph[t].size(), cap));\n\t\t\tgraph[t].add(new Edge(s, graph[s].size() - 1, 0));\n\t\t  }\n \n\t\t  static boolean dinicBfs(List<Edge>[] graph, int src, int dest, int[] dist) {\n\t\t\tArrays.fill(dist, -1);\n\t\t\tdist[src] = 0;\n\t\t\tint[] Q = new int[graph.length];\n\t\t\tint sizeQ = 0;\n\t\t\tQ[sizeQ++] = src;\n\t\t\tfor (int i = 0; i < sizeQ; i++) {\n\t\t\t  int u = Q[i];\n\t\t\t  for (Edge e : graph[u]) {\n\t\t\t\tif (dist[e.t] < 0 && e.f < e.cap) {\n\t\t\t\t  dist[e.t] = dist[u] + 1;\n\t\t\t\t  Q[sizeQ++] = e.t;\n\t\t\t\t}\n\t\t\t  }\n\t\t\t}\n\t\t\treturn dist[dest] >= 0;\n\t\t  }\n \n\t\t  static int dinicDfs(List<Edge>[] graph, int[] ptr, int[] dist, int dest, int u, int f) {\n\t\t\tif (u == dest)\n\t\t\t  return f;\n\t\t\tfor (; ptr[u] < graph[u].size(); ++ptr[u]) {\n\t\t\t  Edge e = graph[u].get(ptr[u]);\n\t\t\t  if (dist[e.t] == dist[u] + 1 && e.f < e.cap) {\n\t\t\t\tint df = dinicDfs(graph, ptr, dist, dest, e.t, Math.min(f, e.cap - e.f));\n\t\t\t\tif (df > 0) {\n\t\t\t\t  e.f += df;\n\t\t\t\t  graph[e.t].get(e.rev).f -= df;\n\t\t\t\t  return df;\n\t\t\t\t}\n\t\t\t  }\n\t\t\t}\n\t\t\treturn 0;\n\t\t  }\n \n\t\t  public static int maxFlow(List<Edge>[] graph, int src, int dest) {\n\t\t\tint flow = 0;\n\t\t\tint[] dist = new int[graph.length];\n\t\t\twhile (dinicBfs(graph, src, dest, dist)) {\n\t\t\t  int[] ptr = new int[graph.length];\n\t\t\t  while (true) {\n\t\t\t\tint df = dinicDfs(graph, ptr, dist, dest, src, Integer.MAX_VALUE);\n\t\t\t\tif (df == 0)\n\t\t\t\t  break;\n\t\t\t\tflow += df;\n\t\t\t  }\n\t\t\t}\n\t\t\treturn flow;\n\t\t  }\n\t\t \n\t }\n\t \n\t \t class Edge {\n\t\t\tint t, rev, cap, f;\n \n\t\t\tpublic Edge(int t, int rev, int cap) {\n\t\t\t  this.t = t;\n\t\t\t  this.rev = rev;\n\t\t\t  this.cap = cap;\n\t\t\t}\n\t\t  }\n\t\t  \n\t   class Seg{\n        int l,r;\n        int min=Integer.MAX_VALUE;\n        Seg left=null,right=null;\n\t\tint tree[];\n        public Seg(int l,int r){\n            this.l=l;\n            this.r=r;\n            if(l!=r){\n                int mid=l+(r-l)/2;\n                if(l<=mid)left=new Seg(l,mid);\n                if(r>=mid+1)right=new Seg(mid+1,r);\n                if(left!=null)min=Math.min(left.min,min);\n                if(right!=null)min=Math.min(right.min,min);\n            }else{\n                min=tree[l];\n            }\n        }\n        public int query(int s,int e){\n            if(l==s&&r==e){\n                return min;\n            }\n            int mid=l+(r-l)/2; //left :  to mid-1,\n            if(e<=mid){\n                return left.query(s,e);\n            }\n            else if(s>=mid+1){\n                return right.query(s,e);\n            }else{\n                return Math.min(left.query(s,mid),right.query(mid+1,e));\n            }\n        }\n\n        public void update(int index){\n            if(l==r){\n                min=tree[l];\n                return;\n            }\n            int mid=l+(r-l)/2;\n            if(index<=mid){\n                left.update(index);\n            }else{\n                right.update(index);\n            }\n            this.min=Math.min(left.min,right.min);\n        }\n    }\n\t\n    \n\t\t  \n\t\t  ", "label": 3}
{"src": "import java.util.*;\n\n\nimport java.io.*;\npublic class EdB {\n\tstatic long[] mods = {1000000007, 998244353, 1000000009};\n\tstatic long mod = mods[0];\n\tpublic static MyScanner sc;\n    public static PrintWriter out;\n\tpublic static void main(String[] omkar) throws Exception{\n\t\t// TODO Auto-generated method stub\n \t\tsc = new MyScanner();\n \t\tout = new PrintWriter(System.out);\n//\t \t\tString input1 = bf.readLine().trim();\n//\t \t\tString input2 = bf.readLine().trim();\n//\t\t\tCOMPARING INTEGER OBJECTS U DO DOT EQUALS NOT ==\n \t\t\tint n = sc.nextInt();\n \t\t\tint k = sc.nextInt();\n \t\t\tint[] arr = readArrayInt1(n);\n \t\t\tint[] no = readArrayInt(k);\n \t\t\tsort(no);\n \t\t\tfor(int j = 1;j<=n;j++)\n \t\t\t\tarr[j]-=j;\n \t\t\tint noindex = 0;\n \t\t\tint ans = 0;\n \t\t\tboolean found = true;\n \t\t\twhile(noindex <=k){\n\t \t\t\tint low = Integer.MIN_VALUE;\n\t\t\t\tint hi = Integer.MAX_VALUE;\n\t\t\t\tif (noindex < k)\n\t\t\t\t\thi = arr[no[noindex]];\n\t\t\t\tif (noindex > 0)\n\t\t\t\t\tlow = arr[no[noindex-1]];\n\t\t\t\tif (hi < low)\n\t\t\t\t\tfound = false;\n\t\t\t\tArrayList<Integer> lis = new ArrayList<>();\n\t \t\t\tfor(int j = (noindex == 0 ? 1 : no[noindex-1]+1);j<(noindex == k ? n+1 : no[noindex]);j++){\n\t \t\t\t\tif (arr[j] >= low && arr[j] <= hi)\n\t \t\t\t\t\tlis.add(arr[j]);\n\t \t\t\t\telse\n\t \t\t\t\t\tans++;\t\n\t \t\t\t}\n\t \t\t\tif (lis.size() > 0)\n\t \t\t\t\tans+=longest(lis);\n\t \t\t\tnoindex++;\n \t\t\t}\n \t\t\tout.println(found ? ans : -1);\n \t\t\t\n \t\t\n\t \t\t\n \t\tout.close();\t\n \t}\n\tpublic static int longest(ArrayList<Integer> lis){\n\t\tint[] arr = new int[lis.size()];\n\t\tArrayList<Operation> array = new ArrayList<Operation>();\n\t\tfor(int j = 0;j<arr.length;j++){\n\t\t\tarr[j] = lis.get(j);\n\t\t\tarray.add(new Operation(j, arr[j]));\n\t\t}\n\t\tSegTreeMax s = new SegTreeMax(0, lis.size()-1, new int[arr.length]);\n\t\tCollections.sort(array);\n\t\tfor(int j =0 ;j<arr.length;j++){\n\t\t\tint val = s.rangeMax(0,  array.get(j).index);\n\t\t\ts.pointUpdate(array.get(j).index, val+1);\n\t\t}\n\t\treturn lis.size()-s.max;\n\t\t\n\t}\n\tstatic class Operation implements Comparable<Operation>{\n\t\tprivate int index;\n\t\tprivate int value;\n\t\tpublic Operation(int index, int value){\n\t\t\tthis.index = index;\n\t\t\tthis.value = value;\n\t\t}\n\t\tpublic int compareTo(Operation other){\n\t\t\tif (value != other.value)\n\t\t\t\treturn Integer.compare(value, other.value);\n\t\t\telse\n\t\t\t\treturn Integer.compare(index, other.index);\n\t\t}\n\t}\n\tstatic class SegTreeMax{\n\t\tint leftmost, rightmost;\n\t\tSegTreeMax left, right;\n\t\tint max;\n\t\tpublic SegTreeMax(int leftmost, int rightmost, int[] a){\n\t\t\tthis.leftmost = leftmost;\n\t\t\tthis.rightmost = rightmost;\n\t\t\tif (leftmost == rightmost){\n\t\t\t\t// it is a leaf\n\t\t\t\tmax = a[leftmost];\n\t\t\t}\n\t\t\telse{\n\t\t\t\t// it is not a leaf\n\t\t\t\tint mid = (leftmost+rightmost)/2;\n\t\t\t\tleft = new SegTreeMax(leftmost, mid, a);\n\t\t\t\tright = new SegTreeMax(mid+1, rightmost, a);\n\t\t\t\trecalc();\n\t\t\t}\n\t\t}\n\t\tpublic void recalc(){\n\t\t\tif (leftmost == rightmost){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tmax = Math.max(left.max, right.max);\n\t\t\t\n\t\t}\n\t\tpublic void pointUpdate(int index, int newVal){\n\t\t\tif (leftmost == rightmost){\n\t\t\t\tmax = newVal;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (index <= left.rightmost){\n\t\t\t\tleft.pointUpdate(index, newVal);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tright.pointUpdate(index,  newVal);\n\t\t\t}\n\t\t\trecalc();\n\t\t}\n\t\tpublic int rangeMax(int l, int r){\n\t\t\t// entirely disjoint\n\t\t\tif (l > rightmost || r < leftmost) \n\t\t\t\treturn Integer.MIN_VALUE;\n\t\t\t//covers us\n\t\t\tif (l <= leftmost && r >= rightmost){\n\t\t\t\treturn max;\n\t\t\t}\n\t\t\t//others\n\t\t\treturn Math.max(left.rangeMax(l,  r),  right.rangeMax(l, r));\n\t\t}\n\t}\n\tpublic static void sort(int[] array){\n\t\tArrayList<Integer> copy = new ArrayList<Integer>();\n\t\tfor (int i : array)\n\t\t\tcopy.add(i);\n\t\tCollections.sort(copy);\n\t\tfor(int i = 0;i<array.length;i++)\n\t\t\tarray[i] = copy.get(i);\n\t}\n\tstatic String[] readArrayString(int n){\n\t\tString[] array = new String[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.next();\n\t\treturn array;\n\t}\n\tstatic int[] readArrayInt(int n){\n    \tint[] array = new int[n];\n    \tfor(int j = 0;j<n;j++)\n    \t\tarray[j] = sc.nextInt();\n    \treturn array;\n    }\n\tstatic int[] readArrayInt1(int n){\n\t\tint[] array = new int[n+1];\n\t\tfor(int j = 1;j<=n;j++){\n\t\t\tarray[j] = sc.nextInt();\n\t\t}\n\t\treturn array;\n\t}\n\tstatic long[] readArrayLong(int n){\n\t\tlong[] array = new long[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextLong();\n\t\treturn array;\n\t}\n\tstatic double[] readArrayDouble(int n){\n\t\tdouble[] array = new double[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextDouble();\n\t\treturn array;\n\t}\n\tstatic int minIndex(int[] array){\n\t\tint minValue = Integer.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(long[] array){\n\t\tlong minValue = Long.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(double[] array){\n\t\tdouble minValue = Double.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic long power(long x, long y){\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y%2 == 1)\n\t\t\treturn (x*power(x, y-1))%mod;\n\t\treturn power((x*x)%mod, y/2)%mod;\n\t}\n\tstatic void verdict(boolean a){\n        out.println(a ? \"YES\" : \"NO\");\n    }\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } \n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String str = \"\";\n            try{\n                str = br.readLine();\n            } \n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n    }\t\n}\n\n//StringJoiner sj = new StringJoiner(\" \"); \n//sj.add(strings)\n//sj.toString() gives string of those stuff w spaces or whatever that sequence is", "label": 3}
{"src": "/**/\n    import java.io.*;\n    import java.util.*;\n    import java.text.*; \n    import java.lang.*;\n    import java.math.*;\npublic class Main{\n/*********************************************Constants***********************************/\n    static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));        \n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static long mod=(long)1e9+7;\n    static long mod1=998244353;\n    static ArrayList<Integer> graph[];\n    static int pptr=0,pptrmax=0;\n    static String st[];\n/*****************************************Solution Begins*********************************/\n    static class MultiTreeSet<K>{\n        TreeMap<K,Integer> map;\n        int sz;\n        MultiTreeSet(){\n            map=new TreeMap<>();\n            sz=0;\n        }\n        boolean contains(K element){\n            return map.containsKey(element);\n        }\n        void add(K element){\n            map.put(element,map.getOrDefault(element,0)+1);\n            sz++;\n        }        \n        void remove(K element){\n            int u=map.get(element);\n            map.put(element,u-1);\n            if(u==1){\n                map.remove(element);\n            }\n            sz--;\n        }\n        K lower(K val){\n            return map.lowerKey(val);\n        }\n        K higher(K val){\n            return map.higherKey(val);\n        }\n        K last(){\n            return map.lastKey();\n        }\n        K first(){\n            return map.firstKey();\n        }\n        int size(){\n            return sz;\n        }\n        boolean isEmpty(){\n            return sz==0;\n        }\n        ArrayList<K> asArray(){\n            ArrayList<K> list=new ArrayList<>();\n            for(K u:map.keySet()){\n                int cur=map.get(u);\n                while(cur-->0){\n                    list.add(u);\n                }\n            }\n            return list;\n        }\n        public String toString(){\n            ArrayList<K> ls=asArray();\n            String str=\"[ \";\n            for(K u:ls)str+=(u+\", \");\n            return str+\" ]\";\n        }\n    }\n\n    static int lis(int a,int b){\n        MultiTreeSet<Long> set=new MultiTreeSet<>();\n        for(int i=a+1;i<=b-1;i++){\n            if(input[i]<input[a] || input[i]>input[b])continue;\n            set.add(input[i]);\n            Long ss=set.higher(input[i]);\n            if(ss!=null){\n                set.remove(ss);\n            }\n        }\n        return (b-a+1)-2-set.size();\n    }\n    static int n;\n    static long input[];\n    static Integer B[];\n    public static void main(String args[]) throws Exception{\n        n=pi();\n        int k=pi();\n        input=new long[n+2];\n        input[0]=-((long)3e10+9);\n        input[n+1]=(long)3e10+9;\n\n        for(int i=1;i<=n;i++){\n            input[i]=pi()-i;\n        }\n        B=new Integer[k+2];\n        B[0]=0;\n        B[k+1]=n+1;\n        for(int i=1;i<=k;i++){\n            B[i]=pi();\n        }\n        long ans=0;\n        Arrays.sort(B);\n        boolean flag=true;\n        for(int i=1;i<k+2;i++){\n            //debug(input[B[i]],input[B[i-1]]);\n\n            if(input[B[i]]<input[B[i-1]]){\n                //debug(\"hihi\",i);\n\n                flag=false;\n            }\n            ans+=lis(B[i-1],B[i]);\n        }\n        if(flag){\n            out.println(ans);\n        }\n        else{\n            out.println(-1);\n        }\n/****************************************Solution Ends*************************************/\n        clr();\n    }\n    static void clr(){\n        out.flush();\n        out.close();\n    }\n    static void nl() throws Exception{\n        pptr=0;\n        st=br.readLine().split(\" \");\n        pptrmax=st.length;\n    }\n    static void nls() throws Exception{\n        pptr=0;\n        st=br.readLine().split(\"\");\n        pptrmax=st.length;\n    }\n    static int pi() throws Exception{\n        if(pptr==pptrmax)\n            nl();\n        return Integer.parseInt(st[pptr++]);\n    }\n    static long pl() throws Exception{\n        if(pptr==pptrmax)\n            nl();\n        return Long.parseLong(st[pptr++]);\n    }\n    static double pd() throws Exception{\n        if(pptr==pptrmax)\n            nl();\n        return Double.parseDouble(st[pptr++]);\n    }\n    static String ps() throws Exception{\n        if(pptr==pptrmax)\n            nl();\n        return st[pptr++];\n    }\n/***************************************Precision Printing*********************************/\n        static void printPrecision(double d){\n            DecimalFormat ft = new DecimalFormat(\"0.00000000000\"); \n            out.println(ft.format(d));\n        }\n/**************************************Bit Count************************************/\n    static int countBit(long mask){\n        int ans=0;\n        while(mask!=0){\n            mask&=(mask-1);\n            ans++;\n        }\n        return ans;\n    }\n/******************************************Graph******************************************/\n    static void Makegraph(int n){\n        graph=new ArrayList[n];\n        for(int i=0;i<n;i++)\n            graph[i]=new ArrayList<>();\n    }\n    static void addEdge(int a,int b){\n        graph[a].add(b);\n    }\n    // static void addEdge(int a,int b,int c){\n    //     graph[a].add(new Pair(b,c));\n    // }    \n/******************************************Pair*****************************************/\n    static class Pair{\n        int u;\n        int v;\n        public Pair(int u, int v) {\n            this.u = u;\n            this.v = v;\n        }\n        public int hashCode() {\n            int hu = (int) (u ^ (u >>> 32));\n            int hv = (int) (v ^ (v >>> 32));\n            return 31 * hu + hv;\n        }\n        public boolean equals(Object o) {\n            Pair other = (Pair) o;\n            return u == other.u && v == other.v;\n        }\n        public String toString() {\n            return \"[u=\" + u + \", v=\" + v + \"]\";\n        }\n    }\n/*****************************************DEBUG********************************************/\n    public static void debug(Object... o){\n        System.err.println(Arrays.deepToString(o));\n    }\n/************************************Modular Exponentiation********************************/\n    static long modulo(long a,long b,long c){\n        long x=1,y=a%c;\n        while(b > 0){\n            if(b%2 == 1)\n                x=(x*y)%c;\n            y = (y*y)%c;\n            b = b>>1;\n        }\n        return  x%c;\n    }\n/********************************************GCD*******************************************/\n    static long gcd(long x, long y){\n        if(x==0)\n            return y;\n        if(y==0)\n            return x;\n        long r=0, a, b;\n        a = (x > y) ? x : y; \n        b = (x < y) ? x : y;\n        r = b;\n        while(a % b != 0){\n            r = a % b;\n            a = b;\n            b = r;\n        }\n        return r;\n    }\n}", "label": 3}
{"src": "//package edu97;\n\nimport java.io.*;\nimport java.util.*;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\n// What's the smallest input?\n// Check * for int/long overflow.\n// Check / for accidental rounding.\n// Are you using doubles? Can you avoid it?\n// Never compare after taking mod.\n// Mod the final result.\n// Initialize globals in solve() unless they are independent of the problem input.\n// Check for local/global name conflicts (n?).\n// Check initial values for max/min (not Integer.MIN_VALUE for long).\npublic class E {\n    static Random rand;\n    static boolean MULTIPLE_CASES = false;\n    static boolean CONSTRUCTIVE = false;\n    static long MOD = (long) 1e9 + 7;\n    static long BIG = (long) 2e9 + 10;\n\n    public static void solve(Reader in, PrintWriter out) {\n        int n = in.ni(), k = in.ni();\n        int[] arr = in.nis(n);\n        int[] b = in.nis(k);\n\n        // check whether feasible\n        boolean ok = true;\n        for (int i = 1; i < k; i++) {\n            // needs to be enough room between the two values\n            int valuesInBetween = b[i] - b[i-1] - 1;\n            int spaces = arr[b[i]-1] - arr[b[i-1]-1] - 1;\n\n            if (valuesInBetween > spaces) {\n                ok = false;\n                break;\n            }\n        }\n\n        if (!ok) {\n            out.println(-1);\n            return;\n        }\n\n        int totalChanged = 0;\n        for (int i = 0; i <= k; i++) {\n            int l = i == 0 ? 0 : b[i-1];\n            int r = i == k ? n - 1 : b[i] - 2;\n            int min = i == 0 ? Integer.MIN_VALUE : arr[b[i-1]-1]+1;\n            int max = i == k ? Integer.MAX_VALUE : arr[b[i]-1]-1;\n\n            int best = r - l + 1;\n//            SortedSet<SubSeq> subSeqs = new TreeSet<>(Comparator.<SubSeq>comparingInt(s -> s.last).thenComparing(s -> s.length));\n            int[] subSeqs = new int[r - l + 2];\n            Arrays.fill(subSeqs, Integer.MAX_VALUE);\n            subSeqs[0] = Integer.MIN_VALUE;\n            for (int j = l; j <= r; j++) {\n                // longest increasing subsequence length\n                boolean feasible = min + j - l <= arr[j] && max - (r - j) >= arr[j];\n                if (feasible) {\n                    int finalJ = j;\n                    int index = binarySearchHighest(0, subSeqs.length-1, mid -> subSeqs[mid] <= arr[finalJ] - finalJ);\n                    subSeqs[index+1] = arr[j] - j;\n                    best = Math.min(best, r - l + 1 - (index + 1));\n                }\n            }\n            totalChanged += best;\n        }\n\n        out.println(totalChanged);\n    }\n\n    static class SubSeq {\n        int last;\n        int length;\n\n        public SubSeq(int last, int length) {\n            this.last = last;\n            this.length = length;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        Reader in = null;\n        PrintWriter out = null;\n        for (String arg : args) {\n            if (arg.startsWith(\"input\")) {\n                in = new Reader(arg);\n            } else if (arg.startsWith(\"output\")) {\n                out = new PrintWriter(new FileWriter(arg));\n            }\n        }\n        if (in == null) in = new Reader();\n        if (out == null) out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        if (MULTIPLE_CASES) {\n            int tests = in.ni();\n            for (int t = 0; t < tests; t++) {\n                solve(in, out);\n            }\n        } else {\n            solve(in, out);\n        }\n\n        out.flush();\n    }\n\n    static class Tester {\n        public static void main(String[] args) throws IOException {\n            Validator validator = new Validator();\n\n            File currentDir = new File(\".\");\n            long before;\n            long after;\n            for (File inputFile : Arrays.stream(currentDir.listFiles())\n                    .sorted(Comparator.comparing(File::getName))\n                    .collect(Collectors.toList())) {\n                if (!inputFile.getName().startsWith(\"input\")\n                        || inputFile.getName().contains(\"sight\")\n                        || inputFile.getName().contains(\"big\")) continue;\n                System.out.println(\"Test file: \" + inputFile.getName());\n\n                before = System.nanoTime();\n                String outputFileName = \"output\" + inputFile.getName().substring(5);\n                E.main(new String[]{inputFile.getName(), outputFileName});\n                after = System.nanoTime();\n\n                File outputFile = new File(outputFileName);\n                if (!outputFile.exists()) {\n                    throw new IllegalStateException(\"Missing output file \" + outputFile);\n                }\n\n                // TODO if verifier is implemented, remove this\n                if (CONSTRUCTIVE) {\n                    System.out.println(\"INPUT:\");\n                    printFile(inputFile);\n                    System.out.printf(\"\\nOUTPUT: (%d milliseconds)\\n\", (after - before) / 1000000L);\n                    printFile(outputFile);\n                    continue;\n                }\n\n                if (validator.validate(inputFile, outputFile)) {\n                    System.out.printf(\"OK (%d milliseconds)\\n\", (after - before) / 1000000L);\n                } else {\n                    System.out.println(\"FAILED\");\n                    System.out.println(\"\\nInput: \");\n                    printFile(inputFile);\n                    System.out.println(\"\\nIncorrect Output: \");\n                    printFile(outputFile);\n                    return;\n                }\n            }\n            System.out.println(\"\\n-----------------\\n\");\n\n            File sightTestInput = new File(\"input-sight\");\n            if (sightTestInput.exists()) {\n                System.out.println(\"Running sight test... Input:\");\n                printFile(sightTestInput);\n                before = System.nanoTime();\n                System.out.println(\"\\nOutput: \");\n                E.main(new String[]{\"input-sight\"});\n                after = System.nanoTime();\n                System.out.printf(\"(%d milliseconds)\\n\", (after - before) / 1000000L);\n                System.out.println(\"\\n-----------------\\n\");\n            }\n\n            File bigTestInput = new File(\"input-big\");\n            if (bigTestInput.exists()) {\n                System.out.println(\"Running big test...\");\n                before = System.nanoTime();\n                E.main(new String[]{\"input-big\"});\n                after = System.nanoTime();\n                System.out.printf(\"(%d milliseconds)\\n\", (after - before) / 1000000L);\n            }\n        }\n\n        static void printFile(File file) throws FileNotFoundException {\n            BufferedReader reader = new BufferedReader(new FileReader(file));\n            reader.lines().forEach(System.out::println);\n        }\n    }\n\n    static class Validator {\n        boolean validate(File inputFile, File outputFile) throws IOException {\n            File expectedOutputFile = new File(\"expected-output\" + inputFile.getName().substring(5));\n            if (CONSTRUCTIVE || !expectedOutputFile.exists()) {\n                return validateManual(inputFile, outputFile);\n            }\n            return areSame(outputFile, expectedOutputFile);\n        }\n\n        private boolean validateManual(File inputFile, File outputFile) throws IOException {\n            if (CONSTRUCTIVE) {\n                // Validate output against input\n                Reader inputReader = new Reader(inputFile.getName());\n                Reader outputReader = new Reader(outputFile.getName());\n\n                // TODO implement manual validation\n\n                throw new IllegalStateException(\"Missing expected output file\");\n            } else {\n                File naiveOutput = new File(\"naive-\" + outputFile.getName());\n                Naive.main(new String[]{inputFile.getName(), naiveOutput.getName()});\n\n                return areSame(outputFile, naiveOutput);\n            }\n        }\n\n        private boolean areSame(File file1, File file2) throws IOException {\n            BufferedReader reader1 = new BufferedReader(new FileReader(file1));\n            BufferedReader reader2 = new BufferedReader(new FileReader(file2));\n\n            String line1;\n            while ((line1 = reader1.readLine()) != null) {\n                String line2 = reader2.readLine();\n                if (line2 == null) line2 = \"\"; // ok if one has an extra newline\n                if (!line1.trim().equals(line2.trim())) {\n                    return false;\n                }\n            }\n            String line2;\n            while ((line2 = reader2.readLine()) != null) {\n                if (!line2.trim().isEmpty()) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n    }\n\n    static class Naive {\n        public static void solveNaive(Reader in, PrintWriter out) {\n            throw new IllegalStateException(\"missing expected output file\");\n        }\n\n        public static void main(String[] args) throws IOException {\n            Reader in = null;\n            PrintWriter out = null;\n            for (String arg : args) {\n                if (arg.startsWith(\"input\")) {\n                    in = new Reader(arg);\n                } else if (arg.startsWith(\"naive-output\")) {\n                    out = new PrintWriter(new FileWriter(arg));\n                }\n            }\n            if (in == null) in = new Reader();\n            if (out == null) out = new PrintWriter(new OutputStreamWriter(System.out));\n\n            int tests = in.ni();\n            for (int t = 0; t < tests; t++) {\n                solveNaive(in, out);\n            }\n\n            out.flush();\n            out.close();\n        }\n    }\n\n    static boolean isPowerOfTwo(int x) {\n        return x > 0 & (x & (x - 1)) == 0;\n    }\n\n    static int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n\n    static void ruffleSort(int[] a) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {\n            int oi = rand.nextInt(n), temp = a[oi];\n            a[oi] = a[i];\n            a[i] = temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static void ruffleSort(long[] a) {\n        int n = a.length;\n        for (int i = 0; i < n; i++) {\n            int oi = rand.nextInt(n);\n            long temp = a[oi];\n            a[oi] = a[i];\n            a[i] = temp;\n        }\n        Arrays.sort(a);\n    }\n\n    ///////////////////////////////////\n    //////////   FAST PAIR   //////////\n    ///////////////////////////////////\n\n    // Works on -1e9 <= x, y <= 1e9\n    static long pair(int x, int y) {\n        x = (int) BIG / 2 - x;\n        y = (int) BIG / 2 - y;\n        return x * BIG + y;\n    }\n\n    static int x(long pair) {\n        return (int) BIG / 2 - (int) (pair / BIG);\n    }\n\n    static int y(long pair) {\n        return (int) BIG / 2 - (int) (pair % BIG);\n    }\n\n    static String str(long pair) {\n        return String.format(\"(%d, %d)\", x(pair), y(pair));\n    }\n\n    ///////////////////////////////////\n    ////////// BINARY SEARCH //////////\n    ///////////////////////////////////\n\n    // return highest in range that still returns true\n    // T T T F F F F\n    // invariant:\n    // -    indicator(min) = true\n    // -    indicator(max+1) = false\n    static int binarySearchHighest(int min, int max, Function<Integer, Boolean> indicator) {\n        int a = min;\n        int b = max;\n        while (a != b) {\n            int mid = (a % 2 != b % 2) ? 1 + (a + b) / 2 : (a + b) / 2;\n            if (indicator.apply(mid)) {\n                a = mid;\n            } else {\n                b = mid - 1;\n            }\n        }\n        return a;\n    }\n\n    // return lowest in range that still returns true\n    // F F F F T T T\n    // invariant:\n    // -    indicator(min-1) = false\n    // -    indicator(max) = true\n    static int binarySearchLowest(int min, int max, Function<Integer, Boolean> indicator) {\n        int a = min;\n        int b = max;\n        while (a != b) {\n            int mid = (a + b) / 2;\n            if (indicator.apply(mid)) {\n                b = mid;\n            } else {\n                a = mid + 1;\n            }\n        }\n        return a;\n    }\n\n    static void insist(boolean bool) {\n        if (!bool) throw new IllegalStateException();\n    }\n\n    static class Reader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public Reader() {\n            reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n            tokenizer = null;\n        }\n\n        public Reader(String fileName) throws FileNotFoundException {\n            reader = new BufferedReader(new FileReader(fileName));\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(next());\n        }\n\n        public long nl() {\n            return Long.parseLong(next());\n        }\n\n        public int[] nis(int n) {\n            int[] out = new int[n];\n            for (int i = 0; i < n; i++) {\n                out[i] = ni();\n            }\n            return out;\n        }\n\n        public long[] nls(int n) {\n            long[] out = new long[n];\n            for (int i = 0; i < n; i++) {\n                out[i] = nl();\n            }\n            return out;\n        }\n    }\n}\n", "label": 3}
{"src": "//package ecr97;\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Queue;\n\npublic class E {\n\tInputStream is;\n\tFastWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint K = ni();\n\t\tint[] a = na(n);\n\t\tboolean[] fix = new boolean[n];\n\t\tfor(int i = 0;i < K;i++){\n\t\t\tfix[ni()-1] = true;\n\t\t}\n\t\t// open open LIS of equal\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\ta[i] = a[i] - i + 500000;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0;i < n;){\n\t\t\tint j = i;\n\t\t\twhile(j < n && !fix[j]){\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tint res = go(a, i-1, j);\n\t\t\tif(res == -1){\n\t\t\t\tout.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tans += res;\n\n\t\t\ti = j + 1;\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tint go(int[] a, int l, int r)\n\t{\n\t\tint n = a.length;\n\t\tint lv = l < 0 ? Integer.MIN_VALUE : a[l];\n\t\tint rv = r >= n ? Integer.MAX_VALUE : a[r];\n\t\tif(lv > rv)return -1;\n\t\tl++; r--;\n\t\tlong[] b = new long[r-l+1];\n\t\tint p = 0;\n\t\tfor(int i = l;i <= r;i++){\n\t\t\tif(lv <= a[i] && a[i] <= rv) {\n\t\t\t\tb[p++] = (long)a[i]<<32|i;\n\t\t\t}\n\t\t}\n\t\treturn r-l+1 - lis(Arrays.copyOf(b, p));\n\t}\n\n\tpublic static int lis(long[] in)\n\t{\n\t\tint n = in.length;\n\t\tint ret = 0;\n\t\tlong[] h = new long[n + 1];\n\t\tArrays.fill(h, Long.MIN_VALUE / 2);\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint ind = Arrays.binarySearch(h, 0, ret + 1, in[i]);\n\t\t\tif(ind < 0){\n\t\t\t\tind = -ind-2;\n\t\t\t\th[ind+1] = in[i];\n\t\t\t\tif(ind >= ret)ret++;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new FastWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new E().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate long[] nal(int n)\n\t{\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = na(m);\n\t\treturn map;\n\t}\n\n\tprivate int ni() { return (int)nl(); }\n\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tpublic static class FastWriter\n\t{\n\t\tprivate static final int BUF_SIZE = 1<<13;\n\t\tprivate final byte[] buf = new byte[BUF_SIZE];\n\t\tprivate final OutputStream out;\n\t\tprivate int ptr = 0;\n\n\t\tprivate FastWriter(){out = null;}\n\n\t\tpublic FastWriter(OutputStream os)\n\t\t{\n\t\t\tthis.out = os;\n\t\t}\n\n\t\tpublic FastWriter(String path)\n\t\t{\n\t\t\ttry {\n\t\t\t\tthis.out = new FileOutputStream(path);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tthrow new RuntimeException(\"FastWriter\");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter write(byte b)\n\t\t{\n\t\t\tbuf[ptr++] = b;\n\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(char c)\n\t\t{\n\t\t\treturn write((byte)c);\n\t\t}\n\n\t\tpublic FastWriter write(char[] s)\n\t\t{\n\t\t\tfor(char c : s){\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(String s)\n\t\t{\n\t\t\ts.chars().forEach(c -> {\n\t\t\t\tbuf[ptr++] = (byte)c;\n\t\t\t\tif(ptr == BUF_SIZE)innerflush();\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(int l) {\n\t\t\tif (l >= 1000000000) return 10;\n\t\t\tif (l >= 100000000) return 9;\n\t\t\tif (l >= 10000000) return 8;\n\t\t\tif (l >= 1000000) return 7;\n\t\t\tif (l >= 100000) return 6;\n\t\t\tif (l >= 10000) return 5;\n\t\t\tif (l >= 1000) return 4;\n\t\t\tif (l >= 100) return 3;\n\t\t\tif (l >= 10) return 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(int x)\n\t\t{\n\t\t\tif(x == Integer.MIN_VALUE){\n\t\t\t\treturn write((long)x);\n\t\t\t}\n\t\t\tif(ptr + 12 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)'-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)('0'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(long l) {\n\t\t\tif (l >= 1000000000000000000L) return 19;\n\t\t\tif (l >= 100000000000000000L) return 18;\n\t\t\tif (l >= 10000000000000000L) return 17;\n\t\t\tif (l >= 1000000000000000L) return 16;\n\t\t\tif (l >= 100000000000000L) return 15;\n\t\t\tif (l >= 10000000000000L) return 14;\n\t\t\tif (l >= 1000000000000L) return 13;\n\t\t\tif (l >= 100000000000L) return 12;\n\t\t\tif (l >= 10000000000L) return 11;\n\t\t\tif (l >= 1000000000L) return 10;\n\t\t\tif (l >= 100000000L) return 9;\n\t\t\tif (l >= 10000000L) return 8;\n\t\t\tif (l >= 1000000L) return 7;\n\t\t\tif (l >= 100000L) return 6;\n\t\t\tif (l >= 10000L) return 5;\n\t\t\tif (l >= 1000L) return 4;\n\t\t\tif (l >= 100L) return 3;\n\t\t\tif (l >= 10L) return 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(long x)\n\t\t{\n\t\t\tif(x == Long.MIN_VALUE){\n\t\t\t\treturn write(\"\" + x);\n\t\t\t}\n\t\t\tif(ptr + 21 >= BUF_SIZE)innerflush();\n\t\t\tif(x < 0){\n\t\t\t\twrite((byte)'-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor(int i = ptr + d - 1;i >= ptr;i--){\n\t\t\t\tbuf[i] = (byte)('0'+x%10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(double x, int precision)\n\t\t{\n\t\t\tif(x < 0){\n\t\t\t\twrite('-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tx += Math.pow(10, -precision)/2;\n\t\t\t//\t\tif(x < 0){ x = 0; }\n\t\t\twrite((long)x).write(\".\");\n\t\t\tx -= (long)x;\n\t\t\tfor(int i = 0;i < precision;i++){\n\t\t\t\tx *= 10;\n\t\t\t\twrite((char)('0'+(int)x));\n\t\t\t\tx -= (int)x;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(char c){\n\t\t\treturn write(c).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(int x){\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long x){\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(double x, int precision){\n\t\t\treturn write(x, precision).writeln();\n\t\t}\n\n\t\tpublic FastWriter write(int... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(int x : xs) {\n\t\t\t\tif (!first) write(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(long... xs)\n\t\t{\n\t\t\tboolean first = true;\n\t\t\tfor(long x : xs) {\n\t\t\t\tif (!first) write(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln()\n\t\t{\n\t\t\treturn write((byte)'\\n');\n\t\t}\n\n\t\tpublic FastWriter writeln(int... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long... xs)\n\t\t{\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[] line)\n\t\t{\n\t\t\treturn write(line).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[]... map)\n\t\t{\n\t\t\tfor(char[] line : map)write(line).writeln();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(String s)\n\t\t{\n\t\t\treturn write(s).writeln();\n\t\t}\n\n\t\tprivate void innerflush()\n\t\t{\n\t\t\ttry {\n\t\t\t\tout.write(buf, 0, ptr);\n\t\t\t\tptr = 0;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"innerflush\");\n\t\t\t}\n\t\t}\n\n\t\tpublic void flush()\n\t\t{\n\t\t\tinnerflush();\n\t\t\ttry {\n\t\t\t\tout.flush();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"flush\");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter print(byte b) { return write(b); }\n\t\tpublic FastWriter print(char c) { return write(c); }\n\t\tpublic FastWriter print(char[] s) { return write(s); }\n\t\tpublic FastWriter print(String s) { return write(s); }\n\t\tpublic FastWriter print(int x) { return write(x); }\n\t\tpublic FastWriter print(long x) { return write(x); }\n\t\tpublic FastWriter print(double x, int precision) { return write(x, precision); }\n\t\tpublic FastWriter println(char c){ return writeln(c); }\n\t\tpublic FastWriter println(int x){ return writeln(x); }\n\t\tpublic FastWriter println(long x){ return writeln(x); }\n\t\tpublic FastWriter println(double x, int precision){ return writeln(x, precision); }\n\t\tpublic FastWriter print(int... xs) { return write(xs); }\n\t\tpublic FastWriter print(long... xs) { return write(xs); }\n\t\tpublic FastWriter println(int... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(long... xs) { return writeln(xs); }\n\t\tpublic FastWriter println(char[] line) { return writeln(line); }\n\t\tpublic FastWriter println(char[]... map) { return writeln(map); }\n\t\tpublic FastWriter println(String s) { return writeln(s); }\n\t\tpublic FastWriter println() { return writeln(); }\n\t}\n\n\tpublic void trnz(int... o)\n\t{\n\t\tfor(int i = 0;i < o.length;i++)if(o[i] != 0)System.out.print(i+\":\"+o[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\n\t// print ids which are 1\n\tpublic void trt(long... o)\n\t{\n\t\tQueue<Integer> stands = new ArrayDeque<>();\n\t\tfor(int i = 0;i < o.length;i++){\n\t\t\tfor(long x = o[i];x != 0;x &= x-1)stands.add(i<<6|Long.numberOfTrailingZeros(x));\n\t\t}\n\t\tSystem.out.println(stands);\n\t}\n\n\tpublic void tf(boolean... r)\n\t{\n\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\tSystem.out.println();\n\t}\n\n\tpublic void tf(boolean[]... b)\n\t{\n\t\tfor(boolean[] r : b) {\n\t\t\tfor(boolean x : r)System.out.print(x?'#':'.');\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic void tf(long[]... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long[] r : b) {\n\t\t\t\tfor (long x : r) {\n\t\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\t\tSystem.out.print(x << ~i < 0 ? '#' : '.');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic void tf(long... b)\n\t{\n\t\tif(INPUT.length() != 0) {\n\t\t\tfor (long x : b) {\n\t\t\t\tfor (int i = 0; i < 64; i++) {\n\t\t\t\t\tSystem.out.print(x << ~i < 0 ? '#' : '.');\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class tr0 {\n\tstatic PrintWriter out;\n\tstatic StringBuilder sb;\n\tstatic long mod = (long) 1e9 + 7;\n\tstatic long inf = (long) 1e16;\n\tstatic int n, k, l;\n\tstatic ArrayList<Integer>[] ad;\n\tstatic int[][] memo;\n\tstatic boolean vis[];\n\tstatic long[] f, inv, ncr[];\n\tstatic HashMap<Integer, Integer> hm;\n\tstatic int[] a;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tn = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\ta = new int[n + 2];\n\t\tboolean[] here = new boolean[n + 2];\n\t\there[0] = true;\n\t\there[n + 1] = true;\n\t\ta[0] = -2000000000;\n\t\ta[n + 1] = 2000000000;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\ta[i] = sc.nextInt();\n\t\tint ans = 0;\n\t\tif (k != 0) {\n\t\t\tint[] idc = new int[k];\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tidc[i] = sc.nextInt();\n\t\t\t\there[idc[i]] = true;\n\t\t\t}\n\t\t\tfor (int i = 1; i < k; i++) {\n\t\t\t\tint x = a[idc[i]];\n\t\t\t\tint y = a[idc[i - 1]];\n\t\t\t\tif (x <= y || x - y < idc[i] - idc[i - 1]) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l = 0;\n\t\tfor (int i = 1; i < a.length; i++)\n\t\t\tif (here[i]) {\n\t\t\t\tans += lis(a, l, i);\n\t\t\t\tl = i;\n\t\t\t}\n\t\tSystem.out.println(ans);\n\t\tout.close();\n\t}\n\n\tstatic int lis(int[] A, int l, int r) {\n\t\tfor (int i = l; i <= r; i++)\n\t\t\tA[i] -= i;\n\t\tConvexSet set = new ConvexSet();\n\t\tint max = 0;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tLong key = set.floorKey(A[i]);\n\t\t\tlong length = 1;\n\t\t\tif (key != null)\n\t\t\t\tlength = 1 + set.get(key);\n\t\t\telse if (i > l)\n\t\t\t\tcontinue;\n\t\t\tset.put(A[i], length);\n\t\t\tmax = Math.max(max, (int) length);\n\t\t}\n\t\tint ans = (int) ((long) set.get(A[r]));\n\t\tfor (int i = l; i <= r; i++)\n\t\t\tA[i] += i;\n\t\treturn r - l + 1 - ans;\n\t}\n\n\tstatic class ConvexSet {\n\t\tTreeMap<Long, Long> map;\n\n\t\tpublic ConvexSet() {\n\t\t\tmap = new TreeMap<>();\n\t\t}\n\n\t\tvoid put(long key, long val) {\n\t\t\tMap.Entry<Long, Long> e;\n\t\t\tif ((e = map.floorEntry(key)) != null && e.getValue() >= val)\n\t\t\t\treturn;\n\t\t\twhile (!map.isEmpty() && (e = map.ceilingEntry(key)) != null && e.getValue() <= val)\n\t\t\t\tmap.remove(e.getKey());\n\t\t\tmap.put(key, val);\n\t\t}\n\n\t\tLong get(long k) {\n\t\t\treturn map.get(k);\n\t\t}\n\n\t\tLong floorKey(long k) {\n\t\t\treturn map.floorKey(k);\n\t\t}\n\t}\n\n\tstatic int solve(int l, int r) {\n\t\tint ans = 0;\n\t\tint len = r - l + 1;\n\t\tFenwickTree ft = new FenwickTree(len + 3);\n\t\tTreeSet<Integer> ts = new TreeSet<>();\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tts.add(a[i] - i);\n\t\t}\n\t\tHashMap<Integer, Integer> hm = new HashMap<>();\n\t\tint id = 1;\n\t\twhile (!ts.isEmpty())\n\t\t\thm.put(ts.pollFirst(), id++);\n\t\tft.point_update(hm.get(a[l] - l), 1);\n\t\tfor (int i = l + 1; i <= r; i++) {\n\t\t\tint best = ft.rsq(hm.get(a[i] - i));\n\t\t\tft.point_update(hm.get(a[i] - i), best + 1);\n\t\t\tif (i == r)\n\t\t\t\tans = best + 1;\n\t\t}\n\t\treturn len - ans;\n\t}\n\n\tpublic static class FenwickTree { // one-based DS\n\n\t\tint ni;\n\t\tint[] ft;\n\n\t\tFenwickTree(int size) {\n\t\t\tni = size;\n\t\t\tft = new int[ni + 1];\n\t\t}\n\n\t\tint rsq(int b) // O(log n)\n\t\t{\n\t\t\tint max = 0;\n\t\t\twhile (b > 0) {\n\t\t\t\tmax = Math.max(max, ft[b]);\n\t\t\t\tb -= b & -b;\n\t\t\t} // min?\n\t\t\treturn max;\n\t\t}\n\n\t\tvoid point_update(int k, int val) // O(log n), update = increment\n\t\t{\n\t\t\twhile (k <= ni) {\n\t\t\t\tft[k] = Math.max(val, ft[k]);\n\t\t\t\tk += k & -k;\n\t\t\t} // min?\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int[] nextArrInt(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextArrLong(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "label": 3}
{"src": "import java.awt.*;\nimport java.io.*;\nimport java.util.*;\nimport java.util.List;\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class Coding {\n\n    private static BufferedReader bi = new BufferedReader(new InputStreamReader(System.in));\n    private static BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n\n    public static void main(String[] args) {\n        try {\n            run();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void run() throws Exception {\n        InputModule inp = new InputModule();\n        OutputModule out = new OutputModule();\n        int t = 1;\n        while (t > 0) {\n            int[] inps = inp.cinIntArray(2);\n            int n = inps[0];\n            int k = inps[1];\n            int[] ints = inp.cinIntArray(n);\n            Set<Integer> has = new HashSet<>();\n            if (k > 0) {\n                inps = inp.cinIntArray(k);\n                for (int i = 0; i < k; ++i) {\n                    has.add(inps[i]);\n                }\n            }\n            boolean poss = true;\n            int ans = 0;\n            int prev = -1;\n            for (int i = 0; i < n; ++i) {\n                if (has.contains(i+1)) {\n                    if ((prev != -1) && (ints[i] < (ints[prev] + i - prev))) {\n                        poss = false;\n                        break;\n                    }\n                    int len = i - prev - 1;\n                    if (len > 0) {\n                        int[] tmp = new int[len];\n                        for (int j = 0; j < len; ++j) {\n                            tmp[j] = ints[prev + 1 + j];\n                        }\n                        ans += LongestIncreasingSubsequenceLength(tmp, len, prev == -1 ? -1 : ints[prev], ints[i]);\n                       // System.out.println(i + \" \" + ans);\n                    }\n                    prev = i;\n                }\n            }\n\n            int len = n - prev - 1;\n            if (len > 0) {\n                int[] tmp = new int[len];\n                for (int j = 0; j < len; ++j) {\n                    tmp[j] = ints[prev + 1 + j];\n                }\n                ans += LongestIncreasingSubsequenceLength(tmp, len, prev == -1 ? -1 : ints[prev], -1);\n            }\n            if (poss) {\n                out.printInt(ans);\n            } else {\n                out.printInt(-1);\n            }\n            t--;\n        }\n    }\n\n    // Binary search (note boundaries in the caller)\n    // A[] is ceilIndex in the caller\n    static int CeilIndex(int tailTable[], int l, int r, int[] A, int keyIndex) {\n        while (r - l > 1) {\n            int m = l + (r - l) / 2;\n            if (A[tailTable[m]] >= A[keyIndex])\n                r = m;\n            else if ((A[keyIndex]-A[tailTable[m]]<(keyIndex-tailTable[m]))) {\n                r = m;\n            }\n            else\n                l = m;\n        }\n\n        return r;\n    }\n\n    static int LongestIncreasingSubsequenceLength(int A[], int size, int lval, int rval) {\n        // Add boundary case, when array size is one\n        //System.out.println(\"LCS for len : \" + size);\n\n        int[] tailTable = new int[size];\n        int len; // always points empty slot\n\n        tailTable[0] = Integer.MAX_VALUE;\n        len = 0;\n        for (int i = 0; i < size; i++) {\n            boolean poss = true;\n            if (lval != -1) {\n                int diff = A[i] - lval;\n                if (diff < i + 1) {\n                    poss = false;\n                }\n            }\n            if (rval != -1) {\n                int diff = rval - A[i];\n                if (diff < size - i) {\n                    poss = false;\n                }\n            }\n            if (!poss) {\n                continue;\n            }\n            //System.out.println(\"Index : \" + i + \" value : \" + A[i]);\n\n            if (len == 0) {\n                len = 1;\n                tailTable[0] = i;\n            } else if (A[i] < A[tailTable[0]]) {\n                tailTable[0] = i;\n            } else if (A[i] > A[tailTable[len - 1]] && (A[i] - A[tailTable[len - 1]])>=(i-tailTable[len - 1])) {\n                tailTable[len++] = i;\n            } else {\n                tailTable[CeilIndex(tailTable, -1, len - 1, A, i)] = i;\n            }\n        }\n\n        return size - len;\n    }\n\n\n    private static class InputModule {\n        private int cinInt() throws Exception {\n            return Integer.parseInt(bi.readLine().split(\" \")[0].trim());\n        }\n\n        private long cinLong() throws Exception {\n            return Long.parseLong(bi.readLine().split(\" \")[0].trim());\n        }\n\n        private Double cinDouble() throws Exception {\n            return Double.parseDouble(bi.readLine().split(\" \")[0].trim());\n        }\n\n        private String cinString() throws Exception {\n            return bi.readLine();\n        }\n\n        private int[] cinIntArray(int n) throws Exception {\n            String input = bi.readLine();\n            String[] values = input.split(\" \");\n            int[] ar = new int[n];\n            for (int i = 0; i < n; ++i) {\n                ar[i] = Integer.parseInt(values[i]);\n            }\n            return ar;\n        }\n\n        private long[] cinLongArray(int n) throws Exception {\n            String input = bi.readLine();\n            String[] values = input.split(\" \");\n            long[] ar = new long[n];\n            for (int i = 0; i < n; ++i) {\n                ar[i] = Long.parseLong(values[i]);\n            }\n            return ar;\n        }\n\n        private String[] cinStringArray(int n) throws Exception {\n            return bi.readLine().split(\" \");\n        }\n    }\n\n    private static class OutputModule {\n        private void printInt(int ans) throws Exception {\n            writer.append(ans + \"\\n\");\n            writer.flush();\n        }\n\n        private void printLong(long ans) throws Exception {\n            writer.append(ans + \"\\n\");\n            writer.flush();\n        }\n\n        private void printDouble(Double ans) throws Exception {\n            writer.append(String.format(\"%.10f\", ans));\n            writer.append(\"\\n\");\n            writer.flush();\n        }\n\n        private void printString(String ans) throws Exception {\n            writer.append(ans + \"\\n\");\n            writer.flush();\n        }\n\n        private void printIntArray(int[] ans) throws Exception {\n            for (int i = 0; i < ans.length; ++i) {\n                writer.append(ans[i] + \" \");\n            }\n            writer.append(\"\\n\");\n            writer.flush();\n        }\n\n        private void printLongArray(long[] ans) throws Exception {\n            for (int i = 0; i < ans.length; ++i) {\n                writer.append(ans[i] + \" \");\n            }\n            writer.append(\"\\n\");\n            writer.flush();\n        }\n\n        private void printIntMatrix(int[][] mat, int n, int m) throws Exception {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    writer.append(mat[i][j] + \" \");\n                }\n                writer.append(\"\\n\");\n            }\n            writer.flush();\n        }\n\n        private void printLongMatrix(long[][] mat, int n, int m) throws Exception {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    writer.append(mat[i][j] + \" \");\n                }\n                writer.append(\"\\n\");\n            }\n            writer.flush();\n        }\n\n        private void printPoint(Point p) throws Exception {\n            writer.append(p.x + \" \" + p.y + \"\\n\");\n            writer.flush();\n        }\n\n        private void printPoints(List<Point> p) throws Exception {\n            for (Point pp : p) {\n                writer.append(pp.x + \" \" + pp.y + \"\\n\");\n            }\n            writer.flush();\n        }\n    }\n}", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class E1437 {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tlong[] arr = new long[n + 2];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tarr[i] = sc.nextInt();\n\t\t}\n\t\tarr[n + 1] = (int) 2e9;\n\t\tarr[0] = -(int) 2e9;\n\t\tlong[] cost = new long[n + 2];\n\t\tArrays.fill(cost, 1);\n\t\twhile (k-- > 0) {\n\t\t\tcost[sc.nextInt()] = (int) 1e6;\n\t\t}\n\t\tcost[n + 1] = (int) 1e6;\n\t\tcost[0] = (int) 1e6;\n\t\tfor (int i = 1; i < cost.length; i++) {\n\t\t\tcost[i] += cost[i - 1];\n\t\t}\n\t\tInteger[] order = new Integer[n + 2];\n\t\tfor (int i = 0; i < order.length; i++) {\n\t\t\torder[i] = i;\n\t\t}\n\t\tArrays.sort(order, (u, v) -> (arr[u] - u == arr[v] - v) ? u - v : Long.compare((arr[u] - u), (arr[v] - v)));\n\t\tint N = 1;\n\t\twhile (N < n + 2)\n\t\t\tN <<= 1;\n\n\t\tlong[] in = new long[N + 1];\n\t\tfor (int i = 1; i < in.length; i++)\n\t\t\tin[i] = (long) 1e9;\n\t\tSegmentTree sg = new SegmentTree(in);\n\t\tsg.update_point(1, -cost[0]);\n\t\tfor (int i = 1; i < order.length; i++) {\n\t\t\tint j = order[i];\n\t\t\tlong query = sg.query(1, j);\n\t\t\tsg.update_point(j + 1, query + cost[j - 1] - cost[j]);\n\t\t}\n//\t\tfor (int i = 1; i <= n + 2; i++) {\n//\t\t\tpw.print(sg.query(i, i) + cost[i - 1] + \" \");\n//\t\t}\n//\t\tpw.println();\n//\t\tpw.println(Arrays.toString(cost));\n//\t\tpw.println();\n\t\tlong ans = sg.query(n + 2, n + 2) + cost[n + 1];\n\t\tpw.println(ans > n ? -1 : ans);\n\t\tpw.close();\n\n\t}\n\n\tstatic class SegmentTree { // 1-based DS, OOP\n\n\t\tint N; // the number of elements in the array as a power of 2 (i.e. after padding)\n\t\tlong[] array, sTree;\n\n\t\tSegmentTree(long[] in) {\n\t\t\tarray = in;\n\t\t\tN = in.length - 1;\n\t\t\tsTree = new long[N << 1]; // no. of nodes = 2*N - 1, we add one to cross out index zero\n\t\t\tbuild(1, 1, N);\n\t\t}\n\n\t\tvoid build(int node, int b, int e) // O(n)\n\t\t{\n\t\t\tif (b == e)\n\t\t\t\tsTree[node] = array[b];\n\t\t\telse {\n\t\t\t\tint mid = b + e >> 1;\n\t\t\t\tbuild(node << 1, b, mid);\n\t\t\t\tbuild(node << 1 | 1, mid + 1, e);\n\t\t\t\tsTree[node] = sTree[node << 1] + sTree[node << 1 | 1];\n\t\t\t}\n\t\t}\n\n\t\tvoid update_point(int index, long val) // O(log n)\n\t\t{\n\t\t\tindex += N - 1;\n\t\t\tsTree[index] = val;\n\t\t\twhile (index > 1) {\n\t\t\t\tindex >>= 1;\n\t\t\t\tsTree[index] = Math.min(sTree[index << 1], sTree[index << 1 | 1]);\n\t\t\t}\n\t\t}\n\n\t\tlong query(int i, int j) {\n\t\t\tif (i > j)\n\t\t\t\treturn 0;\n\t\t\treturn query(1, 1, N, i, j);\n\t\t}\n\n\t\tlong query(int node, int b, int e, int i, int j) // O(log n)\n\t\t{\n\t\t\tif (i > e || j < b)\n\t\t\t\treturn (long) 1e9;\n\t\t\tif (b >= i && e <= j)\n\t\t\t\treturn sTree[node];\n\t\t\tint mid = b + e >> 1;\n\t\t\tlong q1 = query(node << 1, b, mid, i, j);\n\t\t\tlong q2 = query(node << 1 | 1, mid + 1, e, i, j);\n\t\t\treturn Math.min(q1, q2);\n\t\t}\n\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(FileReader f) {\n\t\t\tbr = new BufferedReader(f);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArr(int n) throws IOException {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Integer.parseInt(next());\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t}\n\n}\n", "label": 3}
{"src": "/*\n    Java might be good for Competitive Programming but Python still rocks!!!!!!!!!\n\n\n                            pppppppppppppppppppp\n                         ppppp  ppppppppppppppppppp\n                      ppppppp    ppppppppppppppppppppp\n                      pppppppp  pppppppppppppppppppppp\n                      pppppppppppppppppppppppppppppppp\n                              pppppppppppppppppppppppp\n       ppppppppppppppppppppppppppppppppppppppppppppppp  pppppppppppppppppppp\n      pppppppppppppppppppppppppppppppppppppppppppppppp  ppppppppppppppppppppp\n     ppppppppppppppppppppppppppppppppppppppppppppppppp  pppppppppppppppppppppp\n    ppppppppppppppppppppppppppppppppppppppppppppppp    pppppppppppppppppppppppp\n   pppppppppppppppppppppppppppppppppppppppppppppp     pppppppppppppppppppppppppp\n  ppppppppppppppppppppppppppppppppppppppppppppp      pppppppppppppppppppppppppppp\n  pppppppppppppppppppppppppppppppp               pppppppppppppppppppppppppppppppp\n  pppppppppppppppppppppppppppp     pppppppppppppppppppppppppppppppppppppppppppppp\n  ppppppppppppppppppppppppppp    pppppppppppppppppppppppppppppppppppppppppppppppp\n    pppppppppppppppppppppppp  pppppppppppppppppppppppppppppppppppppppppppppppppp\n     ppppppppppppppppppppppp  ppppppppppppppppppppppppppppppppppppppppppppppppp\n      pppppppppppppppppppppp  ppppppppppppppppppppppppppppppppppppppppppppppp\n       ppppppppppppppppppppp  ppppppppppppppppppppppppppppppppppppppppppppp\n                              pppppppppppppppppppppppp\n                              pppppppppppppppppppppppppppppppp\n                              pppppppppppppppppppppp  pppppppp\n                              ppppppppppppppppppppp    ppppppp\n                                 ppppppppppppppppppp  ppppp\n                                    pppppppppppppppppppp\n*/\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic final class ProblemE\n{\n    public static BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n    public static int t, n, i, j, k, u, v, w, inf = 1_000_000_000;\n    public static int[] arr = new int[500011], b = new int[500011];\n    public static long answer = 0;\n    public static ArrayList<Integer> LIS;\n    public static void main(String[] args) throws IOException\n    {\n        FastScanner sc = new FastScanner();\n        Print print = new Print();\n        n = sc.nextInt();\n        k = sc.nextInt();\n        arr[0] = -inf;\n        for(i = 1; i <= n; i++)\n            arr[i] = sc.nextInt() - i;\n        arr[i] = inf;\n        for(i = 1; i <= k; i++)\n            b[i] = sc.nextInt();\n        b[i] = n + 1;\n        for(j = 0; j <= k; j++)\n        {\n            u = b[j];\n            v = b[j + 1];\n            if(arr[u] > arr[v])\n            {\n                out.write(\"-1\\n\");\n                out.flush();\n                out.close();\n                return;\n            }\n            LIS = new ArrayList<>();\n            for(i = u + 1; i < v; i++)\n                if(arr[u] <= arr[i] && arr[i] <= arr[v])\n                {\n                    int index = bisect_right(arr[i]);\n//                    System.out.println(LIS + \" \" + arr[i] + \" \" + index);\n                    if(index == -1)\n                        LIS.add(arr[i]);\n                    else\n                        LIS.set(index, arr[i]);\n                }\n            answer += v - u - LIS.size() - 1;\n        }\n        out.write(answer + \"\\n\");\n        out.close();\n        out.close();\n    }\n\n    public static int bisect_right(int k)\n    {\n        int s = 0;\n        int e = LIS.size();\n        while (s != e)\n        {\n            int mid = s + e >> 1;\n            if (LIS.get(mid) <= k)\n                s = mid + 1;\n            else\n                e = mid;\n        }\n        if(s == LIS.size())\n            return -1;\n        return s;\n    }\n\n    public static class Print\n    {\n        Print()\n        {}\n\n        void integer(int... arr) throws IOException\n        {\n            for(int value: arr)\n            {\n                out.write(value+\" \");\n                out.flush();\n            }\n            out.write(\"\\n\");\n            out.flush();\n        }\n\n        void string(String... arr) throws IOException\n        {\n            for(String value: arr)\n            {\n                out.write(value+\" \");\n                out.flush();\n            }\n            out.write(\"\\n\");\n            out.flush();\n        }\n\n        void character(char... arr) throws IOException\n        {\n            for(char value: arr)\n            {\n                out.write(value+\" \");\n                out.flush();\n            }\n            out.write(\"\\n\");\n            out.flush();\n        }\n\n        void long_int(long... arr) throws IOException\n        {\n            for(long value: arr)\n            {\n                out.write(value+\" \");\n                out.flush();\n            }\n            out.write(\"\\n\");\n            out.flush();\n        }\n    }\n\n    static class FastScanner\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String next()\n        {\n            while (!st.hasMoreTokens())\n                try\n                {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        int[] readArray(int n)\n        {\n            int[] a=new int[n];\n            for (int i=0; i<n; i++) a[i]=nextInt();\n            return a;\n        }\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1437e {\n\n    public static void main(String[] args) throws IOException {\n        int n = rni(), k = ni(), a[] = ria(n);\n        for (int i = 0; i < n; ++i) {\n            a[i] -= i;\n        }\n        if (k == 0) {\n            prln(n - lis(a, 0, n, -IBIG, IBIG));\n        } else {\n            int b[] = riam1(k), lb = -IBIG, ub, last = -1, ans = 0;\n            for (int i = 1; i < k; ++i) {\n                if (a[b[i]] < a[b[i - 1]]) {\n                    prln(-1);\n                    close();\n                    return;\n                }\n            }\n            for (int i = 0; i < k; ++i) {\n                ub = a[b[i]];\n                /* prln(last + 1, b[i], lb, ub);\n                for (int j = last + 1; j < b[i]; ++j) {\n                    pr(a[j]);\n                    pr(' ');\n                }\n                prln(); */\n                ans += (b[i] - last - 1) - lis(a, last + 1, b[i], lb, ub);\n                lb = ub;\n                last = b[i];\n                // prln(ans);\n            }\n            ub = IBIG;\n            ans += (n - last - 1) - lis(a, last + 1, n, lb, ub);\n            prln(ans);\n        }\n        close();\n    }\n\n    static int lis(int[] a, int s, int e, int lb, int ub) {\n        int n = e - s, tail[] = new int[n], len = 1;\n        int i = s;\n        while (i < e && (a[i] < lb || a[i] > ub)) {\n            ++i;\n        }\n        if (i == e) {\n            return 0;\n        }\n        tail[0] = a[i];\n        for (++i; i < e; ++i) {\n            if (a[i] < lb || a[i] > ub) {\n                continue;\n            }\n            if (a[i] < tail[0]) {\n                tail[0] = a[i];\n            } else if (a[i] >= tail[len - 1]) {\n                tail[len++] = a[i];\n            } else {\n                int ind = len - 1;\n                for (int l = 0, r = len - 1; l <= r; ) {\n                    int m = l + (r - l) / 2;\n                    if (tail[m] > a[i]) {\n                        ind = m;\n                        r = m - 1;\n                    } else {\n                        l = m + 1;\n                    }\n                }\n                tail[ind] = a[i];\n            }\n        }\n        // prln(tail);\n        return len;\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int lcm(int a, int b) {return a * b / gcf(a, b);}\n    static long lcm(long a, long b) {return a * b / gcf(a, b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {prln(\"yes\");}\n    static void pry() {prln(\"Yes\");}\n    static void prY() {prln(\"YES\");}\n    static void prno() {prln(\"no\");}\n    static void prn() {prln(\"No\");}\n    static void prN() {prln(\"NO\");}\n    static boolean pryesno(boolean b) {prln(b ? \"yes\" : \"no\"); return b;};\n    static boolean pryn(boolean b) {prln(b ? \"Yes\" : \"No\"); return b;}\n    static boolean prYN(boolean b) {prln(b ? \"YES\" : \"NO\"); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(\"hlfd\"); flush();}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}", "label": 3}
{"src": "import java.awt.*;\nimport java.io.*;\nimport java.util.*;\nimport java.util.List;\n\npublic class Coding {\n\n    private static BufferedReader bi = new BufferedReader(new InputStreamReader(System.in));\n    private static BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n\n    public static void main(String[] args) {\n        try {\n            run();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void run() throws Exception {\n        InputModule inp = new InputModule();\n        OutputModule out = new OutputModule();\n        int t = 1;\n        while (t > 0) {\n            int[] inps = inp.cinIntArray(2);\n            int n = inps[0];\n            int k = inps[1];\n            int[] ints = inp.cinIntArray(n);\n            Set<Integer> has = new HashSet<>();\n            if (k > 0) {\n                inps = inp.cinIntArray(k);\n                for (int i = 0; i < k; ++i) {\n                    has.add(inps[i]);\n                }\n            }\n\n            int ans = 0;\n            int prev = -1;\n            for (int i = 0; i < n; ++i) {\n                if (has.contains(i + 1)) {\n                    if ((prev != -1) && (ints[i] < (ints[prev] + i - prev))) {\n                        ans = -1;\n                        break;\n                    }\n                    int len = i - prev - 1;\n                    if (len > 0) {\n                        int[] tmp = new int[len];\n                        for (int j = 0; j < len; ++j) {\n                            tmp[j] = ints[prev + 1 + j];\n                        }\n                        ans += lcsMaxWithConstraints(tmp, len, prev == -1 ? -1 : ints[prev], ints[i]);\n                    }\n                    prev = i;\n                }\n            }\n\n            int len = n - prev - 1;\n            if ((len > 0) && ans != -1) {\n                int[] tmp = new int[len];\n                for (int j = 0; j < len; ++j) {\n                    tmp[j] = ints[prev + 1 + j];\n                }\n                ans += lcsMaxWithConstraints(tmp, len, prev == -1 ? -1 : ints[prev], -1);\n            }\n            out.printInt(ans);\n            t--;\n        }\n    }\n\n    static int updateBestLCSs(int bestLCSEndingIndex[], int l, int r, int[] ar, int newIndex) {\n        int index = -1;\n        while (l <= r) {\n            int mid = (l + r) / 2;\n            if (ar[newIndex] <= ar[bestLCSEndingIndex[mid]]) {\n                index = mid;\n                r = mid - 1;\n            } else if ((ar[newIndex] - ar[bestLCSEndingIndex[mid]]) < (newIndex - bestLCSEndingIndex[mid])) {\n                index = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return index;\n    }\n\n    static int lcsMaxWithConstraints(int ar[], int size, int lval, int rval) {\n        int[] bestLCSEndingIndex = new int[size];\n        bestLCSEndingIndex[0] = Integer.MAX_VALUE;\n        // Best LCS yet.\n        int len = 0;\n        for (int i = 0; i < size; i++) {\n            boolean poss = true;\n            if (lval != -1) {\n                int diff = ar[i] - lval;\n                if (diff < i + 1) {\n                    poss = false;\n                }\n            }\n            if (rval != -1) {\n                int diff = rval - ar[i];\n                if (diff < size - i) {\n                    poss = false;\n                }\n            }\n            if (!poss) {\n                continue;\n            }\n\n            if (len == 0) {\n                len = 1;\n                bestLCSEndingIndex[0] = i;\n            } else if (ar[i] < ar[bestLCSEndingIndex[0]]) {\n                bestLCSEndingIndex[0] = i;\n            } else if (ar[i] > ar[bestLCSEndingIndex[len - 1]] && (ar[i] - ar[bestLCSEndingIndex[len - 1]]) >= (i - bestLCSEndingIndex[len - 1])) {\n                bestLCSEndingIndex[len++] = i;\n            } else {\n                bestLCSEndingIndex[updateBestLCSs(bestLCSEndingIndex, 0, len - 1, ar, i)] = i;\n            }\n        }\n\n        // Changes = total length - size of LCS\n        return size - len;\n    }\n\n\n    private static class InputModule {\n        private int cinInt() throws Exception {\n            return Integer.parseInt(bi.readLine().split(\" \")[0].trim());\n        }\n\n        private long cinLong() throws Exception {\n            return Long.parseLong(bi.readLine().split(\" \")[0].trim());\n        }\n\n        private Double cinDouble() throws Exception {\n            return Double.parseDouble(bi.readLine().split(\" \")[0].trim());\n        }\n\n        private String cinString() throws Exception {\n            return bi.readLine();\n        }\n\n        private int[] cinIntArray(int n) throws Exception {\n            String input = bi.readLine();\n            String[] values = input.split(\" \");\n            int[] ar = new int[n];\n            for (int i = 0; i < n; ++i) {\n                ar[i] = Integer.parseInt(values[i]);\n            }\n            return ar;\n        }\n\n        private long[] cinLongArray(int n) throws Exception {\n            String input = bi.readLine();\n            String[] values = input.split(\" \");\n            long[] ar = new long[n];\n            for (int i = 0; i < n; ++i) {\n                ar[i] = Long.parseLong(values[i]);\n            }\n            return ar;\n        }\n\n        private String[] cinStringArray(int n) throws Exception {\n            return bi.readLine().split(\" \");\n        }\n    }\n\n    private static class OutputModule {\n        private void printInt(int ans) throws Exception {\n            writer.append(ans + \"\\n\");\n            writer.flush();\n        }\n\n        private void printLong(long ans) throws Exception {\n            writer.append(ans + \"\\n\");\n            writer.flush();\n        }\n\n        private void printDouble(Double ans) throws Exception {\n            writer.append(String.format(\"%.10f\", ans));\n            writer.append(\"\\n\");\n            writer.flush();\n        }\n\n        private void printString(String ans) throws Exception {\n            writer.append(ans + \"\\n\");\n            writer.flush();\n        }\n\n        private void printIntArray(int[] ans) throws Exception {\n            for (int i = 0; i < ans.length; ++i) {\n                writer.append(ans[i] + \" \");\n            }\n            writer.append(\"\\n\");\n            writer.flush();\n        }\n\n        private void printLongArray(long[] ans) throws Exception {\n            for (int i = 0; i < ans.length; ++i) {\n                writer.append(ans[i] + \" \");\n            }\n            writer.append(\"\\n\");\n            writer.flush();\n        }\n\n        private void printIntMatrix(int[][] mat, int n, int m) throws Exception {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    writer.append(mat[i][j] + \" \");\n                }\n                writer.append(\"\\n\");\n            }\n            writer.flush();\n        }\n\n        private void printLongMatrix(long[][] mat, int n, int m) throws Exception {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    writer.append(mat[i][j] + \" \");\n                }\n                writer.append(\"\\n\");\n            }\n            writer.flush();\n        }\n\n        private void printPoint(Point p) throws Exception {\n            writer.append(p.x + \" \" + p.y + \"\\n\");\n            writer.flush();\n        }\n\n        private void printPoints(List<Point> p) throws Exception {\n            for (Point pp : p) {\n                writer.append(pp.x + \" \" + pp.y + \"\\n\");\n            }\n            writer.flush();\n        }\n    }\n}", "label": 3}
{"src": "/*\nIf you want to aim high, aim high\nDon't let that studying and grades consume you\nJust live life young\n******************************\nWhat do you think? What do you think?\n1st on Billboard, what do you think of it\nNext is a Grammy, what do you think of it\nHowever you think, I\u2019m sorry, but shit, I have no fcking interest\n*******************************\nI'm standing on top of my Monopoly board\nThat means I'm on top of my game and it don't stop\ntil my hip don't hop anymore\nhttps://www.a2oj.com/Ladder16.html\n*******************************\nShining through the city with a little funk and soul\n*/\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n   public class E\n   {\n      public static void main(String hi[]) throws Exception\n      {\n         FastScanner infile = new FastScanner();\n         int N = infile.nextInt();\n         int K = infile.nextInt();\n         int[] arr = new int[N];\n         for(int i=0; i < N; i++)\n            arr[i] = infile.nextInt();\n         boolean[] blocked = new boolean[N];\n         ArrayList<Integer> ls = new ArrayList<Integer>();\n         if(K > 0)\n         {\n            for(int i=0; i < K; i++)\n            {\n               int val = infile.nextInt()-1;\n               ls.add(val);\n               blocked[val] = true;\n            }\n         }\n         for(int i=0; i < N; i++)\n            arr[i] -= i;\n         if(bad(arr, ls))\n            System.out.println(-1);\n         else\n         {\n            ls.add(0, -1);\n            ls.add(N);\n            int res = 0;\n            for(int a=1; a < ls.size(); a++)\n            {\n               int left = ls.get(a-1)+1;\n               int right = ls.get(a)-1;\n               if(left <= right)\n               {\n                  int min = Integer.MIN_VALUE;\n                  int max = Integer.MAX_VALUE;\n                  if(left > 0)\n                     min = arr[left-1];\n                  if(right < N-1)\n                     max = arr[right+1];\n                  ArrayList<Integer> temp = new ArrayList<Integer>();\n                  for(int i=left; i <= right; i++)\n                     if(arr[i] >= min && arr[i] <= max)\n                        temp.add(arr[i]);\n                  res += right-left+1-lis(temp);\n               }\n            }\n            System.out.println(res);\n         }\n      }\n      public static int lis(ArrayList<Integer> temp)\n      {\n         if(temp.size() == 0)\n            return 0;\n         int N = temp.size();\n         int[] min = new int[N+1];\n         int dex = 0;\n         for(int x: temp)\n         {\n            if(dex == 0)\n               min[dex++] = x;\n            else\n            {\n               if(min[0] > x)\n                  min[0] = x;\n               else if(min[dex-1] <= x)\n                  min[dex++] = x;\n               else\n               {\n                  int low = 0;\n                  int high = dex-1;\n                  while(low != high)\n                  {\n                     int mid = (low+high)/2;\n                     if(min[mid] <= x)\n                        low = mid+1;\n                     else\n                        high = mid;\n                  }\n                  min[low] = x;\n               }\n            }\n         }\n         return dex;\n      }\n      public static boolean bad(int[] arr, ArrayList<Integer> ls)\n      {\n         for(int i=1; i < ls.size(); i++)\n            if(arr[ls.get(i-1)] > arr[ls.get(i)])\n               return true;\n         return false;\n      }\n   }\n   class FastScanner {\n        private int BS = 1 << 16;\n        private char NC = (char) 0;\n        private byte[] buf = new byte[BS];\n        private int bId = 0, size = 0;\n        private char c = NC;\n        private double cnt = 1;\n        private BufferedInputStream in;\n \n        public FastScanner() {\n            in = new BufferedInputStream(System.in, BS);\n        }\n \n        public FastScanner(String s) {\n            try {\n                in = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n            } catch (Exception e) {\n                in = new BufferedInputStream(System.in, BS);\n            }\n        }\n \n        private char getChar() {\n            while (bId == size) {\n                try {\n                    size = in.read(buf);\n                } catch (Exception e) {\n                    return NC;\n                }\n                if (size == -1) return NC;\n                bId = 0;\n            }\n            return (char) buf[bId++];\n        }\n \n        public int nextInt() {\n            return (int) nextLong();\n        }\n \n        public int[] nextInts(int N) {\n            int[] res = new int[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = (int) nextLong();\n            }\n            return res;\n        }\n \n        public long[] nextLongs(int N) {\n            long[] res = new long[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextLong();\n            }\n            return res;\n        }\n \n        public long nextLong() {\n            cnt = 1;\n            boolean neg = false;\n            if (c == NC) c = getChar();\n            for (; (c < '0' || c > '9'); c = getChar()) {\n                if (c == '-') neg = true;\n            }\n            long res = 0;\n            for (; c >= '0' && c <= '9'; c = getChar()) {\n                res = (res << 3) + (res << 1) + c - '0';\n                cnt *= 10;\n            }\n            return neg ? -res : res;\n        }\n \n        public double nextDouble() {\n            double cur = nextLong();\n            return c != '.' ? cur : cur + nextLong() / cnt;\n        }\n \n        public double[] nextDoubles(int N) {\n            double[] res = new double[N];\n            for (int i = 0; i < N; i++) {\n                res[i] = nextDouble();\n            }\n            return res;\n        }\n \n        public String next() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c > 32) {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n \n        public String nextLine() {\n            StringBuilder res = new StringBuilder();\n            while (c <= 32) c = getChar();\n            while (c != '\\n') {\n                res.append(c);\n                c = getChar();\n            }\n            return res.toString();\n        }\n \n        public boolean hasNext() {\n            if (c > 32) return true;\n            while (true) {\n                c = getChar();\n                if (c == NC) return false;\n                else if (c > 32) return true;\n            }\n        }\n    }", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.Map;\nimport java.io.OutputStreamWriter;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.AbstractMap;\nimport java.util.TreeMap;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.util.Map.Entry;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            EMakeItIncreasing solver = new EMakeItIncreasing();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class EMakeItIncreasing {\n        Debug debug = new Debug(true);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            int[] a = new int[n];\n            in.populate(a);\n            for (int i = 0; i < n; i++) {\n                a[i] -= i;\n            }\n            int[] b = new int[k];\n            in.populate(b);\n            for (int i = 0; i < k; i++) {\n                b[i]--;\n            }\n            if (k == 0) {\n                out.println(n - lis(a, 0, n - 1, false, false));\n                return;\n            }\n            Randomized.shuffle(b);\n            Arrays.sort(b);\n            for (int i = 1; i < k; i++) {\n                if (a[b[i - 1]] > a[b[i]]) {\n                    out.println(-1);\n                    return;\n                }\n            }\n            int lis = lis(a, 0, b[0], false, true) - 1;\n            for (int i = 1; i < k; i++) {\n                lis += lis(a, b[i - 1], b[i], true, true) - 2;\n            }\n            lis += lis(a, b[k - 1], n - 1, true, false) - 1;\n            out.println(n - k - lis);\n        }\n\n        public int lis(int[] a, int l, int r, boolean includeL, boolean includeR) {\n            MultiSet<Integer> set = new MultiSet<>();\n            set.add(a[l]);\n            for (int i = l + 1; i <= r; i++) {\n                if (includeL && a[i] < a[l]) {\n                    continue;\n                }\n                Integer ceil = set.ceil(a[i] + 1);\n                if (ceil != null) {\n                    set.remove(ceil);\n                }\n                set.add(a[i]);\n            }\n            if (includeR) {\n                while (set.last() > a[r]) {\n                    set.pollLast();\n                }\n            }\n            debug.run(() -> {\n                String s = String.format(\"[%d, %d], %d %d = %d\", l, r, includeL ? 1 : 0, includeR ? 1 : 0, set.size());\n                debug.debug(\"res\", s);\n            });\n            return set.size();\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 1 << 13;\n        private final Writer os;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(String c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append(System.lineSeparator());\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public void run(Runnable task) {\n            if (offline) {\n                task.run();\n            }\n        }\n\n        public Debug debug(String name, String x) {\n            if (offline) {\n                out.printf(\"%s=%s\", name, x);\n                out.println();\n            }\n            return this;\n        }\n\n    }\n\n    static class RandomWrapper {\n        private Random random;\n        public static final RandomWrapper INSTANCE = new RandomWrapper(new Random());\n\n        public RandomWrapper() {\n            this(new Random());\n        }\n\n        public RandomWrapper(Random random) {\n            this.random = random;\n        }\n\n        public int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(int[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readInt();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class MultiSet<T> {\n        private TreeMap<T, Integer> map;\n        private int size;\n\n        public MultiSet(Comparator<T> comp) {\n            this.map = new TreeMap<>(comp);\n        }\n\n        public MultiSet() {\n            this.map = new TreeMap<>();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public T last() {\n            return map.lastKey();\n        }\n\n        public T pollLast() {\n            size--;\n            Map.Entry<T, Integer> last = map.lastEntry();\n            update(last.getKey(), last.getValue() - 1);\n            return last.getKey();\n        }\n\n        public void add(T key) {\n            size++;\n            update(key, map.getOrDefault(key, 0) + 1);\n        }\n\n        public void remove(T key) {\n            size--;\n            update(key, map.getOrDefault(key, 0) - 1);\n        }\n\n        public T ceil(T x) {\n            return map.ceilingKey(x);\n        }\n\n        public void update(T key, int cnt) {\n            if (cnt == 0) {\n                map.remove(key);\n            } else if (cnt > 0) {\n                map.put(key, cnt);\n            } else {\n                size++;\n            }\n        }\n\n        public String toString() {\n            return map.toString();\n        }\n\n    }\n\n    static class Randomized {\n        public static void shuffle(int[] data) {\n            shuffle(data, 0, data.length - 1);\n        }\n\n        public static void shuffle(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return RandomWrapper.INSTANCE.nextInt(l, r);\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\npublic class E {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++) {\n         \tarr[i] = n + sc.nextInt() - i;\n        }\n        ArrayList<Integer> list = new ArrayList<>();\n        int a = -1, b = Integer.MAX_VALUE;\n        int p = 0, r = 0;\n        int res = 0;\n        for (int i = 0; i < k; i++) {\n          \tr = sc.nextInt()-1;\n          \tb = arr[r];\n          \tif(b < a) {\n          \t\tSystem.out.println(-1); return;\n          \t}\n          \tfor(int j = p; j < r; j++){\n\t\t\t\tif(arr[j] >= a && arr[j] <= b) list.add(arr[j]);\n\t\t\t\telse res++;\n\t\t\t}\n          \tint m = list.size();\n          \tif(m > 0) {\n\t          \tint[] brr = new int[m];\n\t          \tfor(int j = 0; j < m; j++) brr[j] = list.get(j);\n\t          \tint solve = lis(brr, m);\n\t          \tres += m - solve;\n\t          \tlist = new ArrayList<>();\n          \t}\n          \tp = r+1;\n          \ta = b;\n          \tb = Integer.MAX_VALUE;\n        }\n        for(int j = p; j < n; j++){\n\t\t\tif(arr[j] >= a && arr[j] <= b) list.add(arr[j]);\n\t\t\telse res++;\n\t\t}\n      \tint m = list.size();\n      \tif(m > 0) {\n\t      \tint[] brr = new int[m];\n\t      \tfor(int j = 0; j < m; j++) brr[j] = list.get(j);\n\t      \tint solve = lis(brr, m);\n\t      \tres += m - solve;\n      \t}\n      \telse {\n      \t\tres += m;\n      \t}\n        System.out.println(res);\n\t}\n\t\n\tstatic int lis(int[] arr, int n) {\n\t    int INF = Integer.MAX_VALUE;\n\t    int[] d = new int[n+1];\n\t    Arrays.fill(d, INF);\n\t    d[0] = -INF;\n\n\t    for (int i = 0; i < n; i++) {\n\t    \tint a = 0, b = n;\n\t    \twhile(b - a > 1) {\n\t    \t\tint c = (a+b)/2;\n\t    \t\tif(d[c] > arr[i]) b = c;\n\t    \t\telse a = c;\n\t    \t}\n\t    \tif (d[b-1] <= arr[i] && arr[i] < d[b])\n\t            d[b] = arr[i];\n\t    }\n\n\t    int ans = 0;\n\t    for (int i = 0; i <= n; i++) {\n\t        if (d[i] < INF)\n\t            ans = i;\n\t    }\n\t    return ans;\n\t}\n      \n\tstatic class FastScanner {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\t\tpublic FastScanner() {\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch(IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t}\n\n}\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskE solver = new TaskE();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskE {\n        public static int lis(ArrayList<Integer> A) {\n            int n = A.size();\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) a[i] = (((long) A.get(i)) << 20) + i;\n            int[] tail = new int[n];\n            int[] prev = new int[n];\n\n            int len = 0;\n            for (int i = 0; i < n; i++) {\n                int pos = lower_bound(a, tail, len, a[i]);\n                len = Math.max(len, pos + 1);\n                prev[i] = pos > 0 ? tail[pos - 1] : -1;\n                tail[pos] = i;\n            }\n//        System.out.println(len);\n            return len;\n//        int[] res = new int[len];\n//        for (int i = tail[len - 1]; i >= 0; i = prev[i]) {\n//            res[--len] = a[i];\n//        }\n//        return res;\n        }\n\n        static int lower_bound(long[] a, int[] tail, int len, long key) {\n            int lo = -1;\n            int hi = len;\n            while (hi - lo > 1) {\n                int mid = (lo + hi) >>> 1;\n                if (a[tail[mid]] < key) {\n                    lo = mid;\n                } else {\n                    hi = mid;\n                }\n            }\n            return hi;\n        }\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt(), k = in.nextInt();\n            int[] a = in.readIntArray(n);\n            int[] b = in.readIntArray(k);\n            for (int i = 0; i < n; i++) a[i] -= i;\n            for (int i = 0; i < k; i++) b[i]--;\n            int lis = k;\n            for (int i = 0; i <= k; i++) {\n                int l = i == 0 ? 0 : b[i - 1] + 1;\n                int r = i == k ? n - 1 : b[i] - 1;\n\n                int L = i == 0 ? Integer.MIN_VALUE : a[b[i - 1]];\n                int R = i == k ? Integer.MAX_VALUE : a[b[i]];\n\n                if (L > R) {\n                    out.println(\"-1\");\n                    return;\n                }\n\n\n                ArrayList<Integer> c = new ArrayList<>();\n                for (int j = l; j <= r; j++) if (a[j] >= L && a[j] <= R) c.add(a[j]);\n                lis += lis(c);\n            }\n            out.println(n - lis);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void println(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n            writer.print('\\n');\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class E {\n    //--------------------------------------------------------\n    private static final MyScanner in = new MyScanner(System.in);\n    private static final PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n    public static void main(String[] args) throws Exception {\n        Solver solver = new Solver();\n        solver.solve();\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve() throws Exception {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            int[] a = new int[n + 2];\n            a[0] = Integer.MIN_VALUE / 2;\n            a[n + 1] = Integer.MAX_VALUE / 2;\n            for (int i = 1; i <= n; i++) {\n                a[i] = in.nextInt();\n            }\n            int last = 0;\n            int ans = 0;\n            for (int i = 1; i <= k + 1; i++) {\n                int b = n + 1;\n                if (i <= k) {\n                    b = in.nextInt();\n                }\n                int part = compute(a, last, b);\n                if (part == -1) {\n                    out.println(\"-1\");\n                    return;\n                }\n                last = b;\n                ans += part;\n            }\n            out.println(ans);\n        }\n\n        private int compute(int[] a, int lower, int upper) {\n            if (a[upper] - a[lower] < upper - lower) {\n                return -1;\n            }\n            int[] d = new int[upper - lower];\n            d[0] = lower;\n            int last = 0;\n            for (int i = lower + 1; i < upper; i++) {\n                if (a[i] - a[lower] < i - lower || a[upper] - a[i] < upper - i) {\n                    continue;\n                }\n                if (a[i] - a[d[last]] >= i - d[last]) {\n                    d[++last] = i;\n                } else {\n                    d[bs(a, d, last + 1, i)] = i;\n                }\n            }\n            return upper - lower - 1 - last;\n        }\n\n        private int bs(int[] a, int[] d, int r, int i) {\n            int l = -1;\n\n            while (l + 1 < r) {\n                int mid = (l + r) / 2;\n                if (a[d[mid]] - a[i] <= d[mid] - i) {\n                    l = mid;\n                } else {\n                    r = mid;\n                }\n            }\n            return r;\n        }\n    }\n\n    public static class MyScanner {\n        private final BufferedReader br;\n        private StringTokenizer st;\n\n        public MyScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        String next() throws IOException {\n            while (st == null || !st.hasMoreElements()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}", "label": 3}
{"src": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner s = new Scanner(System.in);\n\t\tint n = s.nextInt();\n\t\tint k = s.nextInt();\n\t\tint[] input = new int[n + 2];\n\t\tinput[0] = Integer.MIN_VALUE/2;\n\t\tinput[n + 1] = Integer.MAX_VALUE/2;\n\t\tfor(int i = 1;i <= n;i++) input[i] = s.nextInt();\n\t\tboolean[] b = new boolean[n + 2];\n\t\tb[0] = b[b.length - 1] = true;\n\t\tfor(int i = 0;i < k;i++) b[s.nextInt()] = true;\n//\t\tfor(int j=0;j<input.length;j++) {\n//            System.out.println(j+\" \"+input[j]+\" \"+b[j]);\n//        }\n\t\t\n\t\tint prev = 0 , start , end , ans = 0;\n\t\t\n\t\tfor(int i = 1;i < input.length;i++) {\n\t\t\tif(!b[i]) continue;\n\t\t\t\n\t\t\tif(input[i] - input[prev] < (i - prev)) {\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstart = prev;\n\t\t\tend = i;\n\t        \n\t\t\tArrayList<Integer> arrli = new ArrayList<>();\n\t\t\tfor(int j = start + 1;j < end;j++) {\n\t\t\t\tif(input[j] >= input[start] + (j - start) && input[j] <= input[end] - (end - j)) {\n\t\t\t\t\tarrli.add(input[j] - (input[start] + j - start));\n\t\t\t\t\t//System.out.println(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\tint temp = LISL(arrli , arrli.size());\n\t\t\t\tans += (end - start - 1) - temp;\n\t\t\t\tprev = i;\n\t\t\t\n\t\t}\n\t\tSystem.out.println(ans);\n\t\t\n\t}\n\tpublic static int LISL(ArrayList<Integer> arrli , int len) {\n\t\tif(len == 0) return 0;\n\t\t\n\t\tint length = 1;\n\t\tint[] tt = new int[len];\n\t\ttt[0] = arrli.get(0);\n\t\tfor(int i = 1;i < len;i++) {\n\t\t\tif(arrli.get(i) < tt[0]) {\n\t\t\t\ttt[0] = arrli.get(i);\n\t\t\t}\n\t\t\telse if(arrli.get(i) >= tt[length - 1]) {\n\t\t\t\ttt[length++] = arrli.get(i);\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttt[ceilIndex(tt , -1 , length - 1 , arrli.get(i))] = arrli.get(i);\n\t\t\t}\n\t\t}\n\t\treturn length;\n\t}\n\t\n\tpublic static int ceilIndex(int[] tt , int l , int r , int val) {\n\t\t\n\t\twhile(r - l > 1) {\n\t\t\tint m = (l + r)/2;\n\t\t\tif(tt[m] > val) {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl = m;\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}\n\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.text.DecimalFormat;\nimport java.util.*;\n\npublic class Main {\n    public static final DecimalFormat DF_2 = new DecimalFormat(\"0.000\");\n    public static final Comparator<int[]> COMPARATOR = Comparator.comparingInt(o -> o[0]);\n\n    static void sortArray(int[] a, boolean rev) {\n        Random random = new Random();\n\n        for (int i = 0; i < a.length; i++) {\n            int randomPos = random.nextInt(a.length);\n            int t = a[i];\n            a[i] = a[randomPos];\n            a[randomPos] = t;\n        }\n        Arrays.sort(a);\n        if (rev) {\n            for (int i = 0; i < a.length / 2; i++) {\n                int t = a[i];\n                a[i] = a[a.length - i - 1];\n                a[a.length - i - 1] = t;\n            }\n        }\n    }\n\n    static int[] readArray(int size, InputReader in, boolean subOne) {\n        int[] a = new int[size];\n        for (int i = 0; i < size; i++) {\n            a[i] = in.nextInt() + (subOne ? -1 : 0);\n        }\n        return a;\n    }\n\n    static long[] readLongArray(int size, InputReader in) {\n        long[] a = new long[size];\n        for (int i = 0; i < size; i++) {\n            a[i] = in.nextLong();\n        }\n        return a;\n    }\n\n    static class MinSegTree {\n        private int size;\n        private final int[] tree;\n\n        MinSegTree(int[] a) {\n            size = 1;\n            while (size < a.length) {\n                size *= 2;\n            }\n            tree = new int[2 * size - 1];\n            Arrays.fill(tree, Integer.MAX_VALUE);\n\n            build(a, 0, 0, size);\n        }\n\n        private void build(int[] a, int x, int lx, int rx) {\n            if (rx - lx == 1) {\n                if (lx < a.length) {\n                    tree[x] = a[lx];\n                }\n            } else {\n                int m = (rx + lx) / 2;\n                build(a, 2 * x + 1, lx, m);\n                build(a, 2 * x + 2, m, rx);\n                tree[x] = Math.min(tree[2 * x + 1], tree[2 * x + 2]);\n            }\n        }\n\n        public void set(int i, int v) {\n            set(i, v, 0, 0, size);\n        }\n\n        private void set(int i, int v, int x, int lx, int rx) {\n            if (rx - lx == 1) {\n                tree[x] = v;\n                return;\n            }\n            int m = (rx + lx) / 2;\n            if (i >= m) {\n                set(i, v, 2 * x + 2, m, rx);\n            } else {\n                set(i, v, 2 * x + 1, lx, m);\n            }\n            tree[x] = Math.min(tree[2 * x + 1], tree[2 * x + 2]);\n        }\n\n        public int result(int l, int r) {\n            return result(l, r, 0, 0, size);\n        }\n\n        private int result(int l, int r, int x, int lx, int rx) {\n            if (l >= rx || lx >= r) {\n                return Integer.MAX_VALUE;\n            }\n            if (lx >= l && rx <= r) {\n                return tree[x];\n            }\n            int m = (lx + rx) / 2;\n            return Math.min(result(l, r, 2 * x + 1, lx, m), result(l, r, 2 * x + 2, m, rx));\n        }\n    }\n\n    public static final Comparator<int[]> PAIR_COMPARATOR = (o1, o2) -> {\n        if (o1[0] == o2[0]) {\n            return Long.compare(o1[1], o2[1]);\n        }\n        return Long.compare(o1[0], o2[0]);\n    };\n\n\n    static int binSearchRight(List<int[]> list, int key) {\n        int l = -1;\n        int r = list.size();\n        while (l < r - 1) {\n            int m = (l + r) / 2;\n            if (list.get(m)[0] <= key) {\n                l = m;\n            } else {\n                r = m;\n            }\n        }\n        return l;\n    }\n\n    public static void main(String[] args) throws FileNotFoundException {\n//        InputReader in = new InputReader(new FileInputStream(\"input.txt\"));\n//        PrintWriter out = new PrintWriter(new BufferedOutputStream(new FileOutputStream(\"milkvisits.out\")));\n//\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n//        long start = System.currentTimeMillis();\n\n\n        int n = in.nextInt();\n        int k = in.nextInt();\n        int[] a = readArray(n, in, false);\n        int[] b = readArray(k, in, true);\n\n        int l = -1;\n        int r = k == 0 ? n : b[0];\n        int ans = 0;\n        for (int i = 0; i < k + 1; i++) {\n            if (l >= 0 && r < n) {\n                if (a[r] - a[l] < r - l) {\n                    out.println(\"-1\");\n                    out.close();\n                    return;\n                }\n            }\n            if (r == l + 1) {\n                if (i < k) {\n                    l = b[i];\n                    r = i == (k - 1) ? n : b[i + 1];\n                }\n                continue;\n            }\n\n            int dx = l;\n            List<int[]> ax = new ArrayList<>(r - l);\n            for (int j = l; j < r; j++) {\n                ax.add(new int[]{j == -1 ? -n : (a[j] - j), j - dx});\n            }\n            ax.sort(PAIR_COMPARATOR);\n\n            int[] occs = new int[ax.size()];\n            for (int j = 0; j < occs.length; j++) {\n                occs[ax.get(j)[1]] = j;\n            }\n            int[] dp = new int[occs.length];\n            Arrays.fill(dp, 1000000000);\n            dp[occs[0]] = 0;\n            int d = 0;\n\n            MinSegTree segTree = new MinSegTree(dp);\n            for (int x = 1; x < occs.length; x++) {\n                int ind = binSearchRight(ax, a[x + dx] - (x + dx));\n                int dpx = Integer.MAX_VALUE;\n                if (ind >= 0) {\n                    dpx = segTree.result(0, ind + 1) + d;\n                }\n\n                if (dp[occs[x]] > dpx - 1) {\n                    segTree.set(occs[x], dpx - 1 - d);\n                    dp[occs[x]] = dpx - 1 - d;\n                }\n                d += 1;\n            }\n\n            int ind = r < n ? binSearchRight(ax, a[r] - r) + 1 : dp.length;\n            long ans1 = segTree.result(0, ind) + d;\n            if (ans1 < 1000000000) {\n                ans += ans1;\n            } else {\n                out.println(\"-1\");\n                out.close();\n                return;\n            }\n\n            if (i < k) {\n                l = b[i];\n                r = i == (k - 1) ? n : b[i + 1];\n            }\n        }\n\n        out.println(ans);\n\n\n        out.close();\n    }\n\n\n    private static void outputArray(int[] ans, PrintWriter out, boolean addOne) {\n        StringBuilder str = new StringBuilder();\n        for (int i = 0; i < ans.length; i++) {\n            long an = ans[i] + (addOne ? 1 : 0);\n            str.append(an).append(' ');\n        }\n        out.println(str);\n    }\n\n    private static void outputArray(List<Integer> ans, PrintWriter out, boolean addOne) {\n        StringBuilder str = new StringBuilder();\n        for (int j = 0; j < ans.size(); j++) {\n            long i = ans.get(j);\n            long an = i + (addOne ? 1 : 0);\n            str.append(an);\n            if (j < ans.size() - 1) {\n                str.append(' ');\n            }\n        }\n        out.println(str);\n//        out.flush();\n    }\n\n    public static List<List<Integer>> getPerms(int n) {\n        Set<Integer> notUsed = new TreeSet<>();\n        for (int i = 1; i <= n; i++) {\n            notUsed.add(i);\n        }\n        ArrayList<List<Integer>> perms = getPerms(n, notUsed);\n        for (List<Integer> perm : perms) {\n            Collections.reverse(perm);\n        }\n        return perms;\n    }\n\n    public static ArrayList<List<Integer>> getPerms(int n, Set<Integer> notUsed) {\n        if (n == 0) {\n            return new ArrayList<>();\n        }\n\n        if (n == 1) {\n            ArrayList<List<Integer>> res = new ArrayList<>();\n            res.add(new ArrayList<>());\n            res.get(0).add(notUsed.iterator().next());\n            return res;\n        }\n\n        ArrayList<List<Integer>> res = new ArrayList<>();\n        for (Integer num : notUsed) {\n            TreeSet<Integer> s = new TreeSet<>(notUsed);\n            s.remove(num);\n            List<List<Integer>> resChild = getPerms(n - 1, s);\n            for (List<Integer> nums : resChild) {\n                nums.add(num);\n            }\n            res.addAll(resChild);\n        }\n\n        return res;\n    }\n\n    private static int[] getBinary(long a, int size) {\n        int[] result = new int[size];\n        for (int i = 0; i < size; i++) {\n            result[i] = (int) ((a >> i) & 1);\n        }\n        return result;\n    }\n\n    private static long fromBinary(int[] binary) {\n        long res = 0;\n        long d = 1;\n        for (int i = 0; i < binary.length; i++) {\n            if (binary[i] == 1) {\n                res = res | d;\n            }\n            d = d << 1;\n        }\n        return res;\n    }\n\n    private static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextString() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public char nextChar() {\n            return next().charAt(0);\n        }\n\n        public String nextWord() {\n            return next();\n        }\n\n        private List<Integer>[] readTree(int n) {\n            return readGraph(n, n - 1);\n        }\n\n        private List<Integer>[] readGraph(int n, int m) {\n            List<Integer>[] result = new ArrayList[n];\n            for (int i = 0; i < n; i++) {\n                result[i] = new ArrayList<>();\n            }\n            for (int i = 0; i < m; i++) {\n                int u = nextInt() - 1;\n                int v = nextInt() - 1;\n                result[u].add(v);\n                result[v].add(u);\n            }\n            return result;\n        }\n\n    }\n}", "label": 3}
{"src": "// coached by rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF1437E extends PrintWriter {\n\tCF1437E() { super(System.out, true); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1437E o = new CF1437E(); o.main(); o.flush();\n\t}\n\n\tint[] ft;\n\tvoid update(int i, int n, int x) {\n\t\twhile (i < n) {\n\t\t\tft[i] = Math.max(ft[i], x);\n\t\t\ti |= i + 1;\n\t\t}\n\t}\n\tint query(int i) {\n\t\tint x = 0;\n\t\twhile (i >= 0) {\n\t\t\tx = Math.max(x, ft[i]);\n\t\t\ti &= i + 1; i--;\n\t\t}\n\t\treturn x;\n\t}\n\tInteger[] ii;\n\tint[] qu;\n\tint solve(int n) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tii[i] = i;\n\t\tArrays.sort(ii, 0, n, (i, j) -> qu[i] != qu[j] ? qu[i] - qu[j] : i - j);\n\t\tArrays.fill(ft, 0, n, 0);\n\t\tint k_ = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint i_ = ii[i];\n\t\t\tint k = query(i_) + 1;\n\t\t\tupdate(i_, n, k);\n\t\t\tk_ = Math.max(k_, k);\n\t\t}\n\t\treturn n - k_;\n\t}\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint[] aa = new int[n + 2];\n\t\taa[0] = -n; aa[n + 1] = 1000000000;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\taa[i] = sc.nextInt() - i;\n\t\tint[] bb = new int[k + 2];\n\t\tbb[0] = 0; bb[k + 1] = n + 1;\n\t\tfor (int h = 1; h <= k; h++)\n\t\t\tbb[h] = sc.nextInt();\n\t\tfor (int h = 2; h <= k; h++) {\n\t\t\tif (aa[bb[h - 1]] > aa[bb[h]]) {\n\t\t\t\tprintln(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tft = new int[n + 2];\n\t\tii = new Integer[n + 2];\n\t\tqu = new int[n + 2];\n\t\tint ans = 0;\n\t\tfor (int h = 1; h <= k + 1; h++) {\n\t\t\tint l = bb[h - 1], r = bb[h];\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = l; i <= r; i++) {\n\t\t\t\tint a = aa[i];\n\t\t\t\tif (aa[l] <= a && a <= aa[r])\n\t\t\t\t\tqu[cnt++] = a;\n\t\t\t\telse\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\tif (cnt > 2)\n\t\t\t\tans += solve(cnt);\n\t\t}\n\t\tprintln(ans);\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tstatic class TaskAdapter implements Runnable {\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tlong startTime = System.currentTimeMillis();\n\t\t\tInputStream inputStream = System.in;\n\t\t\tOutputStream outputStream = System.out;\n\t\t\tFastReader in = new FastReader(inputStream);\n\t\t\tOutput out = new Output(outputStream);\n\t\t\tEMakeItIncreasing solver = new EMakeItIncreasing();\n\t\t\tsolver.solve(1, in, out);\n\t\t\tout.close();\n\t\t\tSystem.err.println(System.currentTimeMillis()-startTime+\"ms\");\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tThread thread = new Thread(null, new TaskAdapter(), \"\", 1<<28);\n\t\tthread.start();\n\t\tthread.join();\n\t}\n\n\tstatic class EMakeItIncreasing {\n\t\tprivate final int iinf = 1_000_000_000;\n\n\t\tpublic EMakeItIncreasing() {\n\t\t}\n\n\t\tpublic int solve(int[] arr, int l, int r) {\n\t\t\tint n = arr.length, ans = -1;\n\t\t\tint[] val = new int[n], ind = new int[n];\n\t\t\tArrays.fill(val, iinf+1);\n\t\t\tfor(int i = 0; i<n; i++) {\n\t\t\t\tif(arr[i]<r-n+i+1&&arr[i]>l+i) {\n\t\t\t\t\tint a = -1, b = ans;\n\t\t\t\t\twhile(a<b) {\n\t\t\t\t\t\tint mid = (a+b+1)/2;\n\t\t\t\t\t\tif(arr[i]<=val[mid]||i-ind[mid]>arr[i]-val[mid]) {\n\t\t\t\t\t\t\tb = mid-1;\n\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\ta = mid;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tans = Math.max(ans, a+1);\n\t\t\t\t\tif(arr[i]-i<val[a+1]-ind[a+1]) {\n\t\t\t\t\t\tval[a+1] = arr[i];\n\t\t\t\t\t\tind[a+1] = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn n-ans-1;\n\t\t}\n\n\t\tpublic void solve(int kase, InputReader in, Output pw) {\n\t\t\tint n = in.nextInt(), k = in.nextInt();\n\t\t\tint[] arr = in.nextInt(n);\n\t\t\tboolean[] valid = new boolean[n];\n\t\t\tArrays.fill(valid, true);\n\t\t\tfor(int i = 0; i<k; i++) {\n\t\t\t\tvalid[in.nextInt()-1] = false;\n\t\t\t}\n\t\t\tfor(int i = 0; i<n; i++) {\n\t\t\t\tfor(; i<n&&valid[i]; i++) ;\n\t\t\t\tif(i==n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint prev = -1;\n\t\t\t\tfor(; i<n&&!valid[i]; i++) {\n\t\t\t\t\tif(arr[i]<=prev) {\n\t\t\t\t\t\tpw.println(\"-1\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tprev = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = 0;\n\t\t\tfor(int i = 0; i<n; i++) {\n\t\t\t\tfor(; i<n&&!valid[i]; i++) ;\n\t\t\t\tif(i==n) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint start = i;\n\t\t\t\tfor(; i<n&&valid[i]; i++) ;\n\t\t\t\tint l = start==0 ? -2*n : arr[start-1], r = i==n ? iinf+2*n : arr[i];\n\t\t\t\tif(r-l-1<i-start) {\n\t\t\t\t\tpw.println(\"-1\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tans += solve(Arrays.copyOfRange(arr, start, i), l, r);\n//\t\t\t\tUtilities.Debug.dbg(ans);\n\t\t\t}\n\t\t\tpw.println(ans);\n\t\t}\n\n\t}\n\n\tstatic class Output implements Closeable, Flushable {\n\t\tpublic StringBuilder sb;\n\t\tpublic OutputStream os;\n\t\tpublic int BUFFER_SIZE;\n\t\tpublic String lineSeparator;\n\n\t\tpublic Output(OutputStream os) {\n\t\t\tthis(os, 1<<16);\n\t\t}\n\n\t\tpublic Output(OutputStream os, int bs) {\n\t\t\tBUFFER_SIZE = bs;\n\t\t\tsb = new StringBuilder(BUFFER_SIZE);\n\t\t\tthis.os = new BufferedOutputStream(os, 1<<17);\n\t\t\tlineSeparator = System.lineSeparator();\n\t\t}\n\n\t\tpublic void println(int i) {\n\t\t\tprintln(String.valueOf(i));\n\t\t}\n\n\t\tpublic void println(String s) {\n\t\t\tsb.append(s);\n\t\t\tprintln();\n\t\t}\n\n\t\tpublic void println() {\n\t\t\tsb.append(lineSeparator);\n\t\t}\n\n\t\tprivate void flushToBuffer() {\n\t\t\ttry {\n\t\t\t\tos.write(sb.toString().getBytes());\n\t\t\t}catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tsb = new StringBuilder(BUFFER_SIZE);\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\ttry {\n\t\t\t\tflushToBuffer();\n\t\t\t\tos.flush();\n\t\t\t}catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic void close() {\n\t\t\tflush();\n\t\t\ttry {\n\t\t\t\tos.close();\n\t\t\t}catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class Utilities {\n\t\tpublic static class Debug {\n\t\t\tpublic static boolean LOCAL = System.getProperty(\"ONLINE_JUDGE\")==null;\n\n\t\t\tprivate static <T> String ts(T t) {\n\t\t\t\tif(t==null) {\n\t\t\t\t\treturn \"null\";\n\t\t\t\t}\n\t\t\t\ttry {\n\t\t\t\t\treturn ts((Iterable) t);\n\t\t\t\t}catch(ClassCastException e) {\n\t\t\t\t\tif(t instanceof int[]) {\n\t\t\t\t\t\tString s = Arrays.toString((int[]) t);\n\t\t\t\t\t\treturn \"{\"+s.substring(1, s.length()-1)+\"}\";\n\t\t\t\t\t}else if(t instanceof long[]) {\n\t\t\t\t\t\tString s = Arrays.toString((long[]) t);\n\t\t\t\t\t\treturn \"{\"+s.substring(1, s.length()-1)+\"}\";\n\t\t\t\t\t}else if(t instanceof char[]) {\n\t\t\t\t\t\tString s = Arrays.toString((char[]) t);\n\t\t\t\t\t\treturn \"{\"+s.substring(1, s.length()-1)+\"}\";\n\t\t\t\t\t}else if(t instanceof double[]) {\n\t\t\t\t\t\tString s = Arrays.toString((double[]) t);\n\t\t\t\t\t\treturn \"{\"+s.substring(1, s.length()-1)+\"}\";\n\t\t\t\t\t}else if(t instanceof boolean[]) {\n\t\t\t\t\t\tString s = Arrays.toString((boolean[]) t);\n\t\t\t\t\t\treturn \"{\"+s.substring(1, s.length()-1)+\"}\";\n\t\t\t\t\t}\n\t\t\t\t\ttry {\n\t\t\t\t\t\treturn ts((Object[]) t);\n\t\t\t\t\t}catch(ClassCastException e1) {\n\t\t\t\t\t\treturn t.toString();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprivate static <T> String ts(T[] arr) {\n\t\t\t\tStringBuilder ret = new StringBuilder();\n\t\t\t\tret.append(\"{\");\n\t\t\t\tboolean first = true;\n\t\t\t\tfor(T t: arr) {\n\t\t\t\t\tif(!first) {\n\t\t\t\t\t\tret.append(\", \");\n\t\t\t\t\t}\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tret.append(ts(t));\n\t\t\t\t}\n\t\t\t\tret.append(\"}\");\n\t\t\t\treturn ret.toString();\n\t\t\t}\n\n\t\t\tprivate static <T> String ts(Iterable<T> iter) {\n\t\t\t\tStringBuilder ret = new StringBuilder();\n\t\t\t\tret.append(\"{\");\n\t\t\t\tboolean first = true;\n\t\t\t\tfor(T t: iter) {\n\t\t\t\t\tif(!first) {\n\t\t\t\t\t\tret.append(\", \");\n\t\t\t\t\t}\n\t\t\t\t\tfirst = false;\n\t\t\t\t\tret.append(ts(t));\n\t\t\t\t}\n\t\t\t\tret.append(\"}\");\n\t\t\t\treturn ret.toString();\n\t\t\t}\n\n\t\t\tpublic static void dbg(Object... o) {\n\t\t\t\tif(LOCAL) {\n\t\t\t\t\tSystem.err.print(\"Line #\"+Thread.currentThread().getStackTrace()[2].getLineNumber()+\": [\");\n\t\t\t\t\tfor(int i = 0; i<o.length; i++) {\n\t\t\t\t\t\tif(i!=0) {\n\t\t\t\t\t\t\tSystem.err.print(\", \");\n\t\t\t\t\t\t}\n\t\t\t\t\t\tSystem.err.print(ts(o[i]));\n\t\t\t\t\t}\n\t\t\t\t\tSystem.err.println(\"]\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tinterface InputReader {\n\t\tint nextInt();\n\n\t\tdefault int[] nextInt(int n) {\n\t\t\tint[] ret = new int[n];\n\t\t\tfor(int i = 0; i<n; i++) {\n\t\t\t\tret[i] = nextInt();\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t}\n\n\tstatic class FastReader implements InputReader {\n\t\tfinal private int BUFFER_SIZE = 1<<16;\n\t\tprivate final DataInputStream din;\n\t\tprivate final byte[] buffer;\n\t\tprivate int bufferPointer;\n\t\tprivate int bytesRead;\n\n\t\tpublic FastReader(InputStream is) {\n\t\t\tdin = new DataInputStream(is);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint ret = 0;\n\t\t\tbyte c = skipToDigit();\n\t\t\tboolean neg = (c=='-');\n\t\t\tif(neg) {\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdo {\n\t\t\t\tret = ret*10+c-'0';\n\t\t\t} while((c = read())>='0'&&c<='9');\n\t\t\tif(neg) {\n\t\t\t\treturn -ret;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate boolean isDigit(byte b) {\n\t\t\treturn b>='0'&&b<='9';\n\t\t}\n\n\t\tprivate byte skipToDigit() {\n\t\t\tbyte ret;\n\t\t\twhile(!isDigit(ret = read())&&ret!='-') ;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() {\n\t\t\ttry {\n\t\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\t}catch(IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif(bytesRead==-1) {\n\t\t\t\tbuffer[0] = -1;\n\t\t\t}\n\t\t}\n\n\t\tprivate byte read() {\n\t\t\tif(bytesRead==-1) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}else if(bufferPointer==bytesRead) {\n\t\t\t\tfillBuffer();\n\t\t\t}\n\t\t\treturn buffer[bufferPointer++];\n\t\t}\n\n\t}\n}\n\n", "label": 3}
{"src": "\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class E {\n\n\tpublic static class pair implements Comparable<pair> {\n\t\tint f;\n\t\tint s;\n\n\t\tpair(int x, int y) {\n\n\t\t\tf = x;\n\t\t\ts = y;\n\n\t\t}\n\n\t\tpublic pair() {\n\n\t\t}\n\n\t\tpublic int compareTo(pair o) {\n\t\t\t// TODO Auto-generated method stub\n\n\t\t\treturn (int) this.s - (int) o.s;\n\t\t}\n\t}\n\n\tstatic int mod = (int) 1e9 + 7;\n\tstatic ArrayList<Integer> gr[];\n\tstatic int ar[];\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int pri[] = new int[(int) 1e6 + 5];\n\tstatic StringBuilder out = new StringBuilder();\n\n\tstatic void in(int a[], int n) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = sc.nextInt();\n\t}\n\t\n\tstatic void in(int a[],int l,int r) {\n\t\tfor (int i = l+1; i <=r; i++)\n\t\t\ta[i] = sc.nextInt();\n\t\t\n\t\t\n\t}\n\n\tstatic void buildGraph(int n, int m) {\n\n\t\tgr = new ArrayList[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\tgr[i] = new ArrayList<>();\n\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\n\t\t\tu--;\n\t\t\tv--;\n\t\t\tgr[u].add(v);\n\t\t\tgr[v].add(u);\n\t\t}\n\n\t}\n\t\n\tstatic int b[];\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint t =1;// sc.nextInt();\n\t\t\n\t\twhile (t-- > 0) {\n\t\t\t\n\t\t\t\n\t\t\tint n=sc.nextInt();\n\t\t\tint k=sc.nextInt();\n\t\t\t\n\t\t\tar=new int [n+2];\n\t\t\tin(ar,0,n);\n\t\t\t\n\t\t\tfor(int i=1;i<=n;i++)ar[i]-=i;\n\t\t\t\n\t\t\tar[n+1]=(int)2e9;\n\t\t\t\n\t\t\tb=new int [k+1];\n\t\t\tin(b,k);\n\t\t\tb[k]=n+1;\n\t\t\t\n\t\t\t\n\t\t\n\t\t\t\n\t\t\tint lst=0;\n\t\t\tint ans=0;\n\t\t\tar[0]=-(int)1e9;\n\t\t\tfor(int i=0;i<=k;i++) {\n\t\t\t\t\n\t\t\t\n\t\t\tans+=solve(lst,b[i]);\n\t\t\tif(ans>(int)1e9)break;\n\t\t\tlst=b[i];\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tout.append(ans>=(int)1e9?-1:ans+\"\\n\");\n\n\t\t}\n\t\t\n\t\tSystem.out.println(out);\n\t}\n\t\n\t\n\t\n\t\n\tstatic int solve(int l, int r) {\n\t\tif(l==r)return 0;\n\t\t\n\t\tif(ar[l]>ar[r]) {\n\t\t\treturn (int)1e9;\n\t\t}\n\t\t\n\t\tlen=new int[r-l+1];\n\t\tArrays.fill(len, (int)1e9);\n\t\tlen[0]=(int)-1e9;\n\t\t\n\t\tint ans=0;\n\t\tfor(int i=l+1;i<r;i++) {\n\t\t\t\n\t\t\tif(ar[i]>ar[r] || ar[i]<ar[l])continue;\n\t\t\t\n\t\t\tint val=ar[i];\n\t\t\t\n\t\t\tint id=bs(ar[i],len.length-1);\n\t\t\t\n\t\t\tlen[id+1]=Math.min(len[id+1], ar[i]);\n\t\t\t\n\t\t\tans=Math.max(ans, id+1);\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\treturn (r-l-1)-ans;\n\t\t\n\t\t\n\t}\n\t\n\t static  int len[];\n\t   \n\t    \n\t    static int bs(int val,int n){\n\t        \n\t        int l=0;\n\t        int hi=n;\n\t        int ans=0;\n\t        while(l<=hi){\n\t            \n\t            int mid=(l+hi)/2;\n\t            \n\t            if(len[mid]<=val){\n\t                \n\t                ans=mid;\n\t                l=mid+1;\n\t                \n\t            }\n\t            else hi=mid-1;\n\t        }\n\t        return ans;\n\t    }\n\t\n\t\n\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n \npublic class Main{\n\tstatic long[] a;\n\tstatic boolean[] b;\n\tstatic int[] m;\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(in.readLine());\n\t\tint n = pint(st), k = pint(st);\n\t\ta = new long[n];\n\t\tb = new boolean[n];\n\t\tm = new int[n + 1];\n\t\tst = new StringTokenizer(in.readLine());\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\ta[i] = pint(st);\n\t\t}\n\t\tint[] b = new int[k];\n\t\tif(k != 0) {st = new StringTokenizer(in.readLine());}\n\t\tif(k == 0) {\n\t\t\tSystem.out.println( subseq(0, n - 1, -(long)(1e10), (long)(1e10)));\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < k; i++) {\n\t\t\tb[i] = pint(st) - 1;\n\t\t}\n\t\tint t = 0;\n\t\tt += subseq(0, b[0] - 1, -(long)(1e10), a[b[0]]);\n\t\tfor(int i = 0; i < k - 1; i++) {\n\t\t\tt += subseq(b[i] + 1, b[i + 1] - 1, a[b[i]], a[b[i + 1]] );\n\t\t}\n\t\tt += subseq(b[k - 1] + 1, n - 1, a[b[k - 1]], (long)(1e10));\n\t\tif(t > n) {\n\t\t\tt = -1;\n\t\t}\n\t\tSystem.out.println(t);\n\t}\n\tstatic int subseq( int low, int high, long l, long h) {\n\t\tif(h - l < high + 1 - low + 1) {return (int)1e7;}\n\t\tint r = 0;\n\t\tfor(int i = low; i <= high; i++) {\n\t\t\tif(a[i] - l <= i - low) {\n\t\t\t\tb[i] = true;\n\t\t\t\tr++;\n\t\t\t}else if(high - i >= h - a[i]) {\n\t\t\t\tb[i] = true;\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\tm[0] = -Integer.MAX_VALUE;\n\t\tint t = 0;\n\t\tfor(int i = low; i <= high; i++) {\n\t\t\tif(b[i]) {continue;}\n\t\t\tint li = 1, hi = t;\n\t\t\twhile(li <= hi) {\n\t\t\t\tint mid = (int)(Math.ceil(li + hi) / 2);\n\t\t\t\tif(a[m[mid]] - m[mid] <= a[i] - i) {\n\t\t\t\t\tli = mid + 1;\n\t\t\t\t}else {\n\t\t\t\t\thi = mid - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint newl = li;\n\t\t\tm[newl] = i;\n\t\t\tif(newl > t) {\n\t\t\t\tt = newl;\n\t\t\t}\n\t\t}\n\t\treturn high - low - r + 1 - t + r;\n\t}\n    static int pint(BufferedReader in) throws IOException {return Integer.parseInt(in.readLine());}\n    static int pint(StringTokenizer st) {return Integer.parseInt(st.nextToken());}\n}", "label": 3}
{"src": "/*\n    Fixing old WA code.\n */\n\n//created by Whiplash99\nimport java.io.*;\nimport java.util.*;\npublic class A\n{\n    private static int[] dp;\n    private static void NO()\n    {\n        System.out.println(-1);\n        System.exit(0);\n    }\n    private static int greater(int l, int r, int key)\n    {\n        int pos=-1;\n        while (l<=r)\n        {\n            int mid=(l+r)/2;\n            if(dp[mid]>key)\n            {\n                pos=mid;\n                r=mid-1;\n            }\n            else l=mid+1;\n        }\n        return pos;\n    }\n    private static int LIS(int l, int r, int lo, int hi, int[] a)\n    {\n        int last=-1;\n        for(int i=l;i<=r;i++)\n        {\n            if(!(lo+i-l<=a[i]&&a[i]<=hi-(r-i))) continue;\n\n            if(last==-1||dp[last]<=a[i]-i) dp[++last]=a[i]-i;\n            else dp[greater(0,last,a[i]-i)]=a[i]-i;\n        }\n\n        return last+1;\n    }\n    private static int solve(int l, int r, int lo, int hi, int[] a)\n    {\n        if(l>r) return 0;\n        if(l==r)\n        {\n            if(lo<=a[l]&&a[l]<=hi) return 0;\n            return 1;\n        }\n\n        return (r-l+1)-LIS(l,r,lo,hi,a);\n    }\n    public static void main(String[] args) throws Exception\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n        int i,N;\n\n        String[] s=br.readLine().trim().split(\" \");\n        N=Integer.parseInt(s[0]);\n        int K=Integer.parseInt(s[1]);\n\n        int[] a=new int[N];\n        s=br.readLine().trim().split(\" \");\n        for(i=0;i<N;i++) a[i]=Integer.parseInt(s[i]);\n\n        dp=new int[N];\n        if(K==0)\n        {\n            System.out.println(solve(0,N-1,Integer.MIN_VALUE+100,Integer.MAX_VALUE-100,a));\n            System.exit(0);\n        }\n\n        int[] b=new int[K];\n        s=br.readLine().trim().split(\" \");\n        for(i=0;i<K;i++) b[i]=Integer.parseInt(s[i])-1;\n\n        int prev=0,prevVal=Integer.MIN_VALUE;\n        for(i=0;i<K;i++)\n        {\n            if(a[b[i]]-b[i]+prev<prevVal) break;\n            prev=b[i]; prevVal=a[b[i]];\n        }\n\n        if(i<K) NO();\n\n        int ans=0;\n        prev=-1; int lo=Integer.MIN_VALUE+100;\n        for(i=0;i<K;i++)\n        {\n            int cost=solve(prev+1,b[i]-1,lo,a[b[i]]-1,a);\n            if(cost==-1) break;\n\n            ans+=cost;\n            prev=b[i]; lo=a[prev]+1;\n        }\n\n        if(i<K) NO();\n\n        ans+=solve(prev+1,N-1,lo,Integer.MAX_VALUE-100,a);\n        System.out.println(ans);\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n \n \n//Sub_To_Errichto\npublic class Main {\n    static final long MOD = 1000000007L;\n    //static final long MOD = 998244353L;\n    static final int INF = 2000500000;\n    static final int NINF = 500000;\n    \n    static int[] nums;\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        PrintWriter pw = new PrintWriter(System.out);\n        \n        int N = sc.ni();\n        int K = sc.ni();\n        nums = new int[N+2];\n        for (int i = 1; i <= N; i++)\n        \tnums[i] = sc.ni()+1000000000;\n        nums[0] = NINF;\n        nums[N+1] = INF;\n        int[] bad = new int[K+2];\n        for (int i = 1; i <= K; i++)\n        \tbad[i] = sc.ni();\n        bad[0] = 0;\n        bad[K+1] = N+1;\n        \n        \n        for (int i = 1; i <= K+1; i++) {\n        \tif (nums[bad[i]] <= nums[bad[i-1]]) {\n        \t\tpw.println(-1);\n        \t\tpw.close();\n        \t\treturn;\n        \t}\n        }\n        int ans = 0;\n        for (int i = 1; i <= K+1; i++) {\n        \tint gap = nums[bad[i]]-nums[bad[i-1]]-1;\n        \tint size = bad[i]-bad[i-1]-1;\n        \tif (gap < size) {\n        \t\tpw.println(-1);\n        \t\tpw.close();\n        \t\treturn;\n        \t}\n        \t\n        \tans += calc(bad[i-1],bad[i]);\n        }\n        \n        pw.println(ans);\n        pw.close();\n    }\n    \n    public static int calc(int L, int R) {\n    \tif (L >= R-1)\n    \t\treturn 0;\n    \tint N = R-L-1;\n    \tint[] vals = new int[3*N];\n    \tfor (int i = 0; i < N; i++) {\n    \t\tvals[i] = nums[L]-(N-1-i);\n    \t}\n    \tfor (int i = N; i < 2*N; i++) {\n    \t\tvals[i] = nums[i-N+L+1];\n    \t}\n    \tfor (int i = 2*N; i < 3*N; i++) {\n    \t\tvals[i] = nums[R]+(i-2*N);\n    \t}\n    \tint ans = Math.min(N, resolve(vals));\n    \treturn ans;\n    }\n    \n    \n    //Publicly Available Code from Stack Overflow\n    static int resolve(int[] nums) {\n    \tint[] dp = new int[nums.length];\n    \tdp[0] = nums[0];\n    \tint right = 0;\n    \tfor (int i = 1; i < nums.length; i++) {\n    \t\tif (nums[i] >= i) {\n    \t\t\tint realNum = nums[i] - i;\n    \t\t\tif (realNum >= dp[right]) {\n    \t\t\t\tright++;\n    \t\t\t\tdp[right] = realNum;\n    \t\t\t} else {\n    \t\t\t\tdp[binarySearch(dp, 0, right, realNum)] = realNum;\n    \t\t\t}\n    \t\t}\n    \t}\n    \treturn nums.length - (right + 1);\n    }\n\n    static int binarySearch(int[] nums, int left, int right, int key) {\n    \twhile (left <= right) {\n    \t\tint mid = (left + right) >>> 1;\n        \tif (nums[mid] > key) {\n        \t\tright = mid - 1;\n        \t} else {\n        \t\tleft = mid + 1;\n        \t}\n    \t}\n    \treturn left;\n    }\n    \n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int ni() {\n            return Integer.parseInt(next());\n        }\n \n        long nl() {\n            return Long.parseLong(next());\n        }\n \n        double nd() {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "label": 3}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Random;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\n\npublic class Main {\n\n\t\npublic static void main(String[] args){\n \n   new Thread(null, null, \"Anshum Gupta\", 99999999) {\n        public void run() {\n            try {\n                solve();\n            } catch(Exception e) {\n                e.printStackTrace();\n                System.exit(1);\n            }\n        }\n    }.start();\n}\n \nstatic final long MXX = (long)(1e18 + 5), MOD = (long)1e9 + 7;//998244353;\nstatic final int MXN = (int)(1001), MXV = (int)(1e6), log = 18, INF = (int)1e9 + 500;\nstatic boolean[]vis;\nstatic ArrayList<ArrayList<Integer>> adj;\nstatic int n, m, q, k;\nstatic char[] str;\n\n\npublic static void solve() throws Exception {\n\t   // solve the problem here\n\t\ts = new MyScanner();\n   \t\tout = new MyWriter(new BufferedOutputStream(System.out));\n//\t   \t\tout = new PrintWriter(\"output.txt\");\n        int tc = 1;//s.nextInt();   \n    \tfor(int i=1; i<=tc; i++) {\n//        \tout.print(\"Case #\" + i + \": \");\n    \t\ttestcase();\n    \t}\n          \n        out.flush();\n        out.close();\n}\n\n\nstatic void testcase() {\n\tn = s.nextInt();\n\tk = s.nextInt();\n\tlong[] a = new long[n + 2];\n\t\n\t// subtracted i so that I don't have to make strictly increasing\n\t// rather array a should be non decreasing now\n\t\n\ta[0] = Long.MIN_VALUE;\n\ta[n + 1] = Long.MAX_VALUE;\n\tfor(int i = 1; i <= n; i++) \n\t\ta[i] = s.nextLong() - i + n;\n\t\n\t// which positions cannot be changed\n\t\n\tint[] fixed = new int[k + 2];\n\tfixed[k + 1] = n + 1;\n\tfor(int i = 1; i <= k; i++) {\n\t\tfixed[i] = s.nextInt();\n\t}\n\t\n\t\n\t// input => 1, 2, 1, 1, 3, 5, 1\n\t// fixed => 0, 0, 1, 0, 1, 0, 0\n\t\n\t// answer is just (size(segment) - lis(segment))\n\t// do this for each segment separately\n\t\n\t\n\tint answer = 0;\n\t\n\tfor(int i = 1; i < k + 2; i++) {\n\t\tint left = fixed[i - 1], right = fixed[i];\n\t\t\n\t\tint value = getLIS(a, left, right);\n\t\tif(value == -1) {\n\t\t\tout.println(\"-1\");\n\t\t\treturn;\n\t\t}\n\t\tanswer += value;\n\t}\n\t\n\tout.println(answer);\n\t\n\t\n\t\n\t\n}\n\n\n\nprivate static int getLIS(long[] a, int left, int right) {\n\t\n\t\n\tlong leftValue = a[left], rightValue = a[right];\n\tif(leftValue > rightValue) \n\t\treturn -1;\n\t\n\tleft++;\n\tright--;\n\t\n\tint size = right - left + 1;\n\tlong[] temp = new long[size];\n\tint i = 0;\n\tfor(int j = left; j <= right; j++) {\n\t\tif(a[j] >= a[left - 1] && a[j] <= a[right + 1])\n\t\t\ttemp[i++] = (long) a[j] << 32 | j;\n\t}\n\t\n\tlong[] array = Arrays.copyOf(temp, i);\n\t\n\treturn size - getLongestIncreasingSubsequence(array);\n}\n\nprivate static int getLongestIncreasingSubsequence(long[] array) {\n\tint size = array.length;\n\tif(size == 0) return 0;\n\tlong[] tailTable = new long[size]; \n    int len; // always points empty slot \n  \n//    out.println(Arrays.toString(array));\n\n    tailTable[0] = array[0]; \n    len = 1; \n    for (int i = 1; i < size; i++) { \n        if (array[i] < tailTable[0]) \n            // new smallest value \n            tailTable[0] = array[i]; \n\n        else if (array[i] > tailTable[len - 1]) \n            // A[i] wants to extend largest subsequence \n            tailTable[len++] = array[i]; \n\n        else\n            // A[i] wants to be current end candidate of an existing \n            // subsequence. It will replace ceil value in tailTable \n            tailTable[ceilIndex(tailTable, -1, len - 1, array[i])] = array[i]; \n    } \n\n    return len; \n}\n\nprivate static int ceilIndex(long array[], int left, int right, long key) \n{ \n    while (right - left > 1) { \n        int mid = left + (right - left) / 2; \n        if (array[mid] >= key) \n            right = mid; \n        else\n            left = mid; \n    } \n\n    return right; \n} \n\npublic static MyWriter out;\npublic static MyScanner s;\nstatic void shuffleArray(int[] a) {\n\tRandom random = new Random();\n\tfor (int i = a.length-1; i > 0; i--) {\n\t\tint index = random.nextInt(i + 1);\n\t\tint tmp = a[index];\n\t\ta[index] = a[i];\n\t\ta[i] = tmp;\n\t}\n}\nstatic void shuffleSort(int[] a) {\n\tshuffleArray(a);\n\tArrays.parallelSort(a);\n}\nstatic class MyScanner {\n \n    BufferedReader br;\n    StringTokenizer st;\n \n    public MyScanner() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n    public MyScanner(String fileName) {\n    \ttry {\n\t\t\tbr = new BufferedReader(new FileReader(fileName));\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n    }\n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n \n    int nextInt() { return Integer.parseInt(next()); }\n    long nextLong() { return Long.parseLong(next()); }\n    double nextDouble() { return Double.parseDouble(next()); }\n    int[] nextIntArray(int n){\n    \tint[]a = new int[n];\n    \tfor(int i=0; i<n; i++) {\n    \t\ta[i] = this.nextInt();\n    \t}\n    \treturn a;\n    }\n    long[] nextlongArray(int n) {\n    \tlong[]a = new long[n];\n    \tfor(int i=0; i<n; i++) {\n    \t\ta[i] = this.nextLong();\n    \t}\n    \treturn a;\n    }\n    Integer[] nextIntegerArray(int n){\n    \tInteger[]a = new Integer[n];\n    \tfor(int i=0; i<n; i++) {\n    \t\ta[i] = this.nextInt();\n    \t}\n    \treturn a;\n    }\n    Long[] nextLongArray(int n) {\n    \tLong[]a = new Long[n];\n    \tfor(int i=0; i<n; i++) {\n    \t\ta[i] = this.nextLong();\n    \t}\n    \treturn a;\n    }\n    char[][] next2DCharArray(int n, int m){\n    \tchar[][]arr = new char[n][m];\n    \tfor(int i=0; i<n; i++) {\n    \t\tarr[i] = this.next().toCharArray();\n    \t}\n    \treturn arr;\n    }\n    ArrayList<ArrayList<Integer>> readUndirectedUnweightedGraph(int n, int m) {\n    \tArrayList<ArrayList<Integer>>adj = new ArrayList<ArrayList<Integer>>();\n    \tfor(int i=0; i<=n; i++)adj.add(new ArrayList<Integer>());\n    \tfor(int i=0; i<m; i++) {\n    \t\tint u = s.nextInt();\n    \t\tint v = s.nextInt();\n    \t\tadj.get(u).add(v);\n    \t\tadj.get(v).add(u);\n    \t}\n    \treturn adj;\n    }\n    ArrayList<ArrayList<Integer>> readDirectedUnweightedGraph(int n, int m) {\n    \tArrayList<ArrayList<Integer>>adj = new ArrayList<ArrayList<Integer>>();\n    \tfor(int i=0; i<=n; i++)adj.add(new ArrayList<Integer>());\n    \tfor(int i=0; i<m; i++) {\n    \t\tint u = s.nextInt();\n    \t\tint v = s.nextInt();\n    \t\tadj.get(u).add(v);\n    \t}\n    \treturn adj;\n    }\n    String nextLine(){\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}\n \nstatic class MyWriter extends PrintWriter {\n    MyWriter(OutputStream out) {\n        super(out);\n    }\n    void println(int[] x) {\n        println(x, \" \");\n    }\n    void println(int[] x, String delimiter) {\n        if (x.length > 0) {\n            print(x[0]);\n            for (int i = 1; i < x.length; i++) {\n                print(delimiter);\n                print(x[i]);\n            }\n        }\n        println();\n    }\n    void println(long[] x) {\n        println(x, \" \");\n    }\n    void println(long[] x, String delimiter) {\n        if (x.length > 0) {\n            print(x[0]);\n            for (int i = 1; i < x.length; i++) {\n                print(delimiter);\n                print(x[i]);\n            }\n        }\n        println();\n    }\n    void println(Iterable<?> iterable) {\n        println(iterable, \" \");\n    }\n    void println(Iterable<?> iterable, String delimiter) {\n        Iterator<?> i = iterable.iterator();\n        if (i.hasNext()) {\n            print(i.next());\n            while (i.hasNext()) {\n                print(delimiter);\n                print(i.next());\n            }\n        }\n        println();\n    }\n    void printLines(int[] x) {\n        println(x, System.lineSeparator());\n    }\n    void printLines(long[] x) {\n        println(x, System.lineSeparator());\n    }\n    void printLines(Iterable<?> iterable) {\n        println(iterable, System.lineSeparator());\n    }\n}\n \n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class E {\n    public static void main(String[] args) throws Exception {\n        FastReader in = new FastReader(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = in.nextInt(), k = in.nextInt();\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt() - i;\n        }\n        int[] b = new int[k];\n        for (int i = 0; i < k; i++) {\n            b[i] = in.nextInt() - 1;\n        }\n\n        a = shrink(a);\n\n        if (!check(n, k, a, b)) {\n            pw.println(-1);\n        } else {\n            int res = k;\n            SegTree seg = new SegTree(n + 5);\n            if (k == 0) {\n                res = getLIS(0, n - 1, 0, n, a, seg);\n            } else {\n                int last = 0, l = 0;\n                for (int i : b) {\n                    res += getLIS(last, i - 1, l, a[i], a, seg);\n                    last = i + 1;\n                    l = a[i];\n                }\n                res += getLIS(last, n - 1, l, n, a, seg);\n            }\n            pw.println(n - res);\n        }\n\n        pw.close();\n    }\n\n    static int getLIS(int a, int b, int l, int r, int[] arr, SegTree seg) {\n        for (int i = l; i <= r; i++) {\n            seg.set(i, 0);\n        }\n        int cnt = 0;\n        for (int i = b; i >= a; i--) {\n            if (arr[i] < l || arr[i] > r) continue;\n            int val = 1 + seg.query(arr[i], r);\n            seg.update(arr[i], val);\n            cnt = max(cnt, val);\n        }\n\n        return cnt;\n    }\n\n    static boolean check(int n, int k, int[] a, int[] b) {\n        int last = 0;\n        for (int i : b) {\n            if (a[i] < last) {\n                return false;\n            }\n            last = a[i];\n        }\n        return true;\n    }\n\n\n    public static void shuffle(long[] a) {\n        Random rnd = new Random();\n        for (int i = a.length - 1; i >= 1; i--) {\n            int j = rnd.nextInt(i + 1);\n            long t = a[i];\n            a[i] = a[j];\n            a[j] = t;\n        }\n    }\n\n    public static int[] shrink(int[] a) {\n        int n = a.length;\n        long[] b = new long[n];\n        for (int i = 0; i < n; i++) b[i] = (long) a[i] << 32 | i;\n        shuffle(b);\n        Arrays.sort(b);\n        int[] ret = new int[n];\n        int p = 0;\n        for (int i = 0; i < n; i++) {\n            if (i > 0 && (b[i] ^ b[i - 1]) >> 32 != 0) p++;\n            ret[(int) b[i]] = p;\n        }\n\n        for (int i = 0; i < n; i++) {\n            ret[i]++;\n        }\n        return ret;\n    }\n\n\n    static class SegTree {\n        int t[];\n        int n;\n\n        SegTree(int N) { // 0-based indexing\n            t = new int[2 * N];\n            n = t.length;\n        }\n\n        public int get(int i) {\n            return t[i + n / 2];\n        }\n\n        public int operation(int a, int b) {\n            return max(a, b); // change to min(a, b) or (a+b) for different ops\n        }\n\n        public void update(int i, int value) {\n            i += n / 2;\n            t[i] = max(t[i], value);\n            for (; i > 1; i >>= 1)\n                t[i >> 1] = operation(t[i], t[i ^ 1]);\n        }\n\n        public void set(int i, int value) {\n            i += n / 2;\n            t[i] = value;\n            for (; i > 1; i >>= 1)\n                t[i >> 1] = operation(t[i], t[i ^ 1]);\n        }\n\n        public int query(int a, int b) {\n            int res = 0; // for sum, res = 0; for min, res = -inf ..etc\n            for (a += n / 2, b += n / 2; a <= b; a = (a + 1) >> 1, b = (b - 1) >> 1) {\n                if ((a & 1) != 0)\n                    res = operation(res, t[a]);\n                if ((b & 1) == 0)\n                    res = operation(res, t[b]);\n            }\n            return res;\n        }\n    }\n\n    static void debug(Object... obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n\n    static class FastReader {\n        InputStream is;\n        private byte[] inbuf = new byte[1024];\n        private int lenbuf = 0, ptrbuf = 0;\n\n        public FastReader(InputStream is) {\n            this.is = is;\n        }\n\n        public int readByte() {\n            if (lenbuf == -1) throw new InputMismatchException();\n            if (ptrbuf >= lenbuf) {\n                ptrbuf = 0;\n                try {\n                    lenbuf = is.read(inbuf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (lenbuf <= 0) return -1;\n            }\n            return inbuf[ptrbuf++];\n        }\n\n        public boolean isSpaceChar(int c) {\n            return !(c >= 33 && c <= 126);\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        public int skip() {\n            int b;\n            while ((b = readByte()) != -1 && isSpaceChar(b)) ;\n            return b;\n        }\n\n        public String next() {\n            int b = skip();\n            StringBuilder sb = new StringBuilder();\n            while (!(isSpaceChar(b))) {\n                sb.appendCodePoint(b);\n                b = readByte();\n            }\n            return sb.toString();\n        }\n\n\n        public String nextLine() {\n            int c = skip();\n            StringBuilder sb = new StringBuilder();\n            while (!isEndOfLine(c)) {\n                sb.appendCodePoint(c);\n                c = readByte();\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() {\n            int num = 0, b;\n            boolean minus = false;\n            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n            while (true) {\n                if (b >= '0' && b <= '9') {\n                    num = (num << 3) + (num << 1) + (b - '0');\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public long nextLong() {\n            long num = 0;\n            int b;\n            boolean minus = false;\n            while ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-')) ;\n            if (b == '-') {\n                minus = true;\n                b = readByte();\n            }\n\n            while (true) {\n                if (b >= '0' && b <= '9') {\n                    num = (num << 3) + (num << 1) + (b - '0');\n                } else {\n                    return minus ? -num : num;\n                }\n                b = readByte();\n            }\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public char[] next(int n) {\n            char[] buf = new char[n];\n            int b = skip(), p = 0;\n            while (p < n && !(isSpaceChar(b))) {\n                buf[p++] = (char) b;\n                b = readByte();\n            }\n            return n == p ? buf : Arrays.copyOf(buf, p);\n        }\n\n        public char readChar() {\n            return (char) skip();\n        }\n    }\n}", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class tr0 {\n\tstatic PrintWriter out;\n\tstatic StringBuilder sb;\n\tstatic long mod = (long) 1e9 + 7;\n\tstatic long inf = (long) 1e16;\n\tstatic int n, k, l;\n\tstatic ArrayList<Integer>[] ad;\n\tstatic int[][] memo;\n\tstatic boolean vis[];\n\tstatic long[] f, inv, ncr[];\n\tstatic HashMap<Integer, Integer> hm;\n\tstatic int[] a;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tn = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\ta = new int[n + 2];\n\t\tboolean[] here = new boolean[n + 2];\n\t\there[0] = true;\n\t\there[n + 1] = true;\n\t\ta[0] = -2000000000;\n\t\ta[n + 1] = 2000000000;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\ta[i] = sc.nextInt();\n\t\tint ans = 0;\n\t\tif (k != 0) {\n\t\t\tint[] idc = new int[k];\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tidc[i] = sc.nextInt();\n\t\t\t\there[idc[i]] = true;\n\t\t\t}\n\t\t\tfor (int i = 1; i < k; i++) {\n\t\t\t\tint x = a[idc[i]];\n\t\t\t\tint y = a[idc[i - 1]];\n\t\t\t\tif (x <= y || x - y < idc[i] - idc[i - 1]) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l = 0;\n\t\tfor (int i = 1; i < a.length; i++)\n\t\t\tif (here[i]) {\n\t\t\t\tans += solve(l, i);\n\t\t\t\tl = i;\n\t\t\t}\n\t\tSystem.out.println(ans);\n\t\tout.close();\n\t}\n\n\tstatic int solve1(int l, int r) {\n\t\tif (r == l + 1 || r == l)\n\t\t\treturn 0;\n\t\tint ans = 0;\n\t\tArrayList<Integer> ar = new ArrayList<>();\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tint num = a[i] - i;\n\t\t\tint best = 0;\n\t\t\tif (ar.isEmpty()) {\n\t\t\t\tbest = 1;\n\t\t\t\tar.add(num);\n\t\t\t} else if (ar.get(ar.size() - 1) <= num) {\n\t\t\t\tbest = ar.size() + 1;\n\t\t\t\tar.add(num);\n\t\t\t} else {\n\t\t\t\tint lo = 0;\n\t\t\t\tint hi = ar.size() - 1;\n\t\t\t\twhile (lo <= hi) {\n\t\t\t\t\tint mid = (lo + hi) >> 1;\n\t\t\t\t\t// System.out.println(lo+\" \"+hi+\" \"+mid);\n\t\t\t\t\tif (ar.get(mid).intValue() > num) {\n\t\t\t\t\t\thi = mid - 1;\n\t\t\t\t\t\tbest = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlo = mid + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tar.set(best, num);\n\t\t\t\tbest++;\n\t\t\t}\n\t\t\tif (i == r)\n\t\t\t\tans = best;\n\t\t}\n\t\treturn r - l + 1 - ans;\n\t}\n\n\tstatic int solve(int l, int r) {\n\t\tint ans = 0;\n\t\tint len = r - l + 1;\n\t\tFenwickTree ft = new FenwickTree(len + 3);\n\t\tTreeSet<Integer> ts = new TreeSet<>();\n\t\tfor (int i = l; i <= r; i++)\n\t\t\tts.add(a[i] - i);\n\n\t\tHashMap<Integer, Integer> hm = new HashMap<>();\n\t\tint id = 2;\n\t\twhile (!ts.isEmpty())\n\t\t\thm.put(ts.pollFirst(), id++);\n\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tint v = a[i] - i;\n\t\t\tif (v < a[l] - l || a[r] - r < v)\n\t\t\t\tcontinue;\n\t\t\tint num = hm.get(a[i] - i);\n\t\t\tint best = ft.rsq(num);\n\t\t\tft.point_update(num, best + 1);\n\t\t\tif (i == r)\n\t\t\t\tans = best + 1;\n\t\t}\n\n\t\treturn r - l + 1 - ans;\n\t}\n\n\tpublic static class FenwickTree { // one-based DS\n\n\t\tint ni;\n\t\tint[] ft;\n\n\t\tFenwickTree(int size) {\n\t\t\tni = size;\n\t\t\tft = new int[ni + 1];\n\t\t}\n\n\t\tint rsq(int b) // O(log n)\n\t\t{\n\t\t\tint max = 0;\n\t\t\twhile (b > 0) {\n\t\t\t\tmax = Math.max(max, ft[b]);\n\t\t\t\tb -= b & -b;\n\t\t\t} // min?\n\t\t\treturn max;\n\t\t}\n\n\t\tvoid point_update(int k, int val) // O(log n), update = increment\n\t\t{\n\t\t\twhile (k <= ni) {\n\t\t\t\tft[k] = Math.max(val, ft[k]);\n\t\t\t\tk += k & -k;\n\t\t\t} // min?\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int[] nextArrInt(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextArrLong(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "label": 3}
{"src": "// package com.company;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Set;\n\n//****Use Integer Wrapper Class for Arrays.sort()****\npublic class FW5 {\n    static PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n    public static void main(String[] Args) throws Exception {\n        FastReader scan = new FastReader(System.in);\n        int t = 1;\n//        t = scan.nextInt();\n        while (t-- > 0) {\n            int n = scan.nextInt();\n            int k = scan.nextInt();\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = scan.nextInt();\n            }\n            Set<Integer> s = new HashSet<>();\n            ArrayList<Integer> b = new ArrayList<>();\n            for (int i = 0; i < k; i++) {\n                int num = scan.nextInt() - 1;\n                s.add(num);\n                b.add(num);\n            }\n            boolean pos = true;\n            if (k > 1) {\n                for (int i = 1; i < k; i++) {\n                    int i1 = b.get(i);\n                    int i2 = b.get(i - 1);\n                    int v1 = arr[i1];\n                    int v2 = arr[i2];\n                    int req = i1 - i2 - 1;\n                    int avai = v1 - v2 - 1;\n                    if (avai < req) {\n                        pos = false;\n                    }\n                }\n            }\n            if (!pos) {\n                out.println(-1);\n            } else {\n                int max = Integer.MAX_VALUE;\n                Set<Integer> change = new HashSet<>();\n                for (int i = n - 1; i >= 0; i--) {\n                    if (s.contains(i)) {\n                        max = arr[i];\n                    } else {\n                        if (arr[i] > max) {\n                            arr[i] = max;\n                            change.add(i);\n                        }\n                    }\n                    max--;\n                }\n                b.add(n);\n                int nn=b.size();\n                for(int i=0;i<nn-1;i++){\n                    int start=b.get(i);\n                    int min=arr[start]+1;\n                    start++;\n                    int end=b.get(i+1);\n                    for(int l=start;l<end;l++){\n                        if(arr[l]<min){\n                            arr[l]=min;\n                            change.add(l);\n                        }\n                        min++;\n                    }\n                }\n                int ans = change.size();\n                int prev = -1;\n                for (Integer i : b) {\n                    if (i - prev - 1 > 0) {\n                        ArrayList<Integer> send=new ArrayList<>();\n                        for(int j=prev+1;j<i;j++){\n                            if(!change.contains(j)){\n                                send.add(j);\n                            }\n                        }\n                        int[] sen=new int[send.size()];\n                        int l=0;\n                        for(Integer j:send){\n                            sen[l]=arr[j]-j;\n                            l++;\n                        }\n                        int nc=0;\n                        if(sen.length>0){\n                            nc=LIS(sen);\n                        }\n                        ans+=l-nc;\n                    }\n                    prev = i;\n                }\n                out.println(ans);\n            }\n        }\n        out.flush();\n        out.close();\n    }\n\n    static int getin(int arr[], int r, int key) {\n        int l=0;\n        int in=-1;\n        while(l<=r){\n            int mid=(l+r)/2;\n            if(key>=arr[mid]){\n                in=mid;\n                l=mid+1;\n            }else{\n                r=mid-1;\n            }\n        }\n        return in;\n    }\n\n    static int LIS(int[] arr) {\n        int n = arr.length;\n        int[] tailTable = new int[n];\n        int len;\n        tailTable[0] = arr[0];\n        len = 1;\n        for (int i = 1; i < n; i++) {\n            if (arr[i] < tailTable[0]) {\n                tailTable[0] = arr[i];\n            } else if (arr[i] >= tailTable[len - 1]) {\n                tailTable[len++] = arr[i];\n            } else {\n                int in=getin(tailTable,len-2,arr[i]);\n                if(in!=-1&&arr[i]<=tailTable[in+1]){\n                    tailTable[in+1]=arr[i];\n                }\n            }\n        }\n        return len;\n    }\n    static class pair{\n        int x;\n        int y;\n        pair(int x,int y){\n            this.x=x;\n            this.y=y;\n        }\n    }\n    static class FastReader {\n\n        byte[] buf = new byte[2048];\n        int index, total;\n        InputStream in;\n\n        FastReader(InputStream is) {\n            in = is;\n        }\n\n        int scan() throws IOException {\n            if (index >= total) {\n                index = 0;\n                total = in.read(buf);\n                if (total <= 0) {\n                    return -1;\n                }\n            }\n            return buf[index++];\n        }\n\n        String next() throws IOException {\n            int c;\n            for (c = scan(); c <= 32; c = scan()) ;\n            StringBuilder sb = new StringBuilder();\n            for (; c > 32; c = scan()) {\n                sb.append((char) c);\n            }\n            return sb.toString();\n        }\n\n        int nextInt() throws IOException {\n            int c, val = 0;\n            for (c = scan(); c <= 32; c = scan()) ;\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n\n        long nextLong() throws IOException {\n            int c;\n            long val = 0;\n            for (c = scan(); c <= 32; c = scan()) ;\n            boolean neg = c == '-';\n            if (c == '-' || c == '+') {\n                c = scan();\n            }\n            for (; c >= '0' && c <= '9'; c = scan()) {\n                val = (val << 3) + (val << 1) + (c & 15);\n            }\n            return neg ? -val : val;\n        }\n    }\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n \npublic class Main {\n    static PrintWriter out;\n    static Reader in;\n    public static void main(String[] args) throws IOException {\n        //out = new PrintWriter(new File(\"out.txt\"));\n        //PrintWriter out = new PrintWriter(System.out);\n        //in = new Reader(new FileInputStream(\"in.txt\"));\n        //Reader in = new Reader();\n        input_output();\n        Main solver = new Main();\n        solver.solve();\n        out.flush();\n        out.close();\n \n    }\n \n    static int INF = (int)1e9;\n    static int maxn = (int)5e5+5;\n    static int mod = (int)1e9+7;\n    static int n, m, q, t, k;\n\n    void solve() throws IOException{\n        n = in.nextInt();\n        k = in.nextInt();\n\n        int[] arr = new int[n+2];\n        for (int i = 1; i <= n; i++) arr[i] = in.nextInt();\n\n        List<Integer> dontouch = new ArrayList<Integer>();\n        dontouch.add(0); arr[0] = -(int)1e9-1000000;\n        for (int i = 0; i < k; i++) {\n            dontouch.add(in.nextInt());\n        }\n        dontouch.add(n+1); arr[n+1] = (int)1e9+1000000;\n\n        for (int i = 1; i <= k+1; i++) {\n            if (arr[dontouch.get(i)] <= arr[dontouch.get(i-1)] || dontouch.get(i)-dontouch.get(i-1) > arr[dontouch.get(i)]-arr[dontouch.get(i-1)]) {\n                out.println(-1);\n                return;\n            }\n        }\n\n        tree = new int[maxn*4];\n\n        int ans = 0;\n        int l = 0, r = 0;\n        for (int s = 1; s <= k+1; s++) {\n            l = dontouch.get(s-1)+1;\n            r = dontouch.get(s)-1;\n            if (l > r) continue;\n            update(1, 0, maxn, l-1, 0, 0);\n\n            List<Node> list = new ArrayList<Node>();\n            for (int j = l; j <= r; j++) {\n                list.add(new Node(arr[j]-j, j));\n            }\n            list.add(new Node(arr[r+1]-r-1, r+1));\n            list.add(new Node(arr[l-1]-(l-1), l-1));\n\n            Collections.sort(list);\n            for (int i = 0; i < list.size(); i++) {\n                Node node = list.get(i);\n\n                if (node.idx == l-1) {\n                    update(1, 0, maxn, node.idx, 1, 0);\n                    continue;\n                }\n\n                int val = query(1, 0, maxn, l-1, node.idx);\n                if (val != 0)  update(1, 0, maxn, node.idx, val+1, 1);\n            }\n\n\n            int res = query(1, 0, maxn, r+1, r+1);\n            ans += r+1-(l-1)+1-res;\n        }\n\n        out.println(ans);\n    }\n\n    //<>\n\n    static class Node implements Comparable<Node>{\n        int idx, val;\n        Node (int val, int idx) {\n            this.val = val;\n            this.idx = idx;\n        }\n\n        public int compareTo(Node o) {\n            if (this.val != o.val) return this.val - o.val;\n            return this.idx - o.idx;\n        }\n    }\n\n    static int[] tree, cost;\n    \n    static void build(int node, int start, int end){\n        // Leaf node will have a single element\n        if(start == end)   tree[node] = cost[start]; \n        else {\n            int mid = (start + end) / 2;\n            // Recurse on the left child\n            build(2*node, start, mid);\n            // Recurse on the right child\n            build(2*node+1, mid+1, end);\n            // Internal node will have the sum of both of its children\n            tree[node] = Math.max( tree[2*node] , tree[2*node+1]);\n        }\n    }\n    \n    static void update(int node, int start, int end, int idx, int val, int upd){\n        if(start == end){\n            // Leaf node\n            if (upd == 1) tree[node] = Math.max(val, tree[node]);\n            else tree[node] = val;\n        }\n        else{\n            int mid = (start + end) / 2;\n            if(start <= idx && idx <= mid){\n                // If idx is in the left child, recurse on the left child\n                update(2*node, start, mid, idx, val, upd);\n            }\n            else{\n                // if idx is in the right child, recurse on the right child\n                update(2*node+1, mid+1, end, idx, val, upd);\n            }\n            // Internal node will have the sum of both of its children\n            tree[node] = Math.max(tree[2*node] , tree[2*node+1]);\n        }\n    }\n    \n    static int query(int node, int start, int end, int l, int r){\n        if(r < start || end < l){\n            // range represented by a node is completely outside the given range\n            return 0;\n        }\n        if(l <= start && end <= r){\n            // range represented by a node is completely inside the given range\n            return tree[node];\n        }\n        // range represented by a node is partially inside and partially outside the given range\n        int mid = (start + end) / 2;\n        int p1 = query(2*node, start, mid, l, r);\n        int p2 = query(2*node+1, mid+1, end, l, r);\n        return Math.max(p1 , p2);\n    }\n\n    static class Reader {\n \n        private InputStream mIs;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n    \n        public Reader() {\n            this(System.in);\n        }\n    \n        public Reader(InputStream is) {\n            mIs = is;\n        }\n    \n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n    \n        }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = mIs.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n    \n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n    \n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n    \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n    \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n    \n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n    \n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    \n        public boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n \n    }\n    static void input_output() throws IOException {\n        File f = new File(\"in.txt\");\n        if(f.exists() && !f.isDirectory()) { \n            in = new Reader(new FileInputStream(\"in.txt\"));\n        } else in = new Reader();\n        f = new File(\"out.txt\");\n        if(f.exists() && !f.isDirectory()) {\n            out = new PrintWriter(new File(\"out.txt\"));\n        } else out = new PrintWriter(System.out);\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF1437E extends PrintWriter {\n\tCF1437E() { super(System.out, true); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1437E o = new CF1437E(); o.main(); o.flush();\n\t}\n\n\tint[] ft;\n\tvoid update(int i, int n, int x) {\n\t\twhile (i < n) {\n\t\t\tft[i] = Math.max(ft[i], x);\n\t\t\ti |= i + 1;\n\t\t}\n\t}\n\tint query(int i) {\n\t\tint x = 0;\n\t\twhile (i >= 0) {\n\t\t\tx = Math.max(x, ft[i]);\n\t\t\ti &= i + 1; i--;\n\t\t}\n\t\treturn x;\n\t}\n\tInteger[] ii;\n\tint solve(int[] aa, int n) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tii[i] = i;\n\t\tArrays.sort(ii, 0, n, (i, j) -> aa[i] - aa[j]);\n\t\tint m = 0;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\taa[ii[i]] = i + 1 == n || aa[ii[i + 1]] != aa[ii[i]] ? m++ : m;\n\t\tArrays.fill(ft, 0, m, 0);\n\t\tint k_ = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = aa[i];\n\t\t\tint k = query(a) + 1;\n\t\t\tupdate(a, m, k);\n\t\t\tk_ = Math.max(k_, k);\n\t\t}\n\t\treturn n - k_;\n\t}\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint[] aa = new int[n + 2];\n\t\taa[0] = -n; aa[n + 1] = 1000000000;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\taa[i] = sc.nextInt() - i;\n\t\tint[] bb = new int[k + 2];\n\t\tbb[0] = 0; bb[k + 1] = n + 1;\n\t\tfor (int h = 1; h <= k; h++)\n\t\t\tbb[h] = sc.nextInt();\n\t\tfor (int h = 2; h <= k; h++) {\n\t\t\tif (aa[bb[h - 1]] > aa[bb[h]]) {\n\t\t\t\tprintln(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tft = new int[n + 2];\n\t\tii = new Integer[n + 2];\n\t\tint ans = 0;\n\t\tint[] qu = new int[n + 2];\n\t\tfor (int h = 1; h <= k + 1; h++) {\n\t\t\tint l = bb[h - 1], r = bb[h];\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = l; i <= r; i++) {\n\t\t\t\tint a = aa[i];\n\t\t\t\tif (aa[l] <= a && a <= aa[r])\n\t\t\t\t\tqu[cnt++] = a;\n\t\t\t\telse\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\tif (cnt > 2)\n\t\t\t\tans += solve(qu, cnt);\n\t\t}\n\t\tprintln(ans);\n\t}\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String args[]) {new Main().run();}\n\n    FastReader in = new FastReader();\n    PrintWriter out = new PrintWriter(System.out);\n    void run(){\n        work();\n        out.flush();\n    }\n    long mod=1000000007;\n    long gcd(long a,long b) {\n        return a==0?b:gcd(b%a,a);\n    }\n    void work() {\n        int n=ni(),k=ni();\n        int ret=0;\n        long[] A=new long[n+2];\n        A[0]=Integer.MIN_VALUE;\n        A[n+1]=Integer.MAX_VALUE;\n        for(int i=0;i<n;i++){\n            A[i+1]=ni();\n        }\n        int[] B=new int[k+2];\n        B[0]=0;\n        B[k+1]=n+1;\n        for(int i=0;i<k;i++){\n            B[i+1]=ni();\n        }\n        for(int i=0;i<B.length-1;i++){\n            int idx1=B[i],idx2=B[i+1];\n            long v1=A[idx1],v2=A[idx2]-(idx2-idx1);\n            if(v1>v2){\n                out.println(-1);\n                return;\n            }\n            long[] stack=new long[idx2-idx1+1];\n            int cur=1;\n            stack[0]=v1;\n            for(int j=idx1+1;j<=idx2;j++){\n                long v=A[j]-(j-idx1);\n                if(v1>v)continue;\n                if(v>=stack[cur-1]){\n                    if(j==idx2){\n                        ret+=idx2-idx1-cur;\n                    }\n                    stack[cur]=v;\n                    cur++;\n                }else{\n                    int l=0,r=cur;\n                    while(l<r){\n                        int m=(l+r)/2;\n                        if(stack[m]<=v){\n                            l=m+1;\n                        }else{\n                            r=m;\n                        }\n                    }\n                    if(j==idx2){\n                        ret+=idx2-idx1-l;\n                    }\n                    stack[l]=v;\n                }\n            }\n        }\n        out.println(ret);\n    }\n\n\n    //input\n    @SuppressWarnings(\"unused\")\n    private ArrayList<Integer>[] ng(int n, int m) {\n        ArrayList<Integer>[] graph=(ArrayList<Integer>[])new ArrayList[n];\n        for(int i=0;i<n;i++) {\n            graph[i]=new ArrayList<>();\n        }\n        for(int i=1;i<=m;i++) {\n            int s=in.nextInt()-1,e=in.nextInt()-1;\n            graph[s].add(e);\n            graph[e].add(s);\n        }\n        return graph;\n    }\n\n    private ArrayList<long[]>[] ngw(int n, int m) {\n        ArrayList<long[]>[] graph=(ArrayList<long[]>[])new ArrayList[n];\n        for(int i=0;i<n;i++) {\n            graph[i]=new ArrayList<>();\n        }\n        for(int i=1;i<=m;i++) {\n            long s=in.nextLong()-1,e=in.nextLong()-1,w=in.nextLong();\n            graph[(int)s].add(new long[] {e,w});\n//            graph[(int)e].add(new long[] {s,w});\n        }\n        return graph;\n    }\n\n    private int ni() {\n        return in.nextInt();\n    }\n\n    private long nl() {\n        return in.nextLong();\n    }\n\n    private String ns() {\n        return in.next();\n    }\n\n    private long[] na(int n) {\n        long[] A=new long[n];\n        for(int i=0;i<n;i++) {\n            A[i]=in.nextLong();\n        }\n        return A;\n    }\n    private int[] nia(int n) {\n        int[] A=new int[n];\n        for(int i=0;i<n;i++) {\n            A[i]=in.nextInt();\n        }\n        return A;\n    }\n}\n\nclass FastReader\n{\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader()\n    {\n        br=new BufferedReader(new InputStreamReader(System.in));\n    }\n\n\n    public String next()\n    {\n        while(st==null || !st.hasMoreElements())//\u56de\u8f66\uff0c\u7a7a\u884c\u60c5\u51b5\n        {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt()\n    {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong()\n    {\n        return Long.parseLong(next());\n    }\n}", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.Map;\nimport java.io.OutputStreamWriter;\nimport java.io.OutputStream;\nimport java.io.PrintStream;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.util.AbstractMap;\nimport java.util.TreeMap;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.util.Map.Entry;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        new TaskAdapter().run();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            EMakeItIncreasing solver = new EMakeItIncreasing();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class EMakeItIncreasing {\n        Debug debug = new Debug(true);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            int k = in.readInt();\n            int[] a = new int[n];\n            in.populate(a);\n            for (int i = 0; i < n; i++) {\n                a[i] -= i;\n            }\n            int[] b = new int[k];\n            in.populate(b);\n            for (int i = 0; i < k; i++) {\n                b[i]--;\n            }\n            if (k == 0) {\n                out.println(n - lis(a, 0, n - 1, false, false));\n                return;\n            }\n            Randomized.shuffle(b);\n            Arrays.sort(b);\n            for (int i = 1; i < k; i++) {\n                if (a[b[i - 1]] > a[b[i]]) {\n                    out.println(-1);\n                    return;\n                }\n            }\n            int lis = lis(a, 0, b[0], false, true) - 1;\n            for (int i = 1; i < k; i++) {\n                lis += lis(a, b[i - 1], b[i], true, true) - 2;\n            }\n            lis += lis(a, b[k - 1], n - 1, true, false) - 1;\n            out.println(n - k - lis);\n        }\n\n        public int lis(int[] a, int l, int r, boolean includeL, boolean includeR) {\n            MultiSet<Integer> set = new MultiSet<>();\n            set.add(a[l]);\n            for (int i = l + 1; i <= r; i++) {\n                if (includeL && a[i] < a[l]) {\n                    continue;\n                }\n                Integer ceil = set.ceil(a[i] + 1);\n                if (ceil != null) {\n                    set.remove(ceil);\n                }\n                set.add(a[i]);\n            }\n            if (includeR) {\n                while (set.last() > a[r]) {\n                    set.pollLast();\n                }\n            }\n            debug.run(() -> {\n                String s = String.format(\"[%d, %d], %d %d = %d\", l, r, includeL ? 1 : 0, includeR ? 1 : 0, set.size());\n                debug.debug(\"res\", s);\n            });\n            return set.size();\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 1 << 13;\n        private final Writer os;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(int c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(String c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(int c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append(System.lineSeparator());\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager() == null;\n        }\n\n        public void run(Runnable task) {\n            if (offline) {\n                task.run();\n            }\n        }\n\n        public Debug debug(String name, String x) {\n            if (offline) {\n                out.printf(\"%s=%s\", name, x);\n                out.println();\n            }\n            return this;\n        }\n\n    }\n\n    static class RandomWrapper {\n        private Random random;\n        public static final RandomWrapper INSTANCE = new RandomWrapper(new Random());\n\n        public RandomWrapper() {\n            this(new Random());\n        }\n\n        public RandomWrapper(Random random) {\n            this.random = random;\n        }\n\n        public int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(int[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readInt();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class MultiSet<T> {\n        private TreeMap<T, Integer> map;\n        private int size;\n\n        public MultiSet(Comparator<T> comp) {\n            this.map = new TreeMap<>(comp);\n        }\n\n        public MultiSet() {\n            this.map = new TreeMap<>();\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public T last() {\n            return map.lastKey();\n        }\n\n        public T pollLast() {\n            size--;\n            Map.Entry<T, Integer> last = map.lastEntry();\n            update(last.getKey(), last.getValue() - 1);\n            return last.getKey();\n        }\n\n        public void add(T key) {\n            size++;\n            update(key, map.getOrDefault(key, 0) + 1);\n        }\n\n        public void remove(T key) {\n            size--;\n            update(key, map.getOrDefault(key, 0) - 1);\n        }\n\n        public T ceil(T x) {\n            return map.ceilingKey(x);\n        }\n\n        public void update(T key, int cnt) {\n            if (cnt == 0) {\n                map.remove(key);\n            } else if (cnt > 0) {\n                map.put(key, cnt);\n            } else {\n                size++;\n            }\n        }\n\n        public String toString() {\n            return map.toString();\n        }\n\n    }\n\n    static class Randomized {\n        public static void shuffle(int[] data) {\n            shuffle(data, 0, data.length - 1);\n        }\n\n        public static void shuffle(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return RandomWrapper.INSTANCE.nextInt(l, r);\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.Collection;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author aryssoncf\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        EMakeItIncreasing solver = new EMakeItIncreasing();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EMakeItIncreasing {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.readInt(), k = in.readInt();\n            int[] a = in.readIntArray(n), b = in.readIntArray(k);\n            for (int i = 0; i < n; i++) {\n                a[i] -= i;\n            }\n            MiscUtils.decreaseByOne(b);\n            boolean valid = true;\n            int res = 0;\n            for (int i = 0; i <= k; i++) {\n                int left = i > 0 ? a[b[i - 1]] : Integer.MIN_VALUE, right = i < k ? a[b[i]] : Integer.MAX_VALUE;\n                EzIntList list = new EzIntArrayList();\n                int total = 0;\n                for (int j = i > 0 ? b[i - 1] + 1 : 0; j < (i < k ? b[i] : n); j++) {\n                    total++;\n                    if (a[j] >= left && a[j] <= right) {\n                        list.add(a[j]);\n                    }\n                }\n                res += total - lnds(list);\n                if (i > 0 && i < k && a[b[i]] < a[b[i - 1]]) {\n                    valid = false;\n                }\n            }\n            if (!valid) {\n                out.printLine(-1);\n            } else {\n                out.printLine(res);\n            }\n        }\n\n        private int lnds(EzIntList list) {\n            EzIntList stack = new EzIntArrayList();\n            for (int elem : list.toArray()) {\n                int pos = MiscUtils.binarySearchInt(0, stack.size(), i -> i == stack.size() || stack.get(i) > elem);\n                if (pos == stack.size()) {\n                    stack.add(elem);\n                } else {\n                    stack.set(pos, elem);\n                }\n            }\n            return stack.size();\n        }\n\n    }\n\n    static final class PrimitiveHashCalculator {\n        private PrimitiveHashCalculator() {\n        }\n\n        public static int getHash(int x) {\n            return x;\n        }\n\n    }\n\n    static interface EzIntStack extends EzIntCollection {\n        int size();\n\n        EzIntIterator iterator();\n\n        boolean equals(Object object);\n\n        int hashCode();\n\n        String toString();\n\n    }\n\n    static interface EzIntIterator {\n        boolean hasNext();\n\n        int next();\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static interface IntFilter {\n        public boolean accept(int value);\n\n    }\n\n    static class EzIntArrayList implements EzIntList, EzIntStack {\n        private static final int DEFAULT_CAPACITY = 10;\n        private static final double ENLARGE_SCALE = 2.0;\n        private static final int HASHCODE_INITIAL_VALUE = 0x811c9dc5;\n        private static final int HASHCODE_MULTIPLIER = 0x01000193;\n        private int[] array;\n        private int size;\n\n        public EzIntArrayList() {\n            this(DEFAULT_CAPACITY);\n        }\n\n        public EzIntArrayList(int capacity) {\n            if (capacity < 0) {\n                throw new IllegalArgumentException(\"Capacity must be non-negative\");\n            }\n            array = new int[capacity];\n            size = 0;\n        }\n\n        public EzIntArrayList(EzIntCollection collection) {\n            size = collection.size();\n            array = new int[size];\n            int i = 0;\n            for (EzIntIterator iterator = collection.iterator(); iterator.hasNext(); ) {\n                array[i++] = iterator.next();\n            }\n        }\n\n        public EzIntArrayList(int[] srcArray) {\n            size = srcArray.length;\n            array = new int[size];\n            System.arraycopy(srcArray, 0, array, 0, size);\n        }\n\n        public EzIntArrayList(Collection<Integer> javaCollection) {\n            size = javaCollection.size();\n            array = new int[size];\n            int i = 0;\n            for (int element : javaCollection) {\n                array[i++] = element;\n            }\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public EzIntIterator iterator() {\n            return new EzIntArrayListIterator();\n        }\n\n        public int[] toArray() {\n            int[] result = new int[size];\n            System.arraycopy(array, 0, result, 0, size);\n            return result;\n        }\n\n        public boolean add(int element) {\n            if (size == array.length) {\n                enlarge();\n            }\n            array[size++] = element;\n            return true;\n        }\n\n        public int get(int index) {\n            if (index < 0 || index >= size) {\n                throw new IndexOutOfBoundsException(\"Index \" + index + \" is out of range, size = \" + size);\n            }\n            return array[index];\n        }\n\n        public int set(int index, int element) {\n            if (index < 0 || index >= size) {\n                throw new IndexOutOfBoundsException(\"Index \" + index + \" is out of range, size = \" + size);\n            }\n            final int oldElement = array[index];\n            array[index] = element;\n            return oldElement;\n        }\n\n        private void enlarge() {\n            int newSize = Math.max(size + 1, (int) (size * ENLARGE_SCALE));\n            int[] newArray = new int[newSize];\n            System.arraycopy(array, 0, newArray, 0, size);\n            array = newArray;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            EzIntArrayList that = (EzIntArrayList) o;\n\n            if (size != that.size) {\n                return false;\n            }\n            for (int i = 0; i < size; i++) {\n                if (array[i] != that.array[i]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n\n        public int hashCode() {\n            int hash = HASHCODE_INITIAL_VALUE;\n            for (int i = 0; i < size; i++) {\n                hash = (hash ^ PrimitiveHashCalculator.getHash(array[i])) * HASHCODE_MULTIPLIER;\n            }\n            return hash;\n        }\n\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append('[');\n            for (int i = 0; i < size; i++) {\n                sb.append(array[i]);\n                if (i < size - 1) {\n                    sb.append(\", \");\n                }\n            }\n            sb.append(']');\n            return sb.toString();\n        }\n\n        private class EzIntArrayListIterator implements EzIntIterator {\n            private int curIndex = 0;\n\n            public boolean hasNext() {\n                return curIndex < size;\n            }\n\n            public int next() {\n                if (curIndex == size) {\n                    throw new NoSuchElementException(\"Iterator doesn't have more elements\");\n                }\n                return array[curIndex++];\n            }\n\n        }\n\n    }\n\n    static class MiscUtils {\n        public static int binarySearchInt(int from, int to, IntFilter function) {\n            while (from < to) {\n                int argument = from + ((to - from) >> 1);\n                if (function.accept(argument)) {\n                    to = argument;\n                } else {\n                    from = argument + 1;\n                }\n            }\n            return from;\n        }\n\n        public static void decreaseByOne(int[]... arrays) {\n            for (int[] array : arrays) {\n                for (int i = 0; i < array.length; i++) {\n                    array[i]--;\n                }\n            }\n        }\n\n    }\n\n    static interface EzIntList extends EzIntCollection {\n        int size();\n\n        EzIntIterator iterator();\n\n        int[] toArray();\n\n        boolean add(int element);\n\n        boolean equals(Object object);\n\n        int hashCode();\n\n        String toString();\n\n        int get(int index);\n\n        int set(int index, int element);\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static interface EzIntCollection {\n        int size();\n\n        EzIntIterator iterator();\n\n        boolean equals(Object object);\n\n        int hashCode();\n\n        String toString();\n\n    }\n}\n\n", "label": 3}
{"src": "import java.awt.*;\nimport java.io.*;\nimport java.util.*;\nimport java.util.List;\nimport java.util.concurrent.LinkedBlockingQueue;\n\npublic class Coding {\n\n    private static BufferedReader bi = new BufferedReader(new InputStreamReader(System.in));\n    private static BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n\n    public static void main(String[] args) {\n        try {\n            run();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void run() throws Exception {\n        InputModule inp = new InputModule();\n        OutputModule out = new OutputModule();\n        int t = 1;\n        while (t > 0) {\n            int[] inps = inp.cinIntArray(2);\n            int n = inps[0];\n            int k = inps[1];\n            int[] ints = inp.cinIntArray(n);\n            Set<Integer> has = new HashSet<>();\n            if (k > 0) {\n                inps = inp.cinIntArray(k);\n                for (int i = 0; i < k; ++i) {\n                    has.add(inps[i]);\n                }\n            }\n            boolean poss = true;\n            int ans = 0;\n            int prev = -1;\n            for (int i = 0; i < n; ++i) {\n                if (has.contains(i+1)) {\n                    if ((prev != -1) && (ints[i] < (ints[prev] + i - prev))) {\n                        poss = false;\n                        break;\n                    }\n                    int len = i - prev - 1;\n                    if (len > 0) {\n                        int[] tmp = new int[len];\n                        for (int j = 0; j < len; ++j) {\n                            tmp[j] = ints[prev + 1 + j];\n                        }\n                        ans += LCSMaxWithConstraints(tmp, len, prev == -1 ? -1 : ints[prev], ints[i]);\n                       // System.out.println(i + \" \" + ans);\n                    }\n                    prev = i;\n                }\n            }\n\n            int len = n - prev - 1;\n            if (len > 0) {\n                int[] tmp = new int[len];\n                for (int j = 0; j < len; ++j) {\n                    tmp[j] = ints[prev + 1 + j];\n                }\n                ans += LCSMaxWithConstraints(tmp, len, prev == -1 ? -1 : ints[prev], -1);\n            }\n            if (poss) {\n                out.printInt(ans);\n            } else {\n                out.printInt(-1);\n            }\n            t--;\n        }\n    }\n\n    static int CeilIndex(int bestLCSEndingIndex[], int l, int r, int[] ar, int newIndex) {\n        int index = -1;\n        while (l<=r) {\n            int mid = (l+r)/2;\n            if (ar[newIndex]<=ar[bestLCSEndingIndex[mid]]) {\n                index = mid;\n                r = mid-1;\n            } else if ((ar[newIndex]-ar[bestLCSEndingIndex[mid]])<(newIndex-bestLCSEndingIndex[mid])) {\n                index = mid;\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return index;\n    }\n\n    static int LCSMaxWithConstraints(int ar[], int size, int lval, int rval) {\n        int[] bestLCSEndingIndex = new int[size];\n        bestLCSEndingIndex[0] = Integer.MAX_VALUE;\n        // Best LCS yet.\n        int len = 0;\n        for (int i = 0; i < size; i++) {\n            boolean poss = true;\n            if (lval != -1) {\n                int diff = ar[i] - lval;\n                if (diff < i + 1) {\n                    poss = false;\n                }\n            }\n            if (rval != -1) {\n                int diff = rval - ar[i];\n                if (diff < size - i) {\n                    poss = false;\n                }\n            }\n            if (!poss) {\n                continue;\n            }\n\n            if (len == 0) {\n                len = 1;\n                bestLCSEndingIndex[0] = i;\n            } else if (ar[i] < ar[bestLCSEndingIndex[0]]) {\n                bestLCSEndingIndex[0] = i;\n            } else if (ar[i] > ar[bestLCSEndingIndex[len - 1]] && (ar[i] - ar[bestLCSEndingIndex[len - 1]])>=(i-bestLCSEndingIndex[len - 1])) {\n                bestLCSEndingIndex[len++] = i;\n            } else {\n                bestLCSEndingIndex[CeilIndex(bestLCSEndingIndex, 0, len - 1, ar, i)] = i;\n            }\n        }\n\n        // Changes = total length - size of LCS\n        return size - len;\n    }\n\n\n    private static class InputModule {\n        private int cinInt() throws Exception {\n            return Integer.parseInt(bi.readLine().split(\" \")[0].trim());\n        }\n\n        private long cinLong() throws Exception {\n            return Long.parseLong(bi.readLine().split(\" \")[0].trim());\n        }\n\n        private Double cinDouble() throws Exception {\n            return Double.parseDouble(bi.readLine().split(\" \")[0].trim());\n        }\n\n        private String cinString() throws Exception {\n            return bi.readLine();\n        }\n\n        private int[] cinIntArray(int n) throws Exception {\n            String input = bi.readLine();\n            String[] values = input.split(\" \");\n            int[] ar = new int[n];\n            for (int i = 0; i < n; ++i) {\n                ar[i] = Integer.parseInt(values[i]);\n            }\n            return ar;\n        }\n\n        private long[] cinLongArray(int n) throws Exception {\n            String input = bi.readLine();\n            String[] values = input.split(\" \");\n            long[] ar = new long[n];\n            for (int i = 0; i < n; ++i) {\n                ar[i] = Long.parseLong(values[i]);\n            }\n            return ar;\n        }\n\n        private String[] cinStringArray(int n) throws Exception {\n            return bi.readLine().split(\" \");\n        }\n    }\n\n    private static class OutputModule {\n        private void printInt(int ans) throws Exception {\n            writer.append(ans + \"\\n\");\n            writer.flush();\n        }\n\n        private void printLong(long ans) throws Exception {\n            writer.append(ans + \"\\n\");\n            writer.flush();\n        }\n\n        private void printDouble(Double ans) throws Exception {\n            writer.append(String.format(\"%.10f\", ans));\n            writer.append(\"\\n\");\n            writer.flush();\n        }\n\n        private void printString(String ans) throws Exception {\n            writer.append(ans + \"\\n\");\n            writer.flush();\n        }\n\n        private void printIntArray(int[] ans) throws Exception {\n            for (int i = 0; i < ans.length; ++i) {\n                writer.append(ans[i] + \" \");\n            }\n            writer.append(\"\\n\");\n            writer.flush();\n        }\n\n        private void printLongArray(long[] ans) throws Exception {\n            for (int i = 0; i < ans.length; ++i) {\n                writer.append(ans[i] + \" \");\n            }\n            writer.append(\"\\n\");\n            writer.flush();\n        }\n\n        private void printIntMatrix(int[][] mat, int n, int m) throws Exception {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    writer.append(mat[i][j] + \" \");\n                }\n                writer.append(\"\\n\");\n            }\n            writer.flush();\n        }\n\n        private void printLongMatrix(long[][] mat, int n, int m) throws Exception {\n            for (int i = 0; i < n; ++i) {\n                for (int j = 0; j < m; ++j) {\n                    writer.append(mat[i][j] + \" \");\n                }\n                writer.append(\"\\n\");\n            }\n            writer.flush();\n        }\n\n        private void printPoint(Point p) throws Exception {\n            writer.append(p.x + \" \" + p.y + \"\\n\");\n            writer.flush();\n        }\n\n        private void printPoints(List<Point> p) throws Exception {\n            for (Point pp : p) {\n                writer.append(pp.x + \" \" + pp.y + \"\\n\");\n            }\n            writer.flush();\n        }\n    }\n}", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.util.Collections;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Sparsh Sanchorawala\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EMakeItIncreasing solver = new EMakeItIncreasing();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EMakeItIncreasing {\n        int[] tree;\n\n        void update(int n, int nL, int nR, int idx, int v) {\n            if (nR < idx || idx < nL)\n                return;\n            if (nL == idx && nR == idx) {\n                tree[n] = v;\n                return;\n            }\n            update(2 * n + 1, nL, (nL + nR) / 2, idx, v);\n            update(2 * n + 2, (nL + nR) / 2 + 1, nR, idx, v);\n            tree[n] = Math.max(tree[2 * n + 1], tree[2 * n + 2]);\n        }\n\n        int query(int n, int nL, int nR, int l, int r) {\n            if (nR < l || r < nL)\n                return 0;\n            if (l <= nL && nR <= r)\n                return tree[n];\n            return Math.max(query(2 * n + 1, nL, (nL + nR) / 2, l, r), query(2 * n + 2, (nL + nR) / 2 + 1, nR, l, r));\n        }\n\n        public void solve(int testNumber, InputReader s, PrintWriter w) {\n            int n = s.nextInt(), k = s.nextInt();\n            int[] dead = new int[n];\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = s.nextInt() - i;\n            int[] b = new int[k];\n            for (int i = 0; i < k; i++) {\n                b[i] = s.nextInt() - 1;\n                dead[b[i]] = 1;\n                if (i >= 1 && a[b[i - 1]] > a[b[i]]) {\n                    w.println(-1);\n                    return;\n                }\n            }\n            tree = new int[4 * n];\n            ArrayList<Pair> p = new ArrayList<>();\n            int l = 0;\n            while (l < n) {\n                if (dead[l] == 1) {\n                    l++;\n                    continue;\n                }\n                int r = l;\n                while (r < n && dead[r] == 0)\n                    r++;\n                r--;\n                int min = Integer.MIN_VALUE, max = Integer.MAX_VALUE;\n                if (l - 1 >= 0)\n                    min = a[l - 1];\n                if (r + 1 < n)\n                    max = a[r + 1];\n                p.add(new Pair(l, r, min, max));\n                l = r + 1;\n            }\n            int res = 0;\n            for (Pair x : p) {\n                ArrayList<Integer> f = new ArrayList<>();\n                for (int i = x.l; i <= x.r; i++) {\n                    if (a[i] >= x.min && a[i] <= x.max) {\n                        f.add(i);\n                    } else\n                        res++;\n                }\n                Collections.sort(f, new Comparator<Integer>() {\n                    public int compare(Integer i1, Integer i2) {\n                        if (a[i1] < a[i2])\n                            return -1;\n                        if (a[i1] > a[i2])\n                            return 1;\n                        if (i1 < i2)\n                            return -1;\n                        if (i1 > i2)\n                            return 1;\n                        return 0;\n                    }\n                });\n                int m = f.size();\n                int best = 0;\n                for (int j = 0; j < m; j++) {\n                    int idx = f.get(j);\n                    int val = query(0, 0, n - 1, 0, idx) + 1;\n                    best = Math.max(val, best);\n                    update(0, 0, n - 1, idx, val);\n                }\n                res += m - best;\n                for (int j = 0; j < m; j++) {\n                    int idx = f.get(j);\n                    update(0, 0, n - 1, idx, 0);\n                }\n            }\n            w.println(res);\n        }\n\n        class Pair {\n            int l;\n            int r;\n            int min;\n            int max;\n\n            Pair(int l, int r, int min, int max) {\n                this.l = l;\n                this.r = r;\n                this.min = min;\n                this.max = max;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\n/**\n * Accomplished using the EduTools plugin by JetBrains https://plugins.jetbrains.com/plugin/10081-edutools\n */\n\npublic class Main {\n\n    static int longestNonDecreasingSubsequence(List<Integer> a) {\n        int n = a.size();\n        if (n == 0) return 0;\n        int[] s = new int[n];\n        Arrays.fill(s, Integer.MAX_VALUE);\n        s[0] = a.get(0);\n        int sol = 1;\n\n        for (int i = 1; i < n; i++) {\n            int j = Arrays.binarySearch(s, a.get(i));\n            if (j < 0) j = -(j + 1);\n            while (a.get(i) >= s[j]) j++;\n            s[j] = a.get(i);\n            sol = Math.max(sol, j + 1);\n        }\n        return sol;\n    }\n\n    public static void main(String[] args) throws IOException {\n        // Write your solution here\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] line = br.readLine().split(\" \");\n        int n = Integer.parseInt(line[0]);\n        int k = Integer.parseInt(line[1]);\n\n        // Read & augment a\n        int[] a = new int[n + 2];\n        a[0] = Integer.MIN_VALUE / 2;\n        a[n + 1] = Integer.MAX_VALUE / 2;\n        line = br.readLine().split(\" \");\n        for (int i = 0; i < n; i++) {\n            a[i + 1] = Integer.parseInt(line[i]);\n        }\n\n        // Read & augment b\n        int[] b = new int[k + 2];\n        b[0] = 0;\n        b[k + 1] = n + 1;\n        if (k > 0) {\n            line = br.readLine().split(\" \");\n            for (int i = 1; i <= k; i++) {\n                b[i] = Integer.parseInt(line[i - 1]);\n            }\n            for (int i = 1; i <= k + 1; i++) {\n                if (a[b[i]] - a[b[i - 1]] < b[i] - b[i - 1]){\n                    System.out.println(-1);\n                    return;\n                }\n            }\n        }\n\n        // Solve\n        int sol = 0;\n        for (int i = 0; i <= k; i++) {\n            List<Integer> corridor = new ArrayList<>();\n            for (int j = b[i] + 1; j < b[i + 1]; j++) {\n                if (a[j] - a[b[i]] >= j - b[i] && a[b[i + 1]] - a[j] >= b[i + 1] - j) {\n                    corridor.add(a[j] - j);\n                }\n            }\n            sol += b[i + 1] - b[i] - 1 - longestNonDecreasingSubsequence(corridor);\n        }\n\n        System.out.println(sol);\n    }\n}", "label": 3}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class E_v2 {\n    //--------------------------------------------------------\n    private static final MyScanner in = new MyScanner(System.in);\n    private static final PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n    public static void main(String[] args) throws Exception {\n        Solver solver = new Solver();\n        solver.solve();\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve() throws Exception {\n            int n = in.nextInt();\n            int k = in.nextInt();\n            int[] a = new int[n + 2];\n            a[0] = Integer.MIN_VALUE / 2;\n            a[n + 1] = Integer.MAX_VALUE / 2;\n            for (int i = 1; i <= n; i++) {\n                a[i] = in.nextInt() - i;\n            }\n            int last = 0;\n            int ans = 0;\n            for (int i = 1; i <= k + 1; i++) {\n                int b = n + 1;\n                if (i <= k) {\n                    b = in.nextInt();\n                }\n                int part = compute(a, last, b);\n                if (part == -1) {\n                    out.println(\"-1\");\n                    return;\n                }\n                last = b;\n                ans += part;\n            }\n            out.println(ans);\n        }\n\n        private int compute(int[] a, int lower, int upper) {\n            if (a[upper] < a[lower]) {\n                return -1;\n            }\n            int[] d = new int[upper - lower];\n            d[0] = a[lower];\n            int last = 0;\n            for (int i = lower + 1; i < upper; i++) {\n                if (a[i] < a[lower] || a[upper] < a[i]) {\n                    continue;\n                }\n                if (a[i] >= d[last]) {\n                    d[++last] = a[i];\n                } else {\n                    d[bs(d, last + 1, a[i])] = a[i];\n                }\n            }\n            return upper - lower - 1 - last;\n        }\n\n        private int bs(int[] d, int r, int x) {\n            int l = -1;\n\n            while (l + 1 < r) {\n                int mid = (l + r) / 2;\n                if (d[mid] <= x) {\n                    l = mid;\n                } else {\n                    r = mid;\n                }\n            }\n            return r;\n        }\n    }\n\n    public static class MyScanner {\n        private final BufferedReader br;\n        private StringTokenizer st;\n\n        public MyScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        String next() throws IOException {\n            while (st == null || !st.hasMoreElements()) {\n                st = new StringTokenizer(br.readLine());\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n    }\n}", "label": 3}
{"src": "//created by Whiplash99\nimport java.io.*;\nimport java.util.*;\npublic class A\n{\n    private static int[] a,dp;\n    private static int greater(int l, int r, int key)\n    {\n        int pos=-1;\n        while (l<=r)\n        {\n            int mid=(l+r)/2;\n            if(dp[mid]>key)\n            {\n                pos=mid;\n                r=mid-1;\n            }\n            else l=mid+1;\n        }\n        return pos;\n    }\n    private static int LIS(int l, int r, int lo, int hi)\n    {\n        int last=-1;\n        for(int i=l;i<=r;i++)\n        {\n            if(a[i]<lo+i-l||a[i]>hi-(r-i)) continue;\n\n            a[i]-=i;\n            if(last==-1||dp[last]<=a[i]) dp[++last]=a[i];\n            else dp[greater(0,last,a[i])]=a[i];\n        }\n        return last+1;\n    }\n    private static int solve(int l, int r, int lo, int hi)\n    {\n        if(l>r) return 0;\n        if(l==r) return lo<=a[l]&&a[l]<=hi?0:1;\n\n        return (r-l+1)-LIS(l,r,lo,hi);\n    }\n    public static void main(String[] args) throws Exception\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n        int i,N;\n\n        String[] s=br.readLine().trim().split(\" \");\n        N=Integer.parseInt(s[0]);\n        int K=Integer.parseInt(s[1]);\n\n        a=new int[N+2]; a[0]=Integer.MIN_VALUE; a[N+1]=Integer.MAX_VALUE;\n        s=br.readLine().trim().split(\" \");\n        for(i=0;i<N;i++) a[i+1]=Integer.parseInt(s[i]);\n\n        dp=new int[N+5];\n        if(K==0)\n        {\n            System.out.println(solve(1,N,a[0]+1,a[N+1]-1));\n            System.exit(0);\n        }\n\n        int[] b=new int[K+2]; b[0]=0; b[K+1]=N+1;\n        s=br.readLine().trim().split(\" \");\n        for(i=0;i<K;i++) b[i+1]=Integer.parseInt(s[i]);\n\n        int ans=0;\n        for(i=1;i<=K+1;i++)\n        {\n            if (a[b[i]] <= a[b[i - 1]]) break;\n            if(i>1&&b[i]-b[i-1]-1>a[b[i]]-a[b[i-1]]-1) break;\n        }\n        if(i<K+2)\n        {\n            System.out.println(-1);\n            System.exit(0);\n        }\n\n        for(i=1;i<=K+1;i++)\n        {\n            int cost=solve(b[i-1]+1,b[i]-1,a[b[i-1]]+1,a[b[i]]-1);\n            if(cost==-1) break;\n\n            ans+=cost;\n        }\n        if(i<K+2) System.out.println(-1);\n        else System.out.println(ans);\n    }\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\npublic class Task5 {\n    int[] tree;\n    boolean[] reset;\n\n    private void resetTree() {\n        tree[1] = 0;\n        reset[1] = true;\n    }\n\n    private void push(int node) {\n        tree[node * 2] = 0;\n        tree[node * 2 + 1] = 0;\n        reset[node * 2] = true;\n        reset[node * 2 + 1] = true;\n        reset[node] = false;\n    }\n\n    private void set(int index, int num, int a, int b, int node) {\n        if (a == b) {\n            tree[node] = num;\n            return;\n        }\n\n        if (reset[node]) push(node);\n\n        int mid = (a + b) / 2;\n        if (index <= mid) set(index, num, a, mid, node * 2);\n        else set(index, num, mid + 1, b, node * 2 + 1);\n\n        tree[node] = Math.max(tree[node * 2], tree[node * 2 + 1]);\n    }\n\n    private int getMax(int from, int to, int a, int b, int node) {\n        if (from <= a && b <= to) return tree[node];\n\n        if (reset[node]) push(node);\n\n        int mid = (a + b) / 2;\n        int max = 0;\n        if (from <= mid) max = Math.max(max, getMax(from, to ,a ,mid , node * 2));\n        if (to > mid) max = Math.max(max, getMax(from, to, mid + 1, b, node * 2 + 1));\n\n        return max;\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Task5().solve();\n    }\n\n    private void solve() throws IOException {\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n\n        StringTokenizer tokenizer = new StringTokenizer(f.readLine());\n        int n = Integer.parseInt(tokenizer.nextToken());\n        int k = Integer.parseInt(tokenizer.nextToken());\n        int[] ar = new int[n];\n        tokenizer = new StringTokenizer(f.readLine());\n        for (int i = 0; i < n; i++) ar[i] = Integer.parseInt(tokenizer.nextToken()) - i;\n        int[] b = new int[k];\n        if (k != 0) {\n            tokenizer = new StringTokenizer(f.readLine());\n            for (int i = 0; i < k; i++) b[i] =  Integer.parseInt(tokenizer.nextToken()) - 1;\n        }\n\n        boolean impossible = false;\n        for (int i = 1; i < b.length; i++) {\n            if (ar[b[i]] < ar[b[i - 1]]) impossible = true;\n        }\n\n        if (impossible) {\n            out.println(-1);\n        } else {\n            int[][] valAndInd = new int[n][2];\n            for (int i = 0; i <n; i++) {\n                valAndInd[i][0] = ar[i];\n                valAndInd[i][1] = i;\n            }\n\n            Arrays.sort(valAndInd, new ArrayComparator());\n            int[] compressed = new int[n];\n            int currValue = 0;\n            compressed[valAndInd[0][1]] = currValue;\n            for (int i = 1; i < n; i++) {\n                if (valAndInd[i][0] > valAndInd[i - 1][0]) {\n                    currValue++;\n                }\n                compressed[valAndInd[i][1]] = currValue;\n            }\n\n            tree = new int[4 * n];\n            reset = new boolean[4 * n];\n\n            int res = 0;\n            int currB = 0;\n            for (int i = 0; i < n; i++) {\n                int prevMax = 0;\n                prevMax = getMax(0, compressed[i], 0, n - 1, 1);\n                if (currB == 0 || compressed[i] >= compressed[b[currB - 1]]) set(compressed[i], prevMax + 1, 0, n - 1, 1);\n\n\n                if (currB < k && b[currB] == i) {\n                    res += prevMax + 1;\n                    currB++;\n                    resetTree();\n                }\n            }\n\n\n            res += getMax(0, n - 1, 0, n - 1, 1);\n            out.println(n - res);\n        }\n\n        out.close();\n    }\n\n    private static class ArrayComparator implements Comparator<int[]> {\n\n        @Override\n        public int compare(int[] o1, int[] o2) {\n            return Integer.compare(o1[0], o2[0]);\n        }\n    }\n}\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\nimport java.util.ArrayList;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        EMakeItIncreasing solver = new EMakeItIncreasing();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class EMakeItIncreasing {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt(), m = in.nextInt();\n            int[] arr = new int[n + 2];\n            arr[0] = -(int) 1e9;\n            arr[n + 1] = (int) 1e9 - n - 1;\n            boolean f = true;\n            for (int i = 1; i <= n; i++) {\n                arr[i] = in.nextInt() - i;\n            }\n            int[] unchangable = new int[m + 2];\n            unchangable[0] = 0;\n            unchangable[m + 1] = n + 1;\n            for (int i = 1; i <= m; i++) {\n                unchangable[i] = in.nextInt();\n                f &= arr[unchangable[i]] >= arr[unchangable[i - 1]];\n            }\n            int ans = 0;\n            for (int i = 0; i < unchangable.length - 1; i++) {\n                ArrayList<Integer> list = new ArrayList<>();\n                for (int j = unchangable[i] + 1; j < unchangable[i + 1]; j++) {\n                    if (arr[unchangable[i]] <= arr[j] && arr[j] <= arr[unchangable[i + 1]]) {\n                        if (list.size() == 0)\n                            list.add(arr[j]);\n                        else {\n                            int index = bs(list, arr[j]);\n                            if (index + 1 == list.size())\n                                list.add(arr[j]);\n                            else\n                                list.set(index + 1, arr[j]);\n                        }\n                    }\n                }\n                ans += unchangable[i + 1] - unchangable[i] - 1 - list.size();\n            }\n            out.println(f ? ans : -1);\n        }\n\n        private int bs(ArrayList<Integer> list, int val) {\n            int low = 0, high = list.size() - 1;\n            int idx = -1;\n            while (low <= high) {\n                int mid = (low + high) / 2;\n                if (list.get(mid) <= val) {\n                    low = mid + 1;\n                    idx = mid;\n                } else\n                    high = mid - 1;\n            }\n            return idx;\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF1437E extends PrintWriter {\n\tCF1437E() { super(System.out, true); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF1437E o = new CF1437E(); o.main(); o.flush();\n\t}\n\n\tint[] ft;\n\tvoid update(int i, int n, int x) {\n\t\twhile (i < n) {\n\t\t\tft[i] = Math.max(ft[i], x);\n\t\t\ti |= i + 1;\n\t\t}\n\t}\n\tint query(int i) {\n\t\tint x = 0;\n\t\twhile (i >= 0) {\n\t\t\tx = Math.max(x, ft[i]);\n\t\t\ti &= i + 1; i--;\n\t\t}\n\t\treturn x;\n\t}\n\tInteger[] ii;\n\tint solve(int[] aa, int n) {\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tii[i] = i;\n\t\tArrays.sort(ii, 0, n, (i, j) -> aa[i] - aa[j]);\n\t\tArrays.fill(ft, 0, n, 0);\n\t\tint k_ = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint i_ = ii[i];\n\t\t\tint k = query(i_) + 1;\n\t\t\tupdate(i_, n, k);\n\t\t\tk_ = Math.max(k_, k);\n\t\t}\n\t\treturn n - k_;\n\t}\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint k = sc.nextInt();\n\t\tint[] aa = new int[n + 2];\n\t\taa[0] = -n; aa[n + 1] = 1000000000;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\taa[i] = sc.nextInt() - i;\n\t\tint[] bb = new int[k + 2];\n\t\tbb[0] = 0; bb[k + 1] = n + 1;\n\t\tfor (int h = 1; h <= k; h++)\n\t\t\tbb[h] = sc.nextInt();\n\t\tfor (int h = 2; h <= k; h++) {\n\t\t\tif (aa[bb[h - 1]] > aa[bb[h]]) {\n\t\t\t\tprintln(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tft = new int[n + 2];\n\t\tii = new Integer[n + 2];\n\t\tint ans = 0;\n\t\tint[] qu = new int[n + 2];\n\t\tfor (int h = 1; h <= k + 1; h++) {\n\t\t\tint l = bb[h - 1], r = bb[h];\n\t\t\tint cnt = 0;\n\t\t\tfor (int i = l; i <= r; i++) {\n\t\t\t\tint a = aa[i];\n\t\t\t\tif (aa[l] <= a && a <= aa[r])\n\t\t\t\t\tqu[cnt++] = a;\n\t\t\t\telse\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t\tif (cnt > 2)\n\t\t\t\tans += solve(qu, cnt);\n\t\t}\n\t\tprintln(ans);\n\t}\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class tr0 {\n\tstatic PrintWriter out;\n\tstatic StringBuilder sb;\n\tstatic long mod = (long) 1e9 + 7;\n\tstatic long inf = (long) 1e16;\n\tstatic int n, k, l;\n\tstatic ArrayList<Integer>[] ad;\n\tstatic int[][] memo;\n\tstatic boolean vis[];\n\tstatic long[] f, inv, ncr[];\n\tstatic HashMap<Integer, Integer> hm;\n\tstatic int[] a;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tn = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\ta = new int[n + 2];\n\t\tboolean[] here = new boolean[n + 2];\n\t\there[0] = true;\n\t\there[n + 1] = true;\n\t\ta[0] = -2000000000;\n\t\ta[n + 1] = 2000000000;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\ta[i] = sc.nextInt();\n\t\tint ans = 0;\n\t\tif (k != 0) {\n\t\t\tint[] idc = new int[k];\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tidc[i] = sc.nextInt();\n\t\t\t\there[idc[i]] = true;\n\t\t\t}\n\t\t\tfor (int i = 1; i < k; i++) {\n\t\t\t\tint x = a[idc[i]];\n\t\t\t\tint y = a[idc[i - 1]];\n\t\t\t\tif (x <= y || x - y < idc[i] - idc[i - 1]) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l = 0;\n\t\tfor (int i = 1; i < a.length; i++)\n\t\t\tif (here[i]) {\n\t\t\t\tans += lis(a, l, i);\n\t\t\t\tl = i;\n\t\t\t}\n\t\tSystem.out.println(ans);\n\t\tout.close();\n\t}\n\n\tstatic int lis(int[] A, int l, int r) {\n\t\tfor (int i = l; i <= r; i++)\n\t\t\tA[i] -= i;\n\t\tConvexSet set = new ConvexSet();\n\t\tint max = 0;\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tLong key = set.floorKey(A[i]);\n\t\t\tlong length = 1;\n\t\t\tif (key != null)\n\t\t\t\tlength = 1 + set.get(key);\n\t\t\telse if (i > l)\n\t\t\t\tcontinue;\n\t\t\tset.put(A[i], length);\n\t\t\tmax = Math.max(max, (int) length);\n\t\t}\n\t\tint ans = (int) ((long) set.get(A[r]));\n\t\tfor (int i = l; i <= r; i++)\n\t\t\tA[i] += i;\n\t\treturn r - l + 1 - ans;\n\t}\n\n\tstatic class ConvexSet {\n\t\tTreeMap<Long, Long> map;\n\n\t\tpublic ConvexSet() {\n\t\t\tmap = new TreeMap<>();\n\t\t}\n\n\t\tvoid put(long key, long val) {\n\t\t\tMap.Entry<Long, Long> e;\n\t\t\t// if ((e = map.floorEntry(key)) != null && e.getValue() >= val)\n\t\t\t// return;\n\t\t\twhile (!map.isEmpty() && (e = map.ceilingEntry(key)) != null && e.getValue() <= val)\n\t\t\t\tmap.remove(e.getKey());\n\t\t\tmap.put(key, val);\n\t\t}\n\n\t\tLong get(long k) {\n\t\t\treturn map.get(k);\n\t\t}\n\n\t\tLong floorKey(long k) {\n\t\t\treturn map.floorKey(k);\n\t\t}\n\t}\n\n\tstatic int solve(int l, int r) {\n\t\tint ans = 0;\n\t\tint len = r - l + 1;\n\t\tFenwickTree ft = new FenwickTree(len + 3);\n\t\tTreeSet<Integer> ts = new TreeSet<>();\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tts.add(a[i] - i);\n\t\t}\n\t\tHashMap<Integer, Integer> hm = new HashMap<>();\n\t\tint id = 1;\n\t\twhile (!ts.isEmpty())\n\t\t\thm.put(ts.pollFirst(), id++);\n\t\tft.point_update(hm.get(a[l] - l), 1);\n\t\tfor (int i = l + 1; i <= r; i++) {\n\t\t\tint best = ft.rsq(hm.get(a[i] - i));\n\t\t\tft.point_update(hm.get(a[i] - i), best + 1);\n\t\t\tif (i == r)\n\t\t\t\tans = best + 1;\n\t\t}\n\t\treturn len - ans;\n\t}\n\n\tpublic static class FenwickTree { // one-based DS\n\n\t\tint ni;\n\t\tint[] ft;\n\n\t\tFenwickTree(int size) {\n\t\t\tni = size;\n\t\t\tft = new int[ni + 1];\n\t\t}\n\n\t\tint rsq(int b) // O(log n)\n\t\t{\n\t\t\tint max = 0;\n\t\t\twhile (b > 0) {\n\t\t\t\tmax = Math.max(max, ft[b]);\n\t\t\t\tb -= b & -b;\n\t\t\t} // min?\n\t\t\treturn max;\n\t\t}\n\n\t\tvoid point_update(int k, int val) // O(log n), update = increment\n\t\t{\n\t\t\twhile (k <= ni) {\n\t\t\t\tft[k] = Math.max(val, ft[k]);\n\t\t\t\tk += k & -k;\n\t\t\t} // min?\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int[] nextArrInt(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextArrLong(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "label": 3}
{"src": "/**/\n    import java.io.*;\n    import java.util.*;\n    import java.text.*; \n    import java.lang.*;\n    import java.math.*;\npublic class Main{\n/*********************************************Constants***********************************/\n    static PrintWriter out=new PrintWriter(new OutputStreamWriter(System.out));        \n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static long mod=(long)1e9+7;\n    static long mod1=998244353;\n    static ArrayList<Integer> graph[];\n    static int pptr=0,pptrmax=0;\n    static String st[];\n/*****************************************Solution Begins*********************************/\n    static class MultiTreeSet<K>{\n        TreeMap<K,Integer> map;\n        int sz;\n        MultiTreeSet(){\n            map=new TreeMap<>();\n            sz=0;\n        }\n        boolean contains(K element){\n            return map.containsKey(element);\n        }\n        void add(K element){\n            map.put(element,map.getOrDefault(element,0)+1);\n            sz++;\n        }        \n        void remove(K element){\n            int u=map.get(element);\n            map.put(element,u-1);\n            if(u==1){\n                map.remove(element);\n            }\n            sz--;\n        }\n        K lower(K val){\n            return map.lowerKey(val);\n        }\n        K higher(K val){\n            return map.higherKey(val);\n        }\n        K last(){\n            return map.lastKey();\n        }\n        K first(){\n            return map.firstKey();\n        }\n        int size(){\n            return sz;\n        }\n        boolean isEmpty(){\n            return sz==0;\n        }\n        ArrayList<K> asArray(){\n            ArrayList<K> list=new ArrayList<>();\n            for(K u:map.keySet()){\n                int cur=map.get(u);\n                while(cur-->0){\n                    list.add(u);\n                }\n            }\n            return list;\n        }\n        public String toString(){\n            ArrayList<K> ls=asArray();\n            String str=\"[ \";\n            for(K u:ls)str+=(u+\", \");\n            return str+\" ]\";\n        }\n    }\n\n    static int lis(int a,int b){\n        MultiTreeSet<Integer> set=new MultiTreeSet<>();\n        for(int i=a+1;i<=b-1;i++){\n            if(input[i]<input[a] || input[i]>input[b])continue;\n            set.add(input[i]);\n            Integer ss=set.higher(input[i]);\n            if(ss!=null){\n                set.remove(ss);\n            }\n        }\n        return (b-a+1)-2-set.size();\n    }\n    static int n,input[];\n    static Integer B[];\n    public static void main(String args[]) throws Exception{\n        n=pi();\n        int k=pi();\n        input=new int[n+2];\n        input[0]=-((int)1e9+9);\n        input[n+1]=(int)1e9+9;\n\n        for(int i=1;i<=n;i++){\n            input[i]=pi()-i;\n        }\n        B=new Integer[k+2];\n        B[0]=0;\n        B[k+1]=n+1;\n        for(int i=1;i<=k;i++){\n            B[i]=pi();\n        }\n        long ans=0;\n        Arrays.sort(B);\n        boolean flag=true;\n        for(int i=1;i<k+2;i++){\n            //debug(input[B[i]],input[B[i-1]]);\n\n            if(input[B[i]]<input[B[i-1]]){\n                //debug(\"hihi\",i);\n\n                flag=false;\n            }\n            ans+=lis(B[i-1],B[i]);\n        }\n        if(flag){\n            out.println(ans);\n        }\n        else{\n            out.println(-1);\n        }\n/****************************************Solution Ends*************************************/\n        clr();\n    }\n    static void clr(){\n        out.flush();\n        out.close();\n    }\n    static void nl() throws Exception{\n        pptr=0;\n        st=br.readLine().split(\" \");\n        pptrmax=st.length;\n    }\n    static void nls() throws Exception{\n        pptr=0;\n        st=br.readLine().split(\"\");\n        pptrmax=st.length;\n    }\n    static int pi() throws Exception{\n        if(pptr==pptrmax)\n            nl();\n        return Integer.parseInt(st[pptr++]);\n    }\n    static long pl() throws Exception{\n        if(pptr==pptrmax)\n            nl();\n        return Long.parseLong(st[pptr++]);\n    }\n    static double pd() throws Exception{\n        if(pptr==pptrmax)\n            nl();\n        return Double.parseDouble(st[pptr++]);\n    }\n    static String ps() throws Exception{\n        if(pptr==pptrmax)\n            nl();\n        return st[pptr++];\n    }\n/***************************************Precision Printing*********************************/\n        static void printPrecision(double d){\n            DecimalFormat ft = new DecimalFormat(\"0.00000000000\"); \n            out.println(ft.format(d));\n        }\n/**************************************Bit Count************************************/\n    static int countBit(long mask){\n        int ans=0;\n        while(mask!=0){\n            mask&=(mask-1);\n            ans++;\n        }\n        return ans;\n    }\n/******************************************Graph******************************************/\n    static void Makegraph(int n){\n        graph=new ArrayList[n];\n        for(int i=0;i<n;i++)\n            graph[i]=new ArrayList<>();\n    }\n    static void addEdge(int a,int b){\n        graph[a].add(b);\n    }\n    // static void addEdge(int a,int b,int c){\n    //     graph[a].add(new Pair(b,c));\n    // }    \n/******************************************Pair*****************************************/\n    static class Pair{\n        int u;\n        int v;\n        public Pair(int u, int v) {\n            this.u = u;\n            this.v = v;\n        }\n        public int hashCode() {\n            int hu = (int) (u ^ (u >>> 32));\n            int hv = (int) (v ^ (v >>> 32));\n            return 31 * hu + hv;\n        }\n        public boolean equals(Object o) {\n            Pair other = (Pair) o;\n            return u == other.u && v == other.v;\n        }\n        public String toString() {\n            return \"[u=\" + u + \", v=\" + v + \"]\";\n        }\n    }\n/*****************************************DEBUG********************************************/\n    public static void debug(Object... o){\n        System.err.println(Arrays.deepToString(o));\n    }\n/************************************Modular Exponentiation********************************/\n    static long modulo(long a,long b,long c){\n        long x=1,y=a%c;\n        while(b > 0){\n            if(b%2 == 1)\n                x=(x*y)%c;\n            y = (y*y)%c;\n            b = b>>1;\n        }\n        return  x%c;\n    }\n/********************************************GCD*******************************************/\n    static long gcd(long x, long y){\n        if(x==0)\n            return y;\n        if(y==0)\n            return x;\n        long r=0, a, b;\n        a = (x > y) ? x : y; \n        b = (x < y) ? x : y;\n        r = b;\n        while(a % b != 0){\n            r = a % b;\n            a = b;\n            b = r;\n        }\n        return r;\n    }\n}", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class tr0 {\n\tstatic PrintWriter out;\n\tstatic StringBuilder sb;\n\tstatic long mod = (long) 1e9 + 7;\n\tstatic long inf = (long) 1e16;\n\tstatic int n, k, l;\n\tstatic ArrayList<Integer>[] ad;\n\tstatic int[][] memo;\n\tstatic boolean vis[];\n\tstatic long[] f, inv, ncr[];\n\tstatic HashMap<Integer, Integer> hm;\n\tstatic int[] a;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tn = sc.nextInt();\n\t\tk = sc.nextInt();\n\t\ta = new int[n + 2];\n\t\tboolean[] here = new boolean[n + 2];\n\t\there[0] = true;\n\t\there[n + 1] = true;\n\t\ta[0] = -2000000000;\n\t\ta[n + 1] = 2000000000;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\ta[i] = sc.nextInt();\n\t\tint ans = 0;\n\t\tif (k != 0) {\n\t\t\tint[] idc = new int[k];\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tidc[i] = sc.nextInt();\n\t\t\t\there[idc[i]] = true;\n\t\t\t}\n\t\t\tfor (int i = 1; i < k; i++) {\n\t\t\t\tint x = a[idc[i]];\n\t\t\t\tint y = a[idc[i - 1]];\n\t\t\t\tif (x <= y || x - y < idc[i] - idc[i - 1]) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint l = 0;\n\t\tfor (int i = 1; i < a.length; i++)\n\t\t\tif (here[i]) {\n\t\t\t\tans += solve1(l, i);\n\t\t\t\tl = i;\n\t\t\t}\n\t\tSystem.out.println(ans);\n\t\tout.close();\n\t}\n\n\tstatic int solve1(int l, int r) {\n\t\tint ans = 0;\n\t\tArrayList<Integer> ar = new ArrayList<>();\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tint v = a[i] - i;\n\t\t\tif (v < a[l] - l || a[r] - r < v)\n\t\t\t\tcontinue;\n\t\t\tint num = a[i] - i;\n\t\t\tint best = 0;\n\t\t\tif (ar.isEmpty()) {\n\t\t\t\tbest = 1;\n\t\t\t\tar.add(num);\n\t\t\t} else if (ar.get(ar.size() - 1) <= num) {\n\t\t\t\tbest = ar.size() + 1;\n\t\t\t\tar.add(num);\n\t\t\t} else {\n\t\t\t\tint lo = 0;\n\t\t\t\tint hi = ar.size() - 1;\n\t\t\t\twhile (lo <= hi) {\n\t\t\t\t\tint mid = (lo + hi) >> 1;\n\t\t\t\t\t// System.out.println(lo+\" \"+hi+\" \"+mid);\n\t\t\t\t\tif (ar.get(mid).intValue() > num) {\n\t\t\t\t\t\thi = mid - 1;\n\t\t\t\t\t\tbest = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlo = mid + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tar.set(best, num);\n\t\t\t\tbest++;\n\t\t\t}\n\t\t\tif (i == r)\n\t\t\t\tans = best;\n\t\t}\n\t\treturn r - l + 1 - ans;\n\t}\n\n\tstatic int solve(int l, int r) {\n\t\tint ans = 0;\n\t\tint len = r - l + 1;\n\t\tFenwickTree ft = new FenwickTree(len + 3);\n\t\tTreeSet<Integer> ts = new TreeSet<>();\n\t\tfor (int i = l; i <= r; i++)\n\t\t\tts.add(a[i] - i);\n\n\t\tHashMap<Integer, Integer> hm = new HashMap<>();\n\t\tint id = 2;\n\t\twhile (!ts.isEmpty())\n\t\t\thm.put(ts.pollFirst(), id++);\n\n\t\tfor (int i = l; i <= r; i++) {\n\t\t\tint v = a[i] - i;\n\t\t\tif (v < a[l] - l || a[r] - r < v)\n\t\t\t\tcontinue;\n\t\t\tint num = hm.get(a[i] - i);\n\t\t\tint best = ft.rsq(num);\n\t\t\tft.point_update(num, best + 1);\n\t\t\tif (i == r)\n\t\t\t\tans = best + 1;\n\t\t}\n\n\t\treturn r - l + 1 - ans;\n\t}\n\n\tpublic static class FenwickTree { // one-based DS\n\n\t\tint ni;\n\t\tint[] ft;\n\n\t\tFenwickTree(int size) {\n\t\t\tni = size;\n\t\t\tft = new int[ni + 1];\n\t\t}\n\n\t\tint rsq(int b) // O(log n)\n\t\t{\n\t\t\tint max = 0;\n\t\t\twhile (b > 0) {\n\t\t\t\tmax = Math.max(max, ft[b]);\n\t\t\t\tb -= b & -b;\n\t\t\t} // min?\n\t\t\treturn max;\n\t\t}\n\n\t\tvoid point_update(int k, int val) // O(log n), update = increment\n\t\t{\n\t\t\twhile (k <= ni) {\n\t\t\t\tft[k] = Math.max(val, ft[k]);\n\t\t\t\tk += k & -k;\n\t\t\t} // min?\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic int[] nextArrInt(int n) throws IOException {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic long[] nextArrLong(int n) throws IOException {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "label": 3}
{"src": "import java.util.*;\n\npublic class Main {\n\n    static long Func(long n, long k)\n    {\n        long result=0;\n        while (n>0)\n        {\n            if (n%k==0) {\n                n /= k;\n                result++;\n            }\n            else\n            {\n                long rem=n%k;\n                result+=rem;\n                n-=rem;\n            }\n        }\n        return result;\n    }\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int N=sc.nextInt();\n        long arr[]=new long[N];\n        for (int i=0;i<N;i++)\n        {\n            long n=sc.nextLong();long k=sc.nextLong();\n            arr[i]=Func(n,k);\n        }\n        for (int i=0;i<arr.length;i++)\n            System.out.println(arr[i]);\n\n    }\n}", "label": 2}
{"src": "import java.util.Scanner;\n\npublic class fromherotozero {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint numQ = sc.nextInt();\n\t\tlong[][] queries = new long[numQ][2];\n\t\tString t = sc.nextLine();\n\t\tfor (int i = 0; i < numQ; i++) {\n\t\t\tqueries[i][0] = sc.nextLong();\n\t\t\tqueries[i][1] = sc.nextLong();\n\t\t\tt = sc.nextLine();\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < numQ; i++) {\n\t\t\tlong a = queries[i][0];\n\t\t\tlong b = queries[i][1];\n\t\t\t\n\t\t\t\n\t\t\tlong numOps = 0;\n\t\t\t\n\t\t\twhile (a != 0) {\n\t\t\t\tif (a % b == 0) {\n\t\t\t\t\ta = a/b;\n\t\t\t\t\tnumOps++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlong numDivides = a / b;\n\t\t\t\t\tlong total = b * numDivides;\n\t\t\t\t\tlong diff = a - total;\n\t\t\t\t\ta = total;\n\t\t\t\t\tnumOps += diff;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(numOps);\n\t\t}\n\t}\n}\n\n\n\n", "label": 2}
{"src": "import java.util.Scanner;\n\npublic class codeforces {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int t = scan.nextInt();\n        for (int i = 0; i < t; i++) {\n            long n = scan.nextLong();\n            long k = scan.nextLong();\n            long cnt = 0;\n            while (n > 0) {\n                if (n % k != 0) {\n                    cnt += (n % k);\n                    n -= (n % k);\n                } else {\n                    n /= k;\n                    cnt++;\n                }\n            }\n            System.out.println(cnt);\n        }\n    }\n}\n", "label": 2}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author tarek\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        AFromHeroToZero solver = new AFromHeroToZero();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class AFromHeroToZero {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int t = in.readInt();\n            while (t-- > 0) {\n                long n = in.readLong();\n                long r = in.readLong();\n                long count = 0;\n                while (n > 0) {\n                    if (n % r == 0) {\n                        count++;\n                        n = n / r;\n                    } else {\n                        count += n % r;\n                        n -= n % r;\n                    }\n                }\n                out.printLine(count);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "label": 2}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Abc\n{\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n  \n\tstatic long ten=(long)Math.pow(10,18);\n\tstatic PrintWriter pw=new PrintWriter(System.out);\n\tpublic static void main(String[] args) {\n\t\tFastReader in=new FastReader();\n\t\t\n\t\tint t=in.nextInt();\n\t\tassertion(t,1,100);\n\t\tfor(int g=0;g<t;g++)\n\t\t{\n\t\t\tlong n,k;\n\t\t\tn=in.nextLong();\n\t\t\tk=in.nextLong();\n\t\t\t//System.out.println(n+\" \"+k);\n\t\t\tassertion(n,1,ten);\n\t\t\tassertion(k,2,ten);\n\t\t\tBFS(n,k);\n\t\t}\n\t\tpw.close();\n\t}\n\tpublic static void BFS(long n,long k)\n\t{\n\t\tQueue<Long> q=new LinkedList<>();\n\t\tHashMap<Long,Long> map=new HashMap<>();\n\t\tq.add(n);\n\t\tmap.put(n,0l);\n\t\twhile(!q.isEmpty())\n\t\t{\n\t\t\tlong u=q.poll();\n\t\t\t//System.out.println(\"Pulled out \"+u);\n\t\t\tlong a,b;\n\t\t\ta=u-(u%k);\n\t\t\tb=u/k;\n\t\t\tif(u!=a&&map.get(a)==null)\n\t\t\t{\n\t\t\t\tmap.put(a,map.get(u)+(u%k));\n\t\t\t\tq.add(a);\n\t\t\t\tif(a==0l)\n\t\t\t\t\tbreak;\n\t\t\t\t//System.out.println(\"Put : \"+a+\" \"+map.get(a));\n\t\t\t}\n\t\t\tif(u%k==0&&(map.get(b)==null))\n\t\t\t{\n\t\t\t\tmap.put(b,map.get(u)+1);\n\t\t\t\tq.add(b);\n\t\t\t\tif(b==0l)\n\t\t\t\t\tbreak;\n\t\t\t\t//System.out.println(\"Put : \"+b+\" \"+map.get(b));\n\t\t\t}\n\t\t}\n\t\tpw.println(map.get(0l));\n\t}\n\tpublic static void assertion(long a,long b,long c)\n\t{\n\t\tif(a<b||a>c)\n\t\t\tSystem.exit(0);\n\t}\n}", "label": 2}
{"src": "import java.util.* ; \nimport java.math.BigInteger ; \npublic class Main {\n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in) ; \n        int t = sc.nextInt() ; \n        while(t-->0){\n            long  n = sc.nextLong() ; \n            long k = sc.nextLong() ; \n            long count  = 0 ;  \n            while(n > 0){\n                if(n%k!=0){ count+=n%k ; n-=n%k ; }\n                else { count+=1  ; n = n/k ; }\n            }\n            System.out.println(count) ; \n        }\n    }\n}", "label": 2}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        AFromHeroToZero solver = new AFromHeroToZero();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class AFromHeroToZero {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int ntc = 1;\n            ntc = in.nextInt();\n            while ((ntc--) > 0) {\n                long n = in.nextLong();\n                long k = in.nextLong();\n                long count = 0;\n                while (n > 0) {\n                    if (n % k == 0) {\n                        n = n / k;\n                        count += 1;\n                    } else {\n                        count += n % k;\n                        n = n / k * k;\n                    }\n                }\n                out.println(count);\n            }\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "label": 2}
{"src": "import java.lang.*;\nimport java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint t=scanner.nextInt();\n\t\tfor(int i=0;i<t;i++){\n\t\tlong n=scanner.nextLong();\n\t\tlong k=scanner.nextLong();\n\t\tlong num=0;\n\t\twhile(n!=0){\n\t\t\tif(n%k==0){n=n/k;num++;}\n\t\t\telse {num+=n%k;n-=n%k;}\n\t\t}\n\t\tSystem.out.println(num);}\n\t}\n}", "label": 2}
{"src": "import java.util.Scanner;\n\n\npublic class From_Hero_To_Zero {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\t\n\t\t/*\n\t\t * \n\t\t * \n\t\t * Given two integers n, k. \n\t\t *  1 <= n <= 10^18\n\t\t *  2 <= k <= 10^18\n\t\t *  \n\t\t *  At Each step you can do one of the following operations\n\t\t *  \n\t\t *  \n\t\t *  1. subtract 1 from n\n\t\t *  2. divide n by k if n is divisible by k\n\t\t *\n\t\t *  Convert n to 0 in minimum possible steps. Print this minimum steps for given n,k.\n\t\t *  \n\t\t *  Test case 1. n = 25, k = 4\n\t\t *  \n\t\t *  25 -> 24 -> 6 -> 5 -> 4 -> 1 -> 0 // 6 steps\n\t\t *  \n\t\t *  Test case 2. n = 1000, k = 3\n\t\t *  \n\t\t *  1000 -> 999 -> 333 -> 111 -> 37 -> 36 -> 12 -> 4 -> 3 -> 1 -> 0 // 10 steps\n\t\t */\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tlong n,k,t;\n\t\t\n\t\tt = sc.nextInt();\n\t\t\n\t\t\n\t\twhile(t > 0)\n\t\t{\n\t\t\t\n\t\t\tlong steps = 0;\n\t\t\tn = sc.nextLong();\n\t\t\tk = sc.nextLong();\n\t\t\t\n\t\t\twhile(n > 0)\n\t\t\t{\n\t\t\t\t//System.out.print(n + \" --> \");\n\t\t\t\tif(n % k == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tsteps++;\n\t\t\t\t\t\tn /= k;\n\t\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tsteps += n%k;\n\t\t\t\t\t\tn -= n%k;\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t//steps++;\n\t\t\t}\n\t\t\t\n\t\t\t/*System.out.print( \" 0\");\n\t\t\tSystem.out.println();\n\t\t\t*/\n\t\t\tSystem.out.println(steps);\n\t\t\t\n\t\t\tt--;\n\t\t}\n\t\t\n\n\t}\t\n\n}\n", "label": 2}
{"src": "import java.util.*;\npublic class CodeIt {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n    long counter = 0;\n    long queries = sc.nextInt();\n    while(queries > 0) {\n      Long n = Long.parseLong(sc.next());\n      Long k = Long.parseLong(sc.next());\n      while(n != 0) {\n        counter+=n%k+1;\n        n/=k;\n      }\n      System.out.println(counter-1);\n      counter = 0;\n      queries--;\n    }\n    sc.close();\n  }\n}\n", "label": 2}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main {\n    static BufferedReader input = new BufferedReader(\n            new InputStreamReader(System.in)\n    );\n\n    public static void main(String[] args) throws IOException {\n        byte tests = Byte.parseByte(input.readLine());\n\n        while (tests-- > 0) {\n            String[] x = input.readLine().split(\" \");\n            long n = Long.parseLong(x[0]);\n            long k = Long.parseLong(x[1]);\n\n            long times = 0;\n            while (n > 0) {\n                if (n % k == 0) {\n                    n /= k;\n                    times++;\n                }\n                else {\n                    times += n % k;\n                    n -= n % k;\n                }\n            }\n            System.out.println(times);\n        }\n    }\n}\n", "label": 2}
{"src": "\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in= new Scanner (System.in);\n        int t=in.nextInt();\n        for(int i=0;i<t;i++)\n        {\n            long n=in.nextLong();\n            long k=in.nextLong();\n            long count=0;\n            while(n>0)\n            {\n                //System.out.println(n+\" \"+count);\n                if((n%k)==0)\n                {\n                    n=n/k;\n                    count=count+1;\n                }\n                else\n                {\n                    count=count+(n%k);\n                    n=n-(n%k);\n                }\n            }\n            System.out.println(count);\n        }\n    }\n    \n}\n", "label": 2}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Main3 {\n    public static void main(String args[] ) throws Exception {\n        PrintWriter pr=new PrintWriter(System.out);\n        Scanner scan=new Scanner(System.in);\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        int t=scan.nextInt();\n        while(t-->0){\n            long n=scan.nextLong();\n            long k=scan.nextLong();\n            long moves=0;\n            while(n>=k){\n               moves+=n%k;\n               n/=k;\n               moves++;\n            }\n            System.out.println(moves+n);\n        }\n    }\n}", "label": 2}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author anand.oza\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        AFromHeroToZero solver = new AFromHeroToZero();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class AFromHeroToZero {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int t = in.nextInt();\n            for (int testcase = 0; testcase < t; testcase++) {\n                long n = in.nextLong(), k = in.nextLong();\n\n                long answer = 0;\n                while (n > 0) {\n                    if (n % k == 0) {\n                        n /= k;\n                        answer++;\n                    } else {\n                        answer += n % k;\n                        n -= (n % k);\n                    }\n                }\n\n                out.println(answer);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n", "label": 2}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Task1 {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        int c = Integer.parseInt(reader.readLine());\n        List<String[]> list = new ArrayList<>();\n        reader.lines().limit(c).forEach(line -> list.add(line.split(\" \")));\n\n        for (String[] strings : list) {\n            long n = Long.parseLong(strings[0]);\n            long k = Long.parseLong(strings[1]);\n            long count = 0;\n\n            while (n > 0) {\n                if (n % k == 0) {\n                    n = n / k;\n                    count++;\n                } else {\n                    count = count + n % k;\n                    n = n - n % k;\n                }\n            }\n            System.out.println(count);\n        }\n    }\n}\n", "label": 2}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class tr2 {\n\tstatic PrintWriter out;\n\tstatic StringBuilder sb;\n\tstatic int inf = (int) 1e7;\n\tstatic ArrayList<Integer> primes;\n\tstatic int[] si;\n\tstatic long mod = (long) 1e9 + 9;\n\tstatic long num=(long) 1e9+7;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0) {\n\t\t\tlong ans=0;\n\t\t\tlong n=sc.nextLong();\n\t\t\tlong k=sc.nextLong();\n\t\t\twhile(n>0) {\n\t\t\t\twhile(n%k==0) {\n\t\t\t\t\tans++;\n\t\t\t\t\tn/=k;\n\t\t\t\t}\n\t\t\t\tans+=n%k;\n\t\t\t\tn=n-n%k;\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\tout.flush();\n\t}\n\n\tstatic long inver(long x) {\n\t\tlong a = x;\n\t\tlong e = (mod - 2);\n\t\tlong res = 1;\n\t\twhile (e > 0) {\n\t\t\tif ((e & 1) == 1) {\n\t\t\t\tres = ((1l * res * a) % mod);\n\t\t\t}\n\t\t\ta = (int) ((1l * a * a) % mod);\n\t\t\te >>= 1;\n\t\t}\n\t\treturn res % mod;\n\t}\n\n\tstatic class eq {\n\t\tlong x;\n\t\tlong y;\n\t\tlong z;\n\n\t\teq(long x, long y, long z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y + \" \" + z;\n\t\t}\n\t}\n\n\tstatic class Point3D {\n\t\tlong x;\n\t\tlong y;\n\t\tlong z;\n\n\t\tPoint3D(long x, long y, long z) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.z = z;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn x + \" \" + y + \" \" + z;\n\t\t}\n\t}\n\n\tstatic void seive() {\n\t\tsi = new int[10000001];\n\t\tprimes = new ArrayList<>();\n\t\tint N = 10000001;\n\t\tsi[1] = 1;\n\t\tfor (int i = 2; i < N; i++) {\n\t\t\tif (si[i] == 0) {\n\t\t\t\tsi[i] = i;\n\t\t\t\tprimes.add(i);\n\t\t\t}\n\t\t\tfor (int j = 0; j < primes.size() && primes.get(j) <= si[i] && (i * primes.get(j)) < N; j++)\n\t\t\t\tsi[primes.get(j) * i] = primes.get(j);\n\n\t\t}\n\t}\n\n\tstatic public class Vector {\n\n\t\tdouble x, y;\n\n\t\tVector(double a, double b) {\n\t\t\tx = a;\n\t\t\ty = b;\n\t\t}\n\n\t\tVector(Point a, Point b) {\n\t\t\tthis(b.x - a.x, b.y - a.y);\n\t\t}\n\n\t\tVector scale(double s) {\n\t\t\treturn new Vector(x * s, y * s);\n\t\t} // s is a non-negative value\n\n\t\tdouble dot(Vector v) {\n\t\t\treturn (x * v.x + y * v.y);\n\t\t}\n\n\t\tdouble cross(Vector v) {\n\t\t\treturn x * v.y - y * v.x;\n\t\t}\n\n\t\tdouble norm2() {\n\t\t\treturn x * x + y * y;\n\t\t}\n\n\t\tVector reverse() {\n\t\t\treturn new Vector(-x, -y);\n\t\t}\n\n\t\tVector normalize() {\n\t\t\tdouble d = Math.sqrt(norm2());\n\t\t\treturn scale(1 / d);\n\t\t}\n\t}\n\n\tstatic public class Line {\n\n\t\tstatic final double INF = 1e9, EPS = 1e-9;\n\n\t\tdouble a, b, c;\n\n\t\tLine(Point p, Point q) {\n\t\t\tif (Math.abs(p.x - q.x) < EPS) {\n\t\t\t\ta = 1;\n\t\t\t\tb = 0;\n\t\t\t\tc = -p.x;\n\t\t\t} else {\n\t\t\t\ta = (p.y - q.y) / (q.x - p.x);\n\t\t\t\tb = 1.0;\n\t\t\t\tc = -(a * p.x + p.y);\n\t\t\t}\n\n\t\t}\n\n\t\tLine(Point p, double m) {\n\t\t\ta = -m;\n\t\t\tb = 1;\n\t\t\tc = -(a * p.x + p.y);\n\t\t}\n\n\t\tboolean parallel(Line l) {\n\t\t\treturn Math.abs(a - l.a) < EPS && Math.abs(b - l.b) < EPS;\n\t\t}\n\n\t\tboolean same(Line l) {\n\t\t\treturn parallel(l) && Math.abs(c - l.c) < EPS;\n\t\t}\n\n\t\tPoint intersect(Line l) {\n\t\t\tif (parallel(l))\n\t\t\t\treturn null;\n\t\t\tdouble x = (b * l.c - c * l.b) / (a * l.b - b * l.a);\n\t\t\tdouble y;\n\t\t\tif (Math.abs(b) < EPS)\n\t\t\t\ty = -l.a * x - l.c;\n\t\t\telse\n\t\t\t\ty = -a * x - c;\n\n\t\t\treturn new Point(x, y);\n\t\t}\n\n\t\tPoint closestPoint(Point p) {\n\t\t\tif (Math.abs(b) < EPS)\n\t\t\t\treturn new Point(-c, p.y);\n\t\t\tif (Math.abs(a) < EPS)\n\t\t\t\treturn new Point(p.x, -c);\n\t\t\treturn intersect(new Line(p, 1 / a));\n\t\t}\n\n\t}\n\n\tstatic public class Polygon {\n\t\t// Cases to handle: collinear points, polygons with n < 3\n\n\t\tstatic final double EPS = 1e-9;\n\n\t\tPoint[] g; // first point = last point, counter-clockwise representation\n\n\t\tPolygon(Point[] o) {\n\t\t\tg = o;\n\t\t}\n\n\t\tdouble perimeter() {\n\t\t\tdouble sum = 0.0;\n\t\t\tfor (int i = 0; i < g.length - 1; ++i)\n\t\t\t\tsum += g[i].dist(g[i + 1]);\n\t\t\treturn sum;\n\t\t}\n\n\t\tdouble area() // clockwise/anti-clockwise check, for convex/concave polygons\n\t\t{\n\t\t\tdouble area = 0.0;\n\t\t\tfor (int i = 0; i < g.length - 1; ++i)\n\t\t\t\tarea += g[i].x * g[i + 1].y - g[i].y * g[i + 1].x;\n\t\t\treturn Math.abs(area) / 2.0; // negative value in case of clockwise\n\t\t}\n\n\t\tboolean isConvex() {\n\t\t\tif (g.length <= 3) // point or line\n\t\t\t\treturn false;\n\t\t\tboolean ccw = Point.ccw(g[g.length - 2], g[0], g[1]); // edit ccw check to accept collinear points\n\t\t\tfor (int i = 1; i < g.length - 1; ++i)\n\t\t\t\tif (Point.ccw(g[i - 1], g[i], g[i + 1]) != ccw)\n\t\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t\tboolean inside(Point p) // for convex/concave polygons - winding number algorithm\n\t\t{\n\t\t\tdouble sum = 0.0;\n\t\t\tfor (int i = 0; i < g.length - 1; ++i) {\n\t\t\t\tdouble angle = Point.angle(g[i], p, g[i + 1]);\n\t\t\t\tif ((Math.abs(angle) < EPS || Math.abs(angle - Math.PI) < EPS) && p.between(g[i], g[i + 1]))\n\t\t\t\t\treturn true;\n\t\t\t\tif (Point.ccw(p, g[i], g[i + 1]))\n\t\t\t\t\tsum += angle;\n\t\t\t\telse\n\t\t\t\t\tsum -= angle;\n\t\t\t}\n\n\t\t\treturn Math.abs(2 * Math.PI - Math.abs(sum)) < EPS; // abs makes it work for clockwise\n\t\t}\n\t\t/*\n\t\t * Another way if the polygon is convex 1. Triangulate the poylgon through p 2.\n\t\t * Check if sum areas == poygon area 3. Handle empty polygon\n\t\t */\n\n\t\tPolygon cutPolygon(Point a, Point b) // returns the left part of the polygon, swap a & b for the right part\n\t\t{\n\t\t\tPoint[] ans = new Point[g.length << 1];\n\t\t\tLine l = new Line(a, b);\n\t\t\tVector v = new Vector(a, b);\n\n\t\t\tint size = 0;\n\t\t\tfor (int i = 0; i < g.length; ++i) {\n\t\t\t\tdouble left1 = v.cross(new Vector(a, g[i]));\n\t\t\t\tdouble left2 = i == g.length - 1 ? 0 : v.cross(new Vector(a, g[i + 1]));\n\n\t\t\t\tif (left1 + EPS > 0)\n\t\t\t\t\tans[size++] = g[i];\n\t\t\t\tif (left1 * left2 + EPS < 0)\n\t\t\t\t\tans[size++] = l.intersect(new Line(g[i], g[i + 1]));\n\t\t\t}\n\n\t\t\tif (size != 0 && ans[0] != ans[size - 1]) // necessary in case g[0] is not in the new polygon\n\t\t\t\tans[size++] = ans[0];\n\t\t\treturn new Polygon(Arrays.copyOf(ans, size));\n\t\t}\n\n\t\tstatic Polygon convexHull(Point[] points) // all points are unique, remove duplicates, edit ccw to accept\n\t\t\t\t\t\t\t\t\t\t\t\t\t// collinear points\n\t\t{\n\t\t\tint n = points.length;\n\t\t\tArrays.sort(points);\n\t\t\tPoint[] ans = new Point[n << 1];\n\t\t\tint size = 0, start = 0;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tPoint p = points[i];\n\t\t\t\twhile (size - start >= 2 && !Point.ccw(ans[size - 2], ans[size - 1], p))\n\t\t\t\t\t--size;\n\t\t\t\tans[size++] = p;\n\t\t\t}\n\t\t\tstart = --size;\n\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tPoint p = points[i];\n\t\t\t\twhile (size - start >= 2 && !Point.ccw(ans[size - 2], ans[size - 1], p))\n\t\t\t\t\t--size;\n\t\t\t\tans[size++] = p;\n\t\t\t}\n\t\t\t// if(size < 0) size = 0 for empty set of points\n\t\t\treturn new Polygon(Arrays.copyOf(ans, size));\n\t\t}\n\n\t\tPoint centroid() // center of mass\n\t\t{\n\t\t\tdouble cx = 0.0, cy = 0.0;\n\t\t\tfor (int i = 0; i < g.length - 1; i++) {\n\t\t\t\tdouble x1 = g[i].x, y1 = g[i].y;\n\t\t\t\tdouble x2 = g[i + 1].x, y2 = g[i + 1].y;\n\n\t\t\t\tdouble f = x1 * y2 - x2 * y1;\n\t\t\t\tcx += (x1 + x2) * f;\n\t\t\t\tcy += (y1 + y2) * f;\n\t\t\t}\n\t\t\tdouble area = area(); // remove abs\n\t\t\tcx /= 6.0 * area;\n\t\t\tcy /= 6.0 * area;\n\t\t\treturn new Point(cx, cy);\n\t\t}\n\t}\n\n\tstatic public class Point implements Comparable<Point> {\n\n\t\tstatic final double EPS = 1e-9;\n\n\t\tdouble x, y;\n\n\t\tPoint(double a, double b) {\n\t\t\tx = a;\n\t\t\ty = b;\n\t\t}\n\n\t\tpublic int compareTo(Point p) {\n\t\t\tif (Math.abs(x - p.x) > EPS)\n\t\t\t\treturn x > p.x ? 1 : -1;\n\t\t\tif (Math.abs(y - p.y) > EPS)\n\t\t\t\treturn y > p.y ? 1 : -1;\n\t\t\treturn 0;\n\t\t}\n\n\t\tpublic double dist(Point p) {\n\t\t\treturn Math.sqrt(sq(x - p.x) + sq(y - p.y));\n\t\t}\n\n\t\tstatic double sq(double x) {\n\t\t\treturn x * x;\n\t\t}\n\n\t\tPoint rotate(double angle) {\n\t\t\tdouble c = Math.cos(angle), s = Math.sin(angle);\n\t\t\treturn new Point(x * c - y * s, x * s + y * c);\n\t\t}\n\t\t// for integer points and rotation by 90 (counterclockwise) : swap x and y,\n\t\t// negate x\n\n\t\tPoint rotate(double theta, Point p) // rotate around p\n\t\t{\n\t\t\tVector v = new Vector(p, new Point(0, 0));\n\t\t\treturn translate(v).rotate(theta).translate(v.reverse());\n\t\t}\n\n\t\tPoint translate(Vector v) {\n\t\t\treturn new Point(x + v.x, y + v.y);\n\t\t}\n\n\t\tPoint reflectionPoint(Line l) // reflection point of p on line l\n\t\t{\n\t\t\tPoint p = l.closestPoint(this);\n\t\t\tVector v = new Vector(this, p);\n\t\t\treturn this.translate(v).translate(v);\n\t\t}\n\n\t\tboolean between(Point p, Point q) {\n\t\t\treturn x < Math.max(p.x, q.x) + EPS && x + EPS > Math.min(p.x, q.x) && y < Math.max(p.y, q.y) + EPS\n\t\t\t\t\t&& y + EPS > Math.min(p.y, q.y);\n\t\t}\n\n\t\t// returns true if it is on the line defined by a and b\n\t\tboolean onLine(Point a, Point b) {\n\t\t\tif (a.compareTo(b) == 0)\n\t\t\t\treturn compareTo(a) == 0;\n\t\t\treturn Math.abs(new Vector(a, b).cross(new Vector(a, this))) < EPS;\n\t\t}\n\n\t\tboolean onSegment(Point a, Point b) {\n\t\t\tif (a.compareTo(b) == 0)\n\t\t\t\treturn compareTo(a) == 0;\n\t\t\treturn onRay(a, b) && onRay(b, a);\n\t\t}\n\n\t\t// returns true if it is on the ray whose start point is a and passes through b\n\t\tboolean onRay(Point a, Point b) {\n\t\t\tif (a.compareTo(b) == 0)\n\t\t\t\treturn compareTo(a) == 0;\n\t\t\treturn new Vector(a, b).normalize().equals(new Vector(a, this).normalize()); // implement equals()\n\t\t}\n\n\t\t// returns true if it is on the left side of Line pq\n\t\t// add EPS to LHS if on-line points are accepted\n\t\tstatic boolean ccw(Point p, Point q, Point r) {\n\t\t\treturn new Vector(p, q).cross(new Vector(p, r)) > 0;\n\t\t}\n\n\t\tstatic boolean collinear(Point p, Point q, Point r) {\n\t\t\treturn Math.abs(new Vector(p, q).cross(new Vector(p, r))) < EPS;\n\t\t}\n\n\t\tstatic double angle(Point a, Point o, Point b) // angle AOB\n\t\t{\n\t\t\tVector oa = new Vector(o, a), ob = new Vector(o, b);\n\t\t\treturn Math.acos(oa.dot(ob) / Math.sqrt(oa.norm2() * ob.norm2()));\n\t\t}\n\n\t\tstatic double distToLine(Point p, Point a, Point b) // distance between point p and a line defined by points a,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// b (a != b)\n\t\t{\n\t\t\tif (a.compareTo(b) == 0)\n\t\t\t\treturn p.dist(a);\n\t\t\t// formula: c = a + u * ab\n\t\t\tVector ap = new Vector(a, p), ab = new Vector(a, b);\n\t\t\tdouble u = ap.dot(ab) / ab.norm2();\n\t\t\tPoint c = a.translate(ab.scale(u));\n\t\t\treturn p.dist(c);\n\t\t}\n\t\t// Another way: find closest point and calculate the distance between it and p\n\n\t\tstatic double distToLineSegment(Point p, Point a, Point b) {\n\t\t\tVector ap = new Vector(a, p), ab = new Vector(a, b);\n\t\t\tdouble u = ap.dot(ab) / ab.norm2();\n\t\t\tif (u < 0.0)\n\t\t\t\treturn p.dist(a);\n\t\t\tif (u > 1.0)\n\t\t\t\treturn p.dist(b);\n\t\t\treturn distToLine(p, a, b);\n\t\t}\n\t\t// Another way: find closest point and calculate the distance between it and p\n\t}\n\n\tstatic long fac(int n) {\n\t\tif (n == 0)\n\t\t\treturn 1;\n\t\tif (n == 1)\n\t\t\treturn 1;\n\t\tlong ans = 1;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tans = (i % mod * ans % mod) % mod;\n\t\treturn ans % mod;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\n\t\tif (b == 0) {\n\t\t\treturn a;\n\t\t}\n\t\treturn gcd(b, a % b);\n\t}\n\n\tstatic class pair implements Comparable<pair> {\n\t\tint num;\n\t\tint v;\n\n\t\tpair(int n, int v) {\n\t\t\tnum = n;\n\t\t\tthis.v = v;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn num + \" \" + v;\n\t\t}\n\n\t\tpublic int compareTo(pair o) {\n\t\t\treturn o.v - v;\n\t\t}\n\t}\n\n\tstatic class unionfind {\n\t\tint[] p;\n\t\tint[] size;\n\n\t\tunionfind(int n) {\n\t\t\tp = new int[n];\n\t\t\tsize = new int[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tp[i] = i;\n\t\t\t}\n\t\t\tArrays.fill(size, 1);\n\t\t}\n\n\t\tint findSet(int v) {\n\t\t\tif (v == p[v])\n\t\t\t\treturn v;\n\t\t\treturn p[v] = findSet(p[v]);\n\t\t}\n\n\t\tboolean sameSet(int a, int b) {\n\t\t\ta = findSet(a);\n\t\t\tb = findSet(b);\n\t\t\tif (a == b)\n\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\n\t\tint max() {\n\t\t\tint max = 0;\n\t\t\tfor (int i = 0; i < size.length; i++)\n\t\t\t\tif (size[i] > max)\n\t\t\t\t\tmax = size[i];\n\t\t\treturn max;\n\t\t}\n\n\t\tvoid combine(int a, int b) {\n\t\t\ta = findSet(a);\n\t\t\tb = findSet(b);\n\t\t\tif (a == b)\n\t\t\t\treturn;\n\t\t\tif (size[a] > size[b]) {\n\t\t\t\tp[b] = a;\n\t\t\t\tsize[a] += size[b];\n\n\t\t\t} else {\n\t\t\t\tp[a] = b;\n\t\t\t\tsize[b] += size[a];\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\n\t\tpublic Scanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\n\t\tpublic Long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t}\n}", "label": 2}
{"src": "import java.util.*;\npublic class file{\npublic static void main(String[] args){\nScanner scan=new Scanner(System.in);\nint test=scan.nextInt();\nfor(int i=0;i<test;i++){\nlong n=scan.nextLong();\nlong m=scan.nextLong();\nlong c=0;\nwhile(n!=0){\nif(n%m==0){\nn=n/m;\nc++;\n}else{\nlong rem=n%m;\nn-=rem;\nc+=rem;\n}\n\n}\nSystem.out.println(c);\n}\n}\n}", "label": 2}
{"src": "import java.io.*;\nimport java.util.*;\n\n/******************************\\\n * The solution is at the top *\n *                            *\n *   Created by : azhar556    *\n\\******************************/\n\npublic class A {\n    static void solve() {\n\t\tlong n = nl();\n\t\tlong k = nl();\n\t\tlong res = 0L;\n\t\tlong nowN = n;\n\t\twhile (nowN != 0) {\n\t\t\tif (nowN % k == 0) {\n\t\t\t\tnowN /= k;\n\t\t\t\tres++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += (nowN % k);\n\t\t\t\tnowN = k * (nowN / k);\n\t\t\t}\n\t\t\t// err.println(nowN + \" \" + res);\n\t\t}\n\t\tout.println(res);\n    }    \n\n    public static void main(String[] args) {\n        long time = System.currentTimeMillis();\n        int t = ni();\n        // t = 1;\n        while (t-- > 0) solve(); \n        err.println(\"Time elapsed : \" + (System.currentTimeMillis() - time) / 1000F + \" s.\");\n        err.close(); out.close();\n    }\n\n\tstatic int[] radixSort(int[] f){ return radixSort(f, f.length); }\n\tstatic int[] radixSort(int[] f, int n)\n\t{\n\t\tint[] to = new int[n];\n\t\t{\n\t\t\tint[] b = new int[65537];\n\t\t\tfor(int i = 0;i < n;i++)b[1+(f[i]&0xffff)]++;\n\t\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\t\tfor(int i = 0;i < n;i++)to[b[f[i]&0xffff]++] = f[i];\n\t\t\tint[] d = f; f = to;to = d;\n\t\t}\n\t\t{\n\t\t\tint[] b = new int[65537];\n\t\t\tfor(int i = 0;i < n;i++)b[1+(f[i]>>>16)]++;\n\t\t\tfor(int i = 1;i <= 65536;i++)b[i]+=b[i-1];\n\t\t\tfor(int i = 0;i < n;i++)to[b[f[i]>>>16]++] = f[i];\n\t\t\tint[] d = f; f = to;to = d;\n\t\t}\n\t\treturn f;\n\t}\n\n    static PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    static PrintWriter err = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.err)));\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer token;\n        \n    static String ns() {\n        while (token == null || !token.hasMoreTokens()) {\n            try {\n                token = new StringTokenizer(br.readLine());\n            }\n            catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return token.nextToken();\n    }\n    static char nc() {\n        return Character.valueOf(ns().charAt(0));\n    }\n    static int ni() {\n        return Integer.parseInt(ns());\n    }\n    static double nd() {\n        return Double.parseDouble(ns());\n    }\n    static long nl() {\n        return Long.parseLong(ns());\n    }\n}\n// Collections Arrays Math\n// Vector HashSet TreeSet HashMap TreeMap ArrayDeque ", "label": 2}
{"src": "import java.util.*;\npublic class e66a {\n\tpublic static void main(String[] args) {\n\t\tScanner kb = new Scanner(System.in);\n\t\tint N = kb.nextInt();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tlong n = kb.nextLong();\n\t\t\tlong k = kb.nextLong();\n\t\t\tlong c = 0;\n\t\t\twhile (n != 0) {\n\t\t\t\tif (n % k == 0) {\n\t\t\t\t\tn /= k;\n\t\t\t\t\tc++;\n\t\t\t\t} else {\n\t\t\t\t\tc += n % k;\n\t\t\t\t\tn -= n % k;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n}\n", "label": 2}
{"src": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tHashSet<Long> hs = new HashSet<>();\n\t\tint T = sc.nextInt();\n\t\t\n\t\tfor(int test_case = 1; test_case <= T; test_case++)\n\t\t{\n\t\t\tlong N = sc.nextLong();\n\t\t\tlong K = sc.nextLong();\n\t\t\tif(N < K)\n\t\t\t{\n\t\t\t\tSystem.out.println(N);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(K == 1)\n\t\t\t{\n\t\t\t\tSystem.out.println(N);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Pair> pq = new PriorityQueue<>();\n\t\t\tpq.add(new Pair(N, 0));\n\t\t\ths.clear();\n\t\t\twhile(!pq.isEmpty())\n\t\t\t{\n\t\t\t\tPair p = pq.poll();\n\t\t\t\tif(p.num == 0) \n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(p.cnt);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(p.num % K == 0 && !hs.contains(p.num / K))\n\t\t\t\t{\n\t\t\t\t\ths.add(p.num / K);\n\t\t\t\t\tpq.add(new Pair(p.num / K, p.cnt + 1));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tlong mod = p.num % K;\n\t\t\t\t\ths.add(p.num - mod);\n\t\t\t\t\tpq.add(new Pair(p.num - mod, p.cnt + mod));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nclass Pair implements Comparable<Pair>{\n\tlong num, cnt;\n\tPair(long num, long cnt)\n\t{\n\t\tthis.num = num;\n\t\tthis.cnt = cnt;\n\t}\n\t@Override\n\tpublic int compareTo(Pair o) {\n\t\treturn o.cnt > this.cnt ? -1 : 1;\n\t}\n}", "label": 2}
{"src": "import java.util.Scanner;\n\npublic class herotozero {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int q = s.nextInt();\n\n\n        for(int i = 0; i < q; i++) {\n            long n = s.nextLong();\n            long k = s.nextLong();\n            long moves = 0;\n            while (n > 0) {\n                if (n % k == 0) {\n                    n = n / k;\n                    moves++;\n                } else {\n                    long x = n % k;\n                    moves = moves + x;\n                    n = n - x;\n                }\n            }\n            System.out.println(moves);\n        }\n\n\n    }\n}\n\n", "label": 2}
{"src": "import java.util.Scanner;\n\npublic class K {\n\tScanner t = new Scanner(System.in);\n\tlong k, n;\n\tString acumulado;\n\t\n\tpublic void captura() {\n\t\tString s;\n\t\tString[] nom;\t\t\n\t\tint vueltas;\n\t\t\t\t\n\t\tvueltas = Integer.parseInt(t.nextLine());\n\t\tif(vueltas>=1 && vueltas<=100) {\t\t\t\t\n\t\t\twhile(vueltas>0) {\t\t\t\n\t\t\t\ts =t.nextLine();\n\t\t\t\tnom = s.split(\" \");\n\t\t\t\tn = Long.parseLong(nom[0]);\n\t\t\t\tk = Long.parseLong(nom[1]);\t\t\t\n\t\t\t\tif(acumulado == null)\n\t\t\t\t\tacumulado = ope();\n\t\t\t\telse\n\t\t\t\t\tacumulado += ope();\n\t\t\t\tvueltas= vueltas-1;\n\t\t\t}\t\n\t\t\tSystem.out.println(acumulado);\t\t\t\n\t\t}\n\t}\n\t\n\n\tpublic String ope() {\n\t\tlong contador=0;\n\t\twhile(n>0) {\n\t\t\tif(k==1) {\t\t\t\t\n\t\t\t\tcontador=n;\n\t\t\t}else if(n%k==0) {\n\t\t\t\tn = n/k;\n\t\t\t\tcontador++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcontador+= (n%k);\n\t\t\t\tn=(n-(n%k));\t\t\t\t\n\t\t\t} \n\t\t}\n\t\treturn (contador+\"\\n\");\n\t}\t\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tK kp = new K();\n\t\tkp.captura();\t\t\n\t}\n\n}\n//YA SABEMOS QUE NO CUENTA XD JEJEJEJE\n\t\t\t\t  \t \t \t    \t\t \t   \t  \t\t\t \t\t", "label": 2}
{"src": "import java.io.*;\nimport java.util.*;\n\n\n\npublic class Main {\n\t\n\tstatic InputReader in = new InputReader(System.in);\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tstatic int MOD = 1000000007;\n\tstatic int M = 505;\n\tstatic int oo = Integer.MAX_VALUE;\n\t\n\tstatic int[] di = {-1, 1, 0, 0};\n\tstatic int[] dj = {0, 0, -1, 1};\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t\n\t\tint t = in.nextInt();\n\t\twhile(t --> 0) {\n\t\t\tlong n = in.nextLong();\n\t\t\tlong k = in.nextLong();\n\t\t\tSystem.out.println( step(n, k) );\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic long step(long n, long k) {\n\t\tlong cnt = 0;\n\t\twhile(n > 0) {\n\t\t\tif(n % k == 0) {\n\t\t\t\tn /= k;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong m = n / k;\n\t\t\t\tcnt += (n - k * m);\n\t\t\t\tn = k * m;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n\tstatic boolean nextPermutation(int[] a) {\n\t\tfor(int i = a.length - 2; i >= 0; --i) {\n\t\t\tif(a[i] < a[i+1]) {\n\t\t\t\tfor(int j = a.length - 1; ; --j) {\n\t\t\t\t\tif(a[i] < a[j]) {\n\t\t\t\t\t\tint t = a[i];\n\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\tfor(i++, j = a.length - 1; i < j; ++i, --j) {\n\t\t\t\t\t\t\tt = a[i];\n\t\t\t\t\t\t\ta[i] = a[j];\n\t\t\t\t\t\t\ta[j] = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t\n\tstatic void shuffle(int[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tint t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic void shuffle(long[] a) {\n\t\tRandom r = new Random();\n\t\tfor(int i = a.length - 1; i > 0; --i) {\n\t\t\tint si = r.nextInt(i);\n\t\t\tlong t = a[si];\n\t\t\ta[si] = a[i];\n\t\t\ta[i] = t;\n\t\t}\n\t}\n\t\n\tstatic int lower_bound(int[] a, int n, int k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\tstatic int lower_bound(long[] a, int n, long k) {\n\t\tint s = 0;\n\t\tint e = n;\n\t\tint m;\n\t\twhile (e - s > 0) {\n\t\t\tm = (s + e) / 2;\n\t\t\tif (a[m] < k)\n\t\t\t\ts = m + 1;\n\t\t\telse\n\t\t\t\te = m;\n\t\t}\n\t\treturn e;\n\t}\n\t\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\tstatic long gcd(long a, long b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\t\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint first, second;\n\n\t\tpublic Pair(int first, int second) {\n\t\t\tsuper();\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.first != o.first ? this.first - o.first : this.second - o.second;\n\t\t}\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + first;\n\t\t\tresult = prime * result + second;\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPair other = (Pair) obj;\n\t\t\tif (first != other.first)\n\t\t\t\treturn false;\n\t\t\tif (second != other.second)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\t\n}\n\n\n\nclass InputReader {\n\n\tprivate final InputStream stream;\n\tprivate final byte[] buf = new byte[8192];\n\tprivate int curChar, snumChars;\n\n\tpublic InputReader(InputStream st) {\n\t\tthis.stream = st;\n\t}\n\n\tpublic int read() {\n\t\tif (snumChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= snumChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (snumChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int nextInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic long nextLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic int[] nextIntArray(int n) {\n\t\tint a[] = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c)) {\n\t\t\tc = read();\n\t\t}\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tpublic String nextLine() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n\n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n\n}", "label": 2}
{"src": " \nimport java.io.*;\nimport java.util.*; \nimport javafx.util.Pair; \n\npublic class TaskA_june5 \n{ \n\n/*\n *   ********   *******    ******** \t\n *   *          *    *           *\n *   *          *   *           * \n *   *          * *            *\n *   *          *   *         *\n *   ********   *    *       *\n */\n\tstatic\tReader in=new Reader();\n\tstatic Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) throws IOException \n\t{ \n\t\tint test=in.integer();\n\t\tfor(int it=0;it<test;it++) {\n\t\t\tlong n=in._long();\n\t\t\tlong k=in._long();\n\t\t\tlong c=0;\n\t\t\twhile(n>=k) {\n\t\t\t\t\n\t\t\t\tc+=n%k;\n\t\t\t\tn=n/k;\n\t\t\t\tc++;\n\t\t\t}\n\t\t\tc+=n%k;\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\n static int partition(Pair<Integer,Integer> arr[], int low, int high) \n    { \n        int pivot = arr[high].getKey();  \n        int i = (low-1);\n        for (int j=low; j<high; j++) \n        {  \n            if (arr[j].getKey() <= pivot) \n            { \n                i++;\n                Pair<Integer,Integer> temp = arr[i]; \n                arr[i] = arr[j]; \n                arr[j] = temp; \n            } \n        }\n        Pair<Integer,Integer> temp = arr[i+1]; \n        arr[i+1] = arr[high]; \n        arr[high] = temp; \n  \n        return i+1; \n    } \n   static void sort(Pair<Integer,Integer> arr[], int low, int high) \n    { \n        if (low < high) \n        { \n            int pi = partition(arr, low, high); \n            sort(arr, low, pi-1); \n            sort(arr, pi+1, high); \n        } \n    }\n\t/*\n\t * seach algorithm\n\t */\n\tstatic int return_greater_index(int arr[],int start,int end,int x)\n\t{\n\t\tint ans=-1;\n\t\tint mid;\n\t\twhile(start<=end) {\n\t\t\t mid=(start+end)/2;\n\t\t\tif(arr[mid]<=x)\n\t\t\t\tstart=mid+1;\n\t\t\telse \n\t\t\t\t{\n\t\t\t\tans=mid;\n\t\t\t\tend=mid-1;\n\t\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\npublic static int lowerBound(int[] a, int v)\n\t{\n\t\tint low = -1, high = a.length;\n\t\twhile(high-low > 1){\n\t\t\tint h = high+low>>>1;\n\t\t\tif(a[h] >= v){\n\t\t\t\thigh = h;\n\t\t\t}else{\n\t\t\t\tlow = h;\n\t\t\t}\n\t\t}\n\t\treturn high;\n\t}\nstatic int return_lower_index(int arr[],int start,int end,int x)\n\t{\n\t\tint ans=-1;\n\t\tint mid;\n\t\twhile(start<=end) {\n\t\t\t mid=(start+end)/2;\n\t\t\tif(arr[mid]<=x) {\n\t\t\t\tans=mid;\n\t\t\t\tstart=mid+1;\n\t\t\t}\n\t\t\telse \n\t\t\t\t{\n\t\t\t\tend=mid-1;\n\t\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\t/*\n\t * pairs of <int,int> <double,double>\n\t */\n\tstatic Pair<Integer,Integer> pair(int x,int y){\n\t\tPair<Integer,Integer> p=new Pair<Integer, Integer>(x,y);\n\t\treturn p;\n\t}\n\tstatic Pair<Double,Double> pair(double x,double y){\n\t\tPair<Double,Double> p=new Pair<Double,Double>(x,y);\n\t\treturn p;\n\t}\n\t/*\n\t * for loop\n\t */\nstatic void rep(int arr[]) throws IOException {\n\tint n=arr.length;\n\tfor(int i=0;i<n;i++)\n\t\tarr[i]=in.integer();\n}\n\t/*display \n\t array\n\t */\n\tstatic void display(Integer arr[][],int x,int y) {\n\t\tfor(int i=0;i<x;i++) {\n\t\t\tfor(int j=0;j<y;j++)\n\t\t\t{\n\t\t\t\tSystem.out.print(arr[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\tstatic void display(Integer arr[]) {\n\t\tint x=arr.length;\n\t\t\tfor(int j=0;j<x;j++)\n\t\t\t{\n\t\t\t\tSystem.out.print(arr[j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t}\n\t\n\t/*\n\t * input \n\t */\n\t\n\tstatic class Reader \n\t{ \n\t\tfinal private int BUFFER_SIZE = 1 << 16; \n\t\tprivate DataInputStream din; \n\t\tprivate byte[] buffer; \n\t\tprivate int bufferPointer, bytesRead; \n\n\t\tpublic Reader() \n\t\t{ \n\t\t\tdin = new DataInputStream(System.in); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\n\t\tpublic Reader(String file_name) throws IOException \n\t\t{ \n\t\t\tdin = new DataInputStream(new FileInputStream(file_name)); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\n\t\tpublic String string() throws IOException \n\t\t{ \n\t\t\tbyte[] buf = new byte[64]; // line length \n\t\t\tint cnt = 0, c; \n\t\t\twhile ((c = read()) != -1) \n\t\t\t{ \n\t\t\t\tif (c == '\\n') \n\t\t\t\t\tbreak; \n\t\t\t\tbuf[cnt++] = (byte) c; \n\t\t\t} \n\t\t\treturn new String(buf, 0, cnt); \n\t\t} \n\n\t\tpublic int integer() throws IOException \n\t\t{ \n\t\t\tint ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo\n\t\t\t{ \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} while ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic long _long() throws IOException \n\t\t{ \n\t\t\tlong ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic double _double() throws IOException \n\t\t{ \n\t\t\tdouble ret = 0, div = 1; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (c == '.') \n\t\t\t{ \n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') \n\t\t\t\t{ \n\t\t\t\t\tret += (c - '0') / (div *= 10); \n\t\t\t\t} \n\t\t\t} \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tprivate void fillBuffer() throws IOException \n\t\t{ \n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n\t\t\tif (bytesRead == -1) \n\t\t\t\tbuffer[0] = -1; \n\t\t} \n\n\t\tprivate byte read() throws IOException \n\t\t{ \n\t\t\tif (bufferPointer == bytesRead) \n\t\t\t\tfillBuffer(); \n\t\t\treturn buffer[bufferPointer++]; \n\t\t} \n\n\t\tpublic void close() throws IOException \n\t\t{ \n\t\t\tif (din == null) \n\t\t\t\treturn; \n\t\t\tdin.close(); \n\t\t} \n\t} \n\n} \n", "label": 2}
{"src": "import java.util.*;\npublic class Main{\npublic static void main(String [] args){  \nScanner sc = new Scanner(System.in);\nint t = sc.nextInt();\nwhile(t-->0)\n{\nlong n = sc.nextLong();\nlong k= sc.nextLong();\nlong count = 0, rem = 0;\nwhile(n!=0)\n{\nif(n%k==0)\n{\nn=n/k;\ncount++;\n}\nelse {\nrem = n%k;\ncount+=rem;\nn-=rem;\n}\n\n}\nSystem.out.println(count);\n}\n}\n}", "label": 2}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Akash\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        AFromHeroToZero solver = new AFromHeroToZero();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class AFromHeroToZero {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int t = in.nextInt();\n            while (t-- > 0) {\n                long n = in.nextLong();\n                long k = in.nextLong();\n                long ans = f(n, k);\n                out.println(ans);\n            }\n        }\n\n        long f(long n, long k) {\n            if (n < k) {\n                return n;\n            }\n            long q = n / k;\n            long x = k * q;\n            return (n - x) + 1 + f(q, k);\n        }\n\n    }\n}\n\n", "label": 2}
{"src": "import java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Solution {\n\n    public static void main(String[] args) {\n        final Scanner sc = new Scanner(System.in);\n        final PrintWriter pw = new PrintWriter(System.out);\n\n        int t = sc.nextInt();\n\n        for (int i = 0; i < t; ++i) {\n            long n = sc.nextLong();\n            final long k = sc.nextLong();\n\n            long answer = 1;\n\n            while (n != 1) {\n\n                if (k > n) {\n                    answer += (n - 1);\n                    break;\n                } else if (n % k == 0) {\n                    n /= k;\n                    answer++;\n                } else if(n > k) {\n                    long temp = (n - ((n / k) * k));\n                    answer += temp;\n                    n -= temp;\n                }\n            }\n\n            pw.println(answer);\n        }\n\n        pw.flush();\n    }\n}", "label": 2}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \n //@Manan Parmar\n\npublic class p11 implements Runnable {\n\n\n    public void run() {\n        \n        InputReader sc = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n \n        int t=sc.nextInt();\n\n        while(t--!=0)\n        {\n            long n=sc.nextLong();\n            long k=sc.nextLong();\n            long sum=0;\n            while(n!=0)\n            {\n                if(n%k==0)\n                {\n                    n=n/k;\n                    sum=sum+1;\n                }\n                else\n                {\n                    long x=n%k;\n                    sum=sum+x;\n                    n=n-x;\n                    /*double x1=Math.floor(n/k);\n                    long x=(long)x1;\n                    long y=x*k;\n                    long y2=n-y;\n                    sum=sum+y2;\n                    n=n-y2;*/\n                }\n            }\n            out.println(sum);\n        }\n\n\n        out.close();\n            \n    }\n \n\n//========================================================================\n    static int count(String s, char c) \n    { \n        int res = 0; \n  \n        for (int i=0; i<s.length(); i++) \n        { \n            // checking character in string \n            if (s.charAt(i) == c) \n            res++; \n        }  \n        return res; \n    }\n    static String addZeros(String str, int n)  \n    {  \n        for (int i = 0; i < n; i++)  \n        {  \n            str = \"0\" + str;  \n        }  \n        return str; \n    }  \n      \n    // Function to return the XOR  \n    // of the given strings  \n    static String getXOR(String a, String b)  \n    {  \n      \n        // Lengths of the given strings  \n        int aLen = a.length();  \n        int bLen = b.length();  \n      \n        // Make both the strings of equal lengths  \n        // by inserting 0s in the beginning  \n        if (aLen > bLen)  \n        {  \n            a = addZeros(b, aLen - bLen);  \n        }  \n        else if (bLen > aLen)  \n        {  \n            a = addZeros(a, bLen - aLen);  \n        }  \n      \n        // Updated length  \n        int len = Math.max(aLen, bLen);  \n      \n        // To store the resultant XOR  \n        String res = \"\";  \n          \n        for (int i = 0; i < len; i++) \n        {  \n            if (a.charAt(i) == b.charAt(i))  \n                res += \"0\";  \n            else\n                res += \"1\";  \n        }  \n        return res;  \n    }  \n    static class Pair\n    {\n        int a,b;\n        Pair(int aa,int bb)\n        {\n            a=aa;\n            b=bb;\n        }\n    }\n    \n    static void sa(int a[],InputReader sc)\n    {\n        for(int i=0;i<a.length;i++)\n        {\n            a[i]=sc.nextInt();\n        }\n        Arrays.sort(a);\n    }\n\n    static class PairSort implements Comparator<Pair>\n    {\n        public int compare(Pair a,Pair b)\n        {\n            return b.b-a.b;\n        }\n    }\n\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n \n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n       \n        public int read() {\n            if (numChars==-1)\n                throw new InputMismatchException();\n           \n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n               \n                if(numChars <= 0)              \n                    return -1;\n            }\n            return buf[curChar++];\n        }\n     \n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt() {\n            int c = read();\n           \n            while(isSpaceChar(c))\n                c = read();\n           \n            int sgn = 1;\n           \n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n           \n            int res = 0;\n            do {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n           \n            return res * sgn;\n        }\n       \n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n           \n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n                return res * sgn;\n        }\n       \n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n       \n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n           \n            return res.toString();\n        }\n     \n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n     \n        public String next() {\n            return readString();\n        }\n       \n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new p11(),\"Main\",1<<27).start();\n    }\n}", "label": 2}
{"src": "//package BINARY;\nimport java.util.*;\n\npublic class Ques_1 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc=new Scanner(System.in);\n\t\tint t=sc.nextInt();\n\t\tfor(int i=1;i<=t;i++)\n\t\t{\n\t\t\tlong n=sc.nextLong();\n\t\t\tlong k=sc.nextLong();\n\t\t\tlong count=0;\n\t\t\twhile(n!=0)\n\t\t\t{\n\t\t\t\tif(n%k==0) {\n\t\t\t\t\tcount+=1;\n\t\t\t\t\tn=n/k;\n\t\t\t\t}\n\t\t\t\telse if(n%k!=0)\n\t\t\t\t{\n\t\t\t\t\tcount+=n%k;\n\t\t\t\t\tn=n-(n%k);\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t\tcount=0;\n\t\t}\n\t}\n\n}\n", "label": 2}
{"src": "\nimport java.io.*;\n\n\n\nimport java.util.*;\n\n\npublic class Main {\n\n    public static void main(String[] args) throws IOException {\n\n \n \n\tBufferedReader bf=new BufferedReader(new InputStreamReader(System.in));\n        StringBuffer st=new StringBuffer();\n        int q=Integer.parseInt(bf.readLine());\n        while(q-->0){\n       String aa[]=bf.readLine().split(\" \");\nlong a=Long.parseLong(aa[0]);\nlong b=Long.parseLong(aa[1]);\n long count=0;\n if(b==1||a<b){st.append(a);}\n else{\n     while(a>0){\n       \n     if(a%b==0){a/=b;count++;}\n     else{count+=(a%b);a-=(a%b);}\n     }st.append(count);\n     }\n        \n        if(q>0){st.append(\"\\n\");}\n        }\n        System.out.println(st);\n\n        \n    }\n    \n    \n      \n}\n", "label": 2}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class GFG \n{\n\tpublic static void main (String[] args) \n\t{\n\t    Scanner sc=new Scanner(System.in);\n\t    int T=sc.nextInt();\n\t    while(T-->0)\n\t    {\n    \t    long N=sc.nextLong();\n    \t    long k=sc.nextLong();\n    \t    long c=0;\n\t        while(N!=0)\n\t        {\n\t            c=c+N%k+1;\n\t            N/=k;\n\t        }\n\t        System.out.println(c-1);\n\t    }\n\t}\n}", "label": 2}
{"src": "import java.util.*;\n\npublic class Test\n{\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner s=new Scanner(System.in);\n\t\tint t=s.nextInt();\n\t\tTest test=new Test(); \n\t\twhile(t-- >0)\n\t\t{\n\t\t\tlong n=s.nextLong();\n\t\t\tlong k=s.nextLong();\n\t\t\tSystem.out.println(test.minSteps(n,k));\n\t\t}\t\t\n\t}\n\tlong minSteps(long n, long k)\n\t{\n\t\tif(n==0)\n\t\t\treturn 0;\n\t\tif(n%k==0)\n\t\t\treturn 1+minSteps(n/k,k);\n\t\treturn n%k+minSteps(n-n%k,k);\n\t\t\n\t}\n}", "label": 2}
{"src": "                    /* MOHD SADIQ*/\n    import java.util.*;\n    import java.io.*;\n    import java.util.ArrayList;\n    import java.math.*;\n\n    public class Main{\n\n        public static void main(String[] args) throws IOException{\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int t = Integer.parseInt(br.readLine());\n            StringBuffer ans = new StringBuffer();\n            while(t-->0){\n                String[] x = br.readLine().split(\" \");\n                long n = Long.parseLong(x[0]);\n                long k = Long.parseLong(x[1]);\n                long c=0;\n                while(n!=0){\n                    if(n%k==0) {\n                        n /= k;\n                        c++;\n                    }\n                    else {\n                        c+=n%k;\n                        n = n-n%k;\n                    }\n                }\n                ans.append(c+\"\\n\");\n            }\n            System.out.println(ans);\n        }\n\n    }", "label": 2}
{"src": "//package com.krakn.CF.A.A1175;\n\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int t = sc.nextInt();\n        for (int i = 0; i < t; i++) {\n            long n = sc.nextLong();\n            long k = sc.nextLong();\n\n            long count = 0;\n            while (n >= k) {\n                count += n % k;\n                n -= n % k;\n//                System.out.println(n + \" - \" + count);\n                n /= k;\n                count++;\n//                System.out.println(n + \" - \" + count);\n            }\n            System.out.println(count + n);\n        }\n    }\n}\n", "label": 2}
{"src": "\n\nimport java.util.Scanner;\n\npublic class herotozero {\n\n\tpublic static void main(String args[])\n\t{\n\t\tScanner scan=new Scanner(System.in);\n\t\tint t=scan.nextInt();\n\t\tfor(int i=0;i<t;i++) {\n\t\tLong n=scan.nextLong();\n\t\tLong k=scan.nextLong();\n\t\tLong gg=(n/k);\n\t\tlong step=0;\n\t\twhile(n>0)\n\t\t{\n\t\t\tif(n%k==0)\n\t\t\t{\n\t\t\t\tn=n/k;\n\t\t\t\tstep++;\n\n\t\t\t}else{\n\t\t\t\tlong tem=n;\n\t\t\t\tn-=tem-(n/k)*k;\n\t\t\t\tstep+=tem-(n/k)*k;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\t}\n\t\tSystem.out.println(step);\n\t\t}\n\t\t}\n}\n", "label": 2}
{"src": "\nimport java.util.*;\nimport java.io.*;  \npublic class Main \n{\n    PrintWriter out;\n    FastReader sc;\n    long[] m1= {(long)(1e9+7),998244353};\n    long mod=m1[1];\n    long maxlong=Long.MAX_VALUE;\n    long minlong=Long.MIN_VALUE;\n    StringBuilder sb;\n    /******************************************************************************************\n     *****************************************************************************************/\n\tpublic void sol(){\n\t\tlong n=nl(),k=nl(),ans=0,p=k;\n\t\twhile(n>0) {\n\t\t\tif(n%k!=0) {\n\t\t\t\tans+=n%k;\n\t\t\t\tn-=(n%k);\n\t\t\t}if(n>0)ans++;\n\t\t\tn=n/k;\n\t\t}pl(ans);\n\t}\n    public static void main(String[] args) \n\t{ \n\t    Main g=new Main();\n\t\tg.out=new PrintWriter(System.out);\n\t\tg.sc=new FastReader();\n\t\tint t=1;\n \t\tt=g.ni();\n\t\twhile(t-->0)\n\t\tg.sol();\n\t\tg.out.flush();\n\t}\n\t\n\t/****************************************************************************************\n     *****************************************************************************************/\n\tstatic class FastReader \n\t{ \n\t\tBufferedReader br; \n\t\tStringTokenizer st; \n \n\t\tpublic FastReader() \n\t\t{ \n\t\t\tbr = new BufferedReader(new\n\t\t\t\t\tInputStreamReader(System.in)); \n\t\t} \n \n\t\tString next() \n\t\t{ \n\t\t\twhile (st == null || !st.hasMoreElements()) \n\t\t\t{ \n\t\t\t\ttry\n\t\t\t\t{ \n\t\t\t\t\tst = new StringTokenizer(br.readLine()); \n\t\t\t\t} \n\t\t\t\tcatch (IOException e) \n\t\t\t\t{ \n\t\t\t\t\te.printStackTrace(); \n\t\t\t\t} \n\t\t\t} \n\t\t\treturn st.nextToken(); \n\t\t} \n \n\t\tint nextInt() \n\t\t{ \n\t\t\treturn Integer.parseInt(next()); \n\t\t} \n \n\t\tlong nextLong() \n\t\t{ \n\t\t\treturn Long.parseLong(next()); \n\t\t} \n \n\t\tdouble nextDouble() \n\t\t{ \n\t\t\treturn Double.parseDouble(next()); \n\t\t} \n \n\t\tString nextLine() \n\t\t{ \n\t\t\tString str = \"\"; \n\t\t\ttry\n\t\t\t{ \n\t\t\t\tstr = br.readLine(); \n\t\t\t} \n\t\t\tcatch (IOException e) \n\t\t\t{ \n\t\t\t\te.printStackTrace(); \n\t\t\t} \n\t\t\treturn str; \n\t\t} \n\t} public int ni(){\n\t      return sc.nextInt();\n\t}public long nl(){\n\t      return sc.nextLong();\n\t}public double nd(){\n\t      return sc.nextDouble();\n\t}public char[] rl(){\n\t      return sc.nextLine().toCharArray();\n\t}public String rl1(){\n\t      return sc.nextLine();\n\t}\n\tpublic void pl(Object s){\n\t      out.println(s);\n\t}public void ex(){\n\t      out.println();\n\t}\n\tpublic void pr(Object s){\n\t      out.print(s);\n\t}public String next(){\n\t      return sc.next();\n\t}public long abs(long x){\n\t      return Math.abs(x);\n\t}\n\tpublic int abs(int x){\n\t      return Math.abs(x);\n\t}\n\tpublic double abs(double x){\n\t      return Math.abs(x);\n\t}public long min(long x,long y){\n            return (long)Math.min(x,y);\n      }\n      public int min(int x,int y){\n            return (int)Math.min(x,y);\n      }\n      public double min(double x,double y){\n            return Math.min(x,y);\n      }public long gcd(long a, long b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}public long lcm(long a, long b) {\n            return (a / gcd(a, b)) * b;\n      }\n       void sort1(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l,Collections.reverseOrder());\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}\n\t void sort(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}void sort(long[] a) {\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}void sort1(long[] a) {\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l,Collections.reverseOrder());\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}\n\tvoid sort(double[] a) {\n\t\tArrayList<Double> l = new ArrayList<>();\n\t\tfor (double i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}long pow(long a,long b){\n          if(b==0){\n                return 1;\n          }long p=pow(a,b/2);\n          if(b%2==0) return (p*p)%mod;\n          else return (((p*p)%mod)*a)%mod;\n    }\n\t\n\tint  swap(int a,int b){\n\t      return a;\n\t}long  swap(long a,long b){\n\t      return a;\n\t}double  swap(double a,double b){\n\t      return a;\n\t}\n\tboolean isPowerOfTwo (int x) \n      { \n            return x!=0 && ((x&(x-1)) == 0);     \n      }boolean isPowerOfTwo (long x) \n      { \n            return x!=0 && ((x&(x-1)) == 0);     \n      }public long max(long x,long y){\n            return (long)Math.max(x,y);\n      }\n      public int max(int x,int y){\n            return (int)Math.max(x,y);\n      }\n      public double max(double x,double y){\n            return Math.max(x,y);\n      }long sqrt(long x){\n            return (long)Math.sqrt(x);\n      }int sqrt(int x){\n            return (int)Math.sqrt(x);\n      }void input(int[] ar,int n){\n            for(int i=0;i<n;i++)ar[i]=ni();\n      }void input(long[] ar,int n){\n            for(int i=0;i<n;i++)ar[i]=nl();\n      }void fill(int[] ar,int k){\n            Arrays.fill(ar,k);\n      }void yes(){\n            pl(\"YES\");\n      }void no(){\n            pl(\"NO\");\n      }\n    long[] sieve(int n) \n    {\n          long[] k=new long[n+1];\n          boolean[] pr=new boolean[n+1];\n          for(int i=1;i<=n;i++){\n                k[i]=i;\n                pr[i]=true;\n          }for(int i=2;i<=n;i++){\n                if(pr[i]){\n                      for(int j=i+i;j<=n;j+=i){\n                            pr[j]=false;\n                            if(k[j]==j){\n                                  k[j]=i;\n                            }\n                      }\n                }\n          }return k;\n    }\n    int strSmall(int[] arr, int target)  \n    {  \n        int start = 0, end = arr.length-1;  \n        int ans = -1;  \n        while (start <= end) {  \n            int mid = (start + end) / 2;   \n            if (arr[mid] >= target) {  \n                end = mid - 1;  \n            }   \n            else {  \n                ans = mid;  \n                start = mid + 1;  \n            }  \n        }  \n        return ans;  \n    } int strSmall(ArrayList<Integer> arr, int target)  \n    {  \n        int start = 0, end = arr.size()-1;  \n        int ans = -1;  \n        while (start <= end) {  \n            int mid = (start + end) / 2;   \n            if (arr.get(mid) > target) {  \n                start = mid + 1; \n                ans=start;\n            }   \n            else {\n                end = mid - 1;  \n            }  \n        }  \n        return ans;  \n    }long mMultiplication(long a,long b) \n    { \n        long res = 0;    \n        a %= mod; \n  \n        while (b > 0)  \n        {  \n            if ((b & 1) > 0)  \n            { \n                res = (res + a) % mod; \n            }  \n            a = (2 * a) % mod; \n  \n            b >>= 1;  \n        } \n        return res; \n    }long nCr(int n, int r ,int p)\n    {\n \n          if (n<r) \n              return 0;\n        if (r == 0)\n            return 1;\n            long[] fac = new long[n + 1];\n        fac[0] = 1;\n \n        for (int i = 1; i <= n; i++)\n            fac[i] = fac[i - 1] * i %p;\n        return (fac[n] * modInverse(fac[r], p)\n                % p * modInverse(fac[n - r], p)\n                % p)\n            % p;\n    }long power(long x, long y, long p)\n    {\n        long res = 1;\n        x = x % p;\n \n        while (y > 0) {\n            if (y % 2 == 1)\n                res = (res * x) % p;\n            y = y >> 1; \n            x = (x * x) % p;\n        }\n \n        return res;\n    }long modInverse(long n, long p)\n    {\n        return power(n, p - 2, p);\n    }\n    \n    int[][] floydWarshall(int graph[][],int INF,int V)\n    {\n        int dist[][] = new int[V][V];\n        int i, j, k;\n        for (i = 0; i < V; i++)\n            for (j = 0; j < V; j++)\n                dist[i][j] = graph[i][j];\n        for (k = 0; k < V; k++)\n        {\n            for (i = 0; i < V; i++)\n            {\n                for (j = 0; j < V; j++)\n                {\n                    if (dist[i][k] + dist[k][j] < dist[i][j])\n                        dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }return dist;\n    }\n    class minque {\n\t\tDeque<Long> q;\n\t\tminque(){\n\t\t\tq=new ArrayDeque<Long>();\n\t\t}public void add(long p){\n\t\t\twhile(!q.isEmpty()&&q.peekLast()>p)q.pollLast();\n\t\t\tq.addLast(p);\n\t\t}public void remove(long p) {\n\t\t\tif(!q.isEmpty()&&q.getFirst()==p)q.removeFirst();\n\t\t}public long min() {\n\t\t\treturn q.getFirst();\n\t\t}\n\t}\n      public static class Pair implements Comparable<Pair> {\n\t\tlong x;\n\t\tlong y;\n \n\t\tpublic Pair(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tpublic Pair() {\n\t\t\t// TODO Auto-generated constructor stub\n\t\t}\n\t\tpublic int compareTo(Pair other) {\n\t\t\tif (this.x == other.x) {\n\t\t\t\treturn Long.compare(other.y, this.y);\n\t\t\t}\n\t\t\treturn Long.compare(other.x, this.x);\n\t\t}\n      }\n\t \n} ", "label": 2}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\n/* abhi2601 */\n\npublic class Q1 implements Runnable{\n\n    final static long mod = (long)1e9 + 7;\n    /*class Pair implements Comparable<Pair> {\n        int a;\n        int c;\n        Pair(int a, int c) {\n            this.a = a;\n            this.c = c;\n        }\n        public boolean equals(Object o) {\n            Pair p = (Pair) o;\n            return this.a == p.a && this.c == this.c;\n        }\n        public int hashCode() {\n            return Long.hashCode(a) * 27 + Long.hashCode(c) * 31;\n        }\n\n        public int compareTo(Pair p) {\n            return Integer.compare(this.c,p.c);\n        }\n    }*/\n    public void run(){\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int tt=sc.nextInt();\n        for(int i=0;i<tt;i++){\n            long n=sc.nextLong();\n            long k=sc.nextLong();\n            long t=n,ans=0L;\n            while(t>=k){\n                long temp=(t/k)*k;\n                long q=t-temp;\n                ans+=q;\n                t/=k;\n                ans++;\n            }\n            w.println(ans+t);\n        }\n        w.close();\n    }\n    /*static class Pair2{\n        int a,b;\n        Pair2(int a, int b){\n            this.a=a;\n            this.b=b;\n        }\n    }\n    static class Comp implements Comparator<String>{\n        public int compare(String x,String y){\n            return x.length()-y.length();\n        }\n    }*/\n    //static PrintWriter w;\n    /*File in=new File(\"input.txt\");\n        File out=new File(\"output.txt\");\n        Scanner sc= null;\n        try {\n            sc = new Scanner(in);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n        try {\n            w=new PrintWriter(out);\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }*/\n    static class InputReader {\n\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream)\n        {\n            this.stream = stream;\n        }\n\n        public int read()\n        {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars)\n            {\n                curChar = 0;\n                try\n                {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e)\n                {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine()\n        {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int nextInt()\n        {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do\n            {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do\n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.')\n            {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.')\n            {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c))\n                {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do\n            {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c)\n        {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next()\n        {\n            return readString();\n        }\n\n        public interface SpaceCharFilter\n        {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    public static void main(String args[]) throws Exception\n    {\n        new Thread(null, new Q1(),\"q1\",1<<26).start();\n    }\n}", "label": 2}
{"src": "import java.util.Scanner;\n\npublic class HeroToZero {\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\n\t\twhile (t > 0) {\n\t\t\tlong n = sc.nextLong();\n\t\t\tlong k = sc.nextLong();\n\t\t\tlong steps = 0;\n\n\t\t\twhile (n > 0) {\n\t\t\t\tif(n%k!=0) {\n\t\t\t\t\tsteps+=(n%k);\n\t\t\t\t\tn=n-(n%k);\n\t\t\t\t}else if(n%k==0){\n\t\t\t\t\tsteps++;\n\t\t\t\t\tn=n/k;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(steps);\n\t\t\tt--;\n\t\t}\n\t\tsc.close();\n\t}\n}", "label": 2}
{"src": "import java.util.*;\n\npublic class Main {\n\n    public static void main (String[] args){\n\n        Scanner scan = new Scanner(System.in);\n\n        /* start */\n        int test = scan.nextInt();\n\n        for(int i = 0; i < test; i++){\n            long n = scan.nextLong();\n            long k = scan.nextLong();\n            long ans = 0;\n\n            while(n != 0){\n                long rem = n % k;\n                if( rem == 0){\n                    n = n / k;\n                    ans++;\n                }else{\n                    n = n - rem;\n                    ans = ans + rem;\n                }\n            }\n\n            System.out.println(ans);\n        }\n    }\n}\n", "label": 2}
{"src": "/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.util.Arrays;\nimport java.math.BigInteger;\n \n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Main\n{\n     public static void main (String[] args) throws java.lang.Exception\n     {\n     \tScanner in =new Scanner(System.in);\n\t\tint t=1,i,j,m=0,h,l,x,y,d;\n\t\tString s=\"\",st;\n\t\tlong n,k,p;\n\t\tt=in.nextInt();\n\t\tfor(i=0;i<t;i++)\n\t\t{\n\t\t    p=0;\n\t\t    n=in.nextLong();\n\t\t    k=in.nextLong();\n\t\t    while(n>0)\n\t\t    {\n\t\t         if(n%k==0)\n\t\t         {\n\t\t             n=n/k;\n\t\t             p++;\n\t\t         }\n\t\t         else \n\t\t         {\n\t\t             p+=(n%k);\n\t\t             n-=(n%k);\n\t\t         }\n\t\t    }\n\t\t    System.out.println(p);\n\t\t}\n\t}\n}", "label": 2}
{"src": "import java.util.Scanner;\n\npublic class FromHeroToZero {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint runs = sc.nextInt();\n\t\tfor(int i =0;i<runs;i++) {\n\t\t\tLong n = sc.nextLong();Long k = sc.nextLong();\n\t\t\tLong output = (long)0;\n\t\t\twhile(n!=0) {\n\t\t\t\t//System.out.println(n);\n\t\t\t\t//System.out.println(output);\n\t\t\t\tif(n%k==0&&n>=k) {\n\t\t\t\t\tn /=k;\n\t\t\t\t\toutput++;\n\t\t\t\t\t//System.out.println(\"divided \" +  n);\n\t\t\t\t}else if(n%k!=0&&n>=k){\n\t\t\t\t\tLong temp  = n - (n%k);\n\t\t\t\t\t//System.out.println(temp);\n\t\t\t\t\toutput += n%k;\n\t\t\t\t\tn = temp;\n\t\t\t\t\t\n\t\t\t\t\t//System.out.println(temp%3);\n\t\t\t\t\t//System.out.println(\"subtracted \"+ n);\n\t\t\t\t}else {\n\t\t\t\t\toutput += n;\n\t\t\t\t\tn = (long)0;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(output);\n\t\t\t//System.out.println(59%3);\n\t\t}\n\n\t}\n\n}\n", "label": 2}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class A {\n\n    public static void main(String[] args) {\n        Scanner scn = new Scanner(System.in);\n        int t = scn.nextInt();\n        long[] n = new long[t];\n        long[] k = new long[t];\n        for (int i = 0; i < t; i++) {\n            n[i] = scn.nextLong();\n            k[i] = scn.nextLong();\n        }\n        scn.close();\n\n        for (int i = 0; i < t; i++) {\n            long s = -1;\n            while (n[i] > 0) {\n                s += n[i] % k[i] + 1;\n                n[i] /= k[i];\n            }\n            System.out.println(s);\n        }\n    }\n\n}", "label": 2}
{"src": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\npublic class loser\n{\n    static class InputReader {\n        public BufferedReader br;\n        public StringTokenizer token;\n        public InputReader(InputStream stream)\n        {\n            br=new BufferedReader(new InputStreamReader(stream),32768);\n            token=null;\n        }\n\n        public String next()\n        {\n            while(token==null || !token.hasMoreTokens())\n            {\n                try\n                {\n                    token=new StringTokenizer(br.readLine());\n                }\n                catch(IOException e)\n                {\n                    throw new RuntimeException(e);\n                }\n            }\n            return token.nextToken();\n        }\n\n        public int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n    }\n    static class card{\n        String s;\n        int l;\n        public card(String s,int i)\n        {\n            this.s=s;\n            this.l=i;\n        }\n    }\n    static class sort implements Comparator<card>\n    {\n        public int compare(card o1,card o2)\n        {\n            if(o1.l!=o2.l)\n                return (o1.l-o2.l);\n            else\n                return o1.s.compareTo(o2.s);\n        }\n    }\n    static void shuffle(long a[])\n    {\n        List<Long> l=new ArrayList<>();\n        for(int i=0;i<a.length;i++)\n            l.add(a[i]);\n        Collections.shuffle(l);\n        for(int i=0;i<a.length;i++)\n            a[i]=l.get(i);\n    }\n\n    /*static long gcd(long a,long b)\n    {\n    if(b==0)\n    return a;\n    else\n    return gcd(b,a%b);\n    }*/\n    /*static boolean valid(int i,int j)\n    {\n    if(i<4 && i>=0 && j<4 && j>=0)\n    return true;\n    else\n    return false;\n    }*/\n    public  static void main(String[] args) \n    {\n        InputReader sc=new InputReader(System.in);\n        int t=sc.nextInt();\n        while(t>0)\n        {\n            long n=sc.nextLong();\n            long k=sc.nextLong();\n            long ans=0;\n            while(n>0)\n            {\n                if(n%k==0)\n                {\n                    n=n/k;\n                    ans++;\n                }\n                else\n                {\n                    long d=n%k;\n                    ans+=d;\n                    n=n-d;\n                }\n            }\n            System.out.println(ans);\n            t--;\n        }\n    }\n}", "label": 2}
{"src": "//package code.forces;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.stream.Stream;\n\npublic class Solution {\n\tprivate static final BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint t = Integer.parseInt(reader.readLine());\n\t\t\n\t\tfor(int i = 0; i < t; i++) {\n\t\t\tsolve();\n\t\t}\n\t\t\n\t}\n\n\tprivate static void solve() throws IOException {\n\t\tlong nk[] = readLongs(reader);\n\t\t\n\t\tlong n = nk[0], k = nk[1];\n\t\t\n\t\tlong count = 0;\n\t\t\n\t\twhile(n > 0) {\n\t\t\tif(n % k == 0) {\n\t\t\t\tcount++;\n\t\t\t\tn = n / k;\n\t\t\t} else {\n\t\t\t\tcount += n % k;\n\t\t\t\tn -= (n % k);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n\t\n\tpublic static long[] readLongs(BufferedReader reader) throws IOException {\n\t\treturn toLongArray(reader.readLine());\n\t}\n\t\n\tpublic static long[] toLongArray(String s) {\n\t\treturn Stream.of(s.split(\"\\\\s\")).mapToLong(Long::parseLong).toArray();\n    }\n\t\n}\n", "label": 2}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author test\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        AFromHeroToZero solver = new AFromHeroToZero();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class AFromHeroToZero {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n\n            int t = in.nextInt();\n            while (t > 0) {\n                t--;\n\n                long n = in.nextLong();\n                long k = in.nextLong();\n\n                long res = 0;\n\n                while (n != 0) {\n                    if (n % k == 0) {\n                        res++;\n                        n = n / k;\n                    } else {\n                        res += n % k;\n                        n -= n % k;\n                    }\n                }\n                out.println(res);\n            }\n        }\n\n    }\n}\n\n", "label": 2}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n    public static void main(String args[]) {\n        FastScanner scn = new FastScanner();\n        int t = scn.nextInt();\n        while(t-- >0){\n            long n = scn.nextLong();\n            long k = scn.nextLong();\n            long count = 0;\n            while(n!=0){\n                if(n%k == 0){\n                    n/=k;\n                    count++;\n                } else {\n                    count += n%k;\n                    n -= n%k;\n                    continue;\n                }\n            }\n            System.out.println(count);\n        }\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (FileNotFoundException e) {\n                // TODO Auto-generated catch block\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    // TODO Auto-generated catch block\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "label": 2}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Q1 {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint N = Integer.parseInt(br.readLine());\n\t\tfor (int i=0; i<N; i++) {\n\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\tlong n = Long.parseLong(st.nextToken());\n\t\t\tlong k = Long.parseLong(st.nextToken());\n\t\t\tlong total = 0;\n\t\t\tif (k == 1) {\n\t\t\t\tSystem.out.println(n);\n\t\t\t} else {\n\t\t\t\twhile (n > 0) {\n\t\t\t\t\tif (n%k == 0) {\n\t\t\t\t\t\tn /= k;\n\t\t\t\t\t\ttotal ++;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttotal += (n%k);\n\t\t\t\t\t\tn -= (n%k);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(total);\n\t\t\t}\n\t\t}\n\t\tbr.close();\n\t}\n}\n", "label": 2}
{"src": "import java.io.BufferedReader; \nimport java.io.IOException; \nimport java.io.InputStreamReader;\nimport java.util.Scanner; \nimport java.util.StringTokenizer;\npublic class Main\n{\n    \n    \n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n\tpublic static void main(String[] args) throws IOException {\n\t    FastReader s=new FastReader(); \n\tint t=s.nextInt();\n\tlong z=0;\n\tfor(int i=0;i<t;i++){\n\t    z=0;\n\t   long n=s.nextLong();\n\t   long k=s.nextLong();\n\t        while(n>0)\n\t        {\n                if(n%k!=0)\n                {\n                    z=z+(n%k);\n\t            n=n-(n%k);\n\t            \n\t           // System.out.println(z);\n                }\n\t            else\n\t            {\n\t                n=n/k;\n\t                z++;\n\t               // System.out.println(z);\n\t            }\n\t            \n\t        }\n\t        System.out.println(z);\n\t     \n\t}\n  }\n}", "label": 2}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        try (PrintWriter out = new PrintWriter(System.out)) {\n            Solution solution = new Solution();\n            solution.in = new InputReader(getInput());\n            solution.out = out;\n            solution.solve();\n        }\n    }\n\n    static InputStream getInput() {\n        String inputFile = getInputFileName();\n        if (inputFile == null) {\n            return System.in;\n        }\n        try {\n            return new FileInputStream(Main.class.getClassLoader().getResource(inputFile).getFile());\n        } catch (FileNotFoundException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    static String getInputFileName() {\n        try {\n            return System.getProperty(\"compet.input\");\n        } catch (Exception ex) {\n            return null;\n        }\n    }\n}\n\nclass Solution {\n    InputReader in;\n    PrintWriter out;\n\n    void solveCase() {\n        long n = in.nextLong();\n        long k = in.nextLong();\n        long ans = 0;\n        while (true) {\n            ans += n%k;\n            n -= n%k;\n            if (n > 0) {\n                n /= k;\n                ans++;\n            } else {\n                break;\n            }\n        }\n        out.println(ans);\n    }\n\n    void solve() {\n        int t = in.nextInt();\n        for (int i = 0; i < t; i++) {\n            solveCase();\n        }\n    }\n}\n\nclass InputReader {\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n}\n", "label": 2}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\n\npublic class Main {\n\tstatic BigInteger metodo(BigInteger n, BigInteger k) {\n\t\tBigInteger rta = BigInteger.ZERO;\n\t\t\n\t\twhile(n.compareTo(BigInteger.ZERO)>0) {\n\t\t\tif(n.mod(k).compareTo(BigInteger.ZERO)==0) {\n\t\t\t\trta = rta.add(BigInteger.ONE);\n\t\t\t\tn = n.divide(k);\n\t\t\t}\n\t\t\telse {\n\t\t\t\trta = rta.add(n.mod(k));\n\t\t\t\tn = n.subtract(n.mod(k));\n\t\t\t}\n\t\t}\n\t\treturn rta;\n\t\t\n\t}\n\tpublic static void main(String[] args) throws Exception{\n\t\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\t\tint t = Integer.parseInt(bf.readLine());\n\t\twhile(t-->0) {\n\t\t\tString[] data = bf.readLine().split(\" \");\n\t\t\tSystem.out.println(metodo(new BigInteger(data[0]), new BigInteger(data[1])).toString());\n\t\t}\n\t}\n\n}\n", "label": 2}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static long index = 0;\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader in = new BufferedReader (new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\t\tint  casos = Integer.parseInt(in.readLine());\n\t\tString linea;\n\t\tfor (int i = 0; i < casos; i++) {\n\t\t\tlinea = in.readLine();\n\t\t\tStringTokenizer st = new StringTokenizer(linea);\n\t\t\tlong n = Long.parseLong(st.nextToken());\n\t\t\tlong k = Long.parseLong(st.nextToken());\n\t\t\tif(k == 1) index = n;\n\t\t\telse kMethod(n, k);\n\t\t\tout.println(index);\n\t\t\tindex = 0;\n\t\t}\n\t\tout.close();\n\t}\n\t\n\tpublic static void  kMethod (long a, long b) {\n\t\twhile(a > 0) {\n\t\t\tif(a%b == 0) {\n\t\t\t\ta = a/b;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong dif = a % b;\n\t\t\t\ta -= dif;\n\t\t\t\tindex += dif;\n\t\t\t}\n\t\t}\n\t}\n\n}\n \t\t  \t\t\t\t \t \t  \t\t \t\t   \t\t \t\t\t\t\t", "label": 2}
{"src": "import java.io.*; \nimport java.util.*; \n//import javafx.util.*; \nimport java.math.*;\n//import java.lang.*;\n \npublic class untitled \n{ \n    static class Pair{\n        int x;int y;int i;\n        Pair(int x,int y,int i){\n            this.x=x;\n            this.y=y;\n            this.i=i;\n        }\n    }\n    static class sorting implements Comparator<Pair>{\n        public int compare(Pair a,Pair b){\n            //return (a.y)-(b.y);\n            return (a.x-b.x);\n        }\n    }\n \n     static class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[64]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    } \n    \n static void merge(int arr[], int l, int m, int r) \n    { \n        // Find sizes of two subarrays to be merged \n        int n1 = m - l + 1; \n        int n2 = r - m; \n  \n        /* Create temp arrays */\n        int L[] = new int [n1]; \n        int R[] = new int [n2]; \n  \n        /*Copy data to temp arrays*/\n        for (int i=0; i<n1; ++i) \n            L[i] = arr[l + i]; \n        for (int j=0; j<n2; ++j) \n            R[j] = arr[m + 1+ j]; \n  \n  \n        /* Merge the temp arrays */\n  \n        // Initial indexes of first and second subarrays \n        int i = 0, j = 0; \n  \n        // Initial index of merged subarry array \n        int k = l; \n        while (i < n1 && j < n2) \n        { \n            if (L[i] <= R[j]) \n            { \n                arr[k] = L[i]; \n                i++; \n            } \n            else\n            { \n                arr[k] = R[j]; \n                j++; \n            } \n            k++; \n        } \n  \n        /* Copy remaining elements of L[] if any */\n        while (i < n1) \n        { \n            arr[k] = L[i]; \n            i++; \n            k++; \n        } \n  \n        /* Copy remaining elements of R[] if any */\n        while (j < n2) \n        { \n            arr[k] = R[j]; \n            j++; \n            k++; \n        } \n    } \n  \n    // Main function that sorts arr[l..r] using \n    // merge() \n    static void sort(int arr[], int l, int r) \n    { \n        if (l < r) \n        { \n            // Find the middle point \n            int m = (l+r)/2; \n  \n            // Sort first and second halves \n            sort(arr, l, m); \n            sort(arr , m+1, r); \n  \n            // Merge the sorted halves \n            merge(arr, l, m, r); \n        } \n    }\n   // static int n;static ArrayList<Pair> arr1;\n    //static int len;\n    public static int[] na(int n)throws IOException{\n        Reader s1=new Reader();\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = s1.nextInt();\n        return a;\n    }\n    public static void main(String[] args) throws IOException { \n        Reader s=new Reader();\n        int t=s.nextInt();\n        while(t--!=0){\n            long n=s.nextLong();\n            long k=s.nextLong();\n            long ans=0;\n            long m=1;\n            while(n>=k){\n\n                if(n%k==0){\n                    n=n/k;\n                    ans++;\n                }\n                else{\n                    ans=ans+1+n%k;\n                    n=n/k;\n                    \n                   // System.out.println(n%k);\n                }\n             //   ans++;\n            }\n                        System.out.println(ans+n);\n        }\n\n    }\n// Returns factorial of n \nstatic int fact(int n) \n{ \n    int res = 1; \n    for (int i = 2; i <= n; i++) \n        res = res * i; \n    return res; \n}\n    static boolean isPrime(int n) { \n        if (n <= 1) \n            return false; \n        if (n <= 3) \n            return true; \n        if (n % 2 == 0 ||  \n            n % 3 == 0) \n            return false; \n      \n        for (int i = 5; \n                 i * i <= n; i = i + 6) \n            if (n % i == 0 || \n                n % (i + 2) == 0) \n                return false; \n      \n        return true; \n    } \n    static int gcd(int a, int b) \n    { \n      if (b == 0) \n        return a; \n      return gcd(b, a % b);  \n    }  \n    static long fast_pow(long base,long n,long M)\n    {\n        if(n==0)\n           return 1;\n        if(n==1)\n        return base;\n        long halfn=fast_pow(base,n/2,M);\n        if(n%2==0)\n            return ( halfn * halfn ) % M;\n        else\n            return ( ( ( halfn * halfn ) % M ) * base ) % M;\n    }\n    static long findMMI_fermat(long n,int M)\n    {\n        return fast_pow(n,M-2,M);\n    }\n    \n} ", "label": 2}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class A {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int T = Integer.valueOf(br.readLine());\n        //long start = System.currentTimeMillis();\n        for(int i = 0; i < T; i++){\n            String[] input = br.readLine().split(\" \");\n            long N = Long.valueOf(input[0]);\n            long K = Long.valueOf(input[1]);\n            System.out.println(steps(N, K));\n        }\n    }\n\n    private static long steps(long N, long K){\n        long counter = 0;\n        while(N != 0){\n            long next = (N/K) * K;\n            counter += N - next;\n            N = next;\n            if(N >= K){\n                N = N / K;\n                counter++;\n            }\n        }\n        return counter;\n    }\n\n    /*private static int steps(long N, long K){\n        int counter = 0;\n        while(N != 0){\n            if(N % K == 0){\n                N = N / K;\n            }else{\n                N--;\n            }\n            counter++;\n        }\n        return counter;\n    }*/\n}\n", "label": 2}
{"src": "import java.util.*;\n\n/**\n *\n * @author Lenovo\n */\npublic class JavaApplication2 {\n\n  \n    public static void main(String[] args) {\n    long s;\n    long n,k;\n    Scanner in=new Scanner(System.in);\n    s=in.nextInt();\n    for(int i=0;i<s;i++){\n  n=in.nextLong();\n  k=in.nextLong();\n long num=0;\n  if(k>n){num=n;System.out.println(num);}\n  else {\n  while(n>0){if(n%k==0){n/=k;num++;}else{long r=n%k;n-=r;num+=r;}}\n  \n  System.out.println(num);\n  }}\n    \n    }}\n  ", "label": 2}
{"src": "import java.util.*;\nimport java.io.*;\npublic class CODEFORCES1\n{\n    public static void main(String args[])throws IOException\n    {\n        Scanner sc=new Scanner(System.in);\n        int T;\n        long n,k;\n        T=sc.nextInt();\n        while((T--)!=0)\n        {\n            long count=0;\n            n=sc.nextLong();\n            k=sc.nextLong();\n            while(n>0)\n            {\n                if(n%k==0)\n                {\n                    n/=k;\n                    count++;\n                }                \n                else\n                {\n                    count+=(n%k);\n                    n-=(n%k);                    \n                }              \n            }\n            System.out.println(count);\n        }\n    }\n}", "label": 2}
{"src": "import java.util.Scanner;\n\npublic class JavaApplication116 {\n\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0){\n\t\tlong n=sc.nextLong();\n\t\tlong k=sc.nextLong();\n\t\tlong x=n%k;\n\t\twhile(n>0){\n\t\t    n=n/k;\n\t\t   x++;\n\t\t   x+=n%k;\n\t\t}\n\t\tSystem.out.println(x-1);\n\t\t}\n\t}\n}\n", "label": 2}
{"src": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.lang.*;\nimport java.util.stream.IntStream;\nimport java.util.stream.Stream;\n\npublic class Main {\n\n    private static final Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) throws IOException {\n        int n = scanner.nextInt();\n        scanner.skip(\"(\\r\\n|[\\n\\r\\u2028\\u2029\\u0085])?\");\n\n        for (int i = 0; i < n; i++) {\n            long value = scanner.nextLong();\n            long x = scanner.nextLong();\n            long count = 0;\n            while (value > 0) {\n                if (value % x == 0) {\n                    value /= x;\n                    count++;\n                }\n                else {\n                    count += value % x;\n                    value = value - value % x;\n                }\n            }\n\n            System.out.println(count);\n        }\n    }\n\n}", "label": 2}
{"src": "import java.util.*;\n\npublic class solve{\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int t = s.nextInt();\n        while(t-->0){\n            long n, k;\n            long count=0;\n            n=s.nextLong();\n            k=s.nextLong();\n            while(n!=0){\n                while(n%k==0){\n                    n=n/k;\n                    count++;\n                }\n                count+=n%k;\n                n-=n%k;\n            }\n            System.out.println(count);\n        }\n    }\n}", "label": 2}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A implements Runnable {\n\tFastReader scn;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tvoid solve() {\n\t\tint t = scn.nextInt();\n\t\twhile(t-- > 0) {\n\t\t\tlong n = scn.nextLong(), k = scn.nextLong(), ans = 0;\n\t\t\t\n\t\t\twhile(n >= k) {\n\t\t\t\tif(n % k == 0) {\n\t\t\t\t\tn /= k;\n\t\t\t\t\tans++;\n\t\t\t\t} else {\n\t\t\t\t\tans += n;\n\t\t\t\t\tn = (n / k) * k;\n\t\t\t\t\tans -= n;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.println(ans + n);\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\tlong time = System.currentTimeMillis();\n\t\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\tout = new PrintWriter(System.out);\n\t\tscn = new FastReader(oj);\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!oj) {\n\t\t\tSystem.out.println(Arrays.deepToString(new Object[] { System.currentTimeMillis() - time + \" ms\" }));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new A(), \"Main\", 1 << 26).start();\n\t}\n\n\tclass FastReader {\n\t\tInputStream is;\n\n\t\tpublic FastReader(boolean onlineJudge) {\n\t\t\tis = onlineJudge ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\t}\n\n\t\tbyte[] inbuf = new byte[1024];\n\t\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\t\tint readByte() {\n\t\t\tif (lenbuf == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (ptrbuf >= lenbuf) {\n\t\t\t\tptrbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn inbuf[ptrbuf++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tint skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t\t;\n\t\t\treturn b;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\treturn (char) skip();\n\t\t}\n\n\t\tString next() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile ((!isSpaceChar(b) || b == ' ')) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tchar[] next(int n) {\n\t\t\tchar[] buf = new char[n];\n\t\t\tint b = skip(), p = 0;\n\t\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t\t}\n\n\t\tint nextInt() {\n\t\t\tint num = 0, b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tchar[][] nextMatrix(int n, int m) {\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next(m);\n\t\t\treturn map;\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] next2DInt(int n, int m) {\n\t\t\tint[][] arr = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[][] next2DLong(int n, int m) {\n\t\t\tlong[][] arr = new long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] shuffle(int[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tint c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] shuffle(long[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tlong c = arr[i];\n\t\t\t\tarr[i] = arr[j];\n\t\t\t\tarr[j] = c;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] uniq(int[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tint[] rv = new int[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tlong[] uniq(long[] arr) {\n\t\t\tarr = scn.shuffle(arr);\n\t\t\tArrays.sort(arr);\n\t\t\tlong[] rv = new long[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\n\t\tint[] reverse(int[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] reverse(long[] arr) {\n\t\t\tint l = 0, r = arr.length - 1;\n\t\t\twhile (l < r) {\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tarr[r] = arr[l] ^ arr[r];\n\t\t\t\tarr[l] = arr[l] ^ arr[r];\n\t\t\t\tl++;\n\t\t\t\tr--;\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] compress(int[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tint[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[] compress(long[] arr) {\n\t\t\tint n = arr.length;\n\t\t\tlong[] rv = Arrays.copyOf(arr, n);\n\t\t\trv = uniq(rv);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Arrays.binarySearch(rv, arr[i]);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t}\n}", "label": 2}
{"src": "import java.util.Scanner;\n\npublic class Codeforce_A_FromHerotoZero {\n    private static final Scanner SCANNER = new Scanner(System.in);\n\n    public static void main(String args[]) {\n\n        int queries = SCANNER.nextInt();\n\n        for (int k = 0; k < queries; k++) {\n\n            long integer_input = SCANNER.nextLong();\n            long divisor = SCANNER.nextLong();\n\n            long step = 0;\n            long input = integer_input / divisor;\n\n            if(integer_input < divisor){\n                step = integer_input;\n            }\n            else{\n                step = Calculate(integer_input, divisor, step);\n            }\n\n            System.out.printf(\"%d\\n\",step);\n        }\n\n        SCANNER.close();\n    }\n\n    public static long Calculate(long integer_input, long divisor, long step) {\n        long remainder =(long) Math.floor(integer_input % divisor);\n\n        integer_input -= remainder;\n        step += remainder;\n\n        if (integer_input == 0) {\n            return step;\n        }\n\n        integer_input = (long) integer_input / divisor;\n        step += 1;\n\n        return Calculate(integer_input, divisor, step);\n    }\n}\n\n// do a thing once for all not to separate ; recursive faster than for at the cost of memory", "label": 2}
{"src": "//@author Haya\nimport java.util.Scanner;\npublic class FromHeroToZero { \n    public static void main(String[] args) {\n        Scanner sc= new Scanner (System.in);\n        int t= sc.nextInt(); \n        long n, k, count=0;\n        for (int i = 0; i < t; i++){\n            count=0;\n            n= sc.nextLong();\n            k= sc.nextLong();\n            while(n>0){\n                if (n%k==0){\n                    n/=k;\n                    count++;}\n                else{\n                    count+=(n % k);\n                    n-=(n % k);}}\n        \n        System.out.println(count);}\n    }   \n}", "label": 2}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n        int t = sc.nextInt();\n        Long n,k;\n        while (t > 0) {\n            n = sc.nextLong();\n            k = sc.nextLong();\n            out.println(pathToZero(n,k));\n            t--;\n        }\n\n        out.close();\n    }\n\n    public static Long pathToZero(Long n, Long k) {\n        Long toZero = n;\n        Long result = 0L;\n        while (toZero > 0) {\n            Long mod = toZero % k;\n            if (mod == 0) {\n                toZero = toZero/k;\n                result++;\n            } else {\n                toZero -= mod;\n                result += mod;\n            }\n\n        }\n        return result;\n    }\n}\n", "label": 2}
{"src": "import java.util.Scanner;\n\npublic class FromHeroToZero {\n\n  public static void main(String[] args) {\n    Scanner myScanner = new Scanner(System.in);\n    int iNumQueries = myScanner.nextInt();\n    long[] aMinSteps = new long[iNumQueries];\n\n    for(int i = 0; i < iNumQueries; i++) {\n      long n = myScanner.nextLong();\n      long k = myScanner.nextLong();\n      long lNumberOfSteps = 0;\n      while(n != 0) {\n        if(n % k == 0) {\n          n /= k;\n          lNumberOfSteps++;\n        }\n        else {\n          //-- In order to prevent having to subtract 1's O(n) times,\n          //-- we calculate the number of one to be subtracted in order\n          //-- to reach the next divisor of k\n          long lDistanceToNextDivisorOfK = n % k;\n          n -= lDistanceToNextDivisorOfK;\n          lNumberOfSteps += lDistanceToNextDivisorOfK;\n        }\n      }\n      aMinSteps[i] = lNumberOfSteps;\n    }\n    for(int i = 0; i < aMinSteps.length; i++) {\n      System.out.println(aMinSteps[i]);\n    }\n  }\n}\n", "label": 2}
{"src": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class FromZeroToHero {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int t = s.nextInt();\n        for(int i = 0; i < t; i++) {\n            BigInteger n = s.nextBigInteger();\n            BigInteger k = s.nextBigInteger();\n            BigInteger br = BigInteger.valueOf(0);\n            while(n.compareTo(BigInteger.valueOf(0)) != 0) {\n                if(n.mod(k).compareTo(BigInteger.valueOf(0)) == 0) {\n                    n = n.divide(k);\n                    br = br.add(BigInteger.valueOf(1));\n                }\n                else {\n                    BigInteger m = n.mod(k);\n                    n = n.subtract(m);\n                    br = br.add(m);\n                }\n            }\n            System.out.println(br);\n        }\n    }\n}\n", "label": 2}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n\tpublic static void main(String[] args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tlong T=0;\n\t\tif(s.hasNextInt()){\n\t\t    T = s.nextInt();\n\t\t}\n\t\tfor(int i=0;i<T;i++){\n\t\t    long N=0,k=0,count=0;\n\t\t    if(s.hasNextLong()){\n\t\t        N = s.nextLong();\n\t\t    }\n\t\t    if(s.hasNextLong()){\n\t\t        k = s.nextLong();\n\t\t    }\n\t\t    while(true){\n\t\t        if(N==0){\n\t\t            break;\n\t\t        }\n\t\t        else if(N%k==0){\n\t\t            count++;\n\t\t            N=N/k;\n\t\t        }\n\t\t        else{\n\t\t            count = count + N%k;\n\t\t            N = N - N%k;\n\t\t        }\n\t\t    }\n\t\t    System.out.println(count);\n\t\t    \n\t\t}\n\t\t\n\t\treturn;\n\t\t\n\t}\n}\n", "label": 2}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        FastScanner fs = new FastScanner();\n\n        int T = fs.nextInt();\n        for (int t = 0; t < T; t++) {\n\n            long n = fs.nextLong();\n            long k = fs.nextLong();\n            long ans = 0;\n\n            while (n != 0) {\n                if (n % k == 0) {\n                    ++ans;\n                    n /= k;\n                } else {\n                    ans += n % k;\n                    n -= n % k;\n                }\n            }\n\n            System.out.println(ans);\n\n\n            // end test cases\n        }\n\n        // end main\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() { return Integer.parseInt(next()); }\n\n        long nextLong() { return Long.parseLong(next()); }\n\n        double nextDouble() { return Double.parseDouble(next()); }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "label": 2}
{"src": "\nimport java.util.Scanner;\n \npublic class Main\n{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint i=sc.nextInt();\n\t\t \n\t\tlong x,count=0;\n\t\tfor (int t=0;t<i ;t++ )\n\t\t{\n\t\t    count=0;\n\t\t    long n=sc.nextLong();\n\t\t    long k=sc.nextLong();\n\t\t    while(n!=0){\n\t\t        \n\t\t    if(n%k==0){n=n/k;count++;}else{if(n<k){count+=n;n=0;break;}else{ x=n%k;n=n-x;count=count+x;}\n\t\t       }\n\t\t    }\n\t\t    System.out.println(count);\n\t\t    \n\t\t}\n\t}\n}", "label": 2}
{"src": "import java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int nQueries = scanner.nextInt();\n\n        for (int i=0; i < nQueries; i++) {\n            BigInteger n = scanner.nextBigInteger();\n            BigInteger k = scanner.nextBigInteger();\n\n            BigInteger it = n;\n            BigInteger nSteps = new BigInteger(\"0\");\n            BigInteger threshold = new BigInteger(\"0\");\n            while (!it.equals(threshold)) {\n                if (it.mod(k).equals(threshold)) {\n                    it = it.divide(k) ;\n                    nSteps = nSteps.add(new BigInteger(\"1\"));\n                } else {\n                    BigInteger rest = it.mod(k);\n                    it = it.subtract(rest);\n                    nSteps = nSteps.add(rest);\n                }\n            }\n            System.out.println(nSteps);\n        }\n\n    }\n}\n", "label": 2}
{"src": "import java.util.*;\n\npublic class Solution {\n    static HashMap<Character, Integer> in;\n\n    static boolean add(char a, char b, char c) {\n        return (in.get(a) + in.get(b) + in.get(c)) == 7;\n    }\n\n    static public void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int s = sc.nextInt();\n        while (s-- != 0) {\n            long src = sc.nextLong();\n            long d = sc.nextLong();\n            long c = 0;\n            while (src != 0) {\n                long r = src % d;\n                c += r;\n                if ((src - r) == 0) {\n                    break;\n                }\n                src = (src - r) / d;\n                c++;\n            }\n            System.out.println(c);\n        }\n        sc.close();\n    }\n}", "label": 2}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        APutKNulyu solver = new APutKNulyu();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class APutKNulyu {\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int tt = in.nextInt();\n            for (int t = 0; t < tt; t++) {\n                long n = in.nextLong();\n                long k = in.nextLong();\n                long ans = 0;\n                while (n != 0) {\n                    long mod = n % k;\n                    if (mod != 0) {\n                        ans += mod;\n                    }\n                    n -= mod;\n                    if (n > 0) {\n                        n /= k;\n                        ans++;\n                    }\n                }\n                out.println(ans);\n            }\n        }\n    }\n\n    static class InputReader {\n\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n\n", "label": 2}
{"src": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Main<a> {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    public static void main(String[] args) {\n        FastReader scan = new FastReader();\n\n        int t = scan.nextInt();\n\n        while(t--> 0) {\n            long n = scan.nextLong();\n            long k = scan.nextLong();\n\n            long cnt = 0;\n\n            while(n > 0) {\n                if(n / k == 0) {\n                    cnt += n;\n                    break;\n                }\n                if(n % k == 0) {\n                    n /= k;\n                    cnt++;\n                }\n                else {\n                    cnt += n%k;\n                    n -= n%k;\n                }\n            }\n\n            System.out.println(cnt);\n        }\n\n    }\n\n    // Function to sort by column\n    public static void sortbyColumn(int arr[][], int col)\n    {\n        // Using built-in sort function Arrays.sort\n        Arrays.sort(arr, new Comparator<int[]>() {\n\n            @Override\n            // Compare values according to columns\n            public int compare(final int[] entry1,\n                               final int[] entry2) {\n\n                // To sort in descending order revert\n                // the '>' Operator\n                if (entry1[col] > entry2[col])\n                    return 1;\n                else\n                    return -1;\n            }\n        });  // End of function call sort().\n    }\n\n    // Merge sort\n    public static void merge(int arr[], int l, int m, int r) {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        /* Create temp arrays */\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n\n        /*Copy data to temp arrays*/\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        /* Merge the temp arrays */\n\n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n\n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        /* Copy remaining elements of L[] if any */\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        /* Copy remaining elements of R[] if any */\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    // Main function that sorts arr[l..r] using\n    // merge()\n    public static void sort(int arr[], int l, int r) {\n        if (l < r) {\n            // Find the middle point\n            int m = (l + r) / 2;\n\n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n    // Merge sort ends\n\n}", "label": 2}
{"src": "import java.util.Scanner;\n\npublic class ZeroToHero2 {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int t = scanner.nextInt();\n        for (int c = 0; c < t; c++) {\n            long n = scanner.nextLong();\n            long k = scanner.nextLong();\n            long amt = -1;\n            for (long nTemp = n; nTemp > 0; nTemp /= k, amt++);\n            while (n > 0) {\n                amt += n % k;\n                n /= k;\n            }\n            System.out.println(amt);\n        }\n    }\n}\n", "label": 2}
{"src": "import java.util.*;\npublic class fromHeroToZero {\n\n\tpublic static long getAns(long n,long k) {\n\t\t\n\t\tlong ans=0;\n\t\t\n\t\twhile(n>0) {\n\t\t\n\t\twhile(n!=0 && n%k!=0) {\n\t\t\tans+=(n%k);\n\t\t\tn-=(n%k);\n\t\t}\n\t\t\n\t\twhile(n!=0 && n%k==0)\n\t\t{\n\t\t\tans++;\n\t\t\tn=n/k;\n\t\t}\n\t\t\n\t\t}\n\t\t\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner s=new Scanner(System.in);\n\t\t\n\t\tlong t=s.nextLong();\n\t\t\n\t\twhile(t!=0) {\n\t\t\n\t\tlong n=s.nextLong();\n\t\tlong k=s.nextLong();\n\t\t\n\t\tlong ans=getAns(n,k);\n\t\t\n\t\tSystem.out.println(ans);\n\t\t\n\t\tt--;\n\t\t}\n\t}\n\n}\n", "label": 2}
{"src": "import java.io.*;\nimport java.util.Arrays;\npublic class Main {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tint n;\n\t\tlong l=0,r=0,m=0,k=0;;\n\t\tn=Integer.parseInt(br.readLine());\n\t\tlong arr[]=new long[2];\n\t\twhile(n>0) {\n\t\t\tarr=Arrays.stream(br.readLine().split(\" \")).mapToLong(Long::parseLong).toArray();\n\t\t\tl=arr[0];\n\t\t\tr=arr[1];\n\t\t\tm=0;\n\t\t\twhile(l>0) {\n\t\t\t\tif(l%r==0) {\n\t\t\t\t\tl=l/r;\n\t\t\t\t\tm++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tk=l%r;\n\t\t\t\t\tl-=k;\n\t\t\t\t\tm+=k;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\n\t\t\t}\n\t\t\tSystem.out.println(m);\n\t\t\tn--;\n\t\t}\n\n}\n}", "label": 2}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class ER66A {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint t = in.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tlong ans = 0, n = in.nextLong(), k = in.nextLong();\n\t\t\twhile (n > 0) {\n\t\t\t\tans += n % k;\n\t\t\t\tn -= (n % k);\n\t\t\t\tif (n > 0) {\n\t\t\t\t\tn /= k;\n\t\t\t\t\tans++;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}", "label": 2}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\npublic class GFG770 {\n    static int mod1 = (int) (1e9 + 7);\n    static LinkedList<Integer>[] linkedLists;\n    static int count1=0;\n    static int[] visited;\n    static class Reader {\n        final private int BUFFER_SIZE = 1 << 16;\n        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String nextString() throws IOException {\n            String str00 = scan.next();\n            return str00;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        String next() throws IOException {\n            int c;\n            for (c = read(); c <= 32; c = read());\n            StringBuilder sb = new StringBuilder();\n            for (; c > 32; c = read()) {\n                sb.append((char) c);\n            }\n            return sb.toString();\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null)\n                return;\n            din.close();\n        }\n\n        public int[] nextArray(int n) throws IOException {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n    }\n\n\n    static int GCD(int a, int b) {\n        BigInteger big1 = new BigInteger(String.valueOf(a));\n        BigInteger big2 = new BigInteger(String.valueOf(b));\n        big1 = big1.gcd(big2);\n        return Integer.parseInt(big1.toString());\n    }\n\n\n    static long power(long x, long y, long p)\n    {\n        long res = 1;      // Initialize result\n\n        x = x % p;  // Update x if it is more than or\n        // equal to p\n\n        while (y > 0)\n        {\n            // If y is odd, multiply x with result\n            if (y%2!=0)\n                res = (res*x) % p;\n\n            // y must be even now\n            y = y>>1; // y = y/2\n            x = (x*x) % p;\n        }\n        return res;\n    }\n\n\n    static boolean primeCheck(long num0) {\n        boolean b1 = true;\n        if (num0 == 1) {\n            b1 = false;\n        } else {\n            int num01 = (int) (Math.sqrt(num0)) + 1;\n            me1:\n            for (int i = 2; i < num01; i++) {\n                if (num0 % i == 0) {\n                    b1 = false;\n                    break me1;\n                }\n            }\n        }\n        return b1;\n    }\n\n    public static int dev(long num1)\n    {\n        int count00=0;\n        while (num1%2==0)\n        {\n            count00++;\n            num1/=2;\n        }\n        HashMap<Long,Long> hashMap=new HashMap<>();\n        if(count00!=0)\n        {\n            hashMap.put(2L,(long)count00);\n        }\n        for (int i = 3; i <= (int)Math.sqrt(num1); i = i + 2)\n        {\n            // While i divides n, print i and divide n\n            if(num1%i==0) {\n                int count01 = 0;\n\n                while (num1 % i == 0) {\n                    num1 /= i;\n                    count01++;\n                }\n                hashMap.put((long)i,(long)count01);\n            }\n        }\n        if(num1>2)\n        {\n            hashMap.put((long)num1,1L);\n        }\n        long numOfDiv=1;\n        for(long num00:hashMap.keySet())\n        {\n            long cDiv0=hashMap.get(num00);\n            numOfDiv*=(cDiv0+1);\n        }\n\n        return (int)(numOfDiv);\n    }\n\n    static void dfs(int index)\n    {\n        visited[index]=1;\n        count1++;\n\n        for(int num00:linkedLists[index])\n        {\n            if(visited[num00]==0)\n            {\n                dfs(num00);\n            }\n        }\n    }\n\n\n    public static void main(String[] args) throws IOException {\n        //Reader r = new Reader();\n        //PrintWriter writer=new PrintWriter(System.out);\n        //Scanner r = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        Scanner r=new Scanner(System.in);\n        OutputWriter770 out77 = new OutputWriter770(System.out);\n\n        int cas1=r.nextInt();\n        while(cas1-->0)\n        {\n            long num1 = r.nextLong();\n            long num2=r.nextLong();\n\n            long res1=0;\n            while(num1!=0)\n            {\n                if(num1%num2==0)\n                {\n                    res1++;\n                    num1/=num2;\n                }\n                else\n                {\n                    res1+=(num1%num2);\n                    num1-=(num1%num2);\n                }\n            }\n            out77.print(res1+\"\\n\");\n        }\n\n        r.close();\n        out77.close();\n    }\n}\n\nclass OutputWriter770\n{\n    BufferedWriter writer;\n\n    public OutputWriter770(OutputStream stream)\n    {\n        writer = new BufferedWriter(new OutputStreamWriter(stream));\n    }\n    public void print(int i) throws IOException\n    {\n        writer.write(i + \"\");\n    }\n\n    public void println(int i) throws IOException\n    {\n        writer.write(i + \"\\n\");\n    }\n\n    public void print(String s) throws IOException\n    {\n        writer.write(s + \"\");\n    }\n\n    public void println(String s) throws IOException\n    {\n        writer.write(s + \"\\n\");\n    }\n\n    public void print(char[] c) throws IOException\n    {\n        writer.write(c);\n    }\n\n    public void close() throws IOException\n    {\n        writer.flush();\n        writer.close();\n    }\n}\n\nclass NodeInfo\n{\n    int i,j;\n    NodeInfo(int i,int j)\n    {\n        this.i=i;\n        this.j=j;\n    }\n}", "label": 2}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n *  @author Ivan Pryvalov (ivan.pryvalov@gmail.com)\n */\npublic class CF_ER66_Div2_A implements Runnable {\n\n    static EventType eventType = EventType.DEFAULT; //EventType.GOOGLE_CODE_JAM;\n    static boolean interactive = false; //use outGlobal.println()   and   outGlobal.flush()\n    static int T = 0; // T \\in {0,1}. If T=0, it will be read from the input.\n    static String inputFilename = null; // if 'null', it reads data from std-in.\n\n    static boolean largeFakeTest = false; // Check if you generate data on fly\n    static int largeFakeTest_T = 1;\n    //--------------------------------------------------------------------\n\n\n\n    static class Data{\n        BigInteger val;\n        int steps;\n\n        public Data(BigInteger val, int steps) {\n            this.val = val;\n            this.steps = steps;\n        }\n    }\n\n    public static class Solver extends  SolverAbstract{\n\n        long N, K;\n\n        @Override\n        public void readInput() throws IOException {\n            N = scanner.nextLong();\n            K = scanner.nextLong();\n        }\n\n        @Override\n        protected void solve() throws IOException {\n            long steps = 0;\n\n            long A = N;\n            while(A>=K){\n                long Anext = A / K;\n                long A1 = Anext * K;\n                long diff = A - A1;\n                steps += diff + 1;\n                A = Anext;\n            }\n            out.println(steps+A);\n        }\n\n    }\n\n    private long gcd(long a, long b){\n        if (a>b){\n        }\n        return gcd(a%b, b);\n    }\n\n    //--------------------------------------------------------------------\n\n    private void solveAll() throws IOException {\n        long timeStart = System.currentTimeMillis();\n        if (T==0) {\n            if (largeFakeTest) {\n                T = largeFakeTest_T;\n            } else {\n                T = scanner.nextInt();\n            }\n        }\n        final String[] results = new String[T+1];\n        for (int test = 0; test < T; test++) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            PrintStream outLocal = new PrintStream(baos);\n            Solver solver = new Solver(){\n                @Override\n                public void callback() {\n                    results[testNo] = answer;\n                }\n            };\n            solver.out = outLocal;\n            solver.testNo = test+1;\n            if (largeFakeTest) {\n                solver.readFakeInput();\n            }else{\n                solver.readInput();\n            }\n            solver.solveWrapped(baos);\n        }\n\n        long timeEnd = System.currentTimeMillis();\n        if (isInputFromFile())\n            System.out.println(\"All tasks are solved! Elapsed time \"+(timeEnd-timeStart)/1000.0+\" sec.\");\n\n        // write all responses in the proper order\n        if (!interactive) {\n            for (int i = 1; i <= T; i++) {\n                if (eventType == EventType.GOOGLE_CODE_JAM) {\n                    outGlobal.printf(\"Case #%d: %s\", i, results[i]);\n                } else {\n                    outGlobal.print(results[i]);\n                }\n            }\n        }\n    }\n\n    enum EventType{\n        DEFAULT,\n        GOOGLE_CODE_JAM  // Case #1: RES\n    }\n\n    static boolean isInputFromFile() {\n        return inputFilename != null;\n    }\n\n    public static abstract class SolverAbstract {\n        PrintStream out;\n        int testNo;\n        String answer = null;\n\n        public void callback(){};\n\n        public abstract void readInput() throws IOException;\n\n        //generate a randomized test with the maximal input values\n        public void readFakeInput() throws  IOException{\n            throw new RuntimeException(\"not implemented\");\n        }\n\n        protected abstract void solve() throws IOException;\n\n        protected void solveWrapped(ByteArrayOutputStream baos) throws IOException {\n            if (isInputFromFile())\n                System.out.println(\"SOLVER: solving task #\"+testNo+\" out of \"+ T+\"...\");\n            solve();\n            answer = baos.toString();\n            if (isInputFromFile()) {\n                System.out.println(\"\\t\"+answer);\n            }\n            callback();\n        }\n    }\n\n    ////////////////////////////////////////////////////////\n    // Link about multithreading: http://stackoverflow.com/questions/4521983/java-executorservice-that-blocks-on-submission-after-a-certain-queue-size\n\n\n    // ------------- Some stardard tools that are currently not tested.\n    //adopt for the lists of adjacent vertices\n    static class Graph{\n\n        int[][] G;\n        int N;\n\n        int[][] A;\n        int[][] F;\n\n        int[] path;\n        int pathLen;\n        boolean[] visited;\n        int target;\n        boolean flowFound;\n\n        public Graph(int[][] g) {\n            G = g;\n            N = G.length;\n        }\n\n        public int[][] maxflow(int iSource, int iSink) {\n            path = new int[N];\n            visited = new boolean[N];\n\n            A = new int[N][];\n            for (int i = 0; i < N; i++) {\n                A[i] = G[i].clone();\n            }\n            F = new int[N][N];\n\n            target = iSink;\n            //dfs from source to sink\n            //increase path\n            while(true){\n                flowFound = false;\n                visited[iSource] = true;\n                pathLen = 0;\n                path[pathLen++] = iSource;\n                dfs(iSource);\n                if (!flowFound)\n                    break;\n            }\n            return F;\n        }\n\n        private void dfs(int u) {\n            if (u==target){\n                flowFound = true;\n                for (int i = 0; i < pathLen-1; i++) {\n                    int from = path[i];\n                    int to  = path[i+1];\n                    F[from][to]++;\n                    F[to][from]--;\n                }\n            }else {\n                for (int i = 0; i < N && !flowFound; i++) {\n                    if (!visited[i] && A[u][i] > F[u][i]) {\n                        visited[i] = true;\n                        path[pathLen] = i;\n                        pathLen++;\n                        dfs(i);\n                        visited[i] = false;\n                        pathLen--;\n                    }\n                }\n            }\n        }\n    }\n\n    public static class Utilities{\n        public static List<Integer> getPrimes(int limit) {\n            boolean[] primes = new boolean[limit+1];\n            Arrays.fill(primes, true);\n\n            primes[1] = false;\n            for(int i=2; i<=limit; i++){\n                if (primes[i]){\n                    for(int j=i+i; j<=limit; j+=i){\n                        primes[j] = false;\n                    }\n                }\n            }\n            List<Integer> listPrimes = new ArrayList<>();\n            for(int i=2; i<=limit; i++){\n                if (primes[i]){\n                    listPrimes.add(i);\n                }\n            }\n            return listPrimes;\n        }\n    }\n\n    public static class Modulo{\n        long mod = (long)1e9+7;\n\n        public Modulo(long mod) {\n            super();\n            this.mod = mod;\n        }\n\n        public long inv(long a) {\n            long res =  pow(a, mod-2);\n            return res;\n        }\n\n        public long pow(long a, long x) {\n            if (x==0)\n                return 1;\n            long part = 1;\n            if ((x&1)!=0)\n                part = a;\n            return (part * pow((a*a)%mod, x>>1)) % mod;\n        }\n\n        public long c(long n, long m){\n            long res = 1;\n            for(int i=1; i<=m; i++){\n                res = (res * (n-m+i)) % mod;\n                res = (res * inv(i)) % mod;\n            }\n            return res;\n        }\n    }\n\n    /**\n     * Added 26.04.2013.\n     * See KROK 2013, Round 1, Problem D.\n     */\n    static class DisjointUnionSet implements Cloneable{\n        int[] rank;\n        int[] parent;\n\n        protected DisjointUnionSet clone(){\n            DisjointUnionSet cloned = new DisjointUnionSet(parent.length);\n            for(int i=0; i<parent.length; i++){\n                cloned.parent[i] = parent[i];\n                cloned.rank[i] = rank[i];\n            }\n            return cloned;\n        }\n\n        public DisjointUnionSet(int n) {\n            rank = new int[n];\n            parent = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n            }\n        }\n\n        @Override\n        public String toString() {\n            return \"disj [parents=\" + Arrays.toString(parent) + \"]\";\n        }\n\n        /**\n         * Problem specific or general?\n         * O(N * alpha)\n         */\n        public void union(DisjointUnionSet set2){\n            for(int i=0; i<parent.length; i++){\n                parent[find(i)] = parent[find(set2.find(i))];\n            }\n        }\n\n        /**\n         * @param index1 range 0..n-1\n         * @param index2\n         */\n        public void union(int index1, int index2){\n            int p1 = find(index1);\n            int p2 = find(index2);\n            if (rank[p1] > rank[p2]){\n                parent[p2] = p1;\n            }else if (rank[p2] > rank[p1]){\n                parent[p1] = p2;\n            }else{\n                parent[p2] = p1;\n                rank[p1]++;\n            }\n        }\n\n        // O(alpha(n))\n        private int find(int index) {\n            if (parent[index] != index)\n                parent[index] =  find(parent[index]);\n            return parent[index];\n        }\n\n        // O(N alpha(N)) ==> see find()\n        public int getCountDisjointSets(){\n            int[] used = new int[parent.length];\n            for(int i=0; i<parent.length; i++){\n                used[find(i)] = 1;\n            }\n            int res = 0;\n            for(int i=0; i<parent.length; i++){\n                res += used[i];\n            }\n            return res;\n        }\n    }\n\n    private static Random rnd = new Random();\n    public static class ArrayUtils{\n        public static void shuffle(int[] a){\n            for(int j=a.length-1; j>=1; j--){\n                int i = rnd.nextInt(j+1);\n                swap(a, i, j);\n            }\n        }\n\n        public static void swap(int[] a, int i, int j){\n            int tmp = a[i];\n            a[i] = a[j];\n            a[j] = tmp;\n        }\n    }\n\n    static class GraphSupport{\n        /*\n        //Added 20.02.2017.\n        //See Codeforces Round 398, Div.2, C.\n        // Recoursive call to dfs function may result in either MTL or StackOverflow.\n        // Codeforces provide stacksize 64M\n\n        private void dfs_no_recursion(int root, IntConsumer dfs_post){\n            int[] stack = new int[N];\n            int[] stackInt = new int[N];\n            int iStack = 0;\n            stack[iStack] = root;\n            stackInt[iStack++] = 0;\n            while(true){\n                Node node = nodes[stack[iStack-1]];\n                int childIdx = stackInt[iStack-1];\n                if (childIdx < node.children.size()){\n                    stack[iStack] = node.children.get(childIdx).idx;\n                    stackInt[iStack++] = 0;\n                }else{\n                    dfs_post.accept(node.idx);\n\n                    iStack--;\n                    if (iStack==0){\n                        break;\n                    }\n                    stackInt[iStack-1]++;\n                }\n            }\n        }\n        */\n    }\n\n\n    ////////////////////////////////////////////////////////\n    /// Typically, you don't want to edit anything below\n    ///////////////////////////////////////////////////////\n    final int BUF_SIZE = 1024 * 1024 * 8;//important to read long-string tokens properly\n    final int INPUT_BUFFER_SIZE = 1024 * 1024 * 8;\n    final int BUF_SIZE_INPUT = 1024;\n\n    boolean useClassResourceTopDir = true;\n    String outSuffix = \".out\";\n\n    static PrintStream outGlobal;\n    static ByteScanner scanner;\n\n    public void run() {\n        try{\n            InputStream bis;\n            OutputStream bos;\n            if (inputFilename !=null){\n                File inputFile;\n                File outputFile;\n                if (useClassResourceTopDir) {\n                    File baseFile = new File(getClass().getResource(\"/\").getFile());\n                    inputFile = new File(baseFile, inputFilename);\n                    outputFile = new File(baseFile, inputFilename +outSuffix);\n                }else{\n                    inputFile = new File(inputFilename);\n                    outputFile = new File(inputFilename +outSuffix);\n                }\n                System.out.println(\"Input file canonical path: \"+inputFile.getCanonicalPath());\n                bis = new BufferedInputStream(\n                        new FileInputStream(inputFile),\n                        INPUT_BUFFER_SIZE);\n                bos = new BufferedOutputStream(new FileOutputStream(outputFile));\n                outGlobal = new PrintStream(bos);\n            }else{\n                bis = new BufferedInputStream(System.in, INPUT_BUFFER_SIZE);\n                bos = new BufferedOutputStream(System.out);\n                outGlobal = new PrintStream(bos);\n            }\n            scanner = new ByteScanner(bis, BUF_SIZE_INPUT, BUF_SIZE);\n\n            solveAll();\n            outGlobal.flush();\n        }catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    public static class EofException extends IOException{\n    }\n\n    public static class ByteScanner{\n        InputStream is;\n\n        public ByteScanner(InputStream is, int bufSizeInput, int bufSize){\n            this.is = is;\n            this.bufSizeInput = bufSizeInput;\n            this.bufSize = bufSize;\n\n            byteBufInput = new byte[this.bufSizeInput];\n            byteBuf = new byte[this.bufSize];\n        }\n\n        public ByteScanner(byte[] data){\n            byteBufInput = data;\n            bufSizeInput = data.length;\n            bufSize = data.length;\n            byteBuf = new byte[bufSize];\n            byteRead = data.length;\n            bytePos = 0;\n        }\n\n        private int bufSizeInput;\n        private int bufSize;\n\n        byte[] byteBufInput;\n        byte by=-1;\n        int byteRead=-1;\n        int bytePos=-1;\n\n        byte[] byteBuf;\n        int totalBytes;\n\n        boolean eofMet = false;\n\n        private byte nextByte() throws IOException{\n            if (bytePos<0 || bytePos>=byteRead){\n                byteRead = is==null? -1: is.read(byteBufInput);\n                bytePos=0;\n                if (byteRead<0){\n                    byteBufInput[bytePos]=-1;//!!!\n                    if (eofMet)\n                        throw new EofException();\n                    eofMet = true;\n                }\n            }\n            return byteBufInput[bytePos++];\n        }\n\n        public byte nextVisibleChar() throws IOException{\n            while ((by=nextByte())<=0x20);\n            return by;\n        }\n\n        public String nextLine() throws IOException {\n            readToken((byte)0x20);\n            return new String(byteBuf,0,totalBytes);\n        }\n\n        // Reads token. Spacebar is separator char.\n        public String nextToken() throws IOException {\n            readToken((byte)0x21);\n            return new String(byteBuf,0,totalBytes);\n        }\n\n        // Spacebar is included as separator char\n        private void readToken() throws IOException {\n            readToken((byte)0x21);\n        }\n\n        private void readToken(byte acceptFrom) throws IOException {\n            totalBytes = 0;\n            while ((by=nextByte())<acceptFrom);\n            byteBuf[totalBytes++] = by;\n            while ((by=nextByte())>=acceptFrom){\n                byteBuf[totalBytes++] = by;\n            }\n        }\n\n        public int nextInt() throws IOException{\n            readToken();\n            int num=0, i=0;\n            boolean sign=false;\n            if (byteBuf[i]=='-'){\n                sign = true;\n                i++;\n            }\n            for (; i<totalBytes; i++){\n                num*=10;\n                num+=byteBuf[i]-'0';\n            }\n            return sign?-num:num;\n        }\n\n        public long nextLong() throws IOException{\n            readToken();\n            long num=0;\n            int i=0;\n            boolean sign=false;\n            if (byteBuf[i]=='-'){\n                sign = true;\n                i++;\n            }\n            for (; i<totalBytes; i++){\n                num*=10;\n                num+=byteBuf[i]-'0';\n            }\n            return sign?-num:num;\n        }\n\n        public double nextDouble() throws IOException{\n            readToken();\n            char[] token = new char[totalBytes];\n            for (int i = 0; i < totalBytes; i++) {\n                token[i] = (char)byteBuf[i];\n            }\n            return Double.parseDouble(new String(token));\n        }\n\n        public int[] loadIntArray(int size) throws IOException{\n            int[] a = new int[size];\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        public long[] loadLongArray(int size) throws IOException{\n            long[] a = new long[size];\n            for (int i = 0; i < a.length; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n    }\n\n    public static void main(String[] args) {\n        new CF_ER66_Div2_A().run();\n    }\n}", "label": 2}
{"src": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st = new StringTokenizer(\"\");\n    PrintWriter pw = new PrintWriter(System.out);\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    String next() throws IOException {\n        if (!st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n\n    void run() throws IOException {\n        int t;\n        t = nextInt();\n        for (int i = 0; i < t; i++) {\n            long a = nextLong();\n            long b = nextLong();\n            long ans = 0;\n            while (a != 0) {\n                if (a % b != 0) {\n                    ans += a % b;\n                    a -= a % b;\n                } else {\n                    a /= b;\n                    ans++;\n                }\n            }\n            pw.println(ans);\n        }\n\n        pw.close();\n    }\n}", "label": 2}
{"src": "import java.util.*;\nimport java.io.*;\n/**\n *\n * @author alanl\n */\npublic class Main{\n    static BufferedReader input = new BufferedReader(new InputStreamReader(System.in));\n    static StringTokenizer st;\n    static PrintWriter pr = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    public static void main(String[] args) throws IOException{\n        int t = readInt();\n        while(t-->0){\n            long n = readLong(), k = readLong(), ans = 0;\n            while(n!=0){\n                if(n%k==0){\n                    n/=k;\n                    ans++;\n                }\n                else{\n                    long val = n%k;\n                    n-=val;\n                    ans+=val;\n                }\n            }\n            println(ans);\n        }\n    }\n    static String next () throws IOException {\n        while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(input.readLine().trim());\n        return st.nextToken();\n    }\n    static long readLong () throws IOException {\n        return Long.parseLong(next());\n    }\n    static int readInt () throws IOException {\n        return Integer.parseInt(next());\n    }\n    static double readDouble () throws IOException {\n        return Double.parseDouble(next());\n    }\n    static char readChar () throws IOException {\n        return next().charAt(0);\n    }\n    static String readLine () throws IOException {\n        return input.readLine().trim();\n    }\n    static void print(Object b) {\n        System.out.print(b);\n    }\n    static void println(Object b) {\n        System.out.println(b);\n    }\n    static void println() {\n        System.out.println();\n    }\n}\n", "label": 2}
{"src": "import java.util.*;\npublic class FF\n{\npublic static void main(String[] args) {\nScanner sc=new Scanner(System.in);\nlong t=sc.nextLong();\nwhile(t-->0)\n{\nlong c=0;\nlong n=sc.nextLong();\nlong k=sc.nextLong();\nwhile(n>0)\n{\nif(n%k==0)\n{\nc++;\nn=n/k;\n}\nelse\n{\nlong r=n%k;\nc=c+r;\nn=n-r;\n\n}\n}\nSystem.out.println(c);\n}\n}\n\n\n}\n", "label": 2}
{"src": "\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int length = sc.nextInt();\n        sc.nextLine();\n\n        int textVol = 0;\n        String text = sc.nextLine();\n\n        String[] words = text.split(\" \");\n        int[] wordVol = new int[words.length];\n\n        for (int wordNumber=0; wordNumber < words.length; wordNumber++) {\n            for (int i = 0; i < words[wordNumber].length(); i++) {\n                if (Character.isUpperCase(words[wordNumber].charAt(i))) {\n                    wordVol[wordNumber]++;\n                }\n            }\n        }\n\n        for (int wordVolume : wordVol) {\n            if (wordVolume > textVol) {\n                textVol = wordVolume;\n            }\n        }\n        System.out.println(textVol);\n    }\n}\n", "label": 1}
{"src": "\nimport java.util.*;\n\npublic class Works {\n    public static void main(String[] args){\n        Scanner in = new Scanner(System.in);\n        List<Integer> counts = new ArrayList<>();\n        int n = in.nextInt();\n        int count = 0;\n        int letters = 0;\n        while (n >= 0){\n            String s = in.next();\n            letters=s.length() + 1;\n            count = countVolume(s);\n            counts.add(count);\n            n-=letters;\n        }\n        if (counts.size() == 1) System.out.println(count);\n        else System.out.println(max(counts));\n    }\n\n    private static int max(List<Integer> counts) {\n        int max = 0;\n        for (int i = 0; i < counts.size(); i++) {\n            if (counts.get(i) > max) max = counts.get(i);\n        }\n        return max;\n    }\n\n    private static int countVolume(String s) {\n        int count = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (Character.isUpperCase(s.charAt(i))) count++;\n\n        }\n        return count;\n    }\n}", "label": 1}
{"src": "var a = +readline();\nvar b = readline();\nvar count = 0;\nvar maxCount = 0;\nfor(var i = 0;i <b.length; i++){\n\tif(b[i]>='A' && b[i] <= 'Z'){\n\t\tcount++;\n\t}\n\tif(b[i] == ' '){\n\t\tmaxCount = Math.max(maxCount, count);\n\t\tcount = 0;\n\t}\n}\nmaxCount = Math.max(maxCount, count);\nprint(maxCount);", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class G{\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int max = 0, aux = 0;\n        String dummy = \"\";\n        while(sc.hasNext()){\n            dummy = sc.next();\n            aux = countCapital(dummy);\n            if(aux > max){\n                max = aux; \n            }\n        }\n        System.out.println(max);\n    }\n\n    public static int countCapital(String word){\n        int count = 0;\n        for(int i = 0; i < word.length(); i++){\n            if(Character.isUpperCase(word.charAt(i))){\n                count++;\n            }\n        }\n        return count;\n    }\n}\n\t \t\t  \t \t   \t\t\t \t\t\t \t\t  \t\t\t\t \t", "label": 1}
{"src": "n=readline();\ns=readline().split(\" \");\nans=0;\nfor(i=0; i<s.length; i++){\n    x=0;\n    for(j of s[i]){\n        if(j>='A' && j<='Z') x++;\n    }\n    ans = x>ans?x:ans;\n}\nprint(ans);\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Task {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        sc.nextLine();\n        String s = sc.nextLine();\n        int ans = 0;\n        int cur = 0;\n        for (char c : s.toCharArray()) {\n            if (c == ' ') {\n                ans = StrictMath.max(ans, cur);\n                cur = 0;\n            }\n            if (c >= 'A' && c <= 'Z') {\n                cur++;\n            }\n        }\n        ans = StrictMath.max(ans, cur);\n        System.out.println(ans);\n    }\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\n/**\n * Created by user on 8/12/2017.\n */\npublic class TextVolume {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String n = sc.nextLine();\n        String text = sc.nextLine();\n        String[] words = text.split(\" \");\n        int max_count = 0;\n        for (String word : words) {\n            int count = 0;\n            for (int i = 0; i < word.length(); i++) {\n                if (word.substring(i, i + 1).matches(\"([A-Z])\")) {\n                    count++;\n                }\n            }\n            if (count > max_count) {\n                max_count = count;\n            }\n        }\n        System.out.println(max_count);\n        //while (sc.hasNext()) {\n        //   text = sc.next();\n        //n = text.length();\n\n                /*\n                if (text.contains(space)){\n                     String[] splitText = text.split(space);\n\n                    ArrayList<Integer> subCounts = new ArrayList<>();\n\n                     for (int i = 0; i < splitText.length; i++){\n\n                         for (int a = 0; i < splitText[i].length(); a++){\n                             int subCount = 0;\n                            if ((splitText[i].substring(a, a+1)).matches(\"([A-Z])\")){\n                                subCount++;\n                            }\n                             subCounts.add(subCount);\n                         }\n                     }\n                        Collections.sort(subCounts);\n                        count = subCounts.get(subCounts.size()-1);\n                }else{\n                    for (int i = 0; i < n; i++) {\n                    if ((text.substring(i, i + 1)).matches(\"([A-Z])\"))\n                        count++;\n                }*/\n        // }\n        //System.out.println(count);\n    }\n}\n\n", "label": 1}
{"src": "import java.util.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main\n{\n\n  public static void main(String[] args) throws Exception\n  {\n    long startTime = System.nanoTime();\n    String line=br.readLine();\n    char [] data=br.readLine().toCharArray();\n    int ans=0;\n    int count=0;\n    for(int i=0;i<data.length;i++)\n    {\n        if(Character.isUpperCase(data[i]))\n        {\n            count++;\n        }\n        else if(data[i]==' ')\n        {\n            count=0;\n        }\n        ans=Math.max(ans,count);\n    }\n    out.println(ans);\n    long endTime = System.nanoTime();\n    err.println(\"Execution Time : +\" + (endTime-startTime)/1000000 + \" ms\");\n    exit(0);\n  }\n\n  static class InputReader\n  {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble(){\n           return Double.parseDouble(next());\n        }\n    }\n\n    static void exit(int a)\n    {\n      out.close();\n      err.close();\n      System.exit(a);\n    }\n\n    static InputStream inputStream = System.in;\n    static OutputStream outputStream = System.out;\n    static OutputStream errStream = System.err;\n    static InputReader in = new InputReader(inputStream);\n    static PrintWriter out = new PrintWriter(outputStream);\n    static PrintWriter err = new PrintWriter(errStream);\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class G{\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int length = sc.nextInt();\n        sc.nextLine();\n        String str = sc.nextLine();\n        int max = 0;\n        int counter = 0;\n        for(int i = 0; i < length; i++){\n            if(str.charAt(i) == ' '){\n                max = Math.max(max, counter);\n                counter = 0;\n            }else{\n                if(Character.isUpperCase(str.charAt(i))){\n                    counter++;\n                }\n            }\n        }\n        max = Math.max(max, counter);\n        System.out.println(max);\n    }\n}\n    \t \t      \t \t\t \t\t\t \t \t   \t\t\t", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n = scanner.nextInt();\n        scanner.nextLine();\n\n        String line = scanner.nextLine();\n\n        String[] array = line.split(\" \");\n\n        int[] volume = new int[array.length];\n\n        for (int i = 0; i < array.length; i++) {\n            char[] temp = array[i].toCharArray();\n\n            int k = 0;\n\n            for (int j = 0; j < temp.length; j++) {\n                if (temp[j] == Character.toUpperCase(temp[j]) && String.valueOf(temp[j]) != \" \" ) {\n                    k += 1;\n                }\n            }\n            volume[i] = k;\n\n        }\n\n        int max = volume[0];\n\n        for (int i = 0; i < volume.length; i++) {\n            if (volume[i] > max) {\n                max = volume[i];\n            }\n        }\n\n        System.out.println(max);\n    }\n}", "label": 1}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n/**\n * Built using CHelper plug-in Actual solution is at the top\n */\npublic class Main {\n\tpublic final static double MAX_T = 1000000;\n\tpublic final static double MIN_T = 0;\n\tpublic static int s = 0;\n\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskC {\n\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tArrayList<String>words = new ArrayList<>();\n\t\t\tint volume = 0;\n\t\t\tint charsRead = 0;\n\t\t\twhile(charsRead < n)\n\t\t\t{\n\t\t\t\tString s = in.next();\n\t\t\t\tcharsRead += s.length() +1;\n\t\t\t\twords.add(s);\n\t\t\t}\n\t\t\t\n\t\t\tfor(String s: words)\n\t\t\t{\n\t\t\t\tint currentVolume=  getWordVolume(s);\n\t\t\t\tif (currentVolume>volume)\n\t\t\t\t\tvolume=currentVolume;\n\t\t\t}\n\t\t\t\n\t\t\tout.print(volume);\n\t\t}\n\n\t\tprivate static int getWordVolume(String s)\n\t\t{\n\t\t\tint vol = 0;\n\t\t\tfor(int i=0; i<s.length(); i++)\n\t\t\t{\n\t\t\t\tif(s.charAt(i) >='A' && s.charAt(i)<='Z')\n\t\t\t\t{\n\t\t\t\t\tvol++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn vol;\n\t\t}\n\t\t\n\t\t\n\t}\n\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextFloat() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t}\n}", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class G{\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = Integer.parseInt(sc.nextLine()), i = 0, count = 0, temp = 0;\n        String text = sc.nextLine();         \n        for(i = 0; i < n; i++){            \n            if((int)text.charAt(i) > 64 && (int)text.charAt(i) < 91){                \n                temp++;            \n            }\n            //System.out.println(\"ch: \" + text.charAt(i));\n            if(text.charAt(i) == ' '){                \n                if(temp > count){                    \n                    count = temp;\n                    temp = 0;\n                } else{\n                    temp = 0; \n                }\n            }\n            if(i == n-1){\n                if(temp > count){                    \n                    count = temp;\n                    temp = 0;\n                }\n            }\n        }        \n        System.out.println(count);\n    }\n}\n \t \t \t\t\t  \t\t\t   \t \t \t\t\t \t\t\t  \t", "label": 1}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class Solution {\n\n    public static void solve(InputReader in, PrintWriter out, DebugWriter debug) throws IOException {\n        int n = in.nextInt();\n        String[] arr = in.reader.readLine().split(\" \");\n        int max = 0;\n        for (int i=0; i<arr.length; i++){\n            String s = arr[i];\n            int count = 0;\n            for (int j=0; j<s.length(); j++){\n                if (s.charAt(j) >= 'A' && s.charAt(j) <= 'Z') count++;\n            }\n\n            max = Math.max(max, count);\n        }\n\n        out.print(max);\n    }\n\n    public static void print(DebugWriter debug, int[] a){\n        if (!debug.enable) return;\n        for (int i=0; i<a.length; i++) debug.print(a[i] + \" \");\n        debug.println(\"\");\n    }\n\n    public static final String NAME = \"\";\n\n    public static void main(String[] args) throws IOException{\n        InputReader in;\n        PrintWriter out;\n        DebugWriter debug;\n\n        if (args.length > 0 && args[0].equals(\"file\")) {\n            in = new InputReader(new BufferedReader(new FileReader(\"input.txt\")));\n            out = new PrintWriter(new FileWriter(\"output.txt\"));\n            debug = new DebugWriter(true);\n\n            int sampleNumber = 1;\n            do {\n                String nextSample = \"Sample #\" + sampleNumber++ + \": \";\n                out.println(nextSample);\n                debug.println(nextSample);\n\n                solve(in, out, debug);\n\n                out.println(\"\");\n                debug.println(\"\");\n            } while (in.reader.readLine() != null);\n        } else {\n            if (NAME.length() > 0) {\n                in = new InputReader(new BufferedReader(new FileReader(NAME + \".in\")));\n                out = new PrintWriter(new FileWriter(NAME + \".out\"));\n            } else {\n                in = new InputReader(new BufferedReader(new InputStreamReader(System.in)));\n                out = new PrintWriter(new OutputStreamWriter(System.out));\n            }\n\n            debug = new DebugWriter(false);\n            solve(in, out, debug);\n        }\n\n        in.reader.close();\n        out.close();\n    }\n\n    public static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(BufferedReader reader) {\n            this.reader = reader;\n            tokenizer = null;\n        }\n\n        public String next() throws IOException{\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(reader.readLine());\n            }\n\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() throws IOException{\n            return Integer.parseInt(next());\n        }\n\n        public int[] nextIntArray(int n) throws IOException{\n            int[] array = new int[n];\n            for (int i=0; i<n; i++){\n                array[i] = nextInt();\n            }\n\n            return array;\n        }\n    }\n\n    public static class DebugWriter {\n        public boolean enable;\n\n        public DebugWriter(boolean enable){\n            this.enable = enable;\n        }\n\n        public void print(Object o){\n            if (enable) System.out.print(o);\n        }\n\n        public void println(Object o){\n            if (enable) System.out.println(o);\n        }\n    }\n\n}", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class TextVolume {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = Integer.parseInt(in.nextLine());\n\t\tString[] text = in.nextLine().split(\" \");\n\t\tin.close();\n\t\tint sol = 0;\n\t\tfor (String s: text) {\n\t\t\tint c = 0;\n\t\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\t\tif (Character.isUpperCase(s.charAt(i))) c++;\n\t\t\t}\n\t\t\tif (c > sol) sol = c;\n\t\t}\n\t\tSystem.out.println(sol);\n\t}\n\n}\n", "label": 1}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class t {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner scn=new Scanner(System.in);\n\t\tint n=scn.nextInt();\n\t\tscn.nextLine();\n\t\tString s=scn.nextLine();\n\t\tString[] words=s.split(\"\\\\ \");\n\t\tint ans=0,max=0;\n\t\tfor(int i=0;i<words.length;i++){\n\t\t\tmax=0;\n\t\t    for(int j=0;j<words[i].length();j++){\n\t\t        if(words[i].charAt(j)>= 65 && words[i].charAt(j)<= 90  )\n\t\t        \tmax++;\n\t\t    }\n\t\t    if(max>ans)\n\t\t    \tans=max;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class codeforces1 {\n\tpublic static void main(String[] args){\n\t\tint T = 15;\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N;\n\t\tN = sc.nextInt();\n\t\tsc.nextLine();\n\t\tString S = sc.nextLine();\n\t\tScanner my = new Scanner(S);\n\t\t//sc.nextLine();\n\t\tint i = 0;\n\t\tint ctr = 0;\n\t\tint max = 0;\n\t\twhile(i<N){\n\t\t\tif(S.charAt(i)>='A' && S.charAt(i)<='Z'){\n\t\t\t\tctr++;\n\t\t\t}\n\t\t\tif(S.charAt(i)==' ' || i==N-1){\n\t\t\t\tif(max<ctr)\n\t\t\t\t\tmax = ctr;\n\t\t\t\tctr=0;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tSystem.out.println(max);\n\t\tsc.close();\n\t}\n}\n", "label": 1}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n// Meticulous\npublic class A {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\n\t\tBufferedReader br = new BufferedReader ( new InputStreamReader(System.in));\t\t\n\t\tint maxVolume = 0;\n\t\t\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tString s = br.readLine();\n\t\tString [] parts= s.split(\" \");\n\t\t\n\t\tfor(String ss  : parts){\n\t\t\tint volume = 0;\n\t\t\tfor ( int i=0; i < ss.length();i++){\n\t\t\t\tif(ss.charAt(i)>='A' && ss.charAt(i)<='Z'){\n\t\t\t\t\tvolume++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (volume > maxVolume)\n\t\t\t\tmaxVolume = volume;\n\t\t}\n\t\t\n\t\tSystem.out.println(maxVolume);\n\t\t\n\t\tbr.close();\n\n\t}\n\n}", "label": 1}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Dia3 {\n\n\t\n\tpublic static void problemaG() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = Integer.parseInt(sc.nextLine());\n\t\n\t\tString palabras = sc.nextLine();\n\t\tStringTokenizer letras = new StringTokenizer(palabras);\n\t\tlong max = 0;\n\t\twhile(letras.hasMoreTokens()) {\n\t\t\tlong contador = 0;\n\t\t\t\n\t\t\tString palabra = letras.nextToken();\n\t\t\t\n\t\t\tfor(int i = 0; i < palabra.length(); i++) {\n\t\t\t\t\n\t\t\t\tCharacter letra = palabra.charAt(i);\n\t\t\t\tif(Character.isUpperCase(letra)) {\n\t\t\t\t\tcontador++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(contador > max) {\n\t\t\t\tmax = contador;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tSystem.out.println(max);\n\t}\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tproblemaG();\n\t}\n}\n\n  \t\t\t   \t    \t\t    \t\t\t\t \t\t\t \t\t\t", "label": 1}
{"src": "import java.util.Scanner;\n\n/**\n * Created by fxpark on 2017-08-22.\n */\npublic class TextVolume {\n\n    public static void main(String[] args) {\n\n        Scanner scanner = new Scanner(System.in);\n        int wordSize = Integer.valueOf(scanner.nextLine());\n        String wordStr = scanner.nextLine();\n        char[] word = wordStr.toCharArray();\n\n        int maxVolume = 0;\n        int tempVolume = 0;\n        for(int idx = 0; idx < wordSize; idx++) {\n            char character = word[idx];\n            if('A' <= character && 'Z' >= character) {\n                tempVolume++;\n            } else if(character == ' ') {\n                if(maxVolume < tempVolume)\n                    maxVolume = tempVolume;\n                tempVolume = 0;\n            } else {\n               continue;\n            }\n        }\n        if(maxVolume < tempVolume)\n            maxVolume = tempVolume;\n\n        System.out.println(maxVolume);\n\n    }\n}\n", "label": 1}
{"src": "import java.io.*;\nimport java.math.RoundingMode;\nimport java.text.DecimalFormat;\nimport java.text.NumberFormat;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Scanner in = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        in.nextInt();\n        int maxCount = 0;\n        while(in.hasNext()){\n            String s = in.next();\n            int count = 0;\n            for (int i = 0; i < s.length(); i++) {\n                if(Character.isUpperCase(s.charAt(i)))\n                    count++;\n            }\n            if(count > maxCount) maxCount = count;\n        }\n        out.print(maxCount);\n        out.close();\n        in.close();\n    }\n\n    static class MyStack {\n        private int maxSize; // \u0420\u0430\u0437\u043c\u0435\u0440 \u043c\u0430\u0441\u0441\u0438\u0432\u0430\n        private int[] stackArray;\n        private int top; // \u0412\u0435\u0440\u0448\u0438\u043d\u0430 \u0441\u0442\u0435\u043a\u0430\n\n        public MyStack(int s) // \u041a\u043e\u043d\u0441\u0442\u0440\u0443\u043a\u0442\u043e\u0440\n        {\n            maxSize = s; // \u041e\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0440\u0430\u0437\u043c\u0435\u0440\u0430 \u0441\u0442\u0435\u043a\u0430\n            stackArray = new int[maxSize]; // \u0421\u043e\u0437\u0434\u0430\u043d\u0438\u0435 \u043c\u0430\u0441\u0441\u0438\u0432\u0430\n            top = -1; // \u041f\u043e\u043a\u0430 \u043d\u0435\u0442 \u043d\u0438 \u043e\u0434\u043d\u043e\u0433\u043e \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\n        }\n\n        public void push(int v) // \u0420\u0430\u0437\u043c\u0435\u0449\u0435\u043d\u0438\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u043d\u0430 \u0432\u0435\u0440\u0448\u0438\u043d\u0435 \u0441\u0442\u0435\u043a\u0430\n        {\n            top++;\n            stackArray[top] = v; // \u0423\u0432\u0435\u043b\u0438\u0447\u0435\u043d\u0438\u0435 top, \u0432\u0441\u0442\u0430\u0432\u043a\u0430 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\n        }\n\n        public int pop() // \u0418\u0437\u0432\u043b\u0435\u0447\u0435\u043d\u0438\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0441 \u0432\u0435\u0440\u0448\u0438\u043d\u044b \u0441\u0442\u0435\u043a\u0430\n        {\n            top--;\n            return stackArray[top + 1]; // \u0418\u0437\u0432\u043b\u0435\u0447\u0435\u043d\u0438\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430\n        }\n\n        public int peek() // \u0427\u0442\u0435\u043d\u0438\u0435 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0430 \u0441 \u0432\u0435\u0440\u0448\u0438\u043d\u044b \u0441\u0442\u0435\u043a\u0430\n        {\n            return stackArray[top];\n        }\n\n        public boolean isEmpty() // true, \u0435\u0441\u043b\u0438 \u0441\u0442\u0435\u043a \u043f\u0443\u0441\u0442\n        {\n            if (top == -1) return true;\n            return false;\n        }\n\n        public boolean isFull() // true, \u0435\u0441\u043b\u0438 \u0441\u0442\u0435\u043a \u043f\u043e\u043b\u043e\u043d\n        {\n            if (top == maxSize - 1) return true;\n            return false;\n        }\n\n        public void clear() {\n            top = -1;\n        }\n    }\n}", "label": 1}
{"src": "// https://codeforces.com/problemset/problem/837/A\n\nimport java.util.Scanner;\n\npublic class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner read = new Scanner(System.in);\n\t\t\n\t\tint n = Integer.parseInt( read.nextLine() );\n\t\tString s = read.nextLine();\n\t\t\n\t\tString[] words = s.split(\" \");\n\t\tint textVolume = 0;\n\t\tfor (String word : words) {\n\t\t\tint wordVolume = 0;\n\t\t\tfor (int i = 0; i < word.length(); ++i) {\n\t\t\t\tchar c = word.charAt(i);\n\t\t\t\tif (Character.isUpperCase(c)) {\n\t\t\t\t\twordVolume++;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttextVolume = Math.max(wordVolume, textVolume);\n\t\t}\n\t\t\n\t\tSystem.out.println(textVolume);\n\t\t\n\t\t// Close scanner\n\t\tread.close();\n\t}\n\n}", "label": 1}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\npublic class ppm{\n\n   \n public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n=in.nextInt();\n     //  System.out.println(n);\n\t\tString s1=in.nextLine();\n     String s=in.nextLine();\n    // System.out.println(s);\n        String[] a=s.split(\" \");\n        int l=a.length;\n       // System.out.println(l);\n        int mx=0;\n      /*  for(int k=0;k<l;k++)\n        {\n            System.out.println(a[k]);\n        }*/\n        for(int i=0;i<l;i++)\n        {\n            // System.out.println(a[i]);\n            int c=0;\n            for(int j=0;j<a[i].length();j++)\n            {\n                if(Character.isUpperCase(a[i].charAt(j)))\n                {\n                    c++;\n                }\n                mx=Math.max(c,mx);\n            }\n        }\n         System.out.println(mx);\n   }\n}\n", "label": 1}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author _disturbed_\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        ATextVolume solver = new ATextVolume();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ATextVolume {\n        public void solve(int tt, FastScanner fs, PrintWriter out) {\n            int n = fs.nextInt();\n            String[] words = fs.nextLine().split(\" \");\n            int ans = 0;\n            for (String word : words) {\n                int cur = 0;\n                for (char c : word.toCharArray()) {\n                    if (Character.isUpperCase(c)) cur++;\n                }\n                ans = Utilities.max(ans, cur);\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class Utilities {\n        public static int max(int... args) {\n            int ret = args[0];\n            for (int i : args) ret = Math.max(ret, i);\n            return ret;\n        }\n\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream inputStream) {\n            br = new BufferedReader(new InputStreamReader(inputStream));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n}\n\n", "label": 1}
{"src": "import java.util.*;\nimport java.io.*;\n//import java.text.*;\n\npublic class Main{\n//    final long MOD = (long)1e9+7, IINF = (long)1e19;\n//    final int MAX = (int)1e5+1, MX = (int)1e7+1, INF = (int)1e9;\n//    DecimalFormat df = new DecimalFormat(\"0.00000000\");\n//    final double EPS = 1e-8;\n    FastReader in;\n    PrintWriter out;\n    boolean multipleTC = false;\n    \n    public static void main(String[] args) throws Exception{new Main().run();};\n    void run(){\n        in = new FastReader();\n        out = new PrintWriter(System.out);\n        for(int i = 1, t = (multipleTC)?ni():1; i<=t; i++)solve(i);\n        out.flush();\n        out.close();\n    }\n    \n    void solve(int TC){\n        int n = ni();\n        String s = in.nextLine();\n        int ans = 0;\n        for(int i = 0, c= 0; i< n; i++){\n            if(s.charAt(i)==' ' || i == n-1){\n                if(Character.isUpperCase(s.charAt(i)))c++;\n                ans = Math.max(ans, c);\n                c = 0;\n            }else if(Character.isUpperCase(s.charAt(i)))c++;\n        }\n        pn(ans);\n    }\n    \n    \n    int[] sort(int[] a){\n        if(a.length==1)return a;\n        int mid = a.length/2;\n        int[] b = sort(Arrays.copyOfRange(a,0,mid)), c = sort(Arrays.copyOfRange(a,mid,a.length));\n        for(int i = 0, j = 0, k = 0; i< a.length; i++){\n            if(j<b.length && k<c.length){\n                if(b[j]<c[k])a[i] = b[j++];\n                else a[i] = c[k++];\n            }else if(j<b.length)a[i] = b[j++];\n            else a[i] = c[k++];\n        }\n        return a;\n    }\n    \n    long[] sort(long[] a){\n        if(a.length==1)return a;\n        int mid = a.length/2;\n        long[] b = sort(Arrays.copyOfRange(a,0,mid)), c = sort(Arrays.copyOfRange(a,mid,a.length));\n        for(int i = 0, j = 0, k = 0; i< a.length; i++){\n            if(j<b.length && k<c.length){\n                if(b[j]<c[k])a[i] = b[j++];\n                else a[i] = c[k++];\n            }else if(j<b.length)a[i] = b[j++];\n            else a[i] = c[k++];\n        }\n        return a;\n    }\n\n    int[] ia(int n){\n        int[] out = new int[n];\n        for(int i = 0; i< n; i++)out[i] = ni();\n        return out;\n    }\n\n    long[] la(int n){\n        long[] out = new long[n];\n        for(int i = 0; i< n; i++)out[i] = nl();\n        return out;\n    }\n\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bitcount(long n){return (n==0)?0:(1+bitcount(n&(n-1)));}\n    void p(Object o){out.print(o);}\n    void pn(Object o){out.println(o);}\n    void pni(Object o){out.println(o);out.flush();}\n    String n(){return in.next();}\n    String nln(){return in.nextLine();}\n    int ni(){return Integer.parseInt(in.next());}\n    long nl(){return Long.parseLong(in.next());}\n    double nd(){return Double.parseDouble(in.next());}\n\n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        String next(){\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine(){\n            String str = \"\";\n            try{\n                str = br.readLine();\n            }catch (IOException e){\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "label": 1}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class TextVolume {\n\n    public static void main(String[] args){\n        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        int n = in.nextInt();\n        in.nextLine();\n        String arr1 = in.nextLine();\n        String [] arr2 = arr1.split(\" \");\n        int sum = 0;\n        for (int i = 0; i < arr2.length; i++){\n            int temp = 0;\n            for (int j = 0; j < arr2[i].length(); j++){\n                if (arr2[i].charAt(j) == Character.toUpperCase(arr2[i].charAt(j))){\n                    temp++;\n                }\n            }\n            if (temp > sum) sum = temp;\n        }\n        System.out.println(sum);\n    }\n\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String args[]){\n        Scanner Input = new Scanner(System.in);\n        \n        short N = Input.nextShort();\n        short Abyss = 0;\n        short Max_Volume = 0;\n        \n        while (Abyss < N){\n            String Word = Input.next();\n            Abyss += Word.length() + 1;\n            short Actual_Volume = 0;\n            \n            for (short i = 0; i < Word.length(); i++){\n                if (Character.isUpperCase(Word.charAt(i))){\n                    Actual_Volume++;\n                }\n            }\n            if (Actual_Volume > Max_Volume){\n                Max_Volume = Actual_Volume;\n            }\n        }\n        System.out.println(Max_Volume);\n    }\n}", "label": 1}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, Scanner sn, PrintWriter out) {\n            int n = Integer.parseInt(sn.nextLine());\n            String a = sn.nextLine();\n            int aux = 0;\n            int r = 0;\n            for (int i = 0; i < a.length(); i++) {\n                if (a.charAt(i) == ' ') {\n                    aux = 0;\n                }\n                if (a.charAt(i) >= 'A' && a.charAt(i) <= 'Z') {\n                    aux++;\n                }\n                r = Math.max(r, aux);\n            }\n            out.println(r);\n\n        }\n\n    }\n}\n\n", "label": 1}
{"src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class TextVolume\n{\n    public static void main(String [] args)\n    {\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt();\n\n        input.nextLine();\n        String str = input.nextLine();\n\n        if(isText(str))\n        {\n            List<Integer> indexes = new ArrayList<>();\n            for(int i = 0; i < n; i++)\n                if(str.charAt(i) == ' ')\n                    indexes.add(i);\n\n            List<String> words = new ArrayList<>();\n            words.add(str.substring(0, indexes.get(0)));\n\n            for(int i = 0; i < indexes.size() - 1; i++)\n                words.add(str.substring(indexes.get(i) + 1, indexes.get(i + 1)));\n\n            words.add(str.substring(indexes.get(indexes.size() - 1) + 1));\n\n            List<Integer> upperCasesCounter = new ArrayList<>();\n            for(String word : words)\n                upperCasesCounter.add((int) word.chars()\n                                                .mapToObj(character -> (char) character)\n                                                .filter(Character::isUpperCase)\n                                                .count());\n\n            System.out.println(Collections.max(upperCasesCounter));\n        }\n        else\n            System.out.println(str.chars()\n                                  .mapToObj(character -> (char) character)\n                                  .filter(Character::isUpperCase)\n                                  .count());\n    }\n\n    public static boolean isText(String str)\n    {\n        return str.chars().filter(character -> character == ' ').count() > 0;\n    }\n}", "label": 1}
{"src": "import java.util.*;\n\npublic class code1\n{\n    public static void main (String[] args)\n    {\n        Scanner s = new Scanner(System.in);\n        String line_one = s.nextLine();\n        String line_two = s.nextLine();\n        \n        String[] line2 = line_two.split(\" \");\n        \n        \n        int i;\n        int j;\n        int output=0;\n        int outpt_var=0;\n        char character ;\n        for (i=0; i<line2.length; i++)\n            \n            {\n            for (j=0; j< line2[i].length();j++)\n             {  \n                character= line2[i].charAt(j);\n                int ascii = (int) character;\n                if (ascii <=90  && ascii >= 65)\n                    outpt_var++;\n                    \n\n            }\n            if (outpt_var> output)\n                {    output= outpt_var;\n                }\n             outpt_var=0;   \n\n                }\n            \n\n            System.out.println (output);\n\n\n    }\n}", "label": 1}
{"src": "import java.util.*;\npublic class TextVolume{\n\tpublic static void main(String[] args){\n\t\tScanner scan = new Scanner(System.in);\n\t\tint num = scan.nextInt(),ans = 0;\n\t\tscan.nextLine();\n\t\tString s = scan.nextLine();\n\t\tString[] split=s.split(\" \");\n\t\tfor(int i=0;i<split.length;i++){\n\t\t\tint count = 0;\n\t\t\tfor(int j=0;j<split[i].length();j++){\n\t\t\t\tif(split[i].charAt(j)>='A' && split[i].charAt(j)<='Z')\n\t\t\t\t\tcount++;\n\t\t\t}\n\t\t\tans = Math.max(ans,count);\n\t\t}\n\t\tSystem.out.println(ans);\n\t\t\n\t}\n}", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Text_volume {\n \n\tpublic static int volume(int size, String phrase) {\n\t\tCharacter letter;\n\t\tint sum = 0;\n\t\tint res = 0;\n\t\tfor(int i=0; i<phrase.length(); i++) {\n\t\t\tletter = phrase.charAt (i);\n\t\t\tif(Character.isUpperCase(letter)) {\n\t\t\t\tsum++;\n\t\t\t}else if(letter == ' ') {\n\t\t\t\tif(sum > res) {\n\t\t\t\t\tres = sum;\n\t\t\t\t}\n\t\t\t\tsum = 0;\n\t\t\t}\n\t\t}\n\t\tif(sum > res) {\n\t\t\tres = sum;\n\t\t}\n\t\treturn res;\n\t}\n\t\npublic static void main(String args[]){\n\n\t\t\n        Scanner res = new Scanner(System.in);\n        int x = Integer.parseInt(res.nextLine());\n        String word = res.nextLine();\n        \n        System.out.println(volume(x, word));;\n    \n        res.close();\n     \n    }\n\t\n\t\n\t\n}\n\t  \t\t       \t\t \t \t  \t \t\t\t \t   \t", "label": 1}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class A{\n\t\n\t\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = sc.nextInt();\n\t\tint ans = 0;\n\t\t\n\t\tStringTokenizer st = new StringTokenizer(sc.nextLine());\n\t\t\n\t\twhile(st.hasMoreTokens()) {\n\t\t\tString s = st.nextToken();\n\t\t\tint cur = 0;\n\t\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\t\tif(s.charAt(i) >= 'A' && s.charAt(i) <= 'Z')\n\t\t\t\t\tcur++;\n\t\t\t}\n\t\t\tans = Math.max(ans, cur);\n\t\t}\n\t\t\n\t\tout.println(ans);\n\t\t\n\t\tout.flush();\n\t}\n\n\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile(st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tpublic int nextInt() throws NumberFormatException, IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t}\n\n}\n", "label": 1}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        int count(String s) {\n            int ret = 0;\n            for (int i = 0; i < s.length(); ++i) if (Character.isUpperCase(s.charAt(i))) ret++;\n            return ret;\n        }\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int re = 0;\n            in.nextToken();\n            while (true) {\n                try {\n                    re = Math.max(re, count(in.nextToken()));\n                } catch (Exception ex) {\n                    break;\n                }\n            }\n            out.println(re);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextToken() {\n            int c;\n            while (isSpaceChar(c = read())) ;\n            StringBuilder result = new StringBuilder();\n            result.appendCodePoint(c);\n            while (!isSpaceChar(c = read()))\n                result.appendCodePoint(c);\n            return result.toString();\n        }\n\n        public static boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "label": 1}
{"src": "import java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class _837A {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        in.nextLine();\n        StringTokenizer st = new StringTokenizer(in.nextLine(), \" \");\n        int MainC = 0;\n        while (st.hasMoreTokens()) {\n            String s = st.nextToken();\n            int subC = 0;\n            for (int i = 0; i < s.length(); i++)\n                if (s.charAt(i) <= 'Z') subC++;\n            MainC = Math.max(subC, MainC);\n        }\n        System.out.println(MainC);\n    }\n}\n", "label": 1}
{"src": "//package codeforces;\n\nimport java.util.Scanner;\n\n/**\n * Created by nitin.s on 03/08/17.\n */\npublic class TextVolume {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        in.nextLine();\n        String s = in.nextLine();\n        String[] split = s.split(\" \");\n        int answer = 0;\n        for(String str: split) {\n            int local = 0;\n            for(int i = 0; i < str.length(); ++i) {\n                if(str.charAt(i) >= 'A' && str.charAt(i) <= 'Z') ++local;\n            }\n            answer = Math.max(answer, local);\n        }\n        System.out.println(answer);\n    }\n}\n", "label": 1}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class CodeForces\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner input = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\n\t\tint n = input.nextInt();\n\t\tinput.nextLine();\n\t\tString[] array = input.nextLine().trim().split(\" \");\n\t\tint max = 0;\n\t\tfor (int i = 0; i < array.length; i++)\n\t\t{\n\t\t\tString s = array[i];\n\t\t\tint count = 0;\n\t\t\tfor (int j = 0; j < s.length(); j++)\n\t\t\t{\n\t\t\t\tif (Character.isUpperCase(s.charAt(j)))\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (count > max)\n\t\t\t{\n\t\t\t\tmax = count;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}", "label": 1}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\n public class Oca {\n\n    public static void main(String[] args) {\n       Scanner in = new Scanner(System.in);\n        int n =in.nextInt();\n        String s=\"\";\n        int a[]=new int[201];\n        in.nextLine();\n        s=in.nextLine();\n        String s1[]=s.split(\" \");\n        for(int i=0;i<s1.length;i++)\n        {\n            String tr=s1[i];\n            int c=0;\n            for(int j=0;j<tr.length();j++)\n            {\n                if(Character.isUpperCase(tr.charAt(j)))\n                {\n                    ++c;\n                }\n            }\n            a[i]=c;\n        }\n       Arrays.sort(a);\n        System.out.println(a[a.length-1]);\n    }\n    \n}\n", "label": 1}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class TextVolume {\n\n    public static void main(String[] args) {\n        FastReader input = new FastReader();\n        int n = input.nextInt();\n        String str = input.nextLine();\n        int count = 0;\n\n        int max = 0;\n       \n        String[] arr = str.split(\" \");\n        \n        for (int i = 0; i < arr.length; i++) {\n            count = 0;\n            for (int j = 0; j < arr[i].length(); j++) {\n                 if (Character.isUpperCase(arr[i].charAt(j))) {\n                count++;\n            }\n                 if(count > max)\n                     max = count;\n            }\n           \n\n        }\n        System.out.println(max);\n\n        \n    }\n}\n\nclass FastReader {\n\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() {\n        InputStreamReader isr = new InputStreamReader(System.in);\n        br = new BufferedReader(isr);\n    }\n\n    String next() {\n        while (st == null || !st.hasMoreElements()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException ex) {\n                ex.printStackTrace();\n            }\n\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    String nextLine() {\n        String str = \"\";\n        try {\n            str = br.readLine();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return str;\n    }\n\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class A{\n    public static void main(String[] args) throws Exception{\n        Scanner scanner = new Scanner(System.in);\n\n        int length = 0;\n        String text = \"\";\n\n        length = Integer.parseInt(scanner.nextLine());\n        text = scanner.nextLine();\n\n        int count = 0;\n        int maxCount = 0;\n        char currentChar;\n\n        for(int i = 0; i < length; i++){\n            currentChar = text.charAt(i);\n\n            if(Character.isUpperCase(currentChar)){\n                count++;\n            }\n            else if(currentChar == ' '){\n                count = 0;\n            }\n            if(maxCount < count){\n                maxCount = count;\n            }\n\n        }\n        System.out.println(maxCount);\n    }\n\n}\n", "label": 1}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tMyScanner sc = new MyScanner();\n\t\tint n = sc.nextInt();\n\t\tString s[] = sc.nextLine().split(\" \");\n\t\tint sum=0,res=0;\n\t\tfor(String c :s)\n\t\t{\n\t\t\tfor(int i=0;i<c.length();i++)\n\t\t\t{\n\t\t\t\tif(Character.isUpperCase(c.charAt(i)))\n\t\t\t\t{\n\t\t\t\t\tsum++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres=Math.max(res,sum);\n\t\t\tsum=0;\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n}\nclass MyScanner {\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tpublic MyScanner() {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\tString next() {\n\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tString nextLine() {\n\t\tString str = \"\";\n\t\ttry {\n\t\t\tstr = br.readLine();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn str;\n\t}\n}\n\n", "label": 1}
{"src": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class ixigo {\n\n\tpublic static void count(String str)\n\t{\n\t\tString a[]=str.split(\",\");\n\t\tString b=\"\";\n\t\tfor(String i:a)\n\t\t\tb=b+i;\n\t\t\n\t\tString s[]=b.split(\" \");\n\t\tint arr[]=new int[s.length];\n\t\tint max=0;\n\t\tfor(int i=0;i<s.length;i++)\n\t\t\t{\n\t\t\tarr[i]=Integer.parseInt(s[i]);\n\t\t\tmax=Math.max(max,arr[i]);\n\t\t\t}\n\t\t\n\t\tboolean v[]=new boolean[max+1];\n\t\tArrays.fill(v,false);\n\t\t\n\t\tfor(int i:arr)\n\t\t{\n\t\t\tv[i]=true;\n\t\t}\n\t\t\n\t\tint maxlen=0;\n\t\tint start=-1;\n\t\tint end=-1;\n\t\t\n\t\tfor(int i=0;i<v.length;i++)\n\t\t{\n\t\t\tif(v[i]==true)\n\t\t\t{\n\t\t\t\tint j=i;\n\t\t\t\twhile(j<v.length && v[j]==true)\n\t\t\t\t\tj++;\n\t\t\t\t\n\t\t\t\tj--;\n\t\t\t\tif((j-i+1)>maxlen)\n\t\t\t\t{\n\t\t\t\t\tmaxlen=j-i+1;\n\t\t\t\t\tstart=i;\n\t\t\t\t\tend=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=start;i<=end;i++)\n\t\t{\n\t\t\tSystem.out.print(i +\", \");\n\t\t}\n\t\tSystem.out.println();\n\t\tSystem.out.println(maxlen);\n\t}\n\t\n\tpublic static void combi(String curr,int limit,boolean visit[],char c[])\n\t{\n\t\tif(curr.length()==limit)\n\t\t{\n\t\t\tSystem.out.println(curr);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<visit.length;i++)\n\t\t{\n\t\t\tif(visit[i]==false)\n\t\t\t{\n\t\t\t\tvisit[i]=true;\n\t\t\t\tcurr+=c[i];\n\t\t\t\tcombi(curr, limit, visit, c);\n\t\t\t\tvisit[i]=false;\n\t\t\t\tcurr=curr.substring(0,curr.length()-1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void permute(String str,int len)\n\t{\n\t\tchar c[]=str.toCharArray();\n\t\tArrays.sort(c);\n\t\tboolean limit[]=new boolean[c.length];\n\t\tArrays.fill(limit, false);\n\t\t\n\t\tfor(int i=0;i<c.length;i++)\n\t\t{\n\t\t\tlimit[i]=true;\n\t\t\tcombi(c[i]+\"\" , len,limit,c);\n\t\t\tlimit[i]=false;\n\t\t}\n\t}\n\tpublic static void volume()\n\t{\n\t\tScanner s=new Scanner(System.in);\n\t\tint n=s.nextInt();\n\t\tString str=s.nextLine();\n\t\tstr=s.nextLine();\n\t\tint max=0;\n\t\tString a[]=str.split(\" \");\n\t\tfor(String ss:a)\n\t\t{\n\t\t\tint temp=0;\n\t\t\tfor(int i=0;i<ss.length();i++)\n\t\t\t{\n\t\t\t\tif(ss.charAt(i)>='A'  && ss.charAt(i)<='Z')\n\t\t\t\t\ttemp++;\n\t\t\t}\n\t\t\tmax=Math.max(max, temp);\n\t\t}\n\t\tSystem.out.println(max);\n\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t//\tcount(\"1, 4, 7, 5, 9, 10, 6, 11, 12, 13\");\n\t\t\n\t//\tpermute(\"cdabe\", 3);\n\t\tvolume();\n\t}\n\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Mai {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint x = scan.nextInt();\n\t\tscan.nextLine();\n\t\tString[] lines = scan.nextLine().split(\" \");\n\t\tint max = 0;\n\t\tfor(String str : lines) {\n\t\t\tint curr = 0;\n\t\t\tfor(int j = 0; j < str.length(); ++j) {\n\t\t\t\tcurr += Character.isUpperCase(str.charAt(j)) ? 1 : 0;\n\t\t\t}\n\t\t\tmax = Math.max(curr, max);\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Codeforces {    \n    public static void main(String[] args) {\n        TaskA Solver = new TaskA();\n        Solver.Solve();        \n    }   \n    private static class TaskA {                            \n        private void Solve() {\n            Scanner in = new Scanner(System.in);\n            int n = in.nextInt();\n            in.nextLine();\n            StringBuilder S = new StringBuilder(in.nextLine());\n            S.append(\" \");\n            int max = 0;\n            while (true) {\n                int indx = S.indexOf(\" \");\n                if (indx == -1)\n                    break;\n                else {\n                    int c = 0;\n                    for (int i = 0; i < indx; i++)                    \n                        if (Character.isUpperCase(S.charAt(i)))\n                            c++;                                                            \n                    max = Math.max(max, c);\n                    S.delete(0, indx + 1);\n                }\n            }\n            System.out.println(max);            \n        }                \n    }\n}", "label": 1}
{"src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tScanner in = new Scanner(System.in);\n\t\tint len = Integer.parseInt(in.nextLine());\n\t\tString[] arr = in.nextLine().split(\"\\\\s+\");\n\t\tint ans = 0;\n\t\t\n\t\tfor(String s : arr) {\n\t\t\tchar[] arrr = s.toCharArray();\n\t\t\tint tmp = 0;\n\t\t\tfor(char c : arrr) {\n\t\t\t\ttmp += (c >= 'A' && c <= 'Z') ? 1: 0;\n\t\t\t}\n\t\t\t\n\t\t\tans = Math.max(ans, tmp);\n\t\t}\n\t\t\n\t\tSystem.out.println(ans);\n\t}\n}", "label": 1}
{"src": "//package TIM;\n\n\nimport java.lang.reflect.Array;\nimport java.math.*;\nimport java.util.*;\n\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int n = input.nextInt();\n        input.nextLine();\n        String s = input.nextLine();\n        int ans = 0;\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (s.charAt(i) == ' ') count = 0;\n            if (s.charAt(i) >= 'A' && s.charAt(i) <= 'Z')\n                count++;\n            if (count > ans) ans = count;\n        }\n        System.out.println(ans);\n    }\n}\n\n\n\n\n\n", "label": 1}
{"src": "import java.util.*;\npublic class TextVolume {\n\tpublic static void main(String[] args) {\n\t\tScanner S= new Scanner(System.in);\n\t\tint n=S.nextInt();int curr=0;int tem=0;\n\t\twhile(S.hasNext()) {\n\t\t\tString s=S.next();\n\t\t\ttem=tem+s.length()+1;\n\t\t\tint max=0;\n\t\t\tfor(int i=0;i<s.length();i++) {\n\t\t\t\tif(Character.isUpperCase(s.charAt(i))) {\n\t\t\t\t\tmax++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max>curr) {\n\t\t\t\tcurr=max;\n\t\t\t}\n\t\t\tif(tem>=n) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(curr);\n\t}\n}\n", "label": 1}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n    Scanner in = new Scanner(System.in);\n    PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out), true);\n\n\n    void run() {\n        int n = in.nextInt();\n        int mxRes = 0;\n        while (in.hasNext()) {\n            String s = in.next();\n            int res = 0;\n            for (int j = 0, len = s.length(); j < len; j++) {\n                if (s.charAt(j) >= 'A' && s.charAt(j) <= 'Z')\n                    res++;\n            }\n            mxRes = Math.max(mxRes, res);\n        }\n        out.print(mxRes);\n        out.close();\n    }\n\n    public static void main(String[] args){\n        new A().run();\n    }\n\n    static class FScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "label": 1}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Nishant\n{\n\tpublic static void main(String args[])throws IOException\n\t{\n\t\tInputStreamReader isr=new InputStreamReader(System.in);\n\t\tBufferedReader br=new BufferedReader(isr);\n\t\tint n=Integer.parseInt(br.readLine());\n\t\tString[] val = (br.readLine()).split(\" \");\n\t\tint max=0;\n\t\tfor(int i=0; i<val.length; i++)\n\t\t{\n\t\t\tint c=0;\n\t\t\tfor(int j=0; j<val[i].length(); j++)\n\t\t\t{\n\t\t\t\tchar ch=val[i].charAt(j);\n\t\t\t\tif(Character.isUpperCase(ch))\n\t\t\t\t\tc++;\n\t\t\t}\n\t\t\tif(c>max)\n\t\t\t\tmax=c;\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}", "label": 1}
{"src": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\n \n \npublic class q5 {\n\t\n    \n    static boolean comp(String a, String b, int k) {\n    \tint count=0;\n    \tfor(int i=0;i<a.length();i++) {\n    \t\tif(a.charAt(i)!=b.charAt(i)) count++;\n    \t}\n    \tif(count<=2*k) return true;\n    \treturn false;\n    }\n\t\n \n\tpublic static void main(String[] args) throws IOException {\n\t\n\tReader.init(System.in);\n\tPrintWriter out=new PrintWriter(System.out);\n\tint n=Reader.nextInt();\n\tint ans=0;\n\tint ans2=0;\n\t\n\t\tString s=Reader.nextLine();\n\t\tfor(int j=0;j<s.length();j++) {\n\t\t\tif(s.charAt(j)==' ') {\n\t\t\t\tans=Math.max(ans, ans2);\n\t\t\t\tans2=0;\n\t\t\t}\n\t\t\tint l=s.charAt(j)-'A';\n\t\t\tif(l>=0 && l<=25) {\n\t\t\t\tans2++;\n\t\t\t}\n\t\t\tans=Math.max(ans, ans2);\n\t\t}\n\t\n\tout.print(ans);\n\tout.flush();\n\t}\n}\n\n\n\n \n \n \nclass Reader {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n    /** call this method to initialize reader for InputStream */\n    static void init() throws IOException {\n    \t reader = new BufferedReader(\n                 new FileReader(\"detect.in\"));\n    tokenizer = new StringTokenizer(\"\");\n    }\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                     new InputStreamReader(input) );\n        tokenizer = new StringTokenizer(\"\");\n    }\n    /** get next word */\n    static String nextLine() throws IOException{\n    \treturn reader.readLine();\n    }\n    static String next() throws IOException {\n        while ( ! tokenizer.hasMoreTokens() ) {\n            //TODO add check for eof if necessary\n            tokenizer = new StringTokenizer(\n                   reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n    static int nextInt() throws IOException {\n        return Integer.parseInt( next() );\n    }\n    static long nextLong() throws IOException {\n        return Long.parseLong( next() );\n    }\n    static double nextDouble() throws IOException {\n        return Double.parseDouble( next() );\n    }\n}", "label": 1}
{"src": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class volume {\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint n = Integer.parseInt(input.nextLine());\n\t\t\n\t\tString[] words = input.nextLine().split(\" \");\n\t\t\n\t\tint best = 0;\n\t\tfor(String s: words) {\n\t\t\tint counter = 0;\n\t\t\tfor(int i = 0; i < s.length(); i++) {\n\t\t\t\tif((int)s.charAt(i) < 97) {\n\t\t\t\t\tcounter++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(counter > best) {\n\t\t\t\tbest = counter;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(best);\n\t}\n}\n", "label": 1}
{"src": "import java.util.*;\nimport java.io.*;\npublic class textvol\n{ \n    private static void solve(FastScanner s1, PrintWriter out){\n        int t = s1.nextInt();\n        String b = s1.nextLine();\n        char[] a = b.toCharArray();\n        int ctr=0,max=0;\n        for(int i=0;i<t;i++){\n            if(a[i]<='Z' && a[i]!=' '){\n                ctr++;\n            }\n            else if(a[i]==' '){\n                ctr=0;\n            }\n            if(ctr>max)\n                    max=ctr;\n        }\n        System.out.println(max);\n    } \n    public static void main(String []args) throws IOException {\n    FastScanner in  = new FastScanner(System.in);\n    PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)), false); \n    solve(in, out);\n    in.close();\n    out.close();\n    }    \n \n    static class FastScanner{\n    BufferedReader reader;\n    StringTokenizer st;\n    FastScanner(InputStream stream){reader=new BufferedReader(new InputStreamReader(stream));st=null;}  \n    String next()\n        {while(st == null || !st.hasMoreTokens()){try{String line = reader.readLine();if(line == null){return null;}            \n         st = new StringTokenizer(line);}catch (Exception e){throw new RuntimeException();}}return st.nextToken();}\n    String nextLine()  {String s=null;try{s=reader.readLine();}catch(IOException e){e.printStackTrace();}return s;}             \n    int    nextInt()   {return Integer.parseInt(next());}\n    long   nextLong()  {return Long.parseLong(next());}     \n    double nextDouble(){return Double.parseDouble(next());}\n    char   nextChar()  {return next().charAt(0);}\n    int[]  nextIntArray(int n)         {int[] arr= new int[n];   int i=0;while(i<n){arr[i++]=nextInt();}  return arr;}\n    long[] nextLongArray(int n)        {long[]arr= new long[n];  int i=0;while(i<n){arr[i++]=nextLong();} return arr;}  \n    int[]  nextIntArrayOneBased(int n) {int[] arr= new int[n+1]; int i=1;while(i<=n){arr[i++]=nextInt();} return arr;}          \n    long[] nextLongArrayOneBased(int n){long[]arr= new long[n+1];int i=1;while(i<=n){arr[i++]=nextLong();}return arr;}          \n    void   close(){try{reader.close();}catch(IOException e){e.printStackTrace();}}              \n    }\n \n}", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        if(n <= 0) {\n            return;\n        }\n        while(sc.hasNext()) {\n            String str = sc.nextLine();\n            char arr[] = str.toCharArray();\n            int max = 0;\n            if(arr.length == n) {\n                int num = 0;\n                for(int i = 0;i<arr.length;i++) {\n                    if(arr[i] == ' ') {\n                        if(num > max) {\n                            max = num;\n                        }\n                        num = 0;\n                    }\n                    if(arr[i] >= 'A' && arr[i]  <= 'Z')\n                        num ++;\n                }\n                if(num > max) {\n                    max = num;\n                }\n                System.out.println(max);\n            }\n        }\n\n\n    }\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n\n    Scanner in = new Scanner(System.in);\n    int n = Integer.parseInt(in.nextLine());\n    String text = in.nextLine();\n    int max = 0;\n    int aux = 0;\n\n    for (int i = 0; i < n; i++) {\n    \n      if (Character.isUpperCase(text.charAt(i))) {\n        aux++;\n      } else {\n        if (text.charAt(i) == ' ') {\n          aux = 0;\n        }\n      }\n       if (aux > max) {\n        max = aux;\n      }\n    }\n    System.out.println(max);\n  }\n}\n\t\t \t\t \t   \t   \t\t    \t \t\t\t\t\t\t\t\t\t", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class TextVolume {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint total = in.nextInt();\n\t\tin.nextLine();\n\t\tString data = in.nextLine();\n\t\tString[] words = data.split(\" \");\n\t\tint count = 0,\n\t\t\tans = 0;\n\t\tfor(int i = 0; i < words.length; i++) {\n\t\t\tchar[] letters = words[i].toCharArray();\n\t\t\tfor(int j = 0; j < letters.length; j++) {\n\t\t\t\tif(letters[j] >= 65 && letters[j] <= 90) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans < count) {\n\t\t\t\tans = count;\n\t\t\t}\n\t\t\tcount = 0;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n\n  \t\t\t\t     \t \t   \t\t   \t \t\t\t\t\t\t", "label": 1}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\npublic class Main\n{\n    public static void main(String[] args) throws IOException {\n        StreamTokenizer in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        Scanner sc = new Scanner(System.in);\n        String s;\n         sc.nextLine();\n        s=sc.nextLine();\n        String sp[]=s.split(\" \");\n        int maxn=0;\n        for(String i:sp)\n        {\n            int len=i.length();\n            int cnt=0;\n            for(int j=0;j<len;j++)\n            {\n               if(i.charAt(j)<='Z'&&i.charAt(j)>='A')\n                cnt++;\n\n            } maxn=Math.max(maxn,cnt);\n        }\n        out.print(maxn);\n\n        out.flush();\n    }\n}", "label": 1}
{"src": "import java.util.*;\npublic class Gromkost {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int a = Integer.parseInt(input.nextLine());\n        String str = input.nextLine().substring(0,a);\n\n        String[] mas = str.split(\" \");\n        int count = 0,max = 0;\n\n        for(String i: mas){\n            count = 0;\n            if(i.length() >1) {\n                for (char ia : i.toCharArray()) {\n                    if (Character.isUpperCase(ia)) {\n                        ++count;\n                    }\n                }\n            }\n            else{\n                if(Character.isUpperCase(i.charAt(0)))\n                    count++;\n            }\n            max = Math.max(max,count);\n\n        }\n\n        System.out.println(Math.max(max,count));\n    }\n}\n", "label": 1}
{"src": "\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tin.nextLine();\n\t\tString s[] = in.nextLine().split(\" \");\n\t\tint max = 0, m = Integer.MIN_VALUE;\n\t\tfor(int i = 0; i < s.length; i++)\n\t\t{\n\t\t   max = 0;\n\t\t    for(int j = 0; j < s[i].length(); j++)\n\t\t    {\n\t\t    if(Character.isUpperCase(s[i].charAt(j)))\n\t\t    max++;\n\t\t    }\n\t\t    if(max>m)m=max;\n\t\t}\n\t\tSystem.out.println(m);\n\t}\n}\n", "label": 1}
{"src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Ideone\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(reader.readLine());\n\t\tString str = reader.readLine();\n\t\tint upperCase =0;\n\t\tint max = 0;\n\t\tfor(int i=0; i<str.length();i++){\n\t\t\tif (Character.isLetter(str.charAt(i))) {\n\t          \tif (Character.isUpperCase(str.charAt(i))) upperCase++;\n\t\t\t\t\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(max<upperCase)\n\t\t\t\tmax = upperCase;\n\t\t\t\tupperCase = 0;\n\t\t\t}\n\t\t}\n\t\tif(upperCase>max)\n\t\tmax = upperCase;\n\t\tSystem.out.println(max);\n\t}\n}", "label": 1}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Code_837A_TextVolume{\n    public static void main(String args[]) throws IOException{\n        BufferedReader reader=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(reader.readLine());\n        StringTokenizer in=new StringTokenizer(reader.readLine());\n        PrintWriter out=new PrintWriter(System.out);\n        ArrayList<String> strings=new ArrayList<>();\n        while(in.hasMoreTokens())strings.add(in.nextToken());\n        int max=0;\n        for(String s:strings)max=Math.max(max,countUpperCase(s));\n        out.print(max);\n\n        out.close();\n    }\n    public static int countUpperCase(String s){\n        int count=0,size=s.length();\n        for(int i=0;i<size;++i)\n            if(Character.isUpperCase(s.charAt(i)))\n                ++count;\n        return count;\n    }\n}", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class TextVolume {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        Integer n = in.nextInt();\n        in.nextLine();\n        String text = in.nextLine();\n        \n        String[] words = text.split(\" \");\n        Integer nVolume = 0;\n        int max=0;\n        for (String word : words) {\n            for (int i = 0; i < word.length(); i++) {\n                if (Character.isUpperCase(word.charAt(i))) {\n                    nVolume++;\n                }\n            }\n            if(max<nVolume){\n                max=nVolume;\n            }\n            nVolume=0;\n                   \n        }\n        \n        System.out.println(max);\n    }\n}", "label": 1}
{"src": "import java.util.*;\nimport java.util.Scanner;\n\npublic class Codeforces6 {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\t\n\t\tScanner scn=new Scanner(System.in);\n                int n=scn.nextInt();\n                scn.nextLine();\n\t\tString str=scn.nextLine();\n\t\t//System.out.println(str);\n\t\tint currans=0;\n\t\tint max=0;\n\t\tString temp=\"\";\n\t\tfor(int i=0;i<str.length();i++){\n\t\t\tif(str.charAt(i)==' '){\n\t\t\t\tif(currans>max){\n\t\t\t\t\tmax=currans;\n\t\t\t\t}\n\t\t\t\tcurrans=0;\n\t\t\t\t\n\t\t\t}else{\n\t\t\t\tif(str.charAt(i)>=65 && str.charAt(i)<91 ){\n\t\t\t\t\tcurrans++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\tif(currans>max){\n\t\t\tmax=currans;\n\t\t}\n\t\tSystem.out.println(max);\n\t\t\n\t\t\n\n\t}\n\n}\n", "label": 1}
{"src": "import java.util.*;\npublic class textvol {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint max = 0;\n\t\tint j = 0;\n\t\twhile(j<n){\n\t\t\tString word = in.next();\n\t\t\tint total=0;\n\t\t\tfor (int i = 0; i < word.length(); i++) {\n\t\t\t\tif(word.charAt(i)==word.toUpperCase().charAt(i)) total++;\n\t\t\t}\n\t\t\tj+=word.length()+1;\n\t\t\tmax = Math.max(total, max);\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n\n}", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class G {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tint size=Integer.parseInt(sc.nextLine());\n\t\t\n\t\tString[] lista = sc.nextLine().split(\" \");\n\t\t\n\t\t\n\t\tint contador=0;\n\t\tint mayor=0;\n\t\tfor (int i = 0; i < lista.length; i++) {\n\t\t\tfor (int j = 0; j < lista[i].length(); j++) {\n\t\t\t\tif (Character.isUpperCase(lista[i].charAt(j))) {\n\t\t\t\t\tcontador++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(contador>mayor) {\n\t\t\t\tmayor=contador;\n\t\t\t}\n\t\t\tcontador=0;\n\t\t}\n\t\t\n\t\tSystem.out.println(mayor);\n\t}\n\t\n}\n\n \t      \t\t\t\t \t \t\t   \t\t    \t\t\t", "label": 1}
{"src": "function numCapitals(word) {\n  var total = 0;\n  for (var i = 0; i < word.length; i++) {\n    if (/[A-Z]/.test(word[i])) {\n      total++;\n    }\n  }\n  return total;\n}\n\nfunction main() {\n  var n = readline();\n  var words = readline().split(' ');\n\n  var max = words.reduce((max, curr) => {\n    var count = numCapitals(curr);\n    if (count > max) {\n      return count;\n    }\n    return max;\n  }, -1);\n\n  print(max);\n}\n\nmain();\n", "label": 1}
{"src": "import java.util.*;\npublic class Higher{\n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    String asss = in.nextLine();\n    String s = in.nextLine();\n    String[] arr = s.split(\" \");\n    int c= 0, m=0;\n    for (int i = 0; i< arr.length; i++) {\n      String[] as = arr[i].split(\"\");\n      for (int j = 0; j<as.length; j++) if (!as[j].equals(as[j].toLowerCase())) c++;\n      if (c>=m) {m = c;}\n      c=0;\n    }\n    System.out.println(m);\n  }\n}\n", "label": 1}
{"src": "\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        sc.nextInt();\n        sc.nextLine();\n\n        int textVol = 0;\n        String text = sc.nextLine();\n\n        String[] words = text.split(\" \");\n        int[] wordVol = new int[words.length];\n\n        for (int wordNumber=0; wordNumber < words.length; wordNumber++) {\n            for (int i = 0; i < words[wordNumber].length(); i++) {\n                if (Character.isUpperCase(words[wordNumber].charAt(i))) {\n                    wordVol[wordNumber]++;\n                }\n            }\n        }\n\n        for (int wordVolume : wordVol) {\n            if (wordVolume > textVol) {\n                textVol = wordVolume;\n            }\n        }\n        System.out.println(textVol);\n    }\n}\n", "label": 1}
{"src": "import java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader cin=new BufferedReader(new InputStreamReader(System.in));\n        int n=Integer.parseInt(cin.readLine()),con=0,max=Integer.MIN_VALUE,t=0;\n        String []arre=cin.readLine().split(\" \");\n        t=arre.length;\n        for(int i=0;i<t;i++)\n        {\n            int tam=arre[i].length();\n            for(int j=0;j<tam;j++)\n                con+=arre[i].charAt(j)>=65 && arre[i].charAt(j)<=90?1:0;\n            max=Math.max(max, con);\n            con=0;\n        }\n        System.out.println(max);\n}\n}", "label": 1}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Solution{\n    public static void main(String args[]){\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        sc.nextLine();\n        String s=sc.nextLine();\n        int max=0;\n        String[] arr=s.split(\" \");\n        for(int i=0;i<arr.length;i++){\n            int count=0;\n            for(int j=0;j<arr[i].length();j++){\n                if((int)arr[i].charAt(j)>=65 && (int)arr[i].charAt(j)<=90)count++;\n            }\n            if(count>max)max=count;\n        }\n        System.out.println(max);\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class A {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt(), maxvol = 0;\n\t\tint totcharcount = 0;\n\t\tsc.nextLine();\n\t\tString everything = sc.nextLine();\n\t\tScanner k = new Scanner(everything);\n\t\twhile(k.hasNext()) {\n\t\t\tString word = k.next();\n\t\t\tint vol = 0;\n\t\t\tfor(int j = 0; j < word.length(); ++j) if(word.charAt(j) >= 'A' && word.charAt(j) <= 'Z')  vol++;\n\t\t\tif(vol > maxvol) maxvol = vol;\n\t\t\t\n\t\t}\n\t\tSystem.out.println(maxvol);\n\t}\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\n/**\n * Created by slay on 8/3/17.\n */\npublic class A {\n\n    public static void main(String[] args) {\n        int n;\n        String s;\n        Scanner in = new Scanner(System.in);\n        n = Integer.parseInt(in.nextLine());\n        s = in.nextLine();\n        int result = 0;\n        int temp = 0;\n        for (int i = 0; i < s.length(); i++) {\n            if (Character.isUpperCase(s.charAt(i))) {\n                temp++;\n            } else if (s.charAt(i) == ' ') {\n                result = Math.max(result, temp);\n                temp = 0;\n            }\n        }\n        System.out.println(Math.max(result, temp));\n    }\n}\n", "label": 1}
{"src": "import java.io.*;\n\npublic class CF837A {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tchar[] cc = br.readLine().toCharArray();\n\t\tint cnt = 0, max = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tchar c = cc[i];\n\t\t\tif (c == ' ')\n\t\t\t\tcnt = 0;\n\t\t\telse if (c >= 'A' && c <= 'Z') {\n\t\t\t\tcnt++;\n\t\t\t\tmax = Math.max(max, cnt);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\n\npublic class A837 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint taille = sc.nextInt();sc.nextLine();\n\t\tString [] tab = sc.nextLine().split(\" \");\n\t\tint max=0;\n\t\tfor(String element :tab){\n\t\t\tint nb =0;\n\t\t\tfor(int i=0 ; i<element.length();i++){\n\t\t\t\tif(trouver(element.charAt(i))){\n\t\t\t\t\tnb++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(max<nb){\n\t\t\t\tmax=nb;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(max);\n\t}\n\n\tprivate static boolean trouver(char ele) {\n\t\tboolean test = false;\n\t\tString[] list = {\"A\",\"B\",\"C\",\"D\",\"E\",\"F\",\"G\",\"H\",\"I\",\"J\",\"K\",\"L\",\"M\",\"N\",\"O\",\"P\",\"Q\",\"R\",\"S\",\"T\",\"U\",\"V\",\"W\",\"X\",\"Y\",\"Z\"};\n\t\tfor(String x : list){\n\t\t\tif((\"\"+ele).equals(x)){\n\t\t\t\ttest= true;\n\t\t\t}\n\t\t}\n\t\treturn test;\n\t}\n\n}\n", "label": 1}
{"src": "import java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.Locale;\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.math.BigInteger;\n\npublic class TextVolume {\n\n\tpublic static void main(String[] args) {\n\n\t\tint n = StdIn.readInt();\n\t\tString[] s = StdIn.readAllStrings();\n\t\t\n\t\tint max = 0;\n\t\t\n\t\tfor(String s1 : s){\n\t\t\tint len = 0;\n\t\t\tfor(int i = 0 ; i < s1.length() ; i++){\n\t\t\t\tif(s1.charAt(i) >= 'A' && s1.charAt(i) <= 'Z'){\n\t\t\t\t\tlen += 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax = Math.max(max, len);\n\t\t}\n\t\t/*\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif(s[i] == ' '){\n\t\t\t\tmax = Math.max(max, len);\n\t\t\t\tlen = 0;\n\t\t\t}else if(s[i] >= 'A' && s[i] <= 'Z'){\n\t\t\t\tlen += 1;\n\t\t\t}\n\t\t\tStdOut.println(\"i = \" + i + \" len = \" + len + \" \" + s[i]);\n\t\t}\n\t\t*/\n\t\t\n\t\tStdOut.println(max);\n\t}\n\n}\n\nfinal class StdIn {\n \n    private StdIn() { }\n \n    private static Scanner scanner;\n    \n    private static final String CHARSET_NAME = \"UTF-8\";\n \n    private static final Locale LOCALE = Locale.US;\n \n    private static final Pattern WHITESPACE_PATTERN = Pattern.compile(\"\\\\p{javaWhitespace}+\");\n \n    private static final Pattern EMPTY_PATTERN = Pattern.compile(\"\");\n \n    private static final Pattern EVERYTHING_PATTERN = Pattern.compile(\"\\\\A\");\n \n    public static boolean isEmpty() {\n        return !scanner.hasNext();\n    }\n \n    public static boolean hasNextLine() {\n        return scanner.hasNextLine();\n    }\n \n    public static boolean hasNextChar() {\n        scanner.useDelimiter(EMPTY_PATTERN);\n        boolean result = scanner.hasNext();\n        scanner.useDelimiter(WHITESPACE_PATTERN);\n        return result;\n    }\n \n    public static String readLine() {\n        String line;\n        try                 { line = scanner.nextLine(); }\n        catch (Exception e) { line = null;               }\n        return line;\n    }\n \n    public static char readChar() {\n        scanner.useDelimiter(EMPTY_PATTERN);\n        String ch = scanner.next();\n        assert (ch.length() == 1) : \"Internal (Std)In.readChar() error!\"\n            + \" Please contact the authors.\";\n        scanner.useDelimiter(WHITESPACE_PATTERN);\n        return ch.charAt(0);\n    }  \n \n \n    public static String readAll() {\n        if (!scanner.hasNextLine())\n            return \"\";\n \n        String result = scanner.useDelimiter(EVERYTHING_PATTERN).next();\n        // not that important to reset delimeter, since now scanner is empty\n        scanner.useDelimiter(WHITESPACE_PATTERN); // but let's do it anyway\n        return result;\n    }\n \n    public static String readString() {\n        return scanner.next();\n    }\n \n    public static int readInt() {\n        return scanner.nextInt();\n    }\n \n    public static double readDouble() {\n        return scanner.nextDouble();\n    }\n \n    public static float readFloat() {\n        return scanner.nextFloat();\n    }\n \n    public static long readLong() {\n        return scanner.nextLong();\n    }\n    \n    public static short readShort() {\n        return scanner.nextShort();\n    }\n \n    public static byte readByte() {\n        return scanner.nextByte();\n    }\n \n    public static boolean readBoolean() {\n        String s = readString();\n        if (s.equalsIgnoreCase(\"true\"))  return true;\n        if (s.equalsIgnoreCase(\"false\")) return false;\n        if (s.equals(\"1\"))               return true;\n        if (s.equals(\"0\"))               return false;\n        throw new InputMismatchException();\n    }\n \n    public static String[] readAllStrings() {\n        // we could use readAll.trim().split(), but that's not consistent\n        // because trim() uses characters 0x00..0x20 as whitespace\n        String[] tokens = WHITESPACE_PATTERN.split(readAll());\n        if (tokens.length == 0 || tokens[0].length() > 0)\n            return tokens;\n \n        // don't include first token if it is leading whitespace\n        String[] decapitokens = new String[tokens.length-1];\n        for (int i = 0; i < tokens.length - 1; i++)\n            decapitokens[i] = tokens[i+1];\n        return decapitokens;\n    }\n \n    public static String[] readAllLines() {\n        ArrayList<String> lines = new ArrayList<String>();\n        while (hasNextLine()) {\n            lines.add(readLine());\n        }\n        return lines.toArray(new String[0]);\n    }\n \n    public static int[] readAllInts() {\n        String[] fields = readAllStrings();\n        int[] vals = new int[fields.length];\n        for (int i = 0; i < fields.length; i++)\n            vals[i] = Integer.parseInt(fields[i]);\n        return vals;\n    }\n \n    public static double[] readAllDoubles() {\n        String[] fields = readAllStrings();\n        double[] vals = new double[fields.length];\n        for (int i = 0; i < fields.length; i++)\n            vals[i] = Double.parseDouble(fields[i]);\n        return vals;\n    }\n    \n    static {\n        resync();\n    }\n \n    private static void resync() {\n        setScanner(new Scanner(new java.io.BufferedInputStream(System.in), CHARSET_NAME));\n    }\n    \n    private static void setScanner(Scanner scanner) {\n        StdIn.scanner = scanner;\n        StdIn.scanner.useLocale(LOCALE);\n    }\n \n    public static int[] readInts() {\n        return readAllInts();\n    }\n \n    public static double[] readDoubles() {\n        return readAllDoubles();\n    }\n \n    public static String[] readStrings() {\n        return readAllStrings();\n    }\n \n}\n \nfinal class StdOut {\n \n    private static final String CHARSET_NAME = \"UTF-8\";\n \n    private static final Locale LOCALE = Locale.US;\n \n    private static PrintWriter out;\n \n    static {\n        try {\n            out = new PrintWriter(new OutputStreamWriter(System.out, CHARSET_NAME), true);\n        }\n        catch (UnsupportedEncodingException e) { System.out.println(e); }\n    }\n \n    private StdOut() { }\n \n    public static void close() {\n        out.close();\n    }\n \n    public static void println() {\n        out.println();\n    }\n \n    public static void println(Object x) {\n        out.println(x);\n    }\n \n    public static void println(boolean x) {\n        out.println(x);\n    }\n \n    public static void println(char x) {\n        out.println(x);\n    }\n \n    public static void println(double x) {\n        out.println(x);\n    }\n \n    public static void println(float x) {\n        out.println(x);\n    }\n \n    public static void println(int x) {\n        out.println(x);\n    }\n \n    public static void println(long x) {\n        out.println(x);\n    }\n \n    public static void println(short x) {\n        out.println(x);\n    }\n \n    public static void println(byte x) {\n        out.println(x);\n    }\n \n    public static void print() {\n        out.flush();\n    }\n \n    public static void print(Object x) {\n        out.print(x);\n        out.flush();\n    }\n \n    public static void print(boolean x) {\n        out.print(x);\n        out.flush();\n    }\n \n    public static void print(char x) {\n        out.print(x);\n        out.flush();\n    }\n \n    public static void print(double x) {\n        out.print(x);\n        out.flush();\n    }\n \n    public static void print(float x) {\n        out.print(x);\n        out.flush();\n    }\n \n    public static void print(int x) {\n        out.print(x);\n        out.flush();\n    }\n \n    public static void print(long x) {\n        out.print(x);\n        out.flush();\n    }\n \n    public static void print(short x) {\n        out.print(x);\n        out.flush();\n    }\n \n    public static void print(byte x) {\n        out.print(x);\n        out.flush();\n    }\n \n    public static void printf(String format, Object... args) {\n        out.printf(LOCALE, format, args);\n        out.flush();\n    }\n \n    public static void printf(Locale locale, String format, Object... args) {\n        out.printf(locale, format, args);\n        out.flush();\n    }\n \n}", "label": 1}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Solution {\n    public static void main(String args[] ) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        String strs = br.readLine();\n        int maxCount = 0;\n        int count = 0;\n        \n        for (int i=0; i<strs.length(); i++) {\n            if (strs.charAt(i) != ' ') {\n                if (Character.isUpperCase(strs.charAt(i))) {\n                    count++;\n                }\n            }\n            else {\n                maxCount = Math.max(maxCount, count);\n                count = 0;\n            }\n        } \n        System.out.println(Math.max(maxCount, count));\n    }\n}", "label": 1}
{"src": "import java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint ans = 0;\n\t\tint n = sc.nextInt();\n\t\tint L = 0;\n\t\twhile (true) {\n\t\t\tif (L >= n)\n\t\t\t\tbreak;\n\t\t\tString s = sc.next();\n\t\t\tL += s.length() + 1;\n\t\t\tint cnt = 0;\n\t\t\tfor (char c : s.toCharArray()) {\n\t\t\t\tint num = (int) (c - 'A');\n\t\t\t\tif (0 <= num && num < 26) {\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.max(ans, cnt);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}", "label": 1}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.PrintStream;\nimport java.util.Scanner;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author captainTurtle\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            in.nextLine();\n            String[] str = in.nextLine().split(\" \");\n            int i, j, k = 0, max = 0;\n            for (i = 0; i < str.length; i++) {\n                k = 0;\n                for (j = 0; j < str[i].length(); j++) {\n                    if (Character.isUpperCase(str[i].charAt(j))) k++;\n                }\n                if (k > max) max = k;\n            }\n            System.out.println(max);\n        }\n\n    }\n}\n\n", "label": 1}
{"src": "readline();\nvar g = readline().split(\" \");\nvar arr = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\");\nvar count = 0;\nvar allCount = [];\nfor(i=0;i<g.length;i++){\n    for(b=0;b<g[i].length;b++){\n        for(j=0;j<arr.length;j++){\n            if(g[i][b] == arr[j]) count++;\n        }\n    }\n    if(count>allCount[0] || typeof allCount[0] == \"undefined\"){\n        allCount[0] = count;\n    }\n    count = 0;\n}\nprint(allCount[0]);", "label": 1}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\nimport javafx.util.Pair;\n\nimport java.awt.*;\nimport java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.math.*;\nimport java.util.regex.*;\n\npublic class Solution {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() throws FileNotFoundException {\n            InputStream inputStream = new FileInputStream(\"c:/Users/alex/code/HackerRank/JavaCode/input.txt\");\n            br = new BufferedReader(new\n                    InputStreamReader(inputStream));//System.in\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n\n    public static void main(String[] args) throws FileNotFoundException {\n        //freopen(\"c:/Users/alex/code/HackerRank/JavaCode/input.txt\", \"r\", stdin);\n        //FastReader in = new FastReader();\n        Scanner in = new Scanner(System.in);\n        /*Scanner in = null;\n        try {\n            in = new Scanner(new File(\"c:/Users/alex/code/HackerRank/JavaCode/input.txt\"));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }*/\n        int n = in.nextInt();\n        in.nextLine();\n        String ln=in.nextLine();\n        String[] lns=ln.split(\" \");\n        int vol=0;\n        for(int i=0;i<lns.length;i++){\n            //char[] st=lns[i].toCharArray();\n            String st=lns[i];\n            int cnt=0;\n            for(int j=0;j<st.length();j++){\n                char c=st.charAt(j);\n                if(c<91){\n                    cnt++;\n                }\n            }\n            if(cnt>vol){\n                vol=cnt;\n            }\n        }\n        System.out.println(vol);\n    }\n}\n", "label": 1}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\npublic class CF_837A \n{\n\tpublic static void main(String[] args) throws IOException\n\t\t{\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\t\t\tbr.readLine();\n\n\t\t\tint ans = 0, x = 0;\n\n\t\t\tString s[] = br.readLine().split(\" \");\n\n\t\t\tfor(int i = 0; i < s.length; i++)\n\t\t\t\t{\n\t\t\t\t\tx = 0;\n\t\t\t\t\tfor(int j = 0; j < s[i].length(); j++)\n\t\t\t\t\t\tif(s[i].charAt(j) >= 'A' && s[i].charAt(j) <= 'Z') x++;\n\t\t\t\t\tif(ans < x) ans = x;\n\t\t\t\t}\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n}", "label": 1}
{"src": "\nimport java.util.Scanner;\n\npublic class A837 {\n    public static void main(String[]args){\n        int maxAns=0;\n        \n        Scanner in = new Scanner(System.in);\n        int words = Integer.parseInt(in.nextLine());\n        String line = in.nextLine();\n        String[]lineToArr=line.split(\" \");\n        //asci\n        //System.out.println(lineToArr[0]);\n        //System.out.println(line);\n        for(int i=0;i<lineToArr.length;i++){\n            int answer=0;\n            char[]letters=lineToArr[i].toCharArray();\n            for(int j=0;j<letters.length;j++){\n                //System.out.println((int)letters[j]);\n                //System.out.println(letters[j]);\n                if((int)(letters[j])>64 && (int)(letters[j])<91){\n                    answer++;\n                }\n            }\n            //   System.out.println(answer);\n            if(answer>maxAns){maxAns=answer;}\n        }\n        System.out.println(maxAns);\n    }\n}\n", "label": 1}
{"src": "import java.math.BigInteger;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.io.*;\n\npublic class TestClass{\n\n    static class Parser\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Parser(InputStream in)\n        {\n            din = new DataInputStream(in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public long nextLong() throws Exception\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = c == '-';\n            if (neg) c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n                c = read();\n            } while (c > ' ');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        //reads in the next string\n        public String next() throws Exception\n        {\n            StringBuilder ret =  new StringBuilder();\n            byte c = read();\n            while (c <= ' ') c = read();\n            do\n            {\n                ret = ret.append((char)c);\n                c = read();\n            } while (c > ' ');\n            return ret.toString();\n        }\n\n        public int nextInt() throws Exception\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = c == '-';\n            if (neg) c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n                c = read();\n            } while (c > ' ');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws Exception\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n\n        private byte read() throws Exception\n        {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n    }\n    static class OutputWriter\n    {\n        private PrintWriter writer;\n\n        public OutputWriter(OutputStream stream)\n        {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(\n                    stream)));\n        }\n\n        public OutputWriter(Writer writer)\n        {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void println(int x)\n        {\n            writer.println(x);\n        }\n\n        public void print(int x)\n        {\n            writer.print(x);\n        }\n\n        public void println(char x)\n        {\n            writer.println(x);\n        }\n\n        public void print(char x)\n        {\n            writer.print(x);\n        }\n\n        public void println(int array[], int size)\n        {\n            for (int i = 0; i < size; i++)\n                println(array[i]);\n        }\n\n        public void print(int array[], int size)\n        {\n            for (int i = 0; i < size; i++)\n                print(array[i] + \" \");\n        }\n\n        public void println(long x)\n        {\n            writer.println(x);\n        }\n\n        public void print(long x)\n        {\n            writer.print(x);\n        }\n\n        public void println(long array[], int size)\n        {\n            for (int i = 0; i < size; i++)\n                println(array[i]);\n        }\n\n        public void print(long array[], int size)\n        {\n            for (int i = 0; i < size; i++)\n                print(array[i]);\n        }\n\n        public void println(float num)\n        {\n            writer.println(num);\n        }\n\n        public void print(float num)\n        {\n            writer.print(num);\n        }\n\n        public void println(double num)\n        {\n            writer.println(num);\n        }\n\n        public void print(double num)\n        {\n            writer.print(num);\n        }\n\n        public void println(String s)\n        {\n            writer.println(s);\n        }\n\n        public void print(String s)\n        {\n            writer.print(s);\n        }\n\n        public void println()\n        {\n            writer.println();\n        }\n\n        public void printSpace()\n        {\n            writer.print(\" \");\n        }\n\n        public void printf(String format, Object args)\n        {\n            writer.printf(format, args);\n        }\n\n        public void flush()\n        {\n            writer.flush();\n        }\n\n        public void close()\n        {\n            writer.close();\n        }\n\n    }\n    static int count[];\n    public static void main(String args[]) throws Exception {\n\n        Parser s = new Parser(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n       int N=s.nextInt();\n        char str[]=s.next().toCharArray();\n        char ch[]=new char[62];\n        int k=0;\n        int start_a=0;\n        for (int i = 0; i <26 ; i++) {\n            ch[k++]=(char)(i+'a');\n        }\n        int start_A=k;\n        for (int i = 0; i <26 ; i++) {\n            ch[k++]=(char)(i+'A');\n        }\n        int start_0=k;\n        for (int i = 0; i <10 ; i++) {\n            ch[k++]=(char)(i+'0');\n        }\n\n        count=new int[62];\n        for (int i = 0; i <str.length; i++) {\n            int x=str[i];\n            if(x>=48&&x<=57){\n                int y=str[i]-'0';\n                count[start_0+y]++;\n            }\n            else{\n                if(x>=65&&x<=90){\n                    int y=str[i]-'A';\n                    count[start_A+y]++;\n                }\n                else{\n                    int y=str[i]-'a';\n                    count[start_a+y]++;\n                }\n            }\n        }\n        int even=0;\n        int odd=0;\n        int even_count=0;\n        ArrayList<Character> list_even=new ArrayList<Character>();\n        ArrayList<Character> list_odd=new ArrayList<Character>();\n        for (int i = 0; i <62 ; i++) {\n            if(count[i]>0){\n                int x=count[i]%2;\n                if(x==0){\n                    even++;\n                even_count+=count[i];\n                    for (int j = 0; j <count[i] ; j++) {\n                        list_even.add(ch[i]);\n                    }\n                }\n                else{\n                    odd++;\n                even_count+=count[i];\n                even_count--;\n                    for (int j = 0; j <count[i]-1 ; j++) {\n                        list_even.add(ch[i]);\n                    }\n                    list_odd.add(ch[i]);\n                }\n            }\n        }\n        if(odd==0){\n            Deque<Character> ans=new LinkedList<>();\n            for (int i = 0; i <list_even.size() ; i++) {\n                ans.addFirst(list_even.get(i));\n                i++;\n                ans.addLast(list_even.get(i));\n            }\n            out.println(1);\n            while (ans.size()>0){\n                out.print(ans.poll()+\"\");\n            }\n        }\n        else {\n           // System.out.println(\"here\");\n            int pairs=even_count/2;\n            int ans=N;\n            for (int i = odd; i <=N ; i++) {\n              //  System.out.println(i+\" xx\");\n                if(N%i==0){\n                    int left=N/i;\n                    int sec=(N-i)/2;\n                    if(sec%i==0){\n                        ans=i;\n                        break;\n                    }\n                }\n            }\n            if(true){\n                int div=N/ans;\n             //   System.out.println(ans);\n                Deque<Character> arr[]=new LinkedList[ans];\n                for (int i = 0; i <ans ; i++) {\n                    arr[i]=new LinkedList<>();\n                }\n                int m=0;\n                for ( m = 0; m <list_odd.size() ; m++) {\n                    arr[m].addFirst(list_odd.get(m));\n                }\n              //  System.out.println(m);\n                int j=0;\n                while (m<ans){\n                  //  System.out.println(m+\" \"+j+\" \"+ans);\n                    arr[m++].addFirst(list_even.get(j++));\n                }\n                for (int f = 0; f < ans ; f++) {\n                for (int i = 0; i <(div-1)/2 ; i++) {\n                    arr[f].addFirst(list_even.get(j++));\n                    arr[f].addLast(list_even.get(j++));\n                }}\n                out.println(ans);\n                for (int i = 0; i <ans ; i++) {\n                    while (arr[i].size()>0){\n                        out.print(arr[i].poll()+\"\");\n                    }\n                  out.print(\" \");\n                }\n            }\n//            else{\n//                out.println(N);\n//                for (int i = 0; i <str.length ; i++) {\n//\n//                    out.print(str[i]+\" \");\n//                }\n//            }\n        }\n\nout.close();\n}}", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskH solver = new TaskH();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskH {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            in.readInt();\n            String s = in.next();\n            HashMap<Character, Integer> counts = new HashMap<>();\n            for (char c : s.toCharArray()) counts.merge(c, 1, Integer::sum);\n            // palandrome has at most one char with odd count\n            // can have at most 192 divisors, so 192 lengths to consider\n            for (int length = s.length(); length >= 1; length--) {\n                if (s.length() % length == 0) {\n                    if (length % 2 == 0) {\n                        boolean works = true;\n                        for (int val : counts.values()) if (val % 2 != 0) works = false;\n                        if (works) {\n                            char[][] res = worksEven(new HashMap<>(counts), length, s.length() / length);\n                            out.printLine(s.length() / length);\n                            for (char[] r : res) {\n                                out.print(r);\n                                out.print(\" \");\n                            }\n                            return;\n                        }\n                    } else {\n                        char[][] res = worksOdd(new HashMap<>(counts), length, s.length() / length);\n                        if (res != null) {\n                            out.printLine(s.length() / length);\n                            for (char[] r : res) {\n                                out.print(r);\n                                out.print(\" \");\n                            }\n                            return;\n                        }\n                    }\n                }\n            }\n            throw new RuntimeException();\n        }\n\n        private char[][] worksEven(HashMap<Character, Integer> counts, int length, int numStr) { // length of each one\n            char[][] res = new char[numStr][length];\n            int row = 0, col = 0;\n            for (char key : counts.keySet()) {\n                int times = counts.get(key);\n                outer:\n                while (times >= 2) {\n                    while (col >= length / 2) {\n                        row++;\n                        col = 0;\n//                    out.printLine(\"HERE\", key, row, numStr);\n                        if (row >= numStr) {\n                            break outer;\n                        }\n                    }\n                    if (row >= numStr) {\n                        break outer;\n                    }\n                    res[row][col] = res[row][length - col - 1] = key;\n                    col++;\n                    times -= 2;\n                }\n                counts.put(key, times);\n            }\n            return res;\n        }\n\n        private char[][] worksOdd(HashMap<Character, Integer> counts, int length, int numStr) { // length of each one\n            int odds = 0;\n            for (int val : counts.values()) if (val % 2 != 0) odds++;\n            if (odds > numStr) return null;\n            char[][] res = worksEven(counts, length, numStr);\n            int row = 0;\n            for (char key : counts.keySet()) {\n                for (int iter = 0; iter < counts.get(key); iter++) {\n                    while (res[row][length / 2] != 0) row++;\n                    res[row++][length / 2] = key;\n                }\n            }\n            if (row != numStr) {\n                throw new RuntimeException(row + \" \" + numStr);\n            }\n            return res;\n        }\n    }\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void print(char[] array) {\n            writer.print(array);\n        }\n\n        public void print(Object... objects) {\n            for (int i = 0; i < objects.length; i++) {\n                if (i != 0) {\n                    writer.print(' ');\n                }\n                writer.print(objects[i]);\n            }\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(int i) {\n            writer.println(i);\n        }\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}\n\n", "label": 3}
{"src": "import java.io.*;\nimport java.security.SecureRandom;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws FileNotFoundException {\n        ConsoleIO io = new ConsoleIO(new InputStreamReader(System.in), new PrintWriter(System.out));\n        //String test = \"D-large\";\n        //ConsoleIO io = new ConsoleIO(new FileReader(\"D:\\\\Dropbox\\\\code\\\\practice\\\\jb\\\\src\\\\\" + test + \".in\"), new PrintWriter(new File(\"D:\\\\Dropbox\\\\code\\\\practice\\\\jb\\\\src\\\\\" + test + \"-out.txt\")));\n\n       new Main(io).solve();\n\n        io.close();\n    }\n\n    ConsoleIO io;\n    Main(ConsoleIO io) {\n        this.io = io;\n    }\n\n    List<List<Integer>> gr = new ArrayList<>();\n    long MOD = 998_244_353;\n\n    public void solve() {\n        int n = Integer.parseInt(io.readLine());\n        char[] s = io.readLine().toCharArray();\n        int[] count = new int[62];\n        char[] lets = new char[62];\n        for(int i = 0;i<62;i++){\n            if(i<10) lets[i] =(char)('0'+i);\n            else if(i<36)lets[i] = (char)('a'+i-10);\n            else lets[i] = (char)('A' + i - 36);\n        }\n        for (int i = 0; i < n; i++) {\n            int v = s[i] >= 'A' && s[i] <= 'Z' ? s[i] - 'A' + 36 : (s[i] >= 'a' && s[i] <= 'z' ? s[i] - 'a' + 10 : s[i] - '0');\n            count[v]++;\n        }\n        int odds = 0;\n        for (int i = 0; i < 62; i++)\n            odds += count[i] % 2;\n\n        int parts = 1;\n        for(;parts<n;parts++){\n            if(n%parts==0) {\n                int c = (n / parts) % 2 == 0 ? 0 : parts;\n                if(odds<=c){\n                    break;\n                }\n            }\n        }\n\n        List<String> res = new ArrayList<>();\n        int k = 0;\n\n        char[][] all = new char[parts][];\n        for(int i = 0;i<parts;i++) {\n            char[] y = new char[n / parts];\n            int left = 0, right = y.length - 1;\n            while (left < right) {\n                if (count[k] < 2) {\n                    k++;\n                } else {\n                    count[k] -= 2;\n                    y[left++] = lets[k];\n                    y[right--] = lets[k];\n                }\n            }\n            all[i] = y;\n        }\n\n        k = 0;\n        for(int i = 0;i<parts;i++) {\n            char[] y = all[i];\n            if (y.length % 2 == 1) {\n                int q = y.length / 2;\n                while (count[k] == 0) k++;\n                y[q] = lets[k];\n                count[k]--;\n            }\n        }\n\n        io.writeLine(parts + \"\");\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0;i<parts;i++) {\n            if (i > 0) sb.append(' ');\n            sb.append(all[i]);\n        }\n        io.writeLine(sb.toString());\n    }\n\n}\n\nclass ConsoleIO {\n    BufferedReader br;\n    PrintWriter out;\n    public ConsoleIO(Reader reader, PrintWriter writer){br = new BufferedReader(reader);out = writer;}\n    public void flush(){this.out.flush();}\n    public void close(){this.out.close();}\n    public void writeLine(String s) {this.out.println(s);}\n    public void writeInt(int a) {this.out.print(a);this.out.print(' ');}\n    public void writeWord(String s){\n        this.out.print(s);\n    }\n    public void writeIntArray(int[] a, int k, String separator) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < k; i++) {\n            if (i > 0) sb.append(separator);\n            sb.append(a[i]);\n        }\n        this.writeLine(sb.toString());\n    }\n    public int read(char[] buf, int len){try {return br.read(buf,0,len);}catch (Exception ex){ return -1; }}\n    public String readLine() {try {return br.readLine();}catch (Exception ex){ return \"\";}}\n    public long[] readLongArray() {\n        String[]n=this.readLine().trim().split(\"\\\\s+\");long[]r=new long[n.length];\n        for(int i=0;i<n.length;i++)r[i]=Long.parseLong(n[i]);\n        return r;\n    }\n    public int[] readIntArray() {\n        String[]n=this.readLine().trim().split(\"\\\\s+\");int[]r=new int[n.length];\n        for(int i=0;i<n.length;i++)r[i]=Integer.parseInt(n[i]);\n        return r;\n    }\n    public int[] readIntArray(int n) {\n        int[] res = new int[n];\n        char[] all = this.readLine().toCharArray();\n        int cur = 0;boolean have = false;\n        int k = 0;\n        boolean neg = false;\n        for(int i = 0;i<all.length;i++){\n            if(all[i]>='0' && all[i]<='9'){\n                cur = cur*10+all[i]-'0';\n                have = true;\n            }else if(all[i]=='-') {\n                neg = true;\n            }\n            else if(have){\n                res[k++] = neg?-cur:cur;\n                cur = 0;\n                have = false;\n                neg = false;\n            }\n        }\n        if(have)res[k++] = neg?-cur:cur;\n        return res;\n    }\n    public int ri() {\n        try {\n            int r = 0;\n            boolean start = false;\n            boolean neg = false;\n            while (true) {\n                int c = br.read();\n                if (c >= '0' && c <= '9') {\n                    r = r * 10 + c - '0';\n                    start = true;\n                } else if (!start && c == '-') {\n                    start = true;\n                    neg = true;\n                } else if (start || c == -1) return neg ? -r : r;\n            }\n        } catch (Exception ex) {\n            return -1;\n        }\n    }\n    public long readLong() {\n        try {\n            long r = 0;\n            boolean start = false;\n            boolean neg = false;\n            while (true) {\n                int c = br.read();\n                if (c >= '0' && c <= '9') {\n                    r = r * 10 + c - '0';\n                    start = true;\n                } else if (!start && c == '-') {\n                    start = true;\n                    neg = true;\n                } else if (start || c == -1) return neg ? -r : r;\n            }\n        } catch (Exception ex) {\n            return -1;\n        }\n    }\n    public String readWord() {\n        try {\n            boolean start = false;\n            StringBuilder sb = new StringBuilder();\n            while (true) {\n                int c = br.read();\n                if (c!= ' ' && c!= '\\r' && c!='\\n' && c!='\\t') {\n                    sb.append((char)c);\n                    start = true;\n                } else if (start || c == -1) return sb.toString();\n            }\n        } catch (Exception ex) {\n            return \"\";\n        }\n    }\n    public char readSymbol() {\n        try {\n            while (true) {\n                int c = br.read();\n                if (c != ' ' && c != '\\r' && c != '\\n' && c != '\\t') {\n                    return (char) c;\n                }\n            }\n        } catch (Exception ex) {\n            return 0;\n        }\n    }\n    //public char readChar(){try {return (char)br.read();}catch (Exception ex){ return 0; }}\n}\nclass Pair {\n    public Pair(int a, int b) {this.a = a;this.b = b;}\n    public int a;\n    public int b;\n}\nclass PairLL {\n    public PairLL(long a, long b) {this.a = a;this.b = b;}\n    public long a;\n    public long b;\n}\nclass Triple {\n    public Triple(int a, int b, int c) {this.a = a;this.b = b;this.c = c;}\n    public int a;\n    public int b;\n    public int c;\n}", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author pandusonu\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskH solver = new TaskH();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskH {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.readInt();\n            String s = in.readString();\n            HashMap<Integer, Integer> hash = new HashMap<>();\n            for (char c : s.toCharArray()) {\n                int x = (int) c;\n                if (!hash.containsKey(x))\n                    hash.put(x, 0);\n                hash.put(x, hash.get(x) + 1);\n            }\n            int count = 0;\n            int[][] a = new int[hash.size()][2];\n            int tmp = 0;\n            for (Map.Entry<Integer, Integer> entry : hash.entrySet()) {\n                a[tmp][0] = entry.getKey();\n                a[tmp][1] = entry.getValue();\n                if (a[tmp][1] % 2 == 1)\n                    count++;\n                tmp++;\n            }\n            if (count == 0) {\n                StringBuilder back = new StringBuilder(\"\");\n                out.println(1);\n                for (int i = 0; i < hash.size(); i++) {\n                    for (int j = 0; j < a[i][1] / 2; j++) {\n                        out.print((char) a[i][0]);\n                        back.append((char) a[i][0]);\n                    }\n                }\n                out.print(back.reverse());\n                return;\n            }\n            int ansSize = count;\n            while (n%ansSize != 0 || (n/ansSize)%2==0) \n                ansSize +=2;\n            if (ansSize == n || ansSize == -1) {\n                out.println(n);\n                for (int i = 0; i < n; i++) {\n                    out.print(s.charAt(i) + \" \");\n                }\n                return;\n            }\n            int size = n / ansSize;\n            StringBuilder[][] ans = new StringBuilder[ansSize][2];\n            for (int i = 0; i < ansSize; i++) {\n                ans[i][0] = new StringBuilder(\"\");\n                ans[i][1] = new StringBuilder(\"\");\n            }\n            outer:\n            for (int i = 0; i < count; i++) {\n                for (int j = 0; j < hash.size(); j++) {\n                    if (a[j][1] % 2 == 1) {\n                        ans[i][1].append((char) a[j][0]);\n                        a[j][1]--;\n                        continue outer;\n                    }\n                }\n            }\n            outer:\n            for (int i = count; i < ansSize; i++) {\n                for (int j = 0; j < hash.size(); j++) {\n                    if (a[j][1] > 0) {\n                        a[j][1]--;\n                        ans[i][1].append((char) a[j][0]);\n                        continue outer;\n                    }\n                }\n            }\n            outer:\n            for (int i = 0; i < ansSize; i++) {\n                int pos = ans[i][0].length() + ans[i][1].length();\n                for (int j = 0; j < hash.size(); j++) {\n                    if (pos == size) continue outer;\n                    int added = 0;\n                    for (int k = 0; k < a[j][1] / 2; k++) {\n                        if (pos == size) break;\n                        ans[i][0].append((char) a[j][0]);\n                        ans[i][1].append((char) a[j][0]);\n                        pos += 2;\n                        added += 2;\n                    }\n                    a[j][1] -= added;\n                    if (pos == size) continue outer;\n                }\n            }\n            out.println(ansSize);\n            for (int i = 0; i < ansSize; i++) {\n                ans[i][0].reverse();\n                out.print(ans[i][0] + \"\" + ans[i][1] + \" \");\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int read() {\n            try {\n                if (curChar >= numChars) {\n                    curChar = 0;\n                    numChars = stream.read(buf);\n                    if (numChars <= 0)\n                        return -1;\n                }\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            return (int) readLong();\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n                if (c == -1) throw new RuntimeException();\n            }\n            boolean negative = false;\n            if (c == '-') {\n                negative = true;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res *= 10;\n                res += (c - '0');\n                c = read();\n            } while (!isSpaceChar(c));\n            return negative ? (-res) : (res);\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n \nimport static java.lang.Math.*;\n \npublic class Main implements Runnable\n{\n\tstatic class InputReader\n\t{\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\t\tprivate BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\t\t\n\t\tpublic int read()\n\t\t{\n\t\t\tif (numChars==-1) \n\t\t\t\tthrow new InputMismatchException();\n\t\t\t\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t}\n\t\t\t\tcatch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\t \n\t\tpublic String nextLine()\n\t\t{\n\t\t\tString str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n\t\t}\n\t\tpublic int nextInt()\n\t\t{\n\t\t\tint c = read();\n\t\t\t\n\t\t\twhile(isSpaceChar(c)) \n\t\t\t\tc = read();\n\t\t\t\n\t\t\tint sgn = 1;\n\t\t\t\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic long nextLong() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\t\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic double nextDouble() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') \n\t\t\t{\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') \n\t\t\t{\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t{\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic String readString() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\n\t\t\treturn res.toString();\n\t\t}\n\t \n\t\tpublic boolean isSpaceChar(int c) \n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t \n\t\tpublic String next() \n\t\t{\n\t\t\treturn readString();\n\t\t}\n\t\t\n\t\tpublic interface SpaceCharFilter \n\t\t{\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n \t\n\tpublic static void main(String args[]) throws Exception\n\t{\n\t\tnew Thread(null, new Main(),\"Main\",1<<26).start();\n\t}\t\n    \n    long querySegTree(int low, int high, int pos, int l, int r)\n    {\n        if(low >= l && high <= r)\n            return segTree[pos];\n            \n        if(low > r || high < l)\n            return Long.MAX_VALUE;\n       \n        int mid = (low + high) >> 1;\n        \n        long val1 = querySegTree(low, mid, 2 * pos + 1, l, r);\n        long val2 = querySegTree(mid + 1, high, 2 * pos + 2, l, r);\n        return min(val1, val2);\n    }\n    \n    void updateSegTree(int low, int high, int pos, int ind, long val)\n    {\n        if(low > ind || high < ind)\n            return;\n        if(low == high)\n        {\n            segTree[pos] = val;\n            return;\n        }\n        int mid = (low + high) >> 1;\n        updateSegTree(low, mid, 2 * pos + 1, ind, val);\n        updateSegTree(mid + 1, high, 2 * pos + 2, ind, val);\n        segTree[pos] = min(segTree[2 * pos + 1], segTree[2 * pos + 2]);\n    }\n    \n    long segTree[];\n\t\n    public void run()\n\t{\n\t\tInputReader sc = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n        \n        int n = sc.nextInt();\n        char s[] = sc.next().toCharArray();\n        \n        int freq[] = new int[150];\n        for(int i = 0; i < n; ++i)\n        {\n            freq[s[i]]++;\n        }\n        \n        int oddcnt = 0;\n        for(int i = 0; i < 150; ++i)\n        {\n            if(freq[i] % 2 == 1)\n                oddcnt++;\n        }     \n        \n        if(oddcnt == 0 || oddcnt == 1)\n        {\n            w.println(\"1\");\n            char ans[] = new char[n];\n            int cur = 0;\n            for(int i = 0; i < 150; ++i)\n            {\n                while(freq[i] > 1)\n                {\n                    ans[cur] = (char)(i);\n                    ans[n - 1 - cur] = (char)(i);\n                    cur++;\n                    freq[i] -= 2;\n                }\n            }\n            for(int i = 0; i < 150; ++i)\n            {\n                if(freq[i] == 1)\n                    ans[cur] = (char)(i);\n            }\n            w.print(ans);\n        }\n        else\n        {\n            int extoddcnt = 0;\n            while(n % (oddcnt + extoddcnt) != 0 || (n / (oddcnt + extoddcnt) % 2 == 0))\n                extoddcnt += 2;\n            w.println((oddcnt + extoddcnt));\n            int size = n / (oddcnt + extoddcnt);\n            char parts[][] = new char[oddcnt + extoddcnt][size];\n            int poss = size / 2;\n            for(int i = 0; i < oddcnt + extoddcnt; ++i)\n            {\n                int alr = 0;\n                int cur = 0;\n                for(int j = 0; j < 150; ++j)\n                {\n                    while(freq[j] > 1 && alr < poss)\n                    {\n                        alr++;\n                        freq[j] -= 2;\n                        parts[i][cur] = (char)(j);\n                        parts[i][size - 1 - cur] = (char)(j);\n                        cur++;\n                    }\n                }\n                    int flag = 0;\n                    for(int j = 0; j < 150; ++j)\n                    {\n                        if(freq[j] % 2 == 1)\n                        {\n                            parts[i][cur] = (char)(j);\n                            flag = 1;\n                            freq[j]--;\n                            break;\n                        }\n                    }\n                    if(flag == 0)\n                    {\n                        for(int j = 0; j < 150; ++j)\n                        {\n                           if(freq[j] > 0)\n                           {\n                                freq[j]--;\n                                parts[i][cur] = (char)(j);\n                                break;\n                           }\n                        }\n                    }\n                }\n                \n                for(int i = 0; i < oddcnt + extoddcnt; ++i)\n                w.print(new String(parts[i]) + \" \");\n            }\n\t\tw.close();\n\t}\n}", "label": 3}
{"src": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class H {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        String word = sc.next();\n\n\n        Map<Character, Integer> count = new HashMap<>();\n        for (Character c : word.toCharArray()) {\n            count.put(c, count.getOrDefault(c, 0) + 1);\n        }\n\n\n        int k = solveK(n, count);\n        System.out.println(k);\n\n        StringBuilder res = new StringBuilder();\n\n        for(int i = 0; i < k; i++) res.append(construct(n / k, count)).append(\" \");\n\n        System.out.println(res);\n\n    }\n\n    private static String construct(int len, Map<Character, Integer> count) {\n        StringBuilder res = new StringBuilder();\n        if(len % 2 == 0){\n            for(int i = 0; i < len / 2; i++){\n                for(Character key: count.keySet()){\n                    if(count.get(key) > 0) {\n                        count.put(key, count.get(key) - 2);\n                        res.append(key);\n                        break;\n                    }\n                }\n            }\n        }\n        else {\n            for(int i = 0; i < len / 2; i++){\n                for(Character key: count.keySet()){\n                    if(count.get(key) >= 2) {\n                        count.put(key, count.get(key) - 2);\n                        res.append(key);\n                        break;\n                    }\n                }\n            }\n\n            boolean find = false;\n            for(Character key: count.keySet()){\n                if(count.get(key) % 2 == 1) {\n                    res.append(key);\n                    count.put(key, count.get(key) - 1);\n                    find = true;\n                    break;\n                }\n            }\n            if(!find){\n                for(Character key: count.keySet()){\n                    if(count.get(key) > 0 ) {\n                        res.append(key);\n                        count.put(key, count.get(key) - 1);\n                        break;\n                    }\n                }\n            }\n        }\n\n        for(int i = 0; i < len / 2; i++){\n            res.append(res.charAt(len / 2 - i - 1));\n        }\n\n        return res.toString();\n    }\n\n    private static int solveK(int n, Map<Character, Integer> count) {\n        int odd = 0;\n\n        for (int x : count.values()) {\n            if (x % 2 == 1) odd += 1;\n        }\n        for (int k = 1; k <= n; k++) {\n            if (n % k != 0) continue;\n\n            int len = n / k;\n            if (len % 2 == 0 && odd == 0) return k;\n            if (len % 2 == 0 && odd != 0) continue;\n\n            if(k < odd) continue;\n            if(k == odd) return k;\n\n            if( (k - odd) % 2 == 0) return k;\n\n        }\n\n        return n;\n    }\n}\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\n\npublic class H_ {\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\t\n\t\tint n = sc.nextInt();\n\t\tchar[] s = sc.next().toCharArray();\n\t\tint[] cnt = new int[128];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tcnt[s[i]]++;\n\t\t\n\t\tint cntEven = 0;\n\t\tboolean allEven = true;\n\t\tfor (int i = 0; i < cnt.length; i++) {\n\t\t\tif(cnt[i]%2 == 1)\n\t\t\t{\n\t\t\t\tallEven = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tArrayList<Character> fill = new ArrayList<Character>();\n\t\tArrayList<Character> pal = new ArrayList<Character>();\n\t\tfor (int i = 0; i < 128; i++) {\n\t\t\tif(cnt[i] % 2 == 1)\n\t\t\t{\n\t\t\t\tpal.add((char)i);\n\t\t\t\tcnt[i]--;\n\t\t\t}\n\t\t\tcntEven += cnt[i];\n\t\t\tfor (int j = 0; j < cnt[i]; j++) {\n\t\t\t\tfill.add((char)i);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tif(pal.size() == 0)\n\t\t{\n\t\t\tCollections.sort(fill);\n\t\t\tint ind = 0;\n\t\t\tpw.println(1);\n\t\t\tStringBuilder pre = new StringBuilder(\"\");\n\t\t\tStringBuilder suf = new StringBuilder(\"\");\n\t\t\tfor (int i = 0; i < n/2; i++) {\n\t\t\t\tpre.append(fill.get(ind++));\n\t\t\t\tsuf.append(fill.get(ind++));\n\t\t\t}\n\t\t\tpw.print(pre);\n\t\t\tpw.print(suf.reverse());\n\t\t\tpw.println();\n\t\t\tpw.flush();\n\t\t\tpw.close();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\t\n\t\tint pals = pal.size();\n\t\tint ans = 0;\n\t\tfor (int l = 1; l <= n; l+=2) {\n\t\t\tint rem = cntEven - (l-1)*pals;\n\t\t\tif(rem < 0)\n\t\t\t\tcontinue;\n\t\t\tif(rem % l == 0)\n\t\t\t\tans = l;\n\t\t}\n\t\t\n\t\tCollections.sort(fill);\n\t\tint ind = 0;\n\t\tint words = n/ans;\n\t\tint others = words - pal.size();\n\t\tfor (int i = 0; i < others; i+=2) {\n\t\t\tpal.add(fill.get(ind++));\n\t\t\tpal.add(fill.get(ind++));\n\t\t}\n\t\tpw.println(words);\n\t\tfor (int i = 0; i < pal.size(); i++) {\n\t\t\tStringBuilder pre = new StringBuilder();\n\t\t\tStringBuilder suf = new StringBuilder();\n\t\t\tfor (int j = 0; j < (ans-1)/2; j++) {\n\t\t\t\tpre.append(fill.get(ind++));\n\t\t\t\tsuf.append(fill.get(ind++));\n\t\t\t}\n\t\t\t\n\t\t\tpw.print(pre);\n\t\t\tpw.print(pal.get(i));\n\t\t\tpw.print(suf.reverse());\n\t\t\tif(i != pal.size()-1)\n\t\t\t\tpw.print(\" \");\n\t\t}\n\t\tpw.println();\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\t\n\tstatic class Scanner\n\t{\n\t\tBufferedReader br; StringTokenizer st;\n\t\tpublic Scanner()\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tpublic String next() throws IOException\n\t\t{\n\t\t\twhile(st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int nextInt() throws IOException\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() throws IOException\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t}\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Q1 {\n\t\n\tstatic InputReader in=new InputReader(System.in);\n\tstatic PrintWriter out=new PrintWriter(System.out);\n\tstatic int T=1,N,M;\n\tstatic int A[];\n \tstatic int dp[][];\n\tstatic ArrayList<Integer> graph[];\n\tpublic static void main(String args[])\n\t{\n\t\t//T=in.readInt();\n\t\tint i,j,k;\n\t\twhile(T-->0)\n\t\t{\n \t\t\tN=in.readInt();\n\t\t\tString S=in.readString();\n\t\t\tHashMap<Character,Integer> map = new HashMap<Character,Integer>();\n\t\t\tint co=0,ce=0;\n\t\t\tfor(i=0;i<N;i++)\n\t\t\t{\n\t\t\t\tif(map.containsKey(S.charAt(i)))\n\t\t\t\t\tmap.put(S.charAt(i),map.get(S.charAt(i))+1);\n\t\t\t\telse \n\t\t\t\t    map.put(S.charAt(i),1);\n\t\t\t}\n\t\t\tIterator itr = map.entrySet().iterator();\n\t\t\tStack<Character> sto = new Stack<Character>();\n\t\t\tStack<Character> ste = new Stack<Character>();\n\t\t\twhile(itr.hasNext())\n\t\t\t{\n\t\t\t\tMap.Entry<Character,Integer> ent = (Map.Entry)itr.next();\n\t\t\t\tchar key = (char)ent.getKey();\n\t\t\t\tint val = (int)ent.getValue();\n\t\t\t\tif(val%2==0){\n\t\t\t\t\twhile(val!=0)\n\t\t\t\t\t{\t\n\t\t\t\t\t\tce++;\n\t\t\t\t\t\tste.push(key);\n\t\t\t\t\t\tval-=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{ \n\t\t\t\t\tco++;\n\t\t\t\t\tsto.push(key);\n\t\t\t\t\tval-=1;\n\t\t\t\t\twhile(val!=0)\n\t\t\t\t\t{\n\t\t\t\t\t\tste.push(key);\n\t\t\t\t\t\tce++;\n\t\t\t\t\t\tval-=2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\titr.remove();\n\t\t\t}\n\t\t\t//out.println(co+\" \"+ce);\n\t\t\tif(co==0)\n\t\t\t{\n\t\t\t\tout.println(1);\n\t\t\t\tStack rev=new Stack();\n\t\t\t\twhile(!ste.isEmpty())\n\t\t\t\t{\n\t\t\t\t\trev.push(ste.peek());\n\t\t\t\t\tout.print(ste.pop());\n\t\t\t\t}\n\t\t\t\twhile(!rev.isEmpty())\n\t\t\t\t{\n\t\t\t\t\tout.print(rev.pop());\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tint temp=0,len=-1;\n\t\t\t\t//out.println(ce+\" \"+co);\n\t\t\t\tfor(i=co;i<N;i+=2)\n\t\t\t\t{\n\t\t\t\t\tif((ce-temp)>=i&&(ce-temp)%i==0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlen=i;\n\t\t\t\t\t\twhile(temp!=0){\n\t\t\t\t\t\tsto.push(ste.peek());\n\t\t\t\t\t\tsto.push(ste.pop());temp--;}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttemp++;\n\t\t\t\t}\n\t\t\t//\tout.println(sto.count());\n\t\t\t//\tout.println(ste.count());\n\t\t\t\tif(len!=-1){\n\t\t\t\t\tout.println(len);\n\t\t\t\t\twhile(!sto.isEmpty())\n\t\t\t\t\t{\n\t\t\t\t\t\tStack rev=new Stack();\n\t\t\t\t\t\tint tp=0;\n\t\t\t\t//\t\tout.println((N/len)/2);\n\t\t\t\t\t\twhile(tp++<(N/len)/2)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trev.push(ste.peek());\n\t\t\t\t\t\t\tout.print(ste.pop());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout.print(sto.pop());\n\t\t\t\t\t\twhile(!rev.isEmpty())\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tout.print(rev.pop());\n\t\t\t\t\t\t}\n\t\t\t\t\t\tout.print(\" \");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tout.println(N);\n\t\t\t\t\tfor(i=0;i<N;i++)\n\t\t\t\t\t\tout.print(S.charAt(i)+\" \");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\tpublic static void printI0(int a[],int n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tout.println(a[i]);\n\t\t}\n\t}\n\tpublic static void printI1(int a[],int n)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tout.println(a[i]);\n\t\t}\n\t}\t\n\tpublic static void printL0(long a[],int n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tout.println(a[i]);\n\t\t}\n\t}\n\tpublic static void printL1(long a[],int n)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tout.println(a[i]);\n\t\t}\n\t}\n\tpublic static void initializeGraph(int n)\n\t{\n\t\tgraph=new ArrayList[n+1];\n\t\tfor(int i=0;i<=n;i++)\n\t\t\tgraph[i]=new ArrayList<Integer>();\n\t}\n}\nclass Pair{\n\tchar x;\n\tint y;\n\tpublic Pair(char x,int y)\n\t{\n\t\tthis.x=x;\n\t\tthis.y=y;\n\t}\n}\nclass InputReader{\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar;\n\tprivate int numChars;\n\tprivate SpaceCharFilter filter;\n\n\tpublic InputReader(InputStream stream){this.stream = stream;}\n\tpublic int read(){\n\t\tif (numChars==-1) throw new InputMismatchException();\n\t\tif (curChar >= numChars){\n\t\t\tcurChar = 0;\n\t\t\ttry {numChars = stream.read(buf);}\n\t\t\tcatch (IOException e){throw new InputMismatchException();}\n\t\t\tif(numChars <= 0) return -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic int readInt(){\n\t\tint c = read();\n\t\twhile(isSpaceChar(c)) c = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {sgn = -1;c = read();}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif(c<'0'||c>'9') throw new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t}\n\t\twhile (!isSpaceChar(c)); return res * sgn;\n\t}\n\tpublic void inputI0(int a[],int n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t\ta[i]=readInt();\n\t}\n\tpublic void inputI1(int a[],int n)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\ta[i]=readInt();\n\t}\n\tpublic long readLong() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n      }\n\t\tlong res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n      }\n\t\twhile (!isSpaceChar(c));\n          return res * sgn;\n  }\n\tpublic void inputL0(long a[],int n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t\ta[i]=readLong();\n\t}\n\tpublic void inputL1(long a[],int n)\n\t{\n\t\tfor(int i=1;i<=n;i++)\n\t\t\ta[i]=readLong();\n\t}\n\tpublic double readDouble() {\n      int c = read();\n      while (isSpaceChar(c))\n          c = read();\n      int sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n      }\n\t\tdouble res = 0;\n\t\twhile (!isSpaceChar(c) && c != '.') {\n\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n      }\n\t\tif (c == '.') {\n\t\t\tc = read();\n\t\t\tdouble m = 1;\n\t\t\twhile (!isSpaceChar(c)) {\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, readInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tm /= 10;\n\t\t\t\tres += (c - '0') * m;\n\t\t\t\tc = read();\n          }\n      }\n\t\treturn res * sgn;\n  }\n\n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tpublic boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\tpublic String next() {\n\t\treturn readString();\n\t}\n\n\tpublic interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.util.Map.Entry;\nimport java.lang.Math;\nimport java.math.BigInteger;\n\npublic class Problem {\n\n\tint INF = -1000 * 1000 * 1000 - 100;\n\n\tTreeMap<Character, Integer> count = new TreeMap<Character, Integer>();\n\tTreeSet<Character> odds = new TreeSet<Character>();\n\tint n;\n\n\tvoid solve() throws IOException {\n\n\t\tn = rI();\n\t\tchar[] s = rS().toCharArray();\n\n\t\tfor (char c : s) {\n\t\t\tif (count.containsKey(c)) {\n\t\t\t\tint val = count.get(c);\n\t\t\t\tcount.put(c, val + 1);\n\t\t\t\tif (val % 2 == 0)\n\t\t\t\t\todds.add(c);\n\t\t\t\telse\n\t\t\t\t\todds.remove(c);\n\t\t\t} else {\n\t\t\t\tcount.put(c, 1);\n\t\t\t\todds.add(c);\n\t\t\t}\n\t\t}\n\n\t\tList<Integer> divs = new ArrayList<>();\n\n\t\tfor (int i = 1; i * i <= n; ++i) {\n\t\t\tif (n % i == 0) {\n\t\t\t\tdivs.add(i);\n\t\t\t\tdivs.add(n / i);\n\t\t\t}\n\t\t}\n\n\t\tCollections.sort(divs);\n\t\tCollections.reverse(divs);\n\n\t\tfor (int i : divs) {\n\t\t\tArrayList<ArrayDeque<Character>> outp = new ArrayList<>();\n\t\t\tif (test(outp, i)) {\n\t\t\t\tout.println(n / i);\n\t\t\t\tfor (ArrayDeque<Character> st : outp) {\n\t\t\t\t\twhile(st.size() > 0){\n\t\t\t\t\t\tout.print(st.pop());\n\t\t\t\t\t}\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tboolean test(ArrayList<ArrayDeque<Character>> out, int del) {\n\t\tSet<Character> cop = (TreeSet<Character>) odds.clone();\n\t\tMap<Character, Integer> cop2 = (Map<Character, Integer>) count.clone();\n\t\tif (del % 2 == 1) {\n\t\t\tif(n/del < cop.size()) return false;\n\t\t\tfor (Character c : cop) {\n\t\t\t\tArrayDeque<Character> hjrht = new ArrayDeque<Character>();\n\t\t\t\thjrht.add(c);\n\t\t\t\tout.add(hjrht);\n\t\t\t\tcop2.put(c, cop2.get(c) - 1);\n\t\t\t\tif (cop2.get(c) == 0)\n\t\t\t\t\tcop2.remove(c);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n / del - cop.size(); ++i) {\n\t\t\t\tCharacter some = (char) cop2.keySet().toArray()[0];\n\t\t\t\tArrayDeque<Character> bijhe = new ArrayDeque<Character>();\n\t\t\t\tbijhe.add(some);\n\t\t\t\tout.add(bijhe);\n\t\t\t\tcop2.put(some, cop2.get(some) - 1);\n\t\t\t\tif (cop2.get(some) == 0)\n\t\t\t\t\tcop2.remove(some);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int i = 0; i < n / del; ++i)\n\t\t\t\tout.add(new ArrayDeque<Character>());\n\t\t}\n\n\t\treturn deepTest(out, del, cop, cop2);\n\t}\n\n\tboolean deepTest(ArrayList<ArrayDeque<Character>> out, int del, Set<Character> odds, Map<Character, Integer> count) {\n\t\tint level = 0;\n\t\twhile (!count.isEmpty()) {\n\t\t\tchar some = (char) count.keySet().toArray()[0];\n\t\t\tint cnt = count.get(some);\n\t\t\tif (cnt < 2)\n\t\t\t\treturn false;\n\t\t\t\n\t\t\tout.get(level).addFirst(some);\n\t\t\tout.get(level).addLast(some);\n\t\t\tcount.put(some, cnt - 2);\n\t\t\tif (cnt == 2)\n\t\t\t\tcount.remove(some);\n\t\t\tif (level == out.size() - 1)\n\t\t\t\tlevel = 0;\n\t\t\telse\n\t\t\t\tlevel++;\n\t\t}\n\t\tif (level != 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Problem().run();\n\t}\n\n\tboolean isLower(char a) {\n\t\treturn ((int) a) >= 97 ? true : false;\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer tok;\n\tRandom rnd = new Random();\n\tstatic final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tProblem() throws FileNotFoundException {\n\n\t\tif (ONLINE_JUDGE) {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t} else {\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new PrintWriter(\"output.txt\");\n\t\t}\n\t\ttok = new StringTokenizer(\"\");\n\t}\n\n\tlong checkBit(long mask, int bit) {\n\t\treturn (mask >> bit) & 1;\n\t}\n\n\t// ======================================================\n\n\t// ======================================================\n\tvoid run() throws IOException {\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\tchar[] reverseCharArray(char[] arr) {\n\t\tchar[] ans = new char[arr.length];\n\t\tfor (int i = 0; i < arr.length; ++i) {\n\t\t\tans[i] = arr[arr.length - i - 1];\n\t\t}\n\t\treturn ans;\n\t}\n\n\tint sqrt(double m) {\n\t\tint l = 0;\n\t\tint r = 1000000000 + 9;\n\t\tint i = 1000;\n\t\twhile (r - l > 1) {\n\t\t\tint mid = (r + l) / 2;\n\t\t\tif (mid * mid > m) {\n\t\t\t\tr = mid;\n\t\t\t} else {\n\t\t\t\tl = mid;\n\t\t\t}\n\t\t}\n\t\treturn l;\n\t}\n\n\tint countPow(int m, int n) {\n\t\tint ans = 0;\n\t\twhile (m % n == 0 && m > 0) {\n\t\t\tans++;\n\t\t\tm /= n;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tlong binPow(long a, long b) {\n\t\tif (b == 0) {\n\t\t\treturn 1;\n\t\t}\n\t\tif (b % 2 == 1) {\n\t\t\treturn a * binPow(a, b - 1);\n\t\t} else {\n\t\t\tlong c = binPow(a, b / 2);\n\t\t\treturn c * c;\n\t\t}\n\n\t}\n\n\tint gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\n\tlong pow(long x, long k) {\n\t\tlong ans = 1;\n\t\tfor (int i = 0; i < k; ++i) {\n\t\t\tans *= x;\n\t\t}\n\t\treturn ans;\n\t}\n\n\t// ////////////////////////////////////////////////////////////////////\n\n\tString delimiter = \" \";\n\n\tString readLine() throws IOException {\n\t\treturn in.readLine();\n\t}\n\n\tString rS() throws IOException {\n\t\twhile (!tok.hasMoreTokens()) {\n\t\t\tString nextLine = readLine();\n\t\t\tif (null == nextLine)\n\t\t\t\treturn null;\n\n\t\t\ttok = new StringTokenizer(nextLine);\n\t\t}\n\n\t\treturn tok.nextToken(delimiter);\n\t}\n\n\tint rI() throws IOException {\n\t\treturn Integer.parseInt(rS());\n\t}\n\n\tlong rL() throws IOException {\n\t\treturn Long.parseLong(rS());\n\t}\n\n\tdouble rD() throws IOException {\n\t\treturn Double.parseDouble(rS());\n\t}\n\n\tint[] rA(int b) {\n\t\tint a[] = new int[b];\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\ttry {\n\t\t\t\ta[i] = rI();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn a;\n\t}\n\n\tint[] readSortedIntArray(int size) throws IOException {\n\t\tInteger[] array = new Integer[size];\n\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tarray[index] = rI();\n\t\t}\n\t\tArrays.sort(array);\n\n\t\tint[] sortedArray = new int[size];\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tsortedArray[index] = array[index];\n\t\t}\n\n\t\treturn sortedArray;\n\t}\n\n\tint[] sortedIntArray(int size, int[] array) throws IOException {\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tarray[index] = rI();\n\t\t}\n\t\tArrays.sort(array);\n\n\t\tint[] sortedArray = new int[size];\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tsortedArray[index] = array[index];\n\t\t}\n\n\t\treturn sortedArray;\n\t}\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\n\npublic class m {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(br.readLine());\n        String s = br.readLine();\n        int[] upper = new int[26];\n        int[] lower = new int[26];\n        int[] digits = new int[10];\n        for (int i = 0; i < s.length(); i++) {\n            if (Character.isDigit(s.charAt(i)))\n                digits[s.charAt(i) - '0']++;\n            else if (Character.isUpperCase(s.charAt(i)))\n                upper[s.charAt(i) - 'A']++;\n            else\n                lower[s.charAt(i) - 'a']++;\n        }\n        int odd = 0;\n        int even = 0;\n        for (int i = 0; i < 26; i++) {\n            if (upper[i] % 2 == 1)\n                odd++;\n            if (lower[i] % 2 == 1)\n                odd++;\n            even += (lower[i] / 2 + upper[i] / 2) * 2;\n        }\n        for (int i = 0; i < 10; i++) {\n            if (digits[i] % 2 == 1)\n                odd++;\n            even += (digits[i] / 2) * 2;\n        }\n        int z;\n        int x = 0;\n        for (z = 1; z <= n; z++)\n            if (n % z == 0 && (n / z - 1) % 2 == 0 && n - z <= even) {\n                x = (n / z - 1) / 2;\n                break;\n            }\n        if (even == n) {\n            z = 1;\n            x = n / 2;\n        }\n        PrintWriter out = new PrintWriter(System.out);\n\n        out.println(z);\n        for (int j = 0; j < z; j++) {\n            StringBuilder st = new StringBuilder();\n            StringBuilder end = new StringBuilder();\n            boolean done = false;\n            for (int i = 0; i < 26; i++)\n                if (upper[i] % 2 == 1 || (z == n && upper[i] != 0)) {\n                    end.append((char) (i + 'A'));\n                    upper[i] -= 1;\n                    done = true;\n                    break;\n                }\n            for (int i = 0; i < 26 && !done; i++)\n                if (lower[i] % 2 == 1 || (z == n && lower[i] != 0)) {\n                    end.append((char) (i + 'a'));\n                    lower[i] -= 1;\n                    done = true;\n                    break;\n                }\n            for (int i = 0; i < 10 && !done; i++)\n                if (digits[i] % 2 == 1 || (z == n && digits[i] != 0)) {\n                    end.append((char) (i + '0'));\n                    digits[i] -= 1;\n                    done = true;\n                    break;\n                }\n\n            for (int i = 0; i < 26 && st.length() + end.length() <= n / z - 2; i++) {\n                while (upper[i] > 1 && st.length() + end.length() <= n / z - 2) {\n                    upper[i] -= 2;\n                    st.append((char) (i + 'A'));\n                    end.append((char) (i + 'A'));\n                }\n            }\n            for (int i = 0; i < 26 && st.length() + end.length() <= n / z - 2; i++) {\n                while (lower[i] > 1 && st.length() + end.length() <= n / z - 2) {\n                    lower[i] -= 2;\n                    st.append((char) (i + 'a'));\n                    end.append((char) (i + 'a'));\n                }\n            }\n            for (int i = 0; i < 10 && st.length() + end.length() <= n / z - 2; i++) {\n                while (digits[i] > 1 && st.length() + end.length() <= n / z - 2) {\n                    digits[i] -= 2;\n                    st.append((char) (i + '0'));\n                    end.append((char) (i + '0'));\n                }\n            }\n\n            if (st.length() + end.length() < n / z) {\n                done = false;\n                for (int i = 0; i < 26; i++)\n                    if (upper[i] > 0) {\n                        end = new StringBuilder((char) (i + 'A') + \"\").append(end);\n                        upper[i] -= 1;\n                        done = true;\n                        break;\n                    }\n                for (int i = 0; i < 26 && !done; i++)\n                    if (lower[i] > 0) {\n                        end = new StringBuilder((char) (i + 'a') + \"\").append(end);\n                        lower[i] -= 1;\n                        done = true;\n                        break;\n                    }\n                for (int i = 0; i < 10 && !done; i++)\n                    if (digits[i] > 0) {\n                        end = new StringBuilder((char) (i + '0') + \"\").append(end);\n                        digits[i] -= 1;\n                        done = true;\n                        break;\n                    }\n            }\n\n            out.println(((st.reverse()).append(end)).toString());\n        }\n        out.flush();\n        out.close();\n    }\n\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.*;\nimport java.util.*;\n\npublic class icpc\n{\n    public static void main(String[] args) throws IOException\n    {\n//        Reader in = new Reader();\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(in.readLine());\n        String s = in.readLine();\n        HashMap<Character, Integer> h = new HashMap<>();\n        for (int i=0;i<s.length();i++)\n        {\n            char ch = s.charAt(i);\n            if (!h.containsKey(ch))\n                h.put(ch, 1);\n            else\n                h.put(ch, h.get(ch) + 1);\n        }\n        ArrayList<Character> A = new ArrayList<>();\n        ArrayList<Character> B = new ArrayList<>();\n\n        Iterator iter = h.entrySet().iterator();\n        int count = 0;\n        while (iter.hasNext())\n        {\n            Map.Entry element = (Map.Entry)iter.next();\n\n            int c = (int)element.getValue();\n            char key = (char)element.getKey();\n            if (c % 2 == 1)\n            {\n                count++;\n                B.add(key);\n            }\n            for (int i=0;i<c / 2;i++)\n            {\n                A.add(key);\n                A.add(key);\n            }\n        }\n\n        if (count == 0)\n        {\n            System.out.println(1);\n            StringBuilder stringBuilder = new StringBuilder();\n            for (int i=0;i<A.size();i+= 2)\n            {\n                stringBuilder.append(A.get(i));\n            }\n            StringBuilder stringBuilder1 = new StringBuilder(stringBuilder);\n            System.out.println(stringBuilder.reverse().append(stringBuilder1));\n        }\n        else\n        {\n            int ans = 0;\n            for (int i = count;i<=n;i+=2)\n            {\n                if (n % i == 0 && (n / i) % 2 == 1)\n                {\n                    ans = i;\n                    break;\n                }\n            }\n\n            ArrayList<StringBuilder> res = new ArrayList<>();\n            int k = 0;\n            int j = 0;\n            for (int i=0;i<ans;i++)\n            {\n                if (k < B.size())\n                {\n\n                    res.add(new StringBuilder(Character.toString(B.get(k++))));\n                }\n                else\n                {\n                    res.add(new StringBuilder(Character.toString(A.get(j++))));\n                }\n            }\n            int len = n / ans;\n            StringBuilder finalAns = new StringBuilder();\n            for (int i=0;i<res.size();i++)\n            {\n                StringBuilder stringBuilder = new StringBuilder();\n                for (int m = 0;m < len / 2;m++)\n                {\n                    stringBuilder.append(A.get(j));\n                    j += 2;\n                }\n                StringBuilder stringBuilder1 = new StringBuilder(stringBuilder);\n                finalAns.append(stringBuilder.reverse().append(res.get(i)).append(stringBuilder1)).append(\" \");\n            }\n            System.out.println(ans);\n            System.out.println(finalAns);\n        }\n    }\n}\nclass Game\n{\n    char ch;\n    int count;\n\n    public Game(char ch, int count)\n    {\n        this.ch = ch;\n        this.count = count;\n    }\n}\nclass NumberTheory\n{\n    public boolean isPrime(long n)\n    {\n        if(n < 2)\n            return false;\n        for(long x = 2;x * x <= n;x++)\n        {\n            if(n % x == 0)\n                return false;\n        }\n        return true;\n    }\n    public ArrayList<Long> primeFactorisation(long n)\n    {\n        ArrayList<Long> f = new ArrayList<>();\n        for(long x=2;x * x <= n;x++)\n        {\n            while(n % x == 0)\n            {\n                f.add(x);\n                n /= x;\n            }\n        }\n        if(n > 1)\n            f.add(n);\n        return f;\n    }\n    public int[] sieveOfEratosthenes(int n)\n    {\n        int[] sieve = new int[n + 1];\n        for(int x=2;x<=n;x++)\n        {\n            if(sieve[x] != 0)\n                continue;\n            sieve[x] = x;\n            for(int u=2*x;u<=n;u+=x)\n                if(sieve[u] == 0)\n                    sieve[u] = x;\n        }\n        return sieve;\n    }\n    public long gcd(long a, long b)\n    {\n        if(b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public long phi(long n)\n    {\n        double result = n;\n\n        for(long p=2;p*p<=n;p++)\n        {\n            if(n % p == 0)\n            {\n                while (n % p == 0)\n                    n /= p;\n                result *= (1.0 - (1.0 / (double)p));\n            }\n        }\n        if(n > 1)\n            result *= (1.0 - (1.0 / (double)n));\n        return (long)result;\n    }\n    public Name extendedEuclid(long a, long b)\n    {\n        if(b == 0)\n            return new Name(a, 1, 0);\n        Name n1 = extendedEuclid(b, a % b);\n        Name n2 = new Name(n1.d, n1.y, n1.x - (long)Math.floor((double)a / b) * n1.y);\n        return n2;\n    }\n    public long modularExponentiation(long a, long b, long n)\n    {\n        long d = 1L;\n        String bString = Long.toBinaryString(b);\n        for(int i=0;i<bString.length();i++)\n        {\n            d = (d * d) % n;\n            if(bString.charAt(i) == '1')\n                d = (d * a) % n;\n        }\n        return d;\n    }\n}\nclass Name\n{\n    long d;\n    long x;\n    long y;\n\n    public Name(long d, long x, long y)\n    {\n        this.d = d;\n        this.x = x;\n        this.y = y;\n    }\n}\nclass SuffixArray\n{\n    int ALPHABET_SZ = 256, N;\n    int[] T, lcp, sa, sa2, rank, tmp, c;\n\n    public SuffixArray(String str)\n    {\n        this(toIntArray(str));\n    }\n\n    private static int[] toIntArray(String s)\n    {\n        int[] text = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) text[i] = s.charAt(i);\n        return text;\n    }\n\n    public SuffixArray(int[] text)\n    {\n        T = text;\n        N = text.length;\n        sa = new int[N];\n        sa2 = new int[N];\n        rank = new int[N];\n        c = new int[Math.max(ALPHABET_SZ, N)];\n        construct();\n        kasai();\n    }\n\n    private void construct()\n    {\n        int i, p, r;\n        for (i = 0; i < N; ++i) c[rank[i] = T[i]]++;\n        for (i = 1; i < ALPHABET_SZ; ++i) c[i] += c[i - 1];\n        for (i = N - 1; i >= 0; --i) sa[--c[T[i]]] = i;\n        for (p = 1; p < N; p <<= 1)\n        {\n            for (r = 0, i = N - p; i < N; ++i) sa2[r++] = i;\n            for (i = 0; i < N; ++i) if (sa[i] >= p) sa2[r++] = sa[i] - p;\n            Arrays.fill(c, 0, ALPHABET_SZ, 0);\n            for (i = 0; i < N; ++i) c[rank[i]]++;\n            for (i = 1; i < ALPHABET_SZ; ++i) c[i] += c[i - 1];\n            for (i = N - 1; i >= 0; --i) sa[--c[rank[sa2[i]]]] = sa2[i];\n            for (sa2[sa[0]] = r = 0, i = 1; i < N; ++i)\n            {\n                if (!(rank[sa[i - 1]] == rank[sa[i]]\n                        && sa[i - 1] + p < N\n                        && sa[i] + p < N\n                        && rank[sa[i - 1] + p] == rank[sa[i] + p])) r++;\n                sa2[sa[i]] = r;\n            }\n            tmp = rank;\n            rank = sa2;\n            sa2 = tmp;\n            if (r == N - 1) break;\n            ALPHABET_SZ = r + 1;\n        }\n    }\n\n    private void kasai()\n    {\n        lcp = new int[N];\n        int[] inv = new int[N];\n        for (int i = 0; i < N; i++) inv[sa[i]] = i;\n        for (int i = 0, len = 0; i < N; i++)\n        {\n            if (inv[i] > 0)\n            {\n                int k = sa[inv[i] - 1];\n                while ((i + len < N) && (k + len < N) && T[i + len] == T[k + len]) len++;\n                lcp[inv[i] - 1] = len;\n                if (len > 0) len--;\n            }\n        }\n    }\n}\nclass ZAlgorithm\n{\n    public int[] calculateZ(char input[])\n    {\n        int Z[] = new int[input.length];\n        int left = 0;\n        int right = 0;\n        for(int k = 1; k < input.length; k++) {\n            if(k > right) {\n                left = right = k;\n                while(right < input.length && input[right] == input[right - left]) {\n                    right++;\n                }\n                Z[k] = right - left;\n                right--;\n            } else {\n                //we are operating inside box\n                int k1 = k - left;\n                //if value does not stretches till right bound then just copy it.\n                if(Z[k1] < right - k + 1) {\n                    Z[k] = Z[k1];\n                } else { //otherwise try to see if there are more matches.\n                    left = k;\n                    while(right < input.length && input[right] == input[right - left]) {\n                        right++;\n                    }\n                    Z[k] = right - left;\n                    right--;\n                }\n            }\n        }\n        return Z;\n    }\n    public ArrayList<Integer> matchPattern(char text[], char pattern[])\n    {\n        char newString[] = new char[text.length + pattern.length + 1];\n        int i = 0;\n        for(char ch : pattern) {\n            newString[i] = ch;\n            i++;\n        }\n        newString[i] = '$';\n        i++;\n        for(char ch : text) {\n            newString[i] = ch;\n            i++;\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n        int Z[] = calculateZ(newString);\n\n        for(i = 0; i < Z.length ; i++) {\n            if(Z[i] == pattern.length) {\n                result.add(i - pattern.length - 1);\n            }\n        }\n        return result;\n    }\n}\nclass KMPAlgorithm\n{\n    public int[] computeTemporalArray(char[] pattern)\n    {\n        int[] lps = new int[pattern.length];\n\n        int index = 0;\n        for(int i=1;i<pattern.length;)\n        {\n            if(pattern[i] == pattern[index])\n            {\n                lps[i] = index + 1;\n                index++;\n                i++;\n            }\n            else\n            {\n                if(index != 0)\n                {\n                    index = lps[index - 1];\n                }\n                else\n                {\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n        return lps;\n    }\n\n    public ArrayList<Integer> KMPMatcher(char[] text, char[] pattern)\n    {\n        int[] lps = computeTemporalArray(pattern);\n\n        int j = 0;\n        int i = 0;\n        int n = text.length;\n        int m = pattern.length;\n        ArrayList<Integer> indices = new ArrayList<>();\n        while(i < n)\n        {\n            if(pattern[j] == text[i])\n            {\n                i++;\n                j++;\n            }\n            if(j == m)\n            {\n                indices.add(i - j);\n                j = lps[j - 1];\n            }\n            else if(i < n && pattern[j] != text[i])\n            {\n                if(j != 0)\n                    j = lps[j - 1];\n                else\n                    i = i + 1;\n            }\n        }\n        return indices;\n    }\n}\nclass Hashing\n{\n    public long[] computePowers(long p, int n, long m)\n    {\n        long[] powers = new long[n];\n        powers[0] = 1;\n        for(int i=1;i<n;i++)\n        {\n            powers[i] = (powers[i - 1] * p) % m;\n        }\n        return powers;\n    }\n    public long computeHash(String s)\n    {\n        long p = 31;\n        long m = 1_000_000_009;\n        long hashValue = 0L;\n        long[] powers = computePowers(p, s.length(), m);\n        for(int i=0;i<s.length();i++)\n        {\n            char ch = s.charAt(i);\n            hashValue = (hashValue + (ch - 'a' + 1) * powers[i]) % m;\n        }\n        return hashValue;\n    }\n}\nclass BasicFunctions\n{\n    public long min(long[] A)\n    {\n        long min = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            min = Math.min(min, A[i]);\n        }\n        return min;\n    }\n    public long max(long[] A)\n    {\n        long max = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            max = Math.max(max, A[i]);\n        }\n        return max;\n    }\n}\nclass Matrix\n{\n    long a;\n    long b;\n    long c;\n    long d;\n\n    public Matrix(long a, long b, long c, long d)\n    {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.d = d;\n    }\n}\nclass MergeSortInt\n{\n    // Merges two subarrays of arr[].\n    // First subarray is arr[l..m]\n    // Second subarray is arr[m+1..r]\n    void merge(int arr[], int l, int m, int r) {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        /* Create temp arrays */\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n\n        /*Copy data to temp arrays*/\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        /* Merge the temp arrays */\n\n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n\n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        /* Copy remaining elements of L[] if any */\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        /* Copy remaining elements of R[] if any */\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    // Main function that sorts arr[l..r] using\n    // merge()\n    void sort(int arr[], int l, int r) {\n        if (l < r) {\n            // Find the middle point\n            int m = (l + r) / 2;\n\n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n\n}\nclass MergeSortLong\n{\n    // Merges two subarrays of arr[].\n    // First subarray is arr[l..m]\n    // Second subarray is arr[m+1..r]\n    void merge(long arr[], int l, int m, int r) {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        /* Create temp arrays */\n        long L[] = new long[n1];\n        long R[] = new long[n2];\n\n        /*Copy data to temp arrays*/\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        /* Merge the temp arrays */\n\n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n\n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        /* Copy remaining elements of L[] if any */\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        /* Copy remaining elements of R[] if any */\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    // Main function that sorts arr[l..r] using\n    // merge()\n    void sort(long arr[], int l, int r) {\n        if (l < r) {\n            // Find the middle point\n            int m = (l + r) / 2;\n\n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n}\nclass Node\n{\n    int sum;\n    int len;\n    Node(int a, int b)\n    {\n        this.sum = a;\n        this.len = b;\n    }\n\n    @Override\n    public boolean equals(Object ob)\n    {\n        if(ob == null)\n            return false;\n        if(!(ob instanceof Node))\n            return false;\n        if(ob == this)\n            return true;\n        Node obj = (Node)ob;\n        if(this.sum == obj.sum && this.len == obj.len)\n            return true;\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int)this.len;\n    }\n}\nclass Reader\n{\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader()\n    {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException\n    {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String readLine() throws IOException\n    {\n        byte[] buf = new byte[64]; // line length\n        int cnt = 0, c;\n        while ((c = read()) != -1)\n        {\n            if (c == '\\n')\n                break;\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int nextInt() throws IOException\n    {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do\n        {\n            ret = ret * 10 + c - '0';\n        }  while ((c = read()) >= '0' && c <= '9');\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public long nextLong() throws IOException\n    {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public double nextDouble() throws IOException\n    {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n\n        if (c == '.')\n        {\n            while ((c = read()) >= '0' && c <= '9')\n            {\n                ret += (c - '0') / (div *= 10);\n            }\n        }\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException\n    {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1)\n            buffer[0] = -1;\n    }\n\n    private byte read() throws IOException\n    {\n        if (bufferPointer == bytesRead)\n            fillBuffer();\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException\n    {\n        if (din == null)\n            return;\n        din.close();\n    }\n}\nclass FenwickTree\n{\n    public void update(long[] fenwickTree,long delta,int index)\n    {\n        index += 1;\n        while(index < fenwickTree.length)\n        {\n            fenwickTree[index] += delta;\n            index = index + (index & (-index));\n        }\n    }\n    public long prefixSum(long[] fenwickTree,int index)\n    {\n        long sum = 0L;\n        index += 1;\n        while(index > 0)\n        {\n            sum += fenwickTree[index];\n            index -= (index & (-index));\n        }\n        return sum;\n    }\n}\nclass SegmentTree\n{\n    public int nextPowerOfTwo(int num)\n    {\n        if(num == 0)\n            return 1;\n        if(num > 0 && (num & (num - 1)) == 0)\n            return num;\n        while((num &(num - 1)) > 0)\n        {\n            num = num & (num - 1);\n        }\n        return num << 1;\n    }\n    public int[] createSegmentTree(int[] input)\n    {\n        int np2 = nextPowerOfTwo(input.length);\n        int[] segmentTree = new int[np2 * 2 - 1];\n\n        for(int i=0;i<segmentTree.length;i++)\n            segmentTree[i] = Integer.MIN_VALUE;\n\n        constructSegmentTree(segmentTree,input,0,input.length-1,0);\n        return segmentTree;\n\n    }\n    private void constructSegmentTree(int[] segmentTree,int[] input,int low,int high,int pos)\n    {\n        if(low == high)\n        {\n            segmentTree[pos] = input[low];\n            return;\n        }\n        int mid = (low + high)/ 2;\n        constructSegmentTree(segmentTree,input,low,mid,2*pos + 1);\n        constructSegmentTree(segmentTree,input,mid+1,high,2*pos + 2);\n        segmentTree[pos] = Math.max(segmentTree[2*pos + 1],segmentTree[2*pos + 2]);\n    }\n    public int rangeMinimumQuery(int []segmentTree,int qlow,int qhigh,int len)\n    {\n        return rangeMinimumQuery(segmentTree,0,len-1,qlow,qhigh,0);\n    }\n    private int rangeMinimumQuery(int segmentTree[],int low,int high,int qlow,int qhigh,int pos)\n    {\n        if(qlow <= low && qhigh >= high){\n            return segmentTree[pos];\n        }\n        if(qlow > high || qhigh < low){\n            return Integer.MIN_VALUE;\n        }\n        int mid = (low+high)/2;\n        return Math.max(rangeMinimumQuery(segmentTree, low, mid, qlow, qhigh, 2 * pos + 1),\n                rangeMinimumQuery(segmentTree, mid + 1, high, qlow, qhigh, 2 * pos + 2));\n    }\n}\nclass Trie\n{\n    private class TrieNode\n    {\n        Map<Character, TrieNode> children;\n        boolean endOfWord;\n        public TrieNode()\n        {\n            children = new HashMap<>();\n            endOfWord = false;\n        }\n    }\n\n    private final TrieNode root;\n\n    public Trie()\n    {\n        root = new TrieNode();\n    }\n\n    public void insert(String word)\n    {\n        TrieNode current = root;\n        for (int i=0;i<word.length();i++)\n        {\n            char ch = word.charAt(i);\n            TrieNode node = current.children.get(ch);\n            if (node == null)\n            {\n                node = new TrieNode();\n                current.children.put(ch, node);\n            }\n            current.endOfWord = true;\n        }\n    }\n\n    public boolean search(String word)\n    {\n        TrieNode current = root;\n        for (int i=0;i<word.length();i++)\n        {\n            char ch = word.charAt(i);\n            TrieNode node = current.children.get(ch);\n            if (node == null)\n                return false;\n            current = node;\n        }\n        return current.endOfWord;\n    }\n\n    public void delete(String word)\n    {\n        delete(root, word, 0);\n    }\n\n    private boolean delete(TrieNode current, String word, int index)\n    {\n        if (index == word.length())\n        {\n            if (!current.endOfWord)\n                return false;\n            current.endOfWord = false;\n            return current.children.size() == 0;\n        }\n        char ch = word.charAt(index);\n        TrieNode node = current.children.get(ch);\n        if (node == null)\n            return false;\n        boolean shouldDeleteCurrentNode = delete(node, word, index + 1);\n        if (shouldDeleteCurrentNode)\n        {\n            current.children.remove(ch);\n            return current.children.size() == 0;\n        }\n        return false;\n    }\n}\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n/*\n15\naaaaaaaaaaabbbc\n\n */\npublic class P883H\n{\n\tstatic int pInd;\n\tstatic PrintWriter pw = new PrintWriter(System.out);\n\tpublic static void main(String[] args)\n\t{\n\t\tFastScanner scan = new FastScanner();\n\t\tint n = scan.nextInt();\n\t\tchar[] s = scan.next().toCharArray();\n\t\tint[] cnt = new int[256];\n\t\tfor (int i = 0; i < s.length; i++)\n\t\t\tcnt[s[i]]++;\n\t\tArrayList<Character> pairs = new ArrayList<>();\n\t\tArrayList<Character> single = new ArrayList<>();\n\t\tfor (int i = 0; i < cnt.length; i++)\n\t\t{\n\t\t\twhile (cnt[i] >= 2)\n\t\t\t{\n\t\t\t\tpairs.add((char)i);\n\t\t\t\tcnt[i] -= 2;\n\t\t\t}\n\t\t\tif (cnt[i] == 1)\n\t\t\t\tsingle.add((char)i);\n\t\t}\n\t\tint minGroups = Math.max(1, single.size());\n\t\tfor (int i = minGroups; i <= n; i++)\n\t\t{\n\t\t\tif (n % i != 0)\n\t\t\t\tcontinue;\n\t\t\tint each = n/i;\n\t\t\tif (each % 2 == 0 && single.size() > 0)\n\t\t\t\tcontinue; \n\t\t\tpw.println(i);\n\t\t\tif (each % 2 == 0)\n\t\t\t{\n\t\t\t\tprint(each, pairs);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (int j = 0; j < single.size(); j++)\n\t\t\t{\n\t\t\t\tchar mid = single.get(j);\n\t\t\t\tprint(each, mid, pairs);\n\t\t\t}\n\t\t\twhile (pInd < pairs.size())\n\t\t\t{\n\t\t\t\tchar mid = pairs.get(pInd++);\n\t\t\t\tprint(each, mid, pairs);\n\t\t\t\tprint(each, mid, pairs);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tpw.flush();\n\t}\n\tprivate static void print(int size, ArrayList<Character> pairs)\n\t{\n\t\tchar[] str = new char[size];\n\t\tfor (int i = 0; i < size/2; i++)\n\t\t{\n\t\t\tchar outer = pairs.get(pInd++);\n\t\t\tstr[size/2-1-i] = outer;\n\t\t\tstr[size/2+i] = outer;\n\t\t}\n\t\tpw.print(new String(str));\n\t}\n\tprivate static void print(int size, char mid, ArrayList<Character> pairs)\n\t{\n\t\tchar[] str = new char[size];\n\t\tstr[size/2] = mid;\n\t\tfor (int i = 1; i <= size/2; i++)\n\t\t{\n\t\t\tchar outer = pairs.get(pInd++);\n\t\t\tstr[size/2-i] = outer;\n\t\t\tstr[size/2+i] = outer;\n\t\t}\n\t\tpw.print(new String(str) + \" \");\n\t}\n\t\n\tstatic class FastScanner\n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic String next()\n\t\t{\n\t\t\tif (st.hasMoreTokens())\n\t\t\t\treturn st.nextToken();\n\t\t\ttry\n\t\t\t{\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (Exception e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic String nextLine()\n\t\t{\n\t\t\tString line = \"\";\n\t\t\ttry\n\t\t\t{\n\t\t\t\tline = br.readLine();\n\t\t\t} catch (Exception e)\n\t\t\t{\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn line;\n\t\t}\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\npublic class Main\n{\n\tprivate InputStream is;\n\tprivate PrintWriter out;\n\tint time = 0, freq[], start[], end[], dist[], black[], MOD = (int) (1e9 + 7), arr[], weight[][], x[], y[], parent[];\n\tint MAX = 1000001, N, K;\n\tlong red[], ans = Long.MAX_VALUE;\n\n\tArrayList<Integer>[] amp;\n\tArrayList<Pair>[] pmp;\n\tboolean b[];\n\tboolean boo[][], b1[];\n\tPair prr[];\n\tHashMap<Pair, Integer> hm = new HashMap();\n\tint Dp[][] = new int[1100][1100];\n\n\tvoid soln() \n\t{\n\t\tis = System.in;\n\t\tout = new PrintWriter(System.out);\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\n\t\t// out.close();\n\t\tout.flush();\n\t\t// tr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tstatic class ST1 // min ST\n\t{\n\t\tlong arr[], st[];\n\t\tint size;\n\n\t\tST1(long a[]) {\n\t\t\tarr = a.clone();\n\t\t\tsize = 10 * arr.length;\n\t\t\tst = new long[size];\n\t\t\tbuild(0, arr.length - 1, 1);\n\t\t}\n\n\t\tvoid build(int ss, int se, int si) {\n\t\t\tif (ss == se) {\n\t\t\t\tst[si] = arr[ss];\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint mid = (ss + se) / 2;\n\t\t\tint val = 2 * si;\n\t\t\tbuild(ss, mid, val);\n\t\t\tbuild(mid + 1, se, val + 1);\n\t\t\tst[si] = Math.min(st[val], st[val + 1]);\n\t\t}\n\n\t\tvoid update(int ss, int se, int idx, long val, int si) {\n\t\t\tif (ss == se) {\n\t\t\t\t// if(si==idx+1)\n\t\t\t\tst[si] = val;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint mid = (ss + se) / 2;\n\t\t\tif (ss <= idx && idx <= mid) {\n\t\t\t\tupdate(ss, mid, idx, val, 2 * si);\n\t\t\t} else {\n\t\t\t\tupdate(mid + 1, se, idx, val, 2 * si + 1);\n\t\t\t}\n\t\t\tint v = 2 * si;\n\t\t\tst[si] = Math.min(st[v], st[v + 1]);\n\t\t}\n\n\t\tlong get(int ss, int se, int l, int r, int si) {\n\t\t\tif (l > se || r < ss || l > r)\n\t\t\t\treturn Long.MAX_VALUE / 1000;\n\t\t\tif (l <= ss && r >= se)\n\t\t\t\treturn st[si];\n\t\t\tint mid = (ss + se) / 2;\n\t\t\tint val = 2 * si;\n\t\t\treturn Math.min(get(ss, mid, l, r, val), get(mid + 1, se, l, r, val + 1));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tnew Thread(null, new Runnable() \n\t\t{\n\t\t\tpublic void run() \n\t\t\t{\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\t// new CODEFORCES().soln();\n\t\t\t\t} catch (Exception e) \n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}, \"1\", 1 << 26).start();\n\t\tnew Main().soln();\n\t}\n\n\tint D[][];\n\tchar ch[][], ch1[];\n\tint hash = 29;\n\tint x2, y2;\n\tHashSet<Integer>[] hs = (HashSet<Integer>[]) new HashSet[110];\n\tcell[] c;\n\tPair[] p = new Pair[4];\n\tHashSet<String> set = new HashSet<>();\n\tHashSet<String> dp = new HashSet<>();\n\tprivate void solve()\n\t{\n\t\tint n = ni();\n\t\tchar ch[] = ns().toCharArray();\n\t\tint arr[] = new int[256];\n\t\tfor(char c : ch) {\n\t\t\tarr[c]++;\n\t\t}\n\t\tint val = 0;\n\t\tfor(int i : arr) val += i/2;\n\t\tTreeSet<Integer> ts = new TreeSet<>();\n\t\tfor(int i = 1;i<=n;i++) if(n%i==0) ts.add(i);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int k : ts){\n            int y = n/k;\n            int x = k*(y/2);\n            if(val >= x){\n                ArrayList<Character> amp = new ArrayList<>();\n                for(int i = 0; i < 256; i++){\n                    if(arr[i] % 2 != 0){\n                    \tamp.add((char)(i));\n                        arr[i]--;\n                    }\n                }\n                int z = val - x;\n                z *= 2;\n                for(int i = 0; i < 256; i++){\n                    while(z > 0 && arr[i] > 0){\n                    \tamp.add((char)i);\n                        arr[i]--;\n                        z--;\n                    }\n                }\n                int p = 0, q = 0;\n                out.println(k);\n                while(k-- > 0){\n                    char[] c = new char[y];\n                    int r = 0;\n                    while(r<y/2){\n                        while(arr[q] <= 0) q++;\n                        c[r] = (char)(q);\n                        c[y-r-1] = (char)(q);\n                        arr[q] -= 2;\n                        r++;\n                    }\n                    if(y % 2 != 0){\n                        c[r] = amp.get(p++);\n                    }\n                    sb.append(new String(c)+\" \");\n                }\n                out.println(sb);\n                break;\n            }\n        }\n\t\t\n\t}\n\tvoid replace(String str, String prev) {\n\t\tif(dp.contains(str)) return;\n\t\tdp.add(str);\n\t\tif(set.contains(str)) {\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tboolean b = false;\n\t\t\tstr = str.replaceFirst(\"u\",\"oo\");\n\t\t\tif(!str.equals(prev)) {\n\t\t\t\treplace(str, str);\n\t\t\t\tb = true;\n\t\t\t}\n\t\t\tstr = str.replaceFirst(\"kh\",\"h\");\n\t\t\tif(!str.equals(prev)) {\n\t\t\t\treplace(str, str);\n\t\t\t\tb = true;\n\t\t\t}\n\t\t\tif(!b) {\n\t\t\t\tset.add(str);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\tvoid bfs(int s, int n) {\n\t\tb = new boolean[n];\n\t\tdist = new int[n];\n\t\tArrays.fill(dist, 1000000);\n\t\tdist[s] = 0;\n\t\tb[s] = true;\n\t\tQueue<Integer> q = new LinkedList<>();\n\t\tq.add(s);\n\t\twhile(!q.isEmpty()) {\n\t\t\tint y = q.poll();\n\t\t\tfor(int i : amp[y]) {\n\t\t\t\tdist[i] = min(dist[i],dist[y]+1);\n\t\t\t\tif(!b[i]) {\n\t\t\t\t\tb[i] = true;\n\t\t\t\t\tq.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tboolean check(String s, String s1) {\n\t\tchar ch1[] = s.toCharArray(), ch2[] = s1.toCharArray();\n\t\tint arr[] = new int[10];\n\t\tfor(char c : ch1) {\n\t\t\tarr[c-'0']++;\n\t\t}\n\t\tint ans = 0;\n\t\tfor(char c:ch2) {\n\t\t\tarr[c-'0']--;\n\t\t}\n\t\t\n\t\tfor(int i:arr) ans += ((i>0)?i:0);\n\t\treturn ans==3;\n\t}\n\tvoid seive(int n)\n\t{\n\t\tstart = new int[n];\n\t\tfor(int i = 2;i<n;i++) {\n\t\t\tif(start[i]==0) {\n\t\t\t\tfor(int j = 2*i;j<n;j+=i) {\n\t\t\t\t\tstart[j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid print(int[][] arr) \n\t{\n\t\tint seed = 110, n = arr.length - 220;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tSystem.out.print(arr[i + seed][j + seed] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\t class cell implements Comparable<cell>\n\t {\n\t\tint s, d, p, i;\n\n\t\tcell(int t, int d, int p, int i) {\n\t\t\tthis.s = t;\n\t\t\tthis.p = p;\n\t\t\tthis.d = d;\n\t\t\tthis.i = i;\n\t\t}\n\n\t\tpublic int compareTo(cell other) {\n\t\t\t// return Integer.compare(val, other.val);\n\t\t\treturn Long.compare(d, other.d) != 0 ? (Long.compare(d, other.d)): (Long.compare(i,other.i));\n\t\t\t\t\t\t\t\t\t\t\t// other.v));//((Long.compare(u, other.u) != 0 ? (Long.compare(u, other.u)):\n\t\t\t\t\t\t\t\t\t\t\t// (Long.compare(v, other.v)))\n\t\t\t// &(Long.compare(u, other.v) != 0 ? (Long.compare(u, other.v)):\n\t\t\t// (Long.compare(v, other.u))));\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn this.d + \" \" + this.s +\" \"+this.p+\" \"+this.i;\n\t\t}\n\t}\n\n\tint abs(int x)\n\t{\n\t\treturn ((x > 0) ? x : -x);\n\t}\n\n\tlong ret(int p) \n\t{\n\t\tif (p >= 0)\n\t\t\treturn 0;\n\t\telse\n\t\t\treturn 1;\n\t}\n\n\tlong val(int p, int a, int b) \n\t{\n\t\tif (p >= 0) {\n\t\t\treturn (a * 1l * p);\n\t\t}\n\t\treturn (b * 1l * p);\n\t}\n\n\tvoid ternary_search(int l, int r) \n\t{\n\t\t// System.out.println(l+\" \"+r+\" \"+ans);\n\t\t// for(int i : arr) System.out.print(i+\" \");\n\t\t// System.out.println();\n\t\tif (r >= l) {\n\t\t\tint mid1 = l + (r - l) / 3;\n\t\t\tint mid2 = r - (r - l) / 3;\n\t\t\tlong cnt1 = 0, cnt2 = 0;\n\t\t\tcnt1 = compute(mid1);\n\t\t\tcnt2 = compute(mid2);\n\t\t\t// System.out.println(mid1+\" \"+ cnt1+\" \"+mid2+\" \"+cnt2);\n\t\t\tans = Math.min(cnt1, cnt2);\n\t\t\tif (cnt1 < cnt2) {\n\t\t\t\tternary_search(l, mid2 - 1);\n\t\t\t} else {\n\t\t\t\tternary_search(mid1 + 1, r);\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\n\tlong compute(int x) \n\t{\n\t\tlong ans = 0;\n\t\tint c = arr[0];\n\t\tfor (int i = 1; i <= x; i++) {\n\t\t\tans += max(c + 1 - arr[i], 0);\n\t\t\tc = max(c + 1, arr[i]);\n\t\t}\n\t\tint temp = arr[x];\n\t\tarr[x] = max(c + 1, arr[x]);\n\t\t// SSystem.out.println(arr[x]+\" \"+ans);\n\t\tc = arr[arr.length - 1];\n\t\tfor (int i = arr.length - 1; i > x; i--) {\n\t\t\tans += max(c + 1 - arr[i - 1], 0);\n\t\t\tc = max(c + 1, arr[i - 1]);\n\t\t}\n\t\tarr[x] = temp;\n\t\treturn ans;\n\t}\n\n\tpublic int getParent(int x) \n\t{\n\t\twhile (parent[x] != x) {\n\t\t\tparent[x] = parent[parent[x]];\n\t\t\tx = parent[x];\n\t\t}\n\t\treturn x;\n\t}\n\n\tvoid getFactors(int n, int x)\n\t{\n\t\tfor (int i = 1; i * i <= n; i++) {\n\t\t\tif (n % i == 0) {\n\t\t\t\ths[x].add(i);\n\t\t\t\ths[x].add(n / i);\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid recur(int a, int b, int k) \n\t{\n\t\tif (k == 0) {\n\t\t\tif (a == x2 && b == y2)\n\t\t\t\tans++;\n\t\t\treturn;\n\t\t}\n\t\trecur(a, b + 1, k - 1);\n\t\trecur(a, b - 1, k - 1);\n\t\trecur(a + 1, b, k - 1);\n\t\trecur(a - 1, b, k - 1);\n\t}\n\n\tint min(int a, int b) \n\t{\n\t\treturn (a < b) ? a : b;\n\t}\n\n\t/*private class Cell implements Comparable<Cell> {\n\t\tint u, v, s;\n\n\t\tpublic Cell(int u, int v, int s) {\n\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t\tthis.s = s;\n\t\t}\n\n\t\tpublic int hashCode() {\n\t\t\treturn Objects.hash();\n\t\t}\n\n\t\tpublic int compareTo(Cell other) {\n\t\t\treturn (Long.compare(s, other.s) != 0 ? (Long.compare(s, other.s))\n\t\t\t\t\t: (Long.compare(v, other.v) != 0 ? Long.compare(v, other.v) : Long.compare(u, other.u)))\n\t\t\t\t\t& ((Long.compare(s, other.s) != 0 ? (Long.compare(s, other.s))\n\t\t\t\t\t\t\t: (Long.compare(u, other.v) != 0 ? Long.compare(u, other.v) : Long.compare(v, other.u))));\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn this.u + \" \" + this.v;\n\t\t}\n\t}*/\n\n\tclass Pair implements Comparable<Pair>\n\t{\n\t\tint u ,v,i;\n\n\t\tPair(int u, int v) {\n\t\t\tthis.u = u;\n\t\t\tthis.i = v;\n\t\t}\n\n\t\tPair(int u, int v, int i) {\n\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t\tthis.i = i;\n\t\t}\n\n\t\tpublic int hashCode() {\n\t\t\treturn Objects.hash();\n\t\t}\n\n\t\tpublic boolean equals(Object o) {\n\t\t\tPair other = (Pair) o;\n\t\t\treturn ((u == other.u && v == other.v));\n\t\t}\n\n\t\tpublic int compareTo(Pair other) {\n\t\t\t// return Integer.compare(val, other.val);\n\t\t\treturn Long.compare(u, other.u) != 0 ? (Long.compare(u, other.u)) : (Long.compare(i, other.i));// ((Long.compare(u,\n\t\t\n\t\t}\t\t\t\t\t\t\t\t\t\n\t\tpublic String toString() {\n\t\t\treturn this.u + \" \" + this.v +\" \"+this.i;\n\t\t}\n\t}\n\n\tint max(int a, int b) \n\t{\n\t\tif (a > b)\n\t\t\treturn a;\n\t\treturn b;\n\t}\n\n\tstatic class FenwickTree \n\t{\n\n\t\tint[] array; // 1-indexed array, In this array We save cumulative\n\t\t\t\t\t\t// information to perform efficient range queries and\n\t\t\t\t\t\t// updates\n\n\t\tpublic FenwickTree(int size) {\n\t\t\tarray = new int[size + 1];\n\t\t}\n\n\t\tpublic int rsq(int ind) {\n\t\t\tassert ind > 0;\n\t\t\tint sum = 0;\n\t\t\twhile (ind > 0) {\n\t\t\t\tsum += array[ind];\n\t\t\t\t// Extracting the portion up to the first significant one of the\n\t\t\t\t// binary representation of 'ind' and decrementing ind by that\n\t\t\t\t// number\n\t\t\t\tind -= ind & (-ind);\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\n\t\tpublic int rsq(int a, int b) {\n\t\t\tassert b >= a && a > 0 && b > 0;\n\t\t\treturn rsq(b) - rsq(a - 1);\n\t\t}\n\n\t\tpublic void update(int ind, int value) {\n\t\t\tassert ind > 0;\n\t\t\twhile (ind < array.length) {\n\t\t\t\tarray[ind] += value;\n\t\t\t\t// Extracting the portion up to the first significant one of the\n\t\t\t\t// binary representation of 'ind' and incrementing ind by that\n\t\t\t\t// number\n\t\t\t\tind += ind & (-ind);\n\t\t\t}\n\t\t}\n\n\t\tpublic int size() {\n\t\t\treturn array.length - 1;\n\t\t}\n\t}\n\n\tvoid buildGraph(int n)\n\t{\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x1 = ni(), y1 = ni(), z = ni();\n\t\t\t//pmp[x1].add(new Pair(y1, z));\n\t\t}\n\t}\n\n\tlong modInverse(long a, long mOD2)\n\t{\n\t\treturn power(a, mOD2 - 2, mOD2);\n\t}\n\n\tlong power(long x, long y, long m) \n\t{\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tlong p = power(x, y / 2, m) % m;\n\t\tp = (p * p) % m;\n\n\t\treturn (y % 2 == 0) ? p : (x * p) % m;\n\t}\n\n\tpublic long gcd(long a, long b)\n\t{\n\t\tif (b == 0)\n\t\t\treturn a;\n\t\treturn gcd(b, a % b);\n\t}\n\n\tstatic class ST \n\t{\n\t\tint arr[], lazy[], n;\n\n\t\tST(int a) {\n\t\t\tn = a;\n\t\t\tarr = new int[10 * n];\n\t\t\tlazy = new int[10 * n];\n\t\t}\n\n\t\tvoid up(int l, int r, int val) {\n\t\t\tupdate(0, n - 1, 0, l, r, val);\n\t\t}\n\n\t\tvoid update(int l, int r, int c, int x, int y, int val) {\n\t\t\tif (lazy[c] != 0) {\n\t\t\t\tlazy[2 * c + 1] += lazy[c];\n\t\t\t\tlazy[2 * c + 2] += lazy[c];\n\t\t\t\tif (l == r)\n\t\t\t\t\tarr[c] += lazy[c];\n\t\t\t\tlazy[c] = 0;\n\t\t\t}\n\t\t\tif (l > r || x > y || l > y || x > r)\n\t\t\t\treturn;\n\t\t\tif (x <= l && y >= r)\n\n\t\t\t{\n\t\t\t\tlazy[c] += val;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint mid = l + r >> 1;\n\t\t\tupdate(l, mid, 2 * c + 1, x, y, val);\n\t\t\tupdate(mid + 1, r, 2 * c + 2, x, y, val);\n\t\t\tarr[c] = Math.max(arr[2 * c + 1], arr[2 * c + 2]);\n\t\t}\n\n\t\tint an(int ind) {\n\t\t\treturn ans(0, n - 1, 0, ind);\n\t\t}\n\n\t\tint ans(int l, int r, int c, int ind) {\n\t\t\tif (lazy[c] != 0) {\n\t\t\t\tlazy[2 * c + 1] += lazy[c];\n\t\t\t\tlazy[2 * c + 2] += lazy[c];\n\t\t\t\tif (l == r)\n\t\t\t\t\tarr[c] += lazy[c];\n\t\t\t\tlazy[c] = 0;\n\t\t\t}\n\t\t\tif (l == r)\n\t\t\t\treturn arr[c];\n\t\t\tint mid = l + r >> 1;\n\t\t\tif (mid >= ind)\n\t\t\t\treturn ans(l, mid, 2 * c + 1, ind);\n\t\t\treturn ans(mid + 1, r, 2 * c + 2, ind);\n\t\t}\n\t}\n\n\tpublic static int[] shuffle(int[] a, Random gen)\n\t{\n\t\tfor (int i = 0, n = a.length; i < n; i++) {\n\t\t\tint ind = gen.nextInt(n - i) + i;\n\t\t\tint d = a[i];\n\t\t\ta[i] = a[ind];\n\t\t\ta[ind] = d;\n\t\t}\n\t\treturn a;\n\t}\n\n\tlong power(long x, long y, int mod)\n\t{\n\t\tlong ans = 1;\n\t\twhile (y > 0) {\n\t\t\tif (y % 2 == 0) {\n\t\t\t\tx = (x * x) % mod;\n\t\t\t\ty /= 2;\n\t\t\t} else {\n\t\t\t\tans = (x * ans) % mod;\n\t\t\t\ty--;\n\t\t\t}\n\t\t}\n\t\treturn ans;\n\t}\n\n\t// To Get Input\n\t// Some Buffer Methods\n\tprivate byte[] inbuf = new byte[1024];\n\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() \n\t{\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate int ni() {\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tprivate void tr(Object... o) {\n\t\tif (!oj)\n\t\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n}", "label": 3}
{"src": "import java.util.*;\n\npublic class Problem883H {\n  public static void main(String[] args) {\n    Scanner in = new Scanner(System.in);\n    int n = in.nextInt();\n    String s = in.next();\n    Map<Character, Integer> freq = new HashMap<>(2 * 26 + 10);\n    for (int i = 0; i < n; i++) {\n      freq.compute(s.charAt(i), (k, v) -> v == null ? 1 : v + 1);\n    }\n    LinkedList<Character> odds = new LinkedList<>();\n    LinkedList<Character> evens = new LinkedList<>();\n    for (Map.Entry<Character, Integer> entry : freq.entrySet()) {\n      if (entry.getValue() % 2 == 1) {\n        odds.add(entry.getKey());\n        entry.setValue(entry.getValue() - 1);\n      }\n      int val = entry.getValue();\n      if (val > 0) {\n        while (val != 0) {\n          val -= 2;\n          evens.addLast(entry.getKey());\n        }\n        entry.setValue(0);\n      }\n    }\n    if (odds.size() == 0) {\n      System.out.println(1);\n      char[] res = new char[n];\n      Iterator<Character> iterator = evens.iterator();\n      for (int i = 0; i < n / 2; i++) {\n        res[i] = res[n - i - 1] = iterator.next();\n      }\n      System.out.println(new String(res));\n      return;\n    }\n    while (evens.size() % odds.size() != 0) {\n      Character c = evens.pollLast();\n      odds.addLast(c);\n      odds.addLast(c);\n    }\n    System.out.println(odds.size());\n    int len = n / odds.size();\n    char[] res = new char[len];\n    Iterator<Character> iterator = evens.iterator();\n    for (Character odd : odds) {\n      res[len / 2] = odd;\n      for (int i = 0; i < len / 2; i++) {\n        res[i] = res[len - i - 1] = iterator.next();\n      }\n      System.out.print(new String(res) + \" \");\n    }\n  }\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n    public static void main(String[] args) throws Exception {\n        MyReader reader = new MyReader(System.in);\n        MyWriter writer = new MyWriter(System.out);\n        new Solution().run(reader, writer);\n        writer.close();\n    }\n\n    private void run(MyReader reader, MyWriter writer) throws IOException {\n        int n = reader.nextInt();\n        String s = reader.nextString();\n        Map<Character, Integer> map = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            map.putIfAbsent(c, 0);\n            map.merge(c, 1, (e1, e2) -> e1 + e2);\n        }\n        Set<Character> set = new HashSet<>();\n        StringBuilder w = new StringBuilder();\n        for (Map.Entry<Character, Integer> entry : map.entrySet()) {\n            if (entry.getValue() % 2 == 1) {\n                set.add(entry.getKey());\n            } else {\n                for (int i = 0; i < entry.getValue() / 2; i++) {\n                    w.append(entry.getKey());\n                }\n            }\n        }\n        if (set.size() == 0) {\n            writer.print(1);\n            writer.println();\n            writer.print(w.toString() + w.reverse().toString());\n            return;\n        }\n        int ans = set.size();\n        for (int i = ans; i <= n; i++) {\n            if (n % i == 0 && n / i % 2 == 1) {\n                ans = i;\n                break;\n            }\n        }\n        writer.print(ans);\n        writer.println();\n        int length = n / ans;\n        char[] r = new char[ans];\n        StringBuilder[] q = new StringBuilder[ans];\n        for (int i = 0; i < ans; i++) {\n            q[i] = new StringBuilder();\n        }\n        int i = 0;\n        for (char c : set) {\n            r[i++] = c;\n            map.merge(c, 1, (e1, e2) -> e1 - e2);\n        }\n        for (char c : s.toCharArray()) {\n            if (i >= ans) {\n                break;\n            }\n            if (map.get(c) > 0) {\n                r[i++] = c;\n                r[i++] = c;\n                map.merge(c, 2, (e1, e2) -> e1 - e2);\n            }\n        }\n        i = 0;\n        for (Map.Entry<Character, Integer> entry : map.entrySet()) {\n            for (int j = 0; j < entry.getValue() / 2; j++) {\n                if (q[i].length() * 2 + 1 < length) {\n                    q[i].append(entry.getKey());\n                } else {\n                    i++;\n                    j--;\n                }\n            }\n        }\n        for (int j = 0; j < ans; j++) {\n            writer.print(q[j].toString() + r[j] + q[j].reverse().toString() + \" \");\n        }\n    }\n\n    static class MyReader {\n\n        final BufferedInputStream in;\n        final int bufSize = 1 << 16;\n        final byte buf[] = new byte[bufSize];\n        int i = bufSize;\n        int k = bufSize;\n        final StringBuilder str = new StringBuilder();\n\n        MyReader(InputStream in) {\n            this.in = new BufferedInputStream(in, bufSize);\n        }\n\n        int nextInt() throws IOException {\n            return (int) nextLong();\n        }\n\n        int[] nextIntArray(int n) throws IOException {\n            int[] m = new int[n];\n            for (int i = 0; i < n; i++) {\n                m[i] = nextInt();\n            }\n            return m;\n        }\n\n        int[][] nextIntMatrix(int n, int m) throws IOException {\n            int[][] a = new int[n][0];\n            for (int j = 0; j < n; j++) {\n                a[j] = nextIntArray(m);\n            }\n            return a;\n        }\n\n        long nextLong() throws IOException {\n            int c;\n            long x = 0;\n            boolean sign = true;\n            while ((c = nextChar()) <= 32) ;\n            if (c == '-') {\n                sign = false;\n                c = nextChar();\n            }\n            if (c == '+') {\n                c = nextChar();\n            }\n            while (c >= '0') {\n                x = x * 10 + (c - '0');\n                c = nextChar();\n            }\n            return sign ? x : -x;\n        }\n\n        long[] nextLongArray(int n) throws IOException {\n            long[] m = new long[n];\n            for (int i = 0; i < n; i++) {\n                m[i] = nextLong();\n            }\n            return m;\n        }\n\n        int nextChar() throws IOException {\n            if (i == k) {\n                k = in.read(buf, 0, bufSize);\n                i = 0;\n            }\n            return i >= k ? -1 : buf[i++];\n        }\n\n        String nextString() throws IOException {\n            int c;\n            str.setLength(0);\n            while ((c = nextChar()) <= 32 && c != -1) ;\n            if (c == -1) {\n                return null;\n            }\n            while (c > 32) {\n                str.append((char) c);\n                c = nextChar();\n            }\n            return str.toString();\n        }\n\n        String nextLine() throws IOException {\n            int c;\n            str.setLength(0);\n            while ((c = nextChar()) <= 32 && c != -1) ;\n            if (c == -1) {\n                return null;\n            }\n            while (c != '\\n') {\n                str.append((char) c);\n                c = nextChar();\n            }\n            return str.toString();\n        }\n\n        char[] nextCharArray() throws IOException {\n            return nextString().toCharArray();\n        }\n\n        char[][] nextCharMatrix(int n) throws IOException {\n            char[][] a = new char[n][0];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextCharArray();\n            }\n            return a;\n        }\n    }\n\n    static class MyWriter {\n\n        final BufferedOutputStream out;\n        final int bufSize = 1 << 16;\n        final byte buf[] = new byte[bufSize];\n        int i = 0;\n        final byte c[] = new byte[30];\n        static final String newLine = System.getProperty(\"line.separator\");\n\n        MyWriter(OutputStream out) {\n            this.out = new BufferedOutputStream(out, bufSize);\n        }\n\n        void print(long x) throws IOException {\n            int j = 0;\n            if (i + 30 >= bufSize) {\n                flush();\n            }\n            if (x < 0) {\n                buf[i++] = (byte) ('-');\n                x = -x;\n            }\n            while (j == 0 || x != 0) {\n                c[j++] = (byte) (x % 10 + '0');\n                x /= 10;\n            }\n            while (j-- > 0)\n                buf[i++] = c[j];\n        }\n\n        void print(int[] m) throws IOException {\n            for (int a : m) {\n                print(a);\n                print(' ');\n            }\n        }\n\n        void print(long[] m) throws IOException {\n            for (long a : m) {\n                print(a);\n                print(' ');\n            }\n        }\n\n        void print(String s) throws IOException {\n            for (int i = 0; i < s.length(); i++) {\n                print(s.charAt(i));\n            }\n        }\n\n        void print(char x) throws IOException {\n            if (i == bufSize) {\n                flush();\n            }\n            buf[i++] = (byte) x;\n        }\n\n        void print(char[] m) throws IOException {\n            for (char c : m) {\n                print(c);\n            }\n        }\n\n        void println(String s) throws IOException {\n            print(s);\n            println();\n        }\n\n        void println() throws IOException {\n            print(newLine);\n        }\n\n        void flush() throws IOException {\n            out.write(buf, 0, i);\n            out.flush();\n            i = 0;\n        }\n\n        void close() throws IOException {\n            flush();\n            out.close();\n        }\n    }\n}", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n/**\n* @author me\n**/\npublic class Test {\n    public static void main(String[] args) {\n        Scanner scannered = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        int n = scannered.nextInt();\n        String s = scannered.next();\n        int[] copied = new int[150];\n        for(int i = 0 ; i < n ; i++)\n        {\n            copied[s.charAt(i)]++;\n        }\n        int odd = 0;\n        for(int i = 0 ; i < 150 ; i++)\n            if(copied[i]%2 == 1)\n                odd++;\n        if(odd > 0)\n        {\n            int addOn = 0;\n            while(n%(odd+addOn) != 0 || (n%(odd+addOn) == 0 && (n/(odd+addOn)%2 == 0)))\n                addOn+=2;\n            int length = n/(odd+addOn);\n            char[][] res = new char[odd+addOn][length];\n            int idx = 0;\n            for(char i = 0 ; i < 150 ; i++) {\n                if(copied[i]%2 == 1) {\n                    res[idx++][length/2] = i;\n                    copied[i]--;\n                }\n            }\n            for(char i = 0 ; i < 150 ; i++) {\n                while(idx < res.length && copied[i] > 0) {\n                    res[idx++][length/2] = i;\n                    res[idx++][length/2] = i;\n                    copied[i]-=2;\n                }\n            }\n            idx = 0;\n            int idx2 = 0;\n            for(char k = 0 ; k < 150 ; k++) {\n                for(int i = 0 ; i < copied[k] ; i+=2) {\n                    while(res[idx][idx2] > 0) {\n                        idx2 = 0;\n                        idx++;\n                    }\n                    res[idx][idx2] = k;\n                    res[idx][length-idx2-1] = k;\n                    idx2++;\n                }\n            }\n            out.println(res.length);\n            for(int i = 0 ; i < res.length ; i++)\n                out.print(new String(res[i]) + \" \");\n        } else {\n            char[] res = new char[n];\n            int idx = 0;\n            for(char k = 0 ; k < 150 ; k++) {\n                for(int i = 0 ; i < copied[k] ; i+=2) {\n                    res[idx] = k;\n                    res[n-idx-1] = k;\n                    idx++;\n                }\n            }\n            out.println(1);\n            out.println(new String(res));\n        }\n        out.close();\n    }\n}", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.InputStreamReader;\nimport java.util.AbstractCollection;\nimport java.util.TreeMap;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.io.BufferedReader;\nimport java.util.LinkedList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        HPalindromicCut solver = new HPalindromicCut();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class HPalindromicCut {\n        int n;\n        char[] arr;\n        int[] count;\n\n        public void readInput(Scanner sc) {\n            n = sc.nextInt();\n            arr = sc.next().toCharArray();\n        }\n\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            int q = 1;\n            while (q-- > 0) {\n                readInput(sc);\n                TreeMap<Character, Integer> map = new TreeMap<>();\n                for (char c : arr)\n                    map.put(c, map.getOrDefault(c, 0) + 1);\n                count = new int[2];\n                for (int x : map.values()) {\n                    count[0] += x / 2;\n                    if (x % 2 == 1)\n                        count[1]++;\n                }\n                TreeMap<Character, Integer> even = new TreeMap<>(), odd = new TreeMap<>();\n                for (Map.Entry<Character, Integer> entry : map.entrySet()) {\n                    int val = entry.getValue();\n                    char c = entry.getKey();\n                    if (val / 2 > 0)\n                        even.put(c, val / 2);\n                    if (val % 2 == 1)\n                        odd.put(c, 1);\n                }\n                int max = 0;\n                for (int i = 1; i * i <= n; i++) {\n                    if (n % i == 0) {\n                        if (valid(i)) {\n                            max = Math.max(max, i);\n                        }\n                        if (valid(n / i)) {\n                            max = Math.max(max, n / i);\n                        }\n                    }\n                }\n                pw.println(n / max);\n                for (int i = 0; i < n / max; i++) {\n                    LinkedList<Character> list = new LinkedList<>();\n                    int ev = max / 2;\n                    count[0] -= ev;\n                    int od = max % 2;\n                    if (count[1] < od) {\n                        count[1] += 2;\n                        count[0]--;\n                        char c = even.firstKey();\n                        even.put(c, even.get(c) - 1);\n                        if (even.get(c) == 0)\n                            even.remove(c);\n                        odd.put(c, odd.getOrDefault(c, 0) + 2);\n                    }\n                    if (od == 1) {\n                        char c = odd.firstKey();\n                        odd.put(c, odd.get(c) - 1);\n                        if (odd.get(c) == 0)\n                            odd.remove(c);\n                        list.addFirst(c);\n                        count[1]--;\n                    }\n                    while (ev > 0) {\n                        char c = even.firstKey();\n                        even.put(c, even.get(c) - 1);\n                        if (even.get(c) == 0)\n                            even.remove(c);\n                        list.addFirst(c);\n                        list.addLast(c);\n                        ev--;\n                    }\n                    StringBuilder sb = new StringBuilder();\n                    while (!list.isEmpty())\n                        sb.append(list.pollFirst());\n                    pw.print(sb.toString() + \" \");\n                }\n            }\n        }\n\n        private boolean valid(int div) {\n            int[] temp = count.clone();\n            for (int i = 0; i < n / div; i++) {\n                int even = div / 2;\n                temp[0] -= even;\n                int odd = div % 2;\n                if (temp[1] < odd) {\n                    temp[1] += 2;\n                    temp[0]--;\n                }\n                temp[1] -= odd;\n            }\n            return temp[0] == 0 && temp[1] == 0;\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            try {\n                while (st == null || !st.hasMoreTokens())\n                    st = new StringTokenizer(br.readLine());\n                return st.nextToken();\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class TaskH {\n\n    private static BufferedReader in;\n    private static StringTokenizer tok;\n    private static PrintWriter out;\n\n    public static String readToken() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    public static int readInt() throws IOException {\n        return Integer.parseInt(readToken());\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        run();\n        in.close();\n        out.close();\n    }\n\n    public static final int CHAR_COUNT = 257;\n\n    public static void run() throws IOException {\n        int n = readInt();\n        int[] counts = new int[CHAR_COUNT];\n        Deque<Character> middle = new ArrayDeque<>();\n        String s = in.readLine();\n        for (int i = 0; i < n; i++) {\n            counts[s.charAt(i)]++;\n        }\n        int k = 0;  // \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u043d\u0435\u0447\u0435\u0442\u043d\u044b\u0445\n        for (int i = 0; i < CHAR_COUNT; i++) {\n            if (counts[i] % 2 != 0) {\n                counts[i]--;\n                middle.push((char) i);\n                k++;\n            }\n        }\n        if (k == 0) {\n            out.println(1);\n            StringBuilder str = new StringBuilder();\n            for (char c = 0; c < CHAR_COUNT; c++) {\n                for (int i = 0; i < counts[c] / 2; i++)\n                    str.append(c);\n            }\n            out.println(str.toString() + str.reverse().toString());\n        } else {\n            while (n % k != 0 || (n / k) % 2 == 0) {\n                char ch = 0;\n                for (char c = 0; c < CHAR_COUNT; c++) {\n                    if (counts[c] >= 2) {\n                        ch = c;\n                        counts[c] -= 2;\n                        break;\n                    }\n                }\n                middle.push(ch);\n                middle.push(ch);\n                k += 2;\n            }\n            out.println(k);\n            int m = n / k - 1;\n            for (int i = 0; i < k; i++) {\n                StringBuilder str = new StringBuilder();\n                int j = m;\n                for (char c = 0; c < CHAR_COUNT; c++) {\n                    if (counts[c] > 0) {\n                        if (counts[c] >= j) {\n                            for (int jj = 0; jj < j / 2; jj++) {\n                                str.append(c);\n                            }\n                            counts[c] -= j;\n                            j = 0;\n                        } else {\n                            for (int jj = 0; jj < counts[c] / 2; jj++) {\n                                str.append(c);\n                            }\n                            j -= counts[c];\n                            counts[c] = 0;\n                        }\n                        if (j == 0) break;\n                    }\n                }\n                out.print(str.toString() + middle.pop() + str.reverse().toString() + \" \");\n            }\n        }\n    }\n}\n", "label": 3}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class H {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tString s = br.readLine();\n\t\tint[] occ = new int[256];\n\t\tfor(int i = 0; i < s.length(); i++)\n\t\t\tocc[s.charAt(i)]++;\n\t\tint odd = 0;\n\t\tArrayList<Integer> odds = new ArrayList<>();\n\t\tfor(int i =0 ; i < 256; i++) {\n\t\t\tif(occ[i] % 2 == 1) {\n\t\t\t\todd++;\n\t\t\t\todds.add(i);\n\t\t\t\tocc[i]--;\n\t\t\t}\n\t\t}\n\n\t\tArrayList<Integer> divs = new ArrayList<Integer>();\n\t\tfor(int i = 1; (long) i * i <= n; i++) {\n\t\t\tif(n % i == 0) {\n\t\t\t\tdivs.add(i);\n\t\t\t\tif(n / i != i)\n\t\t\t\t\tdivs.add(n / i);\n\t\t\t}\n\t\t}\n\n\t\tCollections.sort(divs);\n\t\tint max = 0;\n\t\tfor(int d: divs)\n\t\t{\n\t\t\tif(d % 2 == 0) {\n\t\t\t\tif(odd == 0)\n\t\t\t\t\tmax = d;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint nums = n / d;\n\t\t\tif(odd > nums)\n\t\t\t\tcontinue;\n\t\t\tif(nums % 2 == odd % 2)\n\t\t\t\tmax = d;\n\t\t}\n\n\t\tint numS = n / max;\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tout.println(numS);\n\t\tint oddi = 0;\n\t\tfor(int i = 0; i < numS; i++) {\n\t\t\tchar[] st = new char[max];\n\t\t\tif(oddi < odds.size())\n\t\t\t\tst[max / 2] = (char) odds.get(oddi++).intValue();\n\t\t\telse if(max % 2 == 1) {\n\t\t\t\tfor(int k = 0; k < 256; k++)\n\t\t\t\t\tif(occ[k] > 0) {\n\t\t\t\t\t\todds.add(k);\n\t\t\t\t\t\tocc[k]-=2;\n\t\t\t\t\t\tst[max / 2] = (char) k;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int j = 0; j < max / 2; j++) {\n\t\t\t\tfor(int k = 0; k < 256; k++) {\n\t\t\t\t\tif(occ[k] > 0) {\n\t\t\t\t\t\tst[j] = (char)(k);\n\t\t\t\t\t\tst[max - 1 - j] = (char)(k);\n\t\t\t\t\t\tocc[k] -= 2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tout.print(new String(st));\n\t\t\tif(i == numS - 1)\n\t\t\t\tout.println();\n\t\t\telse\n\t\t\t\tout.print(\" \");\n\t\t}\n\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.BigInteger;\nimport java.util.Map.Entry;\n\nimport static java.lang.Math.*;\n\npublic class Main extends PrintWriter {\n\n    List<String> solve(final int n, final int m, final int k, int[] cnt) {\n        int odd = 0;\n\n        for (int c = 0; c < k; c++) {\n            if (cnt[c] % 2 == 1) {\n                ++odd;\n            }\n        }\n\n        if (m % 2 == 0 && odd > 0) {\n            return null;\n        }\n\n        if (m % 2 == 1 && odd > n) {\n            return null;\n        }\n\n        List<String> ans = new ArrayList<>();\n\n        char[] buffer = new char[m + 23];\n\n        for (int i = 0; i < n; i++) {\n            int l = buffer.length / 2;\n            int r = l + 1;\n\n            if (m % 2 == 0) {\n                int size = 0;\n\n                for (char c = 0; size < m && c < k; c++) {\n                    while (size < m && cnt[c] >= 2) {\n                        buffer[l--] = c;\n                        buffer[r++] = c;\n                        cnt[c] -= 2;\n                        size += 2;\n                    }\n                }\n            } else {\n\n                int size = 0;\n\n                for (char c = 0; size < 1 && c < k; c++) {\n                    if (cnt[c] % 2 == 1) {\n                        buffer[r++] = c;\n                        cnt[c] -= 1;\n                        size += 1;\n                    }\n                }\n\n                for (char c = 0; size < 1 && c < k; c++) {\n                    if (cnt[c] >= 1) {\n                        buffer[r++] = c;\n                        cnt[c] -= 1;\n                        size += 1;\n                    }\n                }\n\n                for (char c = 0; size < m && c < k; c++) {\n                    while (size < m && cnt[c] >= 2) {\n                        buffer[l--] = c;\n                        buffer[r++] = c;\n                        cnt[c] -= 2;\n                        size += 2;\n                    }\n                }\n\n            }\n\n            ans.add(new String(buffer, l + 1, m));\n        }\n\n        return ans;\n    }\n\n    void run() {\n        int n = nextInt();\n        int k = 123;\n\n        int[] cnt = new int[k];\n\n        String w = next();\n\n        for (int i = 0; i < n; i++) {\n            ++cnt[w.codePointAt(i)];\n        }\n\n        for (int m = n; m >= 1; m--) {\n            if (n % m == 0) {\n                List<String> list = solve(n / m, m, k, cnt.clone());\n                if (list != null) {\n                    println(list.size());\n\n                    for (String string : list) {\n                        print(string);\n                        print(' ');\n                    }\n\n                    break;\n                }\n            }\n\n        }\n\n    }\n\n    public static boolean nextPermutation(int[] permutation) {\n        int n = permutation.length, a = n - 2;\n        while (0 <= a && permutation[a] >= permutation[a + 1]) {\n            a--;\n        }\n        if (a == -1) {\n            return false;\n        }\n\n        int b = n - 1;\n        while (permutation[b] <= permutation[a]) {\n            b--;\n        }\n\n        swap(permutation, a, b);\n        for (int i = a + 1, j = n - 1; i < j; i++, j--) {\n            swap(permutation, i, j);\n        }\n        return true;\n    }\n\n    public static void swap(int[] array, int i, int j) {\n        if (i == j) {\n            return;\n        }\n        array[i] ^= array[j];\n        array[j] ^= array[i];\n        array[i] ^= array[j];\n    }\n\n    int[][] nextMatrix(int n, int m) {\n        int[][] matrix = new int[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                matrix[i][j] = nextInt();\n        return matrix;\n    }\n\n    String next() {\n        while (!tokenizer.hasMoreTokens())\n            tokenizer = new StringTokenizer(nextLine());\n        return tokenizer.nextToken();\n    }\n\n    boolean hasNext() {\n        while (!tokenizer.hasMoreTokens()) {\n            String line = nextLine();\n            if (line == null) {\n                return false;\n            }\n            tokenizer = new StringTokenizer(line);\n        }\n        return true;\n    }\n\n    int[] nextArray(int n) {\n        int[] array = new int[n];\n        for (int i = 0; i < n; i++) {\n            array[i] = nextInt();\n        }\n        return array;\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException err) {\n            return null;\n        }\n    }\n\n    public Main(OutputStream outputStream) {\n        super(outputStream);\n    }\n\n    static BufferedReader reader;\n    static StringTokenizer tokenizer = new StringTokenizer(\"\");\n    static Random rnd = new Random();\n\n    public static void main(String[] args) throws IOException {\n        reader = new BufferedReader(new InputStreamReader(System.in));\n        Main solution = new Main(System.out);\n        solution.run();\n        solution.close();\n        reader.close();\n    }\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\nimport static java.lang.Math.sqrt;\n\npublic class SolutionH extends Thread {\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                                            InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    private static final FastReader scanner = new FastReader();\n    private static final PrintWriter out = new PrintWriter(System.out);\n\n    public static void main(String[] args) {\n        solve();\n        out.close();\n    }\n\n\n    public static List<Integer> getDivisorsOfN(int n) {\n        List<Integer> result = new ArrayList<>();\n\n        result.add(1);\n\n        if (n != 1) {\n            result.add(n);\n        }\n\n        for (int i = 2; i <= sqrt(n); i++) {\n            if (n % i == 0) {\n                result.add(i);\n\n                if (n / i != i) {\n                    result.add(n / i);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private static void solve() {\n        int n = scanner.nextInt();\n        List<Integer> divisors = getDivisorsOfN(n);\n        Collections.sort(divisors);\n        String s = scanner.next();\n        int[] distr = new int[123];\n        for (char c: s.toCharArray()) {\n            distr[c]++;\n        }\n\n        List<Character> middleChar = new ArrayList<>();\n        int amountOddParity = 0;\n        for (int i = 0; i < 123; i++) {\n            if (distr[i] % 2 == 1) {\n                amountOddParity++;\n                middleChar.add((char) i);\n                distr[i]--;\n            }\n        }\n\n        if (amountOddParity == 0) {\n            out.println(1);\n            int pointerChars = 0;\n            char[] string = new char[n];\n            for (int j = 0; j < n / 2; j++) {\n                while (distr[pointerChars] == 0) {\n                    pointerChars++;\n                }\n                string[j] = (char) pointerChars;\n                string[n - 1 - j] = (char) pointerChars;\n                distr[pointerChars] -= 2;\n            }\n            StringBuilder output = new StringBuilder();\n            for (int j = 0; j < n; j++) {\n                output.append(string[j]);\n            }\n            out.println(output);\n            return;\n        }\n\n        int amountPalindromes = n;\n        for (Integer divisor : divisors) {\n            if (divisor >= amountOddParity && (n / divisor) % 2 == 1 && (divisor - amountOddParity) % 2 == 0) {\n                amountPalindromes = divisor;\n                break;\n            }\n        }\n\n        int palindromeLength = n / amountPalindromes;\n        if (middleChar.size() < amountPalindromes && palindromeLength % 2 == 1) {\n            char_iteration:\n            for (int i = 0; i < 123; i++) {\n                while (distr[i] > 0) {\n                    middleChar.add((char) i);\n                    middleChar.add((char) i);\n                    distr[i] -= 2;\n                    if (middleChar.size() >= amountPalindromes) {\n                        break char_iteration;\n                    }\n                }\n            }\n        }\n        int pointerChars = 0;\n        StringBuilder output = new StringBuilder();\n        for (int i = 0; i < amountPalindromes; i++) {\n            char[] string = new char[palindromeLength];\n            string[palindromeLength/2] = middleChar.get(i);\n            for (int j = 0; j < palindromeLength/2; j++) {\n                while (distr[pointerChars] == 0) {\n                    pointerChars++;\n                }\n                string[j] = (char) pointerChars;\n                string[palindromeLength - 1 - j] = (char) pointerChars;\n                distr[pointerChars] -= 2;\n            }\n            for (int j = 0; j < palindromeLength; j++) {\n                output.append(string[j]);\n            }\n            output.append(\" \");\n        }\n\n        out.println(amountPalindromes);\n        out.println(output);\n    }\n\n    //REMINDERS:\n    //- CHECK FOR INTEGER-OVERFLOW BEFORE SUBMITTING\n\n    //- CAN U BRUTEFORCE OVER SOMETHING, TO MAKE IT EASIER TO CALCULATE THE SOLUTION\n}", "label": 3}
{"src": "\nimport java.io.*;\nimport java.util.*;\n\npublic class tr7 {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken());\n\t\tString s = br.readLine();\n\t\tTreeMap<Character, Integer> even = new TreeMap<>(), odd = new TreeMap<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tchar x = s.charAt(i);\n\t\t\tint max = Math.max(even.getOrDefault(x, 0), odd.getOrDefault(x, 0));\n\t\t\tmax++;\n\t\t\tif (max % 2 == 0) {\n\t\t\t\todd.remove(x);\n\t\t\t\teven.put(x, max);\n\t\t\t} else {\n\t\t\t\teven.remove(x);\n\t\t\t\todd.put(x, max);\n\t\t\t}\n\t\t}\n\t\tArrayList<Integer> divs = new ArrayList<>();\n\t\tfor (int d = 1; d <= n / d; d++) {\n\t\t\tif (n % d != 0)\n\t\t\t\tcontinue;\n\t\t\tdivs.add(d);\n\t\t\tif (d != n / d)\n\t\t\t\tdivs.add(n / d);\n\t\t}\n\t\tint ans = 0;\n\t\tCollections.sort(divs, Collections.reverseOrder());\n\t\tArrayList<char[]> pr = new ArrayList<>();\n\t\tfor (int p : divs) {\n\t\t\tif (p % 2 == 0 && odd.size() > 0)\n\t\t\t\tcontinue;\n\t\t\tif (p % 2 == 1) {\n\t\t\t\tint num = n / p;\n\t\t\t\tif (odd.size() > num)\n\t\t\t\t\tcontinue;\n\t\t\t\tint rest = num - odd.size();\n\t\t\t\tif (rest % 2 == 1)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint num = n / p;\n\t\t\tfor (int i = 0; i < num; i++)\n\t\t\t\tpr.add(new char[p]);\n\t\t\tif (p % 2 == 0) {\n\t\t\t\tint id = 0;\n\t\t\t\tint pos = 0;\n\t\t\t\tfor (Character g : even.keySet()) {\n\t\t\t\t\tint c = even.get(g);\n\t\t\t\t\twhile (c > 0) {\n\t\t\t\t\t\tpr.get(id)[pos] = g;\n\t\t\t\t\t\tpr.get(id)[p - pos - 1] = g;\n\t\t\t\t\t\tid++;\n\t\t\t\t\t\tif (id == num) {\n\t\t\t\t\t\t\tid = 0;\n\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc -= 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tint idx = 0;\n\t\t\t\twhile (!odd.isEmpty()) {\n\t\t\t\t\tchar k = odd.firstKey();\n\t\t\t\t\tint gk = odd.get(k);\n\t\t\t\t\todd.pollFirstEntry();\n\t\t\t\t\tpr.get(idx)[p / 2] = k;\n\t\t\t\t\tif (gk != 1)\n\t\t\t\t\t\teven.put(k, gk - 1);\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t\twhile (idx < num) {\n\t\t\t\t\tchar k = even.firstKey();\n\t\t\t\t\tint gk = even.get(k);\n\t\t\t\t\teven.remove(k);\n\t\t\t\t\tpr.get(idx)[p / 2] = k;\n\t\t\t\t\tidx++;\n\t\t\t\t\tpr.get(idx)[p / 2] = k;\n\t\t\t\t\tidx++;\n\t\t\t\t\tgk -= 2;\n\t\t\t\t\tif (gk > 0)\n\t\t\t\t\t\teven.put(k, gk);\n\t\t\t\t}\n\t\t\t\tint id = 0;\n\t\t\t\tint pos = 0;\n\t\t\t\tfor (Character g : even.keySet()) {\n\t\t\t\t\tint c = even.get(g);\n\t\t\t\t\twhile (c > 0) {\n\t\t\t\t\t\tpr.get(id)[pos] = g;\n\t\t\t\t\t\tpr.get(id)[p - pos - 1] = g;\n\t\t\t\t\t\tid++;\n\t\t\t\t\t\tif (id == num) {\n\t\t\t\t\t\t\tid = 0;\n\t\t\t\t\t\t\tpos++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tc -= 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = num;\n\t\t\tbreak;\n\n\t\t}\n\t\tout.println(ans);\n\t\tfor (char[] y : pr)\n\t\t\tout.print(new String(y) + \" \");\n\t\tout.flush();\n\t}\n\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF883H extends PrintWriter {\n\tCF883H() { super(System.out, true); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF883H o = new CF883H(); o.main(); o.flush();\n\t}\n\n\tstatic final int A = 26 + 26 + 10;\n\tint[] kk = new int[A];\n\tbyte a2c(int a) {\n\t\tint c;\n\t\tif (a < 26)\n\t\t\tc = 'a' + a;\n\t\telse if (a < 26 + 26)\n\t\t\tc = 'A' + a - 26;\n\t\telse\n\t\t\tc = '0' + a - 26 - 26;\n\t\treturn (byte) c;\n\t}\n\tint c2a(byte c) {\n\t\tint a;\n\t\tif ('a' <= c && c <= 'z')\n\t\t\ta = c - 'a';\n\t\telse if ('A' <= c && c <= 'Z')\n\t\t\ta = c - 'A' + 26;\n\t\telse\n\t\t\ta = c - '0' + 26 + 26;\n\t\treturn a;\n\t}\n\tvoid fill(byte[] bb, int m) {\n\t\tint l = 0, r = m - 1;\n\t\tfor (int a = 0; a < A && l < r; a++)\n\t\t\twhile (kk[a] >= 2 && l < r) {\n\t\t\t\tkk[a] -= 2;\n\t\t\t\tbb[l++] = bb[r--] = a2c(a);\n\t\t\t}\n\t\tif (l == r) {\n\t\t\tint a = 0;\n\t\t\twhile (a < A && kk[a] % 2 == 0)\n\t\t\t\ta++;\n\t\t\tif (a == A) {\n\t\t\t\ta = 0;\n\t\t\t\twhile (a < A && kk[a] == 0)\n\t\t\t\t\ta++;\n\t\t\t}\n\t\t\tkk[a]--;\n\t\t\tbb[l] = a2c(a);\n\t\t}\n\t}\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tbyte[] cc = sc.next().getBytes();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = c2a(cc[i]);\n\t\t\tkk[a]++;\n\t\t}\n\t\tint o = 0;\n\t\tfor (int a = 0; a < A; a++)\n\t\t\tif (kk[a] % 2 == 1)\n\t\t\t\to++;\n\t\tint m;\n\t\tif (o == 0)\n\t\t\tm = n;\n\t\telse {\n\t\t\tm = n / o;\n\t\t\tif (m % 2 == 0)\n\t\t\t\tm--;\n\t\t\twhile (n % m != 0)\n\t\t\t\tm -= 2;\n\t\t}\n\t\tbyte[] bb = new byte[m + 1]; bb[m] = ' ';\n\t\tint k = n / m;\n\t\tprintln(k);\n\t\twhile (k-- > 0) {\n\t\t\tfill(bb, m);\n\t\t\tprint(new String(bb));\n\t\t}\n\t\tprintln();\n\t}\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class _883_H {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        int n = Integer.parseInt(in.readLine());\n        String s = in.readLine();\n        HashMap<Character, Integer> freqs = new HashMap<Character, Integer>();\n        for(int i = 0; i < n; i++) {\n            char c = s.charAt(i);\n            Integer freq = freqs.get(c);\n            if(freq == null) freq = 0;\n            freqs.put(c, freq + 1);\n        }\n        char[][] res = null;\n        for(int i = 1; i <= n; i++) {\n            res = split(n, i, freqs);\n            if(res != null) break;\n        }\n        out.println(res.length);\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < res.length; i++) {\n            for(int j = 0; j < res[i].length; j++) {\n                sb.append(res[i][j]);\n            }\n            if(i < res.length - 1) sb.append(' ');\n        }\n        out.println(sb.toString());\n        in.close();\n        out.close();\n    }\n    static char[][] split(int n, int k, HashMap<Character, Integer> freqs) {\n        if(n % k != 0) return null;\n        int size = n / k;\n        char[][] pals = new char[k][size];\n        if(size % 2 == 0) {\n            boolean alleven = true;\n            for(char c : freqs.keySet()) {\n                if(freqs.get(c) % 2 == 1) alleven = false;\n            }\n            if(!alleven) return null;\n            int rp = 0;\n            int cp = 0;\n            for(char c : freqs.keySet()) {\n                int freq = freqs.get(c);\n                for(int i = 0; i < freq; i += 2) {\n                    pals[rp][cp] = c;\n                    pals[rp][size - cp - 1] = c;\n                    cp++;\n                    if(cp >= size / 2) {\n                        cp = 0;\n                        rp++;\n                    }\n                }\n            }\n        }else {\n            int mid = size / 2;\n            int numodd = 0;\n            for(char c : freqs.keySet()) {\n                if(freqs.get(c) % 2 == 1) numodd++;\n            }\n            if(numodd > k) return null;\n            HashMap<Character, Integer> freqs2 = new HashMap<Character, Integer>();\n            int rp = 0;\n            for(char c : freqs.keySet()) {\n                int freq = freqs.get(c);\n                if(freq % 2 == 1) {\n                    pals[rp][mid] = c;\n                    if(freq > 1) {\n                        freqs2.put(c, freq - 1);\n                    }\n                    rp++;\n                }else {\n                    freqs2.put(c, freq);\n                }\n            }\n            HashMap<Character, Integer> freqs3 = new HashMap<Character, Integer>(); \n            for(char c : freqs2.keySet()) {\n                int freq = freqs2.get(c);\n                int left = freq;\n                for(int i = 0; i < freq; i++) {\n                    if(rp >= pals.length) break;\n                    pals[rp][mid] = c;\n                    rp++;\n                    left--;\n                }\n                if(left > 0) {\n                    freqs3.put(c, left);\n                }\n            }\n            rp = 0;\n            int cp = 0;\n            for(char c : freqs3.keySet()) {\n                int freq = freqs3.get(c);\n                for(int i = 0; i < freq; i += 2) {\n                    pals[rp][cp] = c;\n                    pals[rp][size - cp - 1] = c;\n                    cp++;\n                    if(cp >= mid) {\n                        cp = 0;\n                        rp++;\n                    }\n                }\n            }\n        }\n        return pals;\n    }\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class MainH {\n\t\n\tpublic static void main(String[] args) {\n\t\tStdIn in = new StdIn();\n\t\tint n=in.nextInt();\n\t\tint[] cnt = new int[256];\n\t\tString s = in.next();\n\t\tfor(char c : s.toCharArray())\n\t\t\t++cnt[c];\n\t\tList<Character> oddEntries = new ArrayList<Character>();\n\t\tfor(int i=0; i<256; ++i)\n\t\t\tif(cnt[i]%2==1) {\n\t\t\t\toddEntries.add((char)i);\n\t\t\t\t--cnt[i];\n\t\t\t}\n\t\tif(oddEntries.isEmpty()) {\n\t\t\tStringBuilder a = new StringBuilder();\n\t\t\tStringBuilder b = new StringBuilder();\n\t\t\tint i=0;\n\t\t\twhile(true) {\n\t\t\t\twhile(i<256&&cnt[i]==0)\n\t\t\t\t\t++i;\n\t\t\t\tif(i>=256)\n\t\t\t\t\tbreak;\n\t\t\t\ta.append((char) i);\n\t\t\t\tb.append((char) i);\n\t\t\t\tcnt[i]-=2;\n\t\t\t}\n\t\t\tb.reverse();\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(a.toString()+b.toString());\n\t\t\treturn;\n\t\t}\n\t\twhile(true) {\n\t\t\tif((n-oddEntries.size())/2%oddEntries.size()==0) {\n\t\t\t\tSystem.out.println(oddEntries.size());\n\t\t\t\tint i=0, pairsPWord=(n-oddEntries.size())/2/oddEntries.size();\n\t\t\t\tfor(char c : oddEntries) {\n\t\t\t\t\tStringBuilder a = new StringBuilder();\n\t\t\t\t\tStringBuilder b = new StringBuilder();\n\t\t\t\t\tfor(int j=0; j<pairsPWord; ++j) {\n\t\t\t\t\t\twhile (cnt[i] == 0)\n\t\t\t\t\t\t\t++i;\n\t\t\t\t\t\ta.append((char) i);\n\t\t\t\t\t\tb.append((char) i);\n\t\t\t\t\t\tcnt[i] -= 2;\n\t\t\t\t\t}\n\n\t\t\t\t\tb.reverse();\n\t\t\t\t\tSystem.out.print(a.toString()+c+b.toString()+\" \");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t} else {\n\t\t\t\tfor(int i=0; i<256; ++i) {\n\t\t\t\t\tif(cnt[i]>0) {\n\t\t\t\t\t\toddEntries.add((char)i);\n\t\t\t\t\t\toddEntries.add((char)i);\n\t\t\t\t\t\tcnt[i]-=2;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tinterface Input {\n\t\tpublic String next();\n\t\tpublic String nextLine();\n\t\tpublic int nextInt();\n\t\tpublic long nextLong();\n\t\tpublic double nextDouble();\n\t}\n\tstatic class StdIn implements Input {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\n\t\tpublic StdIn() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\t\t\n\t\tpublic StdIn(String filename) {\n\t\t\ttry{\n\t\t\t\tdin = new DataInputStream(new FileInputStream(filename));\n\t\t\t} catch(Exception e) {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\t\t\n\t\tpublic String next() {\n\t\t\tint c;\n\t\t\twhile((c=read())!=-1&&(c==' '||c=='\\n'||c=='\\r'));\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\twhile (c != -1)\n\t\t\t{\n\t\t\t\tif (c == ' ' || c == '\\n'||c=='\\r')\n\t\t\t\t\tbreak;\n\t\t\t\ts.append((char)c);\n\t\t\t\tc=read();\n\t\t\t}\n\t\t\treturn s.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c;\n\t\t\twhile((c=read())!=-1&&(c==' '||c=='\\n'||c=='\\r'));\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\twhile (c != -1)\n\t\t\t{\n\t\t\t\tif (c == '\\n'||c=='\\r')\n\t\t\t\t\tbreak;\n\t\t\t\ts.append((char)c);\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\treturn s.toString();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo\n\t\t\t{\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t}  while ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic int[] readIntArray(int n) {\n\t\t\tint[] ar = new int[n];\n\t\t\tfor(int i=0; i<n; ++i)\n\t\t\t\tar[i]=nextInt();\n\t\t\treturn ar;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t}\n\t\t\twhile ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic long[] readLongArray(int n) {\n\t\t\tlong[] ar = new long[n];\n\t\t\tfor(int i=0; i<n; ++i)\n\t\t\t\tar[i]=nextLong();\n\t\t\treturn ar;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\n\t\t\tdo {\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\t}\n\t\t\twhile ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (c == '.')\n\t\t\t{\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9')\n\t\t\t\t{\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\n\t\tprivate byte read() {\n\t\t\ttry{\n\t\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\t\tfillBuffer();\n\t\t\t\treturn buffer[bufferPointer++];\n\t\t\t} catch(IOException e) {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\t}\n}", "label": 3}
{"src": "\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class ProblemH {\n\n\tpublic static void main(String[] args) {\n\n\t\tPalindromicCut PC = new PalindromicCut();\n\t\tPC.solve();\n\t\tPC.print();\n\n\t}\n\n}\n\nclass PalindromicCut {\n\n\tScanner sc;\n\tint n;\n\tString string;\n\tArrayList<Integer> list;\n\tArrayList<Integer> center;\n\tArrayList<String> answer;\n\n\tPalindromicCut() {\n\t\tlist = new ArrayList<>(62);\n\t\tfor (int i = 0; i < 62; i++) {\n\t\t\tlist.add(0);\n\t\t}\n\t\tsc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tstring = sc.next();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tchar p = string.charAt(i);\n\t\t\tif (p >= 'A' && p <= 'Z')\n\t\t\t\tlist.set((int) p - (int) 'A', list.get((int) p - (int) 'A') + 1);\n\t\t\telse if (p >= 'a' && p <= 'z')\n\t\t\t\tlist.set((int) p - (int) 'a' + 26, list.get((int) p - (int) 'a' + 26) + 1);\n\t\t\telse\n\t\t\t\tlist.set((int) p - (int) '0' + 52, list.get((int) p - (int) '0' + 52) + 1);\n\t\t}\n\t\tsc.close();\n\n\t\tcenter = new ArrayList<>();\n\t}\n\n\tvoid solve() {\n\n\t\tanswer = new ArrayList<>();\n\n\t\tint odd = 0;\n\t\tfor (int i = 0; i < 62; i++) {\n\t\t\tif (list.get(i) % 2 != 0) {\n\t\t\t\todd++;\n\t\t\t\tcenter.add(i);\n\t\t\t\tlist.set(i, list.get(i) - 1);\n\t\t\t}\n\t\t}\n\n\t\tif (odd == 0) {\n\t\t\tchar[] word = new char[n];\n\t\t\tint i = 0;\n\n\t\t\tfor (int k = 0; k < n / 2; k++) {\n\t\t\t\twhile (i < 62 && list.get(i) == 0) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tword[k] = fun(i);\n\t\t\t\tword[n - k - 1] = fun(i);\n\t\t\t\tlist.set(i, list.get(i) - 2);\n\t\t\t}\n\t\t\tanswer.add(String.valueOf(word));\n\t\t\treturn;\n\t\t} // odd\n\n\t\tint idx = 0;\n\n\t\twhile (!(n % odd == 0) || (n/odd) % 2 == 0) {\n\t\t\twhile (idx < 62 && list.get(idx) == 0) {\n\t\t\t\tidx++;\n\t\t\t}\n\t\t\tlist.set(idx, list.get(idx) - 2);\n\t\t\tcenter.add(idx);\n\t\t\tcenter.add(idx);\n\t\t\todd = odd + 2;\n\t\t} // while\n\n\t\tint l = n / odd;\n\t\tchar[] word = new char[l];\n\n\t\tint i = idx;\n\t\tfor (int j = 0; j < odd; j++) {\n\t\t\tword[l / 2] = fun(center.get(j));\n\n\t\t\tfor (int k = 0; k < l / 2; k++) {\n\t\t\t\twhile (i < 62 && list.get(i) == 0) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tword[k] = fun(i);\n\t\t\t\tword[l - k - 1] = fun(i);\n\t\t\t\tlist.set(i, list.get(i) - 2);\n\n\t\t\t}\n\t\t\tanswer.add(String.valueOf(word));\n\t\t}\n\n\t} // solve\n\n\tvoid print() {\n\t\tSystem.out.println(answer.size());\n\t\tfor (String s : answer) {\n\t\t\tSystem.out.print(s + \" \");\n\t\t}\n\t}\n\n\tchar fun(int x) {\n\t\tchar c;\n\t\tif (x < 26)\n\t\t\tc = (char) ((int) 'A' + x);\n\t\telse if (x < 52)\n\t\t\tc = (char) ((int) 'a' + x - 26);\n\t\telse\n\t\t\tc = (char) ((int) '0' + x - 52);\n\n\t\treturn c;\n\t}\n}", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskH solver = new TaskH();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskH {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            String s = in.next();\n            int[] cnt = new int[128];\n            for (int i = 0; i < n; i++) {\n                cnt[s.charAt(i)]++;\n            }\n            int oddCnt = 0;\n            for (int i = 0; i < 128; i++) {\n                if (cnt[i] % 2 == 1) oddCnt++;\n            }\n            ArrayList<Integer> qty = new ArrayList<>();\n            for (int i = 1; i * i <= n; i++) {\n                if (n % i == 0) {\n                    qty.add(i);\n                    if (n / i != i) {\n                        qty.add(n / i);\n                    }\n                }\n            }\n            qty.sort(Integer::compareTo);\n            for (int q : qty) {\n                if ((q == 1 && oddCnt == n % 2)\n                        || ((n / q) % 2 == 1 && q >= oddCnt && (q - oddCnt) % 2 == 0)\n                        || ((n / q) % 2 == 0) && oddCnt == 0) {\n                    out.println(q);\n                    out.println(build(cnt, q, n));\n                    return;\n                }\n            }\n        }\n\n        String build(int[] charCnt, int qty, int n) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < qty; i++) {\n                sb.append(buildPal(charCnt, n / qty));\n                if (i != qty - 1) sb.append(\" \");\n            }\n            return sb.toString();\n        }\n\n        String buildPal(int[] charCnt, int len) {\n            char[] ans = new char[len];\n            if (len % 2 == 1) {\n                for (int i = 0; i < 128; i++) {\n                    if (charCnt[i] % 2 == 1) {\n                        charCnt[i]--;\n                        ans[len / 2] = (char) i;\n                        break;\n                    }\n                }\n                if (ans[len / 2] == 0) {\n                    for (int i = 0; i < 128; i++) {\n                        if (charCnt[i] > 0) {\n                            charCnt[i]--;\n                            ans[len / 2] = (char) i;\n                            break;\n                        }\n                    }\n                }\n            }\n            char ind = 0;\n            for (int i = 0; i < len / 2; i++) {\n                while (charCnt[ind] < 2) ind++;\n                ans[i] = ind;\n                ans[len - i - 1] = ind;\n                charCnt[ind] -= 2;\n            }\n            return new String(ans);\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer stt;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public String next() {\n            while (stt == null || !stt.hasMoreTokens()) {\n                stt = new StringTokenizer(nextLine());\n            }\n            return stt.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        ArrayList<StringBuilder> list = new ArrayList<>();\n        int n = Integer.parseInt(in.readLine());\n        String string = in.readLine();\n        int[] freq = new int[200];\n        for (int i = 0; i < string.length(); i++) {\n            freq[string.charAt(i)]++;\n        }\n        for (int i = 0; i < 200; i++) {\n            if (freq[i] % 2 == 1) {\n                list.add(new StringBuilder((char)(i) + \"\"));\n                freq[i]--;\n            }\n        }\n        if (list.isEmpty()) {\n            StringBuilder left = new StringBuilder(\"\");\n            StringBuilder right = new StringBuilder(\"\");\n            while (true) {\n                boolean flag = false;\n                for (int i = 0; i < 200; i++) {\n                    if (freq[i] >= 2) {\n                        left.append((char) (i));\n                        right.append((char) (i));\n                        freq[i] -= 2;\n                        flag = true;\n                    }\n                }\n                if (!flag) {\n                    break;\n                }\n            }\n            out.println(\"1\");\n            out.println(left.toString() + right.reverse().toString());\n            out.close();\n            return;\n        }\n\n        while (true) {\n            /*System.out.println(\"STRINGS \");\n            for (StringBuilder sb : list) {\n                System.out.println(sb.toString());\n            }*/\n            int sum = 0;\n            for (int i = 0; i < 200; i++) {\n                if (freq[i] > 0) {\n                    sum += freq[i];\n                }\n            }\n            if ((sum/2) % list.size() == 0) {\n                out.println(list.size());\n                for (StringBuilder sb : list) {\n                    int per = sum/list.size();\n                    StringBuilder left = new StringBuilder(\"\");\n                    StringBuilder right = new StringBuilder(\"\");\n                    outer: while (true) {\n                        for (int i = 0; i < 200; i++) {\n                            if (per == 0) {\n                                break outer;\n                            }\n                            if (freq[i] >= 2) {\n                                left.append((char) (i));\n                                right.append((char) (i));\n                                freq[i] -= 2;\n                                per -= 2;\n                            }\n                        }\n                    }\n                    out.print(left.toString() + sb.toString() + right.reverse().toString() + \" \");\n                }\n                out.print('\\n');\n                out.close();\n                return;\n            }\n            for (int i = 0; i < 200; i++) {\n                if (freq[i] >= 2) {\n                    list.add(new StringBuilder((char)(i) + \"\"));\n                    list.add(new StringBuilder((char)(i) + \"\"));\n                    freq[i] -= 2;\n                    break;\n                }\n            }\n        }\n    }\n\n}\n\n/*\n20\nqqqoqqoqMoqMMMqqMMqM\n\n\n */", "label": 3}
{"src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static MyScanner in;\n    static PrintWriter out;\n\n    /*\n    20\n11111111111111111123\n     */\n\n    public static void main(String[] args) throws IOException {\n        in = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out), false);\n\n        int n = in.nextInt();\n        String s = in.next();\n\n        int[] chet = new int[1000];\n        int[] nechet = new int[1000];\n\n        for (int i = 0; i < n; i++) {\n            char ch = s.charAt(i);\n\n            nechet[ch]++;\n            if (nechet[ch] == 2) {\n                nechet[ch] = 0;\n                chet[ch]++;\n            }\n        }\n\n        int chetCnt = 0;\n        for (int c : chet)\n            chetCnt += c;\n        int nechetCnt = 0;\n        for (int c : nechet)\n            nechetCnt += c;\n\n        int k = bestK(chetCnt, nechetCnt, n);\n        int mig = 0;\n        int nechet2 = nechetCnt;\n        for (int chet2 = chetCnt - 1; chet2 > 0; chet2--) {\n            nechet2 += 2;\n            if (nechet2 > chet2)\n                break;\n\n            int canK = bestK(chet2, nechet2, n);\n            if (canK < k) {\n                mig += chetCnt - chet2;\n                nechetCnt = nechet2;\n                chetCnt = chet2;\n                k = canK;\n            }\n        }\n//        System.out.println(mig);\n        migrate(chet, nechet, mig);\n\n\n        out.println(k);\n\n        //create\n        LinkedList<Character>[] ans = new LinkedList[k];\n        for (int i = 0; i < k; i++)\n            ans[i] = new LinkedList<>();\n\n        if (k == 1) {\n            fillNechet(ans, nechet);\n            fillChet(ans, chet);\n        } else if (k == n) {\n            int i = 0;\n            for (char ch : s.toCharArray())\n                ans[i++].addLast(ch);\n        } else {\n            fillNechet(ans, nechet);\n            fillChet(ans, chet);\n        }\n\n        //print\n        for (LinkedList<Character> list : ans) {\n            for (char ch : list)\n                out.print(ch);\n            out.print(\" \");\n        }\n        out.println();\n        out.flush();\n        out.close();\n    }\n\n    static void migrate(int[] chet, int[] nechet, int m) {\n\n        for (int i = 0; m != 0 && i < chet.length; i++) {\n            if (chet[i] != 0) {\n                chet[i]--;\n                nechet[i] += 2;\n                m--;\n                i--;\n            }\n        }\n\n    }\n\n    static int bestK(int chet, int nechet, int len) {\n        if (nechet == 0)\n            return 1;\n        else if (chet % nechet == 0)\n            return nechet;\n        else\n            return len;\n    }\n\n    static void fillNechet(LinkedList<Character>[] arr, int[] nechet) {\n        int index = -1;\n\n        for (int i = 0; i < nechet.length; i++) {\n            if (nechet[i] == 0)\n                continue;\n\n            index++;\n            if (index == arr.length)\n                index = 0;\n\n            char ch = (char) i;\n            arr[index].addFirst(ch);\n            nechet[i]--;\n            i--;\n        }\n    }\n\n    static void fillChet(LinkedList<Character>[] arr, int[] chet) {\n        int index = -1;\n\n        for (int i = 0; i < chet.length; i++) {\n            if (chet[i] == 0)\n                continue;\n\n            index++;\n            if (index == arr.length)\n                index = 0;\n\n            char ch = (char) i;\n            arr[index].addFirst(ch);\n            arr[index].addLast(ch);\n            chet[i]--;\n            i--;\n        }\n    }\n}\n\nclass MyScanner implements Closeable {\n\n    public static final String CP1251 = \"cp1251\";\n\n    private final BufferedReader br;\n    private StringTokenizer st;\n    private String last;\n\n    public MyScanner() {\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public MyScanner(String path) throws IOException {\n        br = new BufferedReader(new FileReader(path));\n    }\n\n    public MyScanner(String path, String decoder) throws IOException {\n        br = new BufferedReader(new InputStreamReader(new FileInputStream(path), decoder));\n    }\n\n    public void close() throws IOException {\n        br.close();\n    }\n\n    public String next() throws IOException {\n        while (st == null || !st.hasMoreElements())\n            st = new StringTokenizer(br.readLine());\n        last = null;\n        return st.nextToken();\n    }\n\n    public String next(String delim) throws IOException {\n        while (st == null || !st.hasMoreElements())\n            st = new StringTokenizer(br.readLine());\n        last = null;\n        return st.nextToken(delim);\n    }\n\n    public String nextLine() throws IOException {\n        st = null;\n        return (last == null) ? br.readLine() : last;\n    }\n\n    public boolean hasNext() {\n        if (st != null && st.hasMoreElements())\n            return true;\n\n        try {\n            while (st == null || !st.hasMoreElements()) {\n                last = br.readLine();\n                st = new StringTokenizer(last);\n            }\n        } catch (Exception e) {\n            return false;\n        }\n\n        return true;\n    }\n\n    public String[] nextStrings(int n) throws IOException {\n        String[] arr = new String[n];\n        for (int i = 0; i < n; i++)\n            arr[i] = next();\n        return arr;\n    }\n\n    public String[] nextLines(int n) throws IOException {\n        String[] arr = new String[n];\n        for (int i = 0; i < n; i++)\n            arr[i] = nextLine();\n        return arr;\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public int[] nextInts(int n) throws IOException {\n        int[] arr = new int[n];\n        for (int i = 0; i < n; i++)\n            arr[i] = nextInt();\n        return arr;\n    }\n\n    public Integer[] nextIntegers(int n) throws IOException {\n        Integer[] arr = new Integer[n];\n        for (int i = 0; i < n; i++)\n            arr[i] = nextInt();\n        return arr;\n    }\n\n    public int[][] next2Ints(int n, int m) throws IOException {\n        int[][] arr = new int[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                arr[i][j] = nextInt();\n        return arr;\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public long[] nextLongs(int n) throws IOException {\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++)\n            arr[i] = nextLong();\n        return arr;\n    }\n\n    public long[][] next2Longs(int n, int m) throws IOException {\n        long[][] arr = new long[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                arr[i][j] = nextLong();\n        return arr;\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(next().replace(',', '.'));\n    }\n\n    public double[] nextDoubles(int size) throws IOException {\n        double[] arr = new double[size];\n        for (int i = 0; i < size; i++)\n            arr[i] = nextDouble();\n        return arr;\n    }\n\n    public double[][] next2Doubles(int n, int m) throws IOException {\n        double[][] arr = new double[n][m];\n        for (int i = 0; i < n; i++)\n            for (int j = 0; j < m; j++)\n                arr[i][j] = nextDouble();\n        return arr;\n    }\n\n    public boolean nextBool() throws IOException {\n        String s = next();\n        if (s.equalsIgnoreCase(\"true\") || s.equals(\"1\"))\n            return true;\n\n        if (s.equalsIgnoreCase(\"false\") || s.equals(\"0\"))\n            return false;\n\n        throw new IOException(\"Boolean expected, String found!\");\n    }\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class main {\n    public static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    public static PrintWriter pw = new PrintWriter(System.out);\n    public static String line;\n    public static StringTokenizer st;\n    public static ArrayList<ArrayList<Integer>> adjList;\n    public static int[] dx = {-1, 0, 1, 0, -1, 1, 1, -1};\n    public static int[] dy = {0, 1, 0, -1, 1, 1, -1, -1};\n    public static int INF = 0x3f3f3f3f;\n    public static int MOD = 1000000007;\n\n    public static boolean valid(int parts, int size, int A, int B){\n        if(size % 2 == 0){\n            return A == 0;\n        } else{\n            return A <= parts && (parts - A) % 2 == 0;\n        }\n    }\n\n    public static void main(String[] args) throws Exception{\n        int N = Integer.parseInt(br.readLine());\n        HashMap<Character, Integer> d = new HashMap<Character, Integer>();\n        String s = br.readLine();\n        for(int i = 0; i < N; i++){\n            char c = s.charAt(i);\n            if(!d.containsKey(c)) d.put(c, 0);\n            d.put(c, d.get(c)+1);\n        }\n        ArrayList<Character> A = new ArrayList<Character>();\n        ArrayList<Character> B = new ArrayList<Character>();\n        StringBuilder s1 = new StringBuilder();\n        StringBuilder s2 = new StringBuilder();\n\n        for(Character c : d.keySet()){\n            for(int i = 0; i < d.get(c)/2; i++){\n                B.add(c);\n            }\n            if(d.get(c) % 2 != 0){\n                A.add(c);\n            }\n        }\n\n        ArrayList<Integer> PF = new ArrayList<Integer>();\n        for(int i = 1; i * i <= N; i++){\n            if(N % i == 0){\n                PF.add(i);\n                if(i * i != N) PF.add(N/i);\n            }\n        }\n        Collections.sort(PF);\n        int ans = 0;\n        for(int i = 0; i < PF.size(); i++){\n            int parts = PF.get(i);\n            int size = N / parts;\n            if(valid(parts, size, A.size(), B.size())){\n                ans = PF.get(i);\n                break;\n            }\n        }\n        // System.out.println(A+  \" \"  + B);\n        int a1 = 0;\n        int b1 = 0;\n        pw.print(ans + \"\\n\");\n        for(int i = 0; i < ans; i++){\n            StringBuilder sb1 = new StringBuilder();\n            StringBuilder sb2 = new StringBuilder();\n            int size = N / ans;\n            for(int j = 0; j < size/2; j++){\n                sb1.append(B.get(b1));\n                sb2.append(B.get(b1));\n                b1++;\n            }\n            if(size % 2 != 0){\n                if(a1 >= A.size()){\n                    A.add(B.get(b1));\n                    A.add(B.get(b1));\n                    b1++;\n                }\n                sb1.append(A.get(a1));\n                a1++;\n            }\n            pw.print(sb1.toString() + sb2.reverse().toString());\n            pw.print(i == ans-1 ? \"\\n\" : \" \");\n        }\n\n        pw.close(); \n        br.close();\n    }\n}\n\nclass Pair{\n    public long x, y;\n\n    Pair(long _x, long _y){\n        x = _x;\n        y = _y;\n    }\n}\nclass Point implements Comparable<Point>{\n    public double x, y;\n\n    Point(double x, double y){\n        this.x = x;\n        this.y = y;\n    }\n\n    public int compareTo(Point p){\n        if(x != p.x) return x < p.x ? -1 : 1;\n        else if(y != p.y) return y < p.y ? -1 : 1;\n        return 0;\n    }\n}", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskC solver = new TaskC();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskC {\n\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            in.NextInt();\n            char[] s = in.Next().toCharArray();\n            int[] charCount = new int[256];\n            for (char c : s) {\n                charCount[c]++;\n            }\n            int oddCount = 0;\n            for (int i : charCount) {\n                if (i % 2 != 0) oddCount++;\n            }\n            if (oddCount == 0) {\n                int t = 0;\n                for (int i = 0; i < s.length / 2; i++) {\n                    while (charCount[t] == 0) {\n                        t++;\n                    }\n                    s[i] = (char) (t);\n                    s[s.length - 1 - i] = s[i];\n                    charCount[t] -= 2;\n                }\n                out.println(1);\n                out.println(s);\n                return;\n            }\n            for (int i = oddCount; i < s.length; i++) {\n                if (s.length % i == 0) {\n                    int pLength = s.length / i;\n                    if (pLength % 2 == 1) {\n                        out.println(s.length / pLength);\n                        char[] t = new char[pLength];\n                        for (int j = 0; j < s.length / pLength; j++) {\n                            int c = 0;\n                            for (int k = 0; k < (pLength - 1) / 2; k++) {\n                                while (charCount[c] < 2) {\n                                    c++;\n                                }\n                                t[k] = (char) (c);\n                                t[pLength - 1 - k] = (char) (c);\n                                charCount[c] -= 2;\n                            }\n                            c = 0;\n                            while (c < 256 && charCount[c] % 2 == 0) {\n                                c++;\n                            }\n                            if (c == 256) {\n                                c = 0;\n                                while (charCount[c] == 0) {\n                                    c++;\n                                }\n                            }\n                            t[pLength / 2] = (char) (c);\n                            charCount[c]--;\n                            out.print(t);\n                            out.print(\" \");\n                        }\n                        out.println();\n                        return;\n                    }\n                }\n            }\n            //nothing found.\n            out.println(s.length);\n            for (char c : s) {\n                out.print(\"\" + (char) c + \" \");\n            }\n            out.println();\n        }\n    }\n\n    public static int GetMax(int[] ar) {\n        int max = Integer.MIN_VALUE;\n        for (int a : ar) {\n            max = Math.max(max, a);\n        }\n        return max;\n    }\n\n    public static int[] GetCount(int[] ar) {\n        return GetCount(ar, GetMax(ar));\n    }\n\n    public static int[] GetCount(int[] ar, int maxValue) {\n        int[] dp = new int[maxValue + 1];\n        for (int a : ar) {\n            dp[a]++;\n        }\n        return dp;\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String Next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int NextInt() {\n            return Integer.parseInt(Next());\n        }\n\n        public long NextLong() {\n            return Long.parseLong(Next());\n        }\n\n        public double NextDouble() {\n            return Double.parseDouble(Next());\n        }\n\n        public int[] NextIntArray(int n) {\n            return NextIntArray(n, 0);\n        }\n\n        public int[] NextIntArray(int n, int offset) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = NextInt() - offset;\n            }\n            return a;\n        }\n\n        public int[][] NextIntMatrix(int n, int m) {\n            return NextIntMatrix(n, m, 0);\n        }\n\n        public int[][] NextIntMatrix(int n, int m, int offset) {\n            int[][] a = new int[n][m];\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < m; j++) {\n                    a[i][j] = NextInt() - offset;\n                }\n            }\n            return a;\n        }\n    }\n}", "label": 3}
{"src": "import java.io.BufferedInputStream;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Scanner;\n\n/**\n * Created by leen on 23/10/2017.\n */\npublic class _883H {\n\n\n    private static int char2num(char c) {\n        if(c >= 'A' && c <= 'Z')\n            return c-'A';\n        else if(c >= 'a' && c <= 'z')\n            return 26+(c-'a');\n        else\n            return 52+(c-'0');\n    }\n\n    private static char num2char(int num) {\n        if(num < 26)\n            return (char)('A' + num);\n        else if(num < 52)\n            return (char)('a' + (num - 26));\n        else\n            return (char)('0' + (num - 52));\n    }\n\n    public static void main(String[] args) {\n        int numLetters = 62;\n        int[] letterCnt = new int[numLetters];\n\n        Scanner scan = new Scanner(new BufferedInputStream(System.in, 1024*1024));\n\n        int n = scan.nextInt();\n        scan.nextLine();\n\n        String s = scan.nextLine();\n        for(int i = 0; i < n; i++)\n            letterCnt[char2num(s.charAt(i))]++;\n\n        List<Integer> centers = new ArrayList<>();\n\n        for(int i = 0; i < numLetters; i++) {\n            if (letterCnt[i] % 2 == 1) {\n                letterCnt[i]--;\n                centers.add(i);\n            }\n        }\n\n        int numPairs = (n - centers.size()) / 2;\n\n        if(!centers.isEmpty()) {\n            int p = 0;\n            while (numPairs % centers.size() != 0) {\n                while (letterCnt[p] > 0 && numPairs % centers.size() != 0) {\n                    centers.add(p);\n                    centers.add(p);\n                    letterCnt[p] -= 2;\n                    numPairs--;\n                }\n                p++;\n            }\n        }\n\n        StringBuilder buf = new StringBuilder();\n\n        if(centers.isEmpty()) {\n            printPalindrome(buf, -1, numPairs, letterCnt);\n        }\n        else {\n            for(int center : centers) {\n                if(buf.length() > 0)\n                    buf.append(' ');\n                printPalindrome(buf, center, numPairs/centers.size(), letterCnt);\n            }\n        }\n\n        System.out.println(Math.max(1, centers.size()));\n        System.out.println(buf.toString());\n\n    }\n\n    static void printPalindrome(StringBuilder buf, int center, int numPairs, int[] letterCnt) {\n        LinkedList<Integer> stack = new LinkedList<>();\n\n        int p = 0;\n        while(numPairs > 0) {\n            while(letterCnt[p] > 0 && numPairs > 0) {\n                numPairs--;\n                letterCnt[p]-=2;\n                buf.append(num2char(p));\n                stack.push(p);\n            }\n            p++;\n        }\n\n        if(center != -1)\n            buf.append(num2char(center));\n\n        while(!stack.isEmpty())\n            buf.append(num2char(stack.pop()));\n    }\n\n}\n", "label": 3}
{"src": "//>>>BaZ<<<//\nimport java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\npublic class Main\n{  \n    static int dx[] = {-1,1,0,0};\n    static int dy[] = {0,0,1,-1};\n    static long MOD = 1000000007;\n    static int INF = Integer.MAX_VALUE/10;\n    static PrintWriter pw;\n    static InputReader scan;\n    static int ni(){return scan.nextInt();}\n    static long nl(){return scan.nextLong();}\n    static double nd(){return scan.nextDouble();}\n    static String ne(){return scan.next();}\n    static void pl(){pw.println();}\n    static void pl(Object o){pw.println(o);}\n    static void p(Object o){pw.print(o+\" \");}\n    static void psb(StringBuilder sb){pw.print(sb);}\n    public static void main(String[] args) {\n        new Thread(null,null,\"BaZ\",99999999)\n        {\n            public void run()\n            {\n                try\n                {\n                    solve();\n                }\n                catch(Exception e)\n                {  \n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }.start();\n    }\n    static void solve() throws IOException\n    {\n        scan = new InputReader(System.in);\n        pw = new PrintWriter(System.out,true);\n        StringBuilder sb = new StringBuilder();\n        int n = ni();\n        String s = ne();\n        Map<Character,Integer> freq = new HashMap();\n        for(int i=0;i<n;++i)\n        {\n            char c = s.charAt(i);\n            if(freq.containsKey(c))\n                freq.put(c,freq.get(c)+1);\n            else freq.put(c,1);\n        }\n        LinkedList<Pair> odd = new LinkedList();\n        LinkedList<Pair> even = new LinkedList();\n        LinkedList<Pair> one = new LinkedList();\n        int oddf = 0;\n        for(char c:freq.keySet())\n        {  \n            int f = freq.get(c);\n            if(f%2==0)\n                even.add(new Pair(c,f));\n            else\n            {\n                ++oddf;\n                if(f==1)\n                    one.add(new Pair(c,1));\n                else odd.add(new Pair(c,f));\n            }\n        }\n        for(int nparts=1;nparts<=n;++nparts)\n        {\n            if(n%nparts!=0)\n                continue;\n            int l = n/nparts;\n            if(l%2==0)\n            {\n                if(oddf==0)\n                {\n                    pl(nparts);\n                    for(int i=0;i<nparts;++i)\n                    {\n                        char res[] = new char[l];\n                        int by2 = l/2;\n                        for(int j=0;j<by2;++j)\n                        {\n                            Pair curr = even.poll();\n                            res[j] = res[l-1-j] = curr.c;\n                            curr.freq-=2;\n                            if(curr.freq>0)\n                                even.addFirst(curr);\n                        }\n                        for(int j=0;j<l;++j)\n                            pw.print(res[j]);\n                        pw.print(\" \");\n                    }\n                    pw.flush();\n                    System.exit(0);\n                }\n            }\n            else\n            {\n                if((nparts-oddf)%2==0 && nparts>=oddf)\n                {\n                    pl(nparts);\n                    for(int i=0;i<nparts;++i)\n                    {\n                        char res[] = new char[l];\n                        if(!one.isEmpty())\n                        {\n                            Pair curr = one.poll();\n                            res[l/2] = curr.c;\n                        }\n                        else if(!odd.isEmpty())\n                        {\n                            Pair curr = odd.poll();\n                            res[l/2] = curr.c;\n                            curr.freq--;\n                            even.add(curr);\n                        }\n                        else\n                        {\n                            Pair curr = even.poll();\n                            res[l/2] = curr.c;\n                            curr.freq--;\n                            if(curr.freq==1)\n                                one.add(curr);\n                            else odd.add(curr);\n                        }\n                        int by2 = l/2;\n                        for(int j=0;j<by2;++j)\n                        {  \n                            if(!even.isEmpty())\n                            {\n                                Pair curr = even.poll();\n                                res[j] = res[l-1-j] = curr.c;\n                                curr.freq-=2;\n                                if(curr.freq>0)\n                                   even.add(curr);\n                            }\n                            else\n                            {\n                                Pair curr = odd.poll();\n                                res[j] = res[l-1-j] = curr.c;\n                                curr.freq-=2;\n                                if(curr.freq>0)\n                                {\n                                    if(curr.freq==1)\n                                        one.add(curr);\n                                    else odd.add(curr);\n                                }  \n                            }\n                        }\n                        for(int j=0;j<l;++j)\n                            pw.print(res[j]);\n                        pw.print(\" \");\n                    }\n                    pw.flush();\n                    System.exit(0);\n                }\n            }\n        }\n        pw.flush();\n        pw.close();\n    }\n    static class Pair\n    {\n        Character c;\n        int freq;\n        Pair(Character c,int freq)\n        {\n            this.c=c;this.freq = freq;\n        }\n    }\n    static boolean islong(double d)\n    {\n        return Math.ceil(d)==d;\n    }\n    static double roundLikeCpp(double d,double precision)\n    {   \n        if(islong(d))\n            return d;\n        d*=(long)pow(10,precision+1);\n        if(d%10==5)\n            d--;\n        return d/pow(10,precision+1);\n    }\n    static class InputReader     //NoSuchElementException -> EOF\n\t{\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\t\t\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\tthis.stream = stream;\n\t\t}\n\t\t\n\t\tpublic int read()\n\t\t{\n\t\t\tif (numChars==-1) \n\t\t\t\tthrow new InputMismatchException();\n\t\t\t\n\t\t\tif (curChar >= numChars)\n\t\t\t{\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t}\n\t\t\t\tcatch (IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(numChars <= 0)\t\t\t\t\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\t \n\t\tpublic String nextLine()\n\t\t{\n\t\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\tString str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n\t\t}\n\t\tpublic int nextInt()\n\t\t{\n\t\t\tint c = read();\n\t\t\t\n\t\t\twhile(isSpaceChar(c)) \n\t\t\t\tc = read();\n\t\t\t\n\t\t\tint sgn = 1;\n\t\t\t\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\t\n\t\t\tint res = 0;\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif(c<'0'||c>'9') \n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c)); \n\t\t\t\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic long nextLong() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\t\n\t\t\tdo \n\t\t\t{\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic double nextDouble() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') \n\t\t\t{\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tdouble res = 0;\n\t\t\twhile (!isSpaceChar(c) && c != '.') \n\t\t\t{\n\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tif (c == '.') \n\t\t\t{\n\t\t\t\tc = read();\n\t\t\t\tdouble m = 1;\n\t\t\t\twhile (!isSpaceChar(c)) \n\t\t\t\t{\n\t\t\t\t\tif (c == 'e' || c == 'E')\n\t\t\t\t\t\treturn res * Math.pow(10, nextInt());\n\t\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t\tm /= 10;\n\t\t\t\t\tres += (c - '0') * m;\n\t\t\t\t\tc = read();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res * sgn;\n\t\t}\n\t\t\n\t\tpublic String readString() \n\t\t{\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo \n\t\t\t{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} \n\t\t\twhile (!isSpaceChar(c));\n\t\t\t\n\t\t\treturn res.toString();\n\t\t}\n\t \n\t\tpublic boolean isSpaceChar(int c) \n\t\t{\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t \n\t\tpublic String next() \n\t\t{\n\t\t\treturn readString();\n\t\t}\n\t\t\n\t\tpublic interface SpaceCharFilter \n\t\t{\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\n\n@SuppressWarnings(\"unchecked\")\npublic class P883H {\n\n  List<String> makePalindromes(Deque<Character> od, TreeMap<Character, Integer> em, int k, int l) {\n    List<String> sl = new ArrayList(k);\n    char [] s = new char [l];\n\n    while ((k--) > 0) {\n      if ((l & 0b1) != 0) { // odd len\n        if (od.size() > 0) {\n          s[l >> 1] = od.pollFirst();\n        } else {\n          if (em.size() > 0) {\n            Map.Entry<Character, Integer> cc = em.pollLastEntry();\n            s[l >> 1] = cc.getKey();\n\n            if (cc.getValue() > 1) {\n              em.put(cc.getKey(), cc.getValue() - 1);\n            }\n          } else {\n            return null;\n          }\n        }\n      }\n\n      for (int i = 0, l2 = l >> 1, c = 0; l2 > 0; l2 -= c) {\n        Map.Entry<Character, Integer> cc = em.pollFirstEntry();\n\n        if (cc == null) {\n          return null;\n        }\n\n        c = Math.min(l2, cc.getValue() / 2);\n        for (int j = c; j != 0; s[i] = s[l - i - 1] = cc.getKey(), j--, i++);\n\n        if ((cc.getValue() - 2 * c) > 0) {\n          em.put(cc.getKey(), cc.getValue() - 2 * c);\n        }\n      }\n\n      sl.add(new String(s));\n    }\n\n    return sl;\n  }\n\n  public void run() throws Exception {\n    int n = nextInt();\n    String s = next();\n\n    Map<Character, Integer> cc = new HashMap();\n    for (int i = 0; i < n; i++) {\n      cc.put(s.charAt(i), cc.getOrDefault(s.charAt(i), 0) + 1);\n    }\n\n    TreeMap<Character, Integer> em = new TreeMap();\n    Deque<Character> od = new ArrayDeque();\n    for (Map.Entry<Character, Integer> me : cc.entrySet()) {\n      char c = me.getKey();\n      int v = me.getValue();\n\n      if ((v & 0b1) == 0) {\n        em.put(c, v);\n      } else {\n        od.add(c);\n\n        if (v > 1) {\n          em.put(c, v & (~1));\n        }\n      }\n    }\n\n    for (int k = 1; k <= n; k++) {\n      if ((n % k) != 0) {\n        continue;\n      }\n\n      List<String> pl = makePalindromes(new ArrayDeque(od), new TreeMap(em), k, n / k);\n\n      if (pl != null) {\n        \n        println(pl.size());\n        for (String p : pl) {\n          print(p + \" \");\n        }\n\n        break;\n      }\n    }\n  }\n\n  public static void main(String... args) throws Exception {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    pw = new PrintWriter(new BufferedOutputStream(System.out));\n    new P883H().run();\n    br.close();\n    pw.close();\n    System.err.println(\"\\n[Time : \" + (System.currentTimeMillis() - startTime) + \" ms]\");\n  }\n\n  static long startTime = System.currentTimeMillis();\n  static BufferedReader br;\n  static PrintWriter pw;\n  StringTokenizer stok;\n\n  String nextToken() throws IOException {\n    while (stok == null || !stok.hasMoreTokens()) {\n      String s = br.readLine();\n      if (s == null) { return null; }\n      stok = new StringTokenizer(s);\n    }\n    return stok.nextToken();\n  }\n\n  void print(byte b) { print(\"\" + b); }\n  void print(int i) { print(\"\" + i); }\n  void print(long l) { print(\"\" + l); }\n  void print(double d) { print(\"\" + d); }\n  void print(char c) { print(\"\" + c); }\n  void print(Object o) {\n    if (o instanceof int[]) { print(Arrays.toString((int [])o));\n    } else if (o instanceof long[]) { print(Arrays.toString((long [])o));\n    } else if (o instanceof char[]) { print(Arrays.toString((char [])o));\n    } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));\n    } else if (o instanceof short[]) { print(Arrays.toString((short [])o));\n    } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));\n    } else if (o instanceof float[]) { print(Arrays.toString((float [])o));\n    } else if (o instanceof double[]) { print(Arrays.toString((double [])o));\n    } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));\n    } else { print(\"\" + o); }\n  }\n  void print(String s) { pw.print(s); }\n  void println() { println(\"\"); }\n  void println(byte b) { println(\"\" + b); }\n  void println(int i) { println(\"\" + i); }\n  void println(long l) { println(\"\" + l); }\n  void println(double d) { println(\"\" + d); }\n  void println(char c) { println(\"\" + c); }\n  void println(Object o) { print(o); println(); }\n  void println(String s) { pw.println(s); }\n  int nextInt() throws IOException { return Integer.parseInt(nextToken()); }\n  long nextLong() throws IOException { return Long.parseLong(nextToken()); }\n  double nextDouble() throws IOException { return Double.parseDouble(nextToken()); }\n  char nextChar() throws IOException { return (char) (br.read()); }\n  String next() throws IOException { return nextToken(); }\n  String nextLine() throws IOException { return br.readLine(); }\n  int [] readInt(int size) throws IOException {\n    int [] array = new int [size];\n    for (int i = 0; i < size; i++) { array[i] = nextInt(); }\n    return array;\n  }\n  long [] readLong(int size) throws IOException {\n    long [] array = new long [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLong(); }\n    return array;\n  }\n  double [] readDouble(int size) throws IOException {\n    double [] array = new double [size];\n    for (int i = 0; i < size; i++) { array[i] = nextDouble(); }\n    return array;\n  }\n  String [] readLines(int size) throws IOException {\n    String [] array = new String [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLine(); }\n    return array;\n  }\n\n  int gcd(int a, int b) {\n    if (a == 0) return Math.abs(b); if (b == 0) return Math.abs(a);\n    a = Math.abs(a); b = Math.abs(b);\n    int az = Integer.numberOfTrailingZeros(a), bz = Integer.numberOfTrailingZeros(b);\n    a >>>= az; b >>>= bz;\n    while (a != b) {\n      if (a > b) { a -= b; a >>>= Integer.numberOfTrailingZeros(a); }\n            else { b -= a; b >>>= Integer.numberOfTrailingZeros(b); }\n    }\n    return (a << Math.min(az, bz));\n  }\n\n  long gcd(long a, long b) {\n    if (a == 0) return Math.abs(b); if (b == 0) return Math.abs(a);\n    a = Math.abs(a); b = Math.abs(b);\n    int az = Long.numberOfTrailingZeros(a), bz = Long.numberOfTrailingZeros(b);\n    a >>>= az; b >>>= bz;\n    while (a != b) {\n      if (a > b) { a -= b; a >>>= Long.numberOfTrailingZeros(a); }\n            else { b -= a; b >>>= Long.numberOfTrailingZeros(b); }\n    }\n    return (a << Math.min(az, bz));\n  }\n}", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Aman Kumar Singh\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        HPalindromicCut solver = new HPalindromicCut();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class HPalindromicCut {\n        PrintWriter out;\n        InputReader in;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.out = out;\n            this.in = in;\n            int n = ni();\n            String st = n();\n            int i = 0;\n            int[] freq = new int[256];\n            int last = 0;\n            ArrayList<Integer> ar = new ArrayList<>();\n            int cnt_odd = 0;\n            int mn = n + 5;\n            for (i = 0; i < n; i++)\n                freq[(int) st.charAt(i)]++;\n            for (i = 0; i < 256; i++)\n                cnt_odd += freq[i] % 2;\n            for (i = 1; i <= (int) Math.sqrt(n); i++) {\n                if (n % i == 0) {\n                    int x = i;\n                    int y = n / i;\n                    if (cnt_odd > 0) {\n                        if (x % 2 != 0 && y >= cnt_odd && (y - cnt_odd) % 2 == 0)\n                            mn = Math.min(mn, y);\n                        if (y % 2 != 0 && x >= cnt_odd && (x - cnt_odd) % 2 == 0)\n                            mn = Math.min(mn, x);\n                    } else {\n                        mn = Math.min(x, mn);\n                        mn = Math.min(y, mn);\n                    }\n                }\n            }\n            int len = n / mn;\n            int[] hola = new int[n];\n            if (cnt_odd > 0) {\n                int lol = len / 2;\n                for (i = 0; i < 256; i++) {\n                    if (freq[i] % 2 != 0) {\n                        ar.add(i);\n                        freq[i]--;\n                    }\n                }\n                for (int x : ar) {\n                    hola[lol] = x;\n                    lol += len;\n                }\n                ar.clear();\n                for (i = 0; i < 256; i++) {\n                    if (freq[i] % 2 == 0 && freq[i] > 0)\n                        ar.add(i);\n                }\n                int x = 0;\n                while (lol < n) {\n                    if (freq[ar.get(x)] == 0) {\n                        x++;\n                        continue;\n                    }\n                    hola[lol] = ar.get(x);\n                    lol += len;\n                    freq[ar.get(x)]--;\n                }\n                ar.clear();\n                for (i = 0; i < 256; i++) {\n                    if (freq[i] > 0)\n                        ar.add(i);\n                }\n                x = 0;\n                for (i = 0; i < mn; i++) {\n                    int lo = i * len, hi = len * (i + 1) - 1;\n                    for (int j = 0; j < (len - 1) / 2; j++) {\n                        if (freq[ar.get(x)] == 0)\n                            x++;\n                        hola[lo++] = ar.get(x);\n                        hola[hi--] = ar.get(x);\n                        freq[ar.get(x)] -= 2;\n                    }\n                }\n            } else {\n                int x = 0;\n                ar.clear();\n                for (i = 0; i < 256; i++) {\n                    if (freq[i] > 0)\n                        ar.add(i);\n                }\n                //pn(ar);\n                x = 0;\n                for (i = 0; i < mn; i++) {\n                    int lo = i * len, hi = len * (i + 1) - 1;\n                    for (int j = 0; j < len / 2; j++) {\n                        if (freq[ar.get(x)] == 0)\n                            x++;\n                        hola[lo++] = ar.get(x);\n                        hola[hi--] = ar.get(x);\n                        freq[ar.get(x)] -= 2;\n                    }\n                }\n            }\n            pn(mn);\n            for (i = 0; i < n; i++) {\n                if (i % len == 0 && i != 0)\n                    p(\" \");\n                p((char) hola[i]);\n            }\n        }\n\n        String n() {\n            return in.next();\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        void pn(long zx) {\n            out.println(zx);\n        }\n\n        void p(Object o) {\n            out.print(o);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new UnknownError();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "public class H883 {\n\tstatic int[] counts;\n\tpublic static void main(String[] args) {\n\t\tjava.util.Scanner sc = new java.util.Scanner(System.in);\n\t\tsc.nextLine();\n\t\tString s = sc.nextLine();\n\t\tcounts = new int[150];\n\t\tfor (char c : s.toCharArray())\n\t\t\tcounts[c]++;\n\t\tint odds = 0;\n\t\tfor (int count : counts)\n\t\t\tif (count % 2 != 0)\n\t\t\t\todds++;\n\t\tint len = s.length();\n\t\tif (odds == 0) {\n\t\t\tSystem.out.println(1);\n\t\t\tprint(len, 0);\n\t\t\treturn;\n\t\t}\n\t\t/*if (odds >= len / 2) {\n\t\t\tSystem.out.println(len);\n\t\t\tfor (char c : s.toCharArray())\n\t\t\t\tSystem.out.print(c + \" \");\n\t\t\treturn;\n\t\t}*/\n\t\tint splits = odds;\n\t\twhile (len % splits != 0 || (len / splits) % 2 == 0)\n\t\t\tsplits++;\n\t\tint splitLen = len / splits;\n\t\tSystem.out.println(splits);\n\t\tfor (int i = 0; i < 150; i++) {\n\t\t\tif (counts[i] % 2 != 0) {\n\t\t\t\tcounts[i]--;\n\t\t\t\tprint(splitLen-1, i);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 150; i++) {\n\t\t\twhile (counts[i] > 0) {\n\t\t\t\tcounts[i] -= 2;\n\t\t\t\tprint(splitLen-1, i);\n\t\t\t\tprint(splitLen-1, i);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void print(int n, int mid) {\n\t\tint[] printed = new int[150];\n\t\tfor (int i = 0; i < 150; i++) {\n\t\t\tint x = counts[i] / 2;\n\t\t\tfor (int j = 0; j < x && n > 0; j++) {\n\t\t\t\tSystem.out.print((char) i);\n\t\t\t\tprinted[i]++;\n\t\t\t\tcounts[i] -= 2;\n\t\t\t\tn -= 2;\n\t\t\t}\n\t\t}\n\t\tif (mid != 0)\n\t\t\tSystem.out.print((char) mid);\n\t\tfor (int i = 149; i >= 0; i--) {\n\t\t\tfor (int j = 0; j < printed[i]; j++)\n\t\t\t\tSystem.out.print((char) i);\n\t\t}\n\t\tSystem.out.print(\" \");\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class H {\n\n\tstatic int[] map;\n\tstatic ArrayList<Character> symbols;\n\n\tstatic void fillMap() {\n\t\tint ans = 0;\n\t\tmap = new int[300];\n\t\tsymbols = new ArrayList();\n\t\tfor (char c = 'a'; c <= 'z'; c++) {\n\t\t\tmap[c] = ans++;\n\t\t\tsymbols.add(c);\n\t\t}\n\t\tfor (char c = 'A'; c <= 'Z'; c++) {\n\t\t\tmap[c] = ans++;\n\t\t\tsymbols.add(c);\n\n\t\t}\n\t\tfor (char c = '0'; c <= '9'; c++) {\n\t\t\tmap[c] = ans++;\n\t\t\tsymbols.add(c);\n\t\t}\n\t}\n\n\tstatic boolean ok(int[] cnt, int len, int n, int odd) {\n\t\tint numStrings = n / len;\n\t\tif (odd > numStrings)\n\t\t\treturn false;\n\t\tboolean[] mid = new boolean[numStrings];\n\t\tint last = 0;\n\t\tfor (char c : symbols)\n\t\t\tif (cnt[map[c]] % 2 == 1) {\n\t\t\t\todd--;\n\t\t\t\tcnt[map[c]]--;\n\t\t\t\tmid[last++] = true;\n\t\t\t}\n\t\treturn (numStrings - last) % 2 == 0;\n\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tchar[] s = sc.next().toCharArray();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint[] cnt = new int[26 + 26 + 10];\n\t\tfillMap();\n\t\tfor (char c : s)\n\t\t\tcnt[map[c]]++;\n\t\tint odd = 0;\n\t\tfor (int x : cnt)\n\t\t\tif (x % 2 == 1)\n\t\t\t\todd++;\n\t\tif (odd <= 1) {\n\t\t\tchar[] ans = new char[n];\n\t\t\tint l = 0, r = n - 1;\n\t\t\tfor (char c : symbols) {\n\t\t\t\twhile (cnt[map[c]] >= 2) {\n\t\t\t\t\tcnt[map[c]] -= 2;\n\t\t\t\t\tans[l++] = c;\n\t\t\t\t\tans[r--] = c;\n\t\t\t\t}\n\t\t\t\tif (cnt[map[c]] == 1)\n\t\t\t\t\tans[n / 2] = c;\n\t\t\t}\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.println(ans);\n\t\t\treturn;\n\t\t}\n\t\tint lenAns = 1;\n\t\tfor (int len = n; len > 0; len--)\n\t\t\tif (len % 2 == 1 && n % len == 0) {\n\t\t\t\tboolean ok = ok(cnt.clone(), len, n, odd);\n\t\t\t\tif (ok) {\n\t\t\t\t\tlenAns = len;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tout.println(n / lenAns);\n\n\t\tint numStrings = n / lenAns;\n\t\tchar[][] ans = new char[numStrings][lenAns];\n\t\tint[] l = new int[numStrings];\n\t\tboolean[] mid = new boolean[numStrings];\n\t\tint last = 0;\n\t\tfor (char c : symbols)\n\t\t\tif (cnt[map[c]] % 2 == 1) {\n\t\t\t\todd--;\n\t\t\t\tcnt[map[c]]--;\n\t\t\t\tmid[last] = true;\n\t\t\t\tans[last++][lenAns / 2] = c;\n\t\t\t}\n\t\tfor (char c : symbols) {\n\t\t\twhile (cnt[map[c]] > 0 && last < numStrings) {\n\t\t\t\tans[last++][lenAns / 2] = c;\n\t\t\t\tans[last++][lenAns / 2] = c;\n\t\t\t\tcnt[map[c]] -= 2;\n\t\t\t}\n\t\t}\n\t\n\t\tlast = 0;\n\t\tfor (char c : symbols) {\n\t\t\twhile (cnt[map[c]] > 0) {\n\t\t\t\tif (l[last] == lenAns / 2)\n\t\t\t\t\tlast++;\n\t\t\t\telse {\n\t\t\t\t\tans[last][l[last]] = c;\n\n\t\t\t\t\tans[last][lenAns - l[last] - 1] = c;\n//\t\t\t\t\tlast++;\n\t\t\t\t\tcnt[map[c]] -= 2;\n\t\t\t\t\tl[last]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (char[] x : ans) {\n\t\t\tout.print(x);\n\t\t\tout.print(\" \");\n\t\t}\n\t\tout.println();\n\t\tout.close();\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\n\t\tpublic Scanner(FileReader f) {\n\t\t\tbr = new BufferedReader(f);\n\t\t}\n\n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic int[] nextIntArr(int n) throws IOException {\n\t\t\tint[] arr = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = Integer.parseInt(next());\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Main {\n    public static void main(String args[])\n    {\n        FastReader input=new FastReader();\n        PrintWriter out=new PrintWriter(System.out);\n        int T=1;\n        while(T-->0)\n        {\n            int n=input.nextInt();\n            String s=input.next();\n            int arr[]=new int[123];\n            for(int i=0;i<n;i++)\n            {\n                arr[s.charAt(i)]++;\n            }\n            int count=0;\n            for(int i=0;i<arr.length;i++)\n            {\n                if(arr[i]%2!=0)\n                {\n                    count++;\n                }\n            }\n            if(count==0)\n            {\n                char ch[]=new char[n];\n                int x=0;\n                int j=0;\n                while(j<n/2)\n                {\n                    if(arr[x]>=2)\n                    {\n                        ch[j]=(char)(x);\n                        ch[n-1-j]=(char)(x);\n                        arr[x]-=2;\n                        j++;\n                    }\n                    else\n                    {\n                        x++;\n                    }\n                }\n                out.println(1);\n                out.println(ch);\n            }\n            else\n            {\n                int parts=0;\n                for(int i=count;i<=n;i++)\n                {\n                    if(n%i==0 && (n/i)%2!=0)\n                    {\n                        parts=i;\n                        break;\n                    }\n                }\n                int len=n/parts;\n                char ch[][]=new char[parts][len];\n                int x=0;\n                for(int i=0;i<ch.length;i++)\n                {\n                    int j=0;\n                    while(j<len/2)\n                    {\n                        if(arr[x]>=2)\n                        {\n                            ch[i][j]=(char)(x);\n                            ch[i][len-1-j]=(char)(x);\n                            arr[x]-=2;\n                            j++;\n                        }\n                        else\n                        {\n                            x++;\n                        }\n                    }\n                }\n                x=0;\n                int j=0;\n                while(j<ch.length)\n                {\n                    if(arr[x]>0)\n                    {\n                        ch[j][len/2]=(char)(x);\n                        arr[x]--;\n                        j++;\n                    }\n                    else\n                    {\n                        x++;\n                    }\n                }\n                out.println(parts);\n                for(int i=0;i<ch.length;i++)\n                {\n                    StringBuilder sb=new StringBuilder(String.copyValueOf(ch[i]));\n                    out.print(sb.toString()+\" \");\n                }\n                out.println();\n            }\n        }\n        out.close();\n    }\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader()\n        {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n        String nextLine()\n        {\n            String str=\"\";\n            try\n            {\n                str=br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class ProblemH\n{\n\n    static int mod = (int) (1e9+7);\n    static InputReader in;\n    static PrintWriter out;\n    \n    public static void main(String[] args)\n    {\n        in = new InputReader(System.in);\n        out = new PrintWriter(System.out);            \n\n        int n = in.nextInt();\n        String s = in.readString();\n        int[] cnt = new int[256];\n        \n        for(int i = 0; i < n; i++)\n            cnt[s.charAt(i)]++;\n        \n        ArrayList<Integer> list = new ArrayList<>();\n        for(int i = 1; i <= Math.sqrt(n); i++){\n            if(n % i == 0){\n                list.add(i);\n                if(i * i != n)\n                    list.add(n / i);\n            }\n        }\n        Collections.sort(list);\n        int lol = 0;\n        \n        for(int i = 0; i < 256; i++){\n            lol += cnt[i] / 2;\n        }\n        \n        for(int k : list){\n            int y = n / k;\n            int x = k * (y / 2);\n            if(lol >= x){\n                out.println(k);\n                ArrayList<Character> l1 = new ArrayList<>();\n                for(int i = 0; i < 256; i++){\n                    if(cnt[i] % 2 != 0){\n                        l1.add((char)(i));\n                        cnt[i]--;\n                    }\n                }\n                int z = lol - x;\n                z *= 2;\n                for(int i = 0; i < 256; i++){\n                    while(z > 0 && cnt[i] > 0){\n                        l1.add((char)i);\n                        cnt[i]--;\n                        z--;\n                    }\n                }\n                int p = 0;\n                int q = 0;\n                while(k-- > 0){\n                    char[] c = new char[y];\n                    int r = 0;\n                    while(r < y / 2){\n                        while(cnt[q] <= 0) q++;\n                        c[r] = (char)(q);\n                        c[y - r - 1] = (char)(q);\n                        cnt[q] -= 2;\n                        r++;\n                    }\n                    if(y % 2 != 0){\n                        c[r] = l1.get(p++);\n                    }\n                    out.print(new String(c) + \" \");\n                }\n                out.println();\n                break;\n            }\n        }\n        \n        out.close();\n\n    }\n\n\n    static void debug(Object... o)\n    {\n            System.out.println(Arrays.deepToString(o));\n    }\n\n    static class Pair implements Comparable<Pair>\n    {\n\n        int x,y;\n        \n        \n        Pair (int x,int y)\n        {\n\t\tthis.x = x;\n                this.y = y;\n\t}\n        \n\tpublic int compareTo(Pair o)\n        {\n            return Integer.compare(this.x,o.x);\n\t\t//return 0;\n\t}\n\n        public boolean equals(Object o)\n        {\n            if (o instanceof Pair)\n            {\n                Pair p = (Pair)o;\n                return p.x == x && p.y==y;\n            }\n            return false;\n        }\n\n        @Override\n        public String toString()\n        {\n            return x + \" \"+ y;\n        }\n        \n        public int hashCode()\n        {\n            return new Long(x).hashCode() * 31 + new Long(y).hashCode();\n        }\n    \n    } \n\n    static long gcd(long x,long y)\n    {\n        if(y==0)\n                return x;\n        else\n                return gcd(y,x%y);\n    }\n\n    static int gcd(int x,int y)\n    {\n        if(y==0)\n                return x;\n        else \n                return gcd(y,x%y);\n    }\n\n    static long pow(long n,long p,long m)\n    {\n         long  result = 1;\n          if(p==0)\n            return 1;\n\n        while(p!=0)\n        {\n            if(p%2==1)\n                result *= n;\n            if(result>=m)\n            result%=m;\n            p >>=1;\n            n*=n;\n            if(n>=m)\n            n%=m;\n        }\n        return result;\n    }\n\n    static long pow(long n,long p)\n    {\n        long  result = 1;\n          if(p==0)\n            return 1;\n\n        while(p!=0)\n        {\n            if(p%2==1)\n                result *= n;\t    \n            p >>=1;\n            n*=n;\t    \n        }\n        return result;\n    }\n\n    static class InputReader\n    {\n\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream)\n        {\n                this.stream = stream;\n        }\n\n        public int snext()\n        {\n                if (snumChars == -1)\n                        throw new InputMismatchException();\n                if (curChar >= snumChars)\n                {\n                        curChar = 0;\n                        try\n                        {\n                                snumChars = stream.read(buf);\n                        } catch (IOException e)\n                        {\n                                throw new InputMismatchException();\n                        }\n                        if (snumChars <= 0)\n                                return -1;\n                }\n                return buf[curChar++];\n        }\n\n        public int nextInt()\n        {\n                int c = snext();\n                while (isSpaceChar(c))\n                {\n                        c = snext();\n                }\n                int sgn = 1;\n                if (c == '-')\n                {\n                        sgn = -1;\n                        c = snext();\n                }\n                int res = 0;\n                do\n                {\n                        if (c < '0' || c > '9')\n                                throw new InputMismatchException();\n                        res *= 10;\n                        res += c - '0';\n                        c = snext();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n        }\n\n        public long nextLong()\n        {\n                int c = snext();\n                while (isSpaceChar(c))\n                {\n                        c = snext();\n                }\n                int sgn = 1;\n                if (c == '-')\n                {\n                        sgn = -1;\n                        c = snext();\n                }\n                long res = 0;\n                do\n                {\n                        if (c < '0' || c > '9')\n                                throw new InputMismatchException();\n                        res *= 10;\n                        res += c - '0';\n                        c = snext();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n        }\n\n        public int[] nextIntArray(int n)\n        {\n                int a[] = new int[n];\n                for (int i = 0; i < n; i++)\n                {\n                        a[i] = nextInt();\n                }\n                return a;\n        }\n\n        public long[] nextLongArray(int n)\n        {\n                long a[] = new long[n];\n                for (int i = 0; i < n; i++)\n                {\n                        a[i] = nextLong();\n                }\n                return a;\n        }\n\n        public String readString()\n        {\n                int c = snext();\n                while (isSpaceChar(c))\n                {\n                        c = snext();\n                }\n                StringBuilder res = new StringBuilder();\n                do\n                {\n                        res.appendCodePoint(c);\n                        c = snext();\n                } while (!isSpaceChar(c));\n                return res.toString();\n        }\n\n        public String nextLine()\n        {\n                int c = snext();\n                while (isSpaceChar(c))\n                        c = snext();\n                StringBuilder res = new StringBuilder();\n                do\n                {\n                        res.appendCodePoint(c);\n                        c = snext();\n                } while (!isEndOfLine(c));\n                return res.toString();\n        }\n\n        public boolean isSpaceChar(int c)\n        {\n                if (filter != null)\n                        return filter.isSpaceChar(c);\n                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c)\n        {\n                return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        public interface SpaceCharFilter\n        {\n                public boolean isSpaceChar(int ch);\n        }\n\n    }\n}    \n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n/**\n * Created by dtnha on 10/20/2017.\n */\npublic class PalindromicCut {\n\n\n    public static void main(String[] args) throws IOException {\n        Reader.init(System.in);\n        int n = Reader.nextInt();\n        String s = Reader.next();\n        Map<Character, Integer> map = new HashMap<>();\n        for (int i = 0; i < n; i++) {\n            char c = s.charAt(i);\n            if (map.containsKey(c)) {\n                map.put(c, map.get(c) + 1);\n            } else {\n                map.put(c, 1);\n            }\n        }\n\n\n        Set<Character> keys = map.keySet();\n        List<Character> oddCharacterList = new ArrayList<>();\n        StringBuffer evenCharacterBuffer = new StringBuffer();\n\n        for (Character c : keys) {\n            int value = map.get(c);\n            if (value % 2 == 0) {\n                for (int i = 0; i < value; i++) {\n                    evenCharacterBuffer.append(c);\n                }\n            } else {\n                oddCharacterList.add(c);\n                for (int i = 0; i < value - 1; i++) {\n                    evenCharacterBuffer.append(c);\n                }\n            }\n        }\n\n        int evenLength = evenCharacterBuffer.length();\n        int oddSize = oddCharacterList.size();\n        StringBuffer res = new StringBuffer();\n        if (oddSize == 0 || oddSize == 1) {\n            res.append(1 + \"\\n\");\n            StringBuffer leftCharacters = new StringBuffer();\n            int x = 0;\n            while (x <= evenLength - 1) {\n                leftCharacters.append(evenCharacterBuffer.charAt(x));\n                x = x + 2;\n            }\n            res.append(leftCharacters);\n            for (Character c : oddCharacterList) {\n                res.append(c);\n            }\n            StringBuffer rightCharacters = leftCharacters.reverse();\n            res.append(rightCharacters);\n\n        } else {\n            int minsubString = oddSize;\n            int len = 0;\n            while (minsubString <= n) {\n                if (n % minsubString == 0) {\n                    len = n / minsubString;\n                    if (len % 2 == 1) {\n                        break;\n                    }\n                }\n                minsubString++;\n            }\n            if (len >= 3) {\n                res.append(minsubString + \"\\n\");\n                int x = 0;\n                for (int i = 0; i < oddSize; i++) {\n                    StringBuffer word = new StringBuffer();\n                    Character oddC = oddCharacterList.get(i);\n                    int distance = len - 1;\n                    StringBuffer left = new StringBuffer();\n                    while (distance > 0) {\n                        left.append(evenCharacterBuffer.charAt(x));\n                        distance = distance - 2;\n                        x = x + 2;\n                    }\n\n                    word.append(left);\n                    word.append(oddC);\n                    StringBuffer right = left.reverse();\n                    word.append(right);\n                    res.append(word + \" \");\n                }\n\n                Character oddC = null;\n                for (int i = oddSize; i < minsubString; i++) {\n                    StringBuffer word = new StringBuffer();\n                    StringBuffer left = new StringBuffer();\n                    int distance = len - 1;\n                    while (distance > 0) {\n                        left.append(evenCharacterBuffer.charAt(x));\n                        distance = distance - 2;\n                        x = x + 2;\n                    }\n                    word.append(left);\n                    if (oddC != null) {\n                        word.append(oddC);\n                        oddC = null;\n                    } else {\n                        oddC = evenCharacterBuffer.charAt(x);\n                        word.append(oddC);\n                        x = x+2;\n                    }\n\n                    StringBuffer right = left.reverse();\n                    word.append(right);\n                    res.append(word + \" \");\n                }\n\n            } else {\n                res.append(n + \"\\n\");\n                for (int i = 0; i < n; i++) {\n                    res.append(s.charAt(i) + \" \");\n                }\n            }\n        }\n\n        System.out.println(res.toString());\n\n\n    }\n\n\n    private static class Reader {\n        static BufferedReader reader;\n        static StringTokenizer tokenizer;\n\n        /**\n         * call this method to initialize reader for InputStream\n         */\n        public static void init(InputStream input) {\n            reader = new BufferedReader(\n                    new InputStreamReader(input));\n            tokenizer = new StringTokenizer(\"\");\n        }\n\n        /**\n         * get next word\n         */\n        public static String next() throws IOException {\n            while (!tokenizer.hasMoreTokens()) {\n                //TODO add check for eof if necessary\n                tokenizer = new StringTokenizer(\n                        reader.readLine());\n            }\n            return tokenizer.nextToken();\n        }\n\n        public static int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public static long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public static double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n    }\n}\n", "label": 3}
{"src": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n \npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputReader in = new InputReader();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tThread th = new Thread(null, new Runnable(){public void run(){new Task1().solve(in, out);}},\"Task1\",1<<24);\n\t\ttry{\n\t\t\tth.start();\n\t\t\tth.join();\n\t\t} catch(InterruptedException e){}\n\t\tout.close();\n\t}\n\n\tstatic class Task1{\n\t\tstatic final int MOD = 1000000007;\n\t\tstatic final int MAX = 400001;\n\t\tstatic final int R = 256;\n\n\t\tpublic void solve(InputReader in, PrintWriter out){\n\t\t\tint n = in.nextInt();\n\t\t\tArrayList<Integer> divisors = new ArrayList<Integer>();\n\t\t\tfor(int i=1; i*i<=n; i++){\n\t\t\t\tif(n%i==0){\n\t\t\t\t\tif(i%2==1 || (n/i)%2==1){\n\t\t\t\t\t\tdivisors.add(i);\n\t\t\t\t\t\tif(i!=n/i) divisors.add(n/i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(divisors);\n\t\t\t/*for(Integer i: divisors)\n\t\t\t\tout.println(i);*/\n\n\t\t\t//if(1>0) return;\n\t\t\tString s = in.next();\n\t\t\tint[] hash = new int[R];\n\t\t\tfor(int i=0; i<s.length(); i++) hash[s.charAt(i)]++;\n\n\t\t\tint start = 0, even = 0, odd = 0, ec = 0, oc = 0;\n\t\t\tArrayList<Character> E = new ArrayList<Character>(), O = new ArrayList<Character>();\n\t\t\tfor(int i=0; i<R; i++){\n\t\t\t\tint temp = hash[i];\n\t\t\t\twhile(temp>0){\n\t\t\t\t\tif(temp==1){\n\t\t\t\t\t\tO.add((char)i);\n\t\t\t\t\t\ttemp = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tE.add((char)i);\n\t\t\t\t\t\ttemp -= 2;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\teven += hash[i]/2;\n\t\t\t\todd += hash[i]%2;\n\t\t\t}\n\n\t\t\t/*out.println(\"---------------------\");\n\t\t\tfor(Character c: E)\n\t\t\t\tout.print(c+\"\");\n\t\t\tout.println();\n\t\t\tfor(Character c: O)\n\t\t\t\tout.print(c+\"\");\n\t\t\tout.println();\n\t\t\tout.println(odd+\" \"+even);\n\t\t\tout.println(\"--------------------\");*/\n\t\t\tif(n%2==0 && odd==0){\n\t\t\t\tout.println(1);\n\t\t\t\tStringBuilder s1 = new StringBuilder(\"\");\n\t\t\t\tStringBuilder s3 = new StringBuilder(\"\");\n\t\t\t\tfor(int j=0; j<even; j++){\n\t\t\t\t\ts1.append(E.get(ec));\n\t\t\t\t\ts3.append(E.get(ec++));\n\t\t\t\t}\n\t\t\t\ts3.reverse();\n\t\t\t\tout.print(s1.toString()+s3.toString()+\" \");\n\t\t\t\treturn;\n\t\t\t} else if(n%2==1 && odd==1){\n\t\t\t\tout.println(1);\n\t\t\t\tStringBuilder s1 = new StringBuilder(\"\");\n\t\t\t\tStringBuilder s3 = new StringBuilder(\"\");\n\t\t\t\tfor(int j=0; j<even; j++){\n\t\t\t\t\ts1.append(E.get(ec));\n\t\t\t\t\ts3.append(E.get(ec++));\n\t\t\t\t}\n\t\t\t\ts3.reverse();\n\t\t\t\tout.print(s1.toString()+O.get(oc++)+s3.toString()+\" \");\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tboolean flag = false;\n\t\t\twhile(start<divisors.size()){\n\t\t\t\tint first = divisors.get(start);\t// number\n\t\t\t\tint second = n/first;\t\t\t\t// length\n\t\t\t\tif(odd == first){\n\t\t\t\t\t// this is the answer\n\t\t\t\t\tflag = true;\n\t\t\t\t\tout.println(first);\n\t\t\t\t\tfor(int i=0; i<first; i++){\n\t\t\t\t\t\tStringBuilder s1 = new StringBuilder(\"\");\n\t\t\t\t\t\tStringBuilder s2 = new StringBuilder(\"\");\n\t\t\t\t\t\tStringBuilder s3 = new StringBuilder(\"\");\n\t\t\t\t\t\ts2.append(O.get(oc++));\n\t\t\t\t\t\tfor(int j=0; j<second/2; j++){\n\t\t\t\t\t\t\ts1.append(E.get(ec));\n\t\t\t\t\t\t\ts3.append(E.get(ec++));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts3.reverse();\n\t\t\t\t\t\tout.print(s1.toString()+s2.toString()+s3.toString()+\" \");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t} else if(odd<first && (first-odd)/2<=even && (first-odd)%2==0){\n\t\t\t\t\t// break some even into odds\n\t\t\t\t\teven -= (first-odd)/2;\n\t\t\t\t\tfor(int j=0; j<(first-odd)/2; j++){\n\t\t\t\t\t\tO.add(E.get(ec));\n\t\t\t\t\t\tO.add(E.get(ec++));\n\t\t\t\t\t}\n\t\t\t\t\tflag = true;\n\t\t\t\t\tout.println(first);\n\t\t\t\t\tfor(int i=0; i<first; i++){\n\t\t\t\t\t\tStringBuilder s1 = new StringBuilder(\"\");\n\t\t\t\t\t\tStringBuilder s2 = new StringBuilder(\"\");\n\t\t\t\t\t\tStringBuilder s3 = new StringBuilder(\"\");\n\t\t\t\t\t\ts2.append(O.get(oc++));\n\t\t\t\t\t\tfor(int j=0; j<second/2; j++){\n\t\t\t\t\t\t\ts1.append(E.get(ec));\n\t\t\t\t\t\t\ts3.append(E.get(ec++));\n\t\t\t\t\t\t}\n\t\t\t\t\t\ts3.reverse();\n\t\t\t\t\t\tout.print(s1.toString()+s2.toString()+s3.toString()+\" \");\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}else {\n\t\t\t\t\tstart++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(!flag){\n\t\t\t\tout.println(n);\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tout.print(s.charAt(i)+\" \");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlong gcd(long a, long b){\n\t\t\twhile(a>0){\n\t\t\t\tlong rem = b%a;\n\t\t\t\tb = a;\n\t\t\t\ta = rem;\n\t\t\t}\n\t\t\treturn b;\n\t\t}\n\t\tlong expo(long a, long b, long MOD){\n\t\t\tlong result = 1;\n\t\t\twhile (b>0){\n\t\t\t\tif (b%2==1) result=(result*a)%MOD;\n\t\t\t\tb>>=1;\n\t\t\t\ta=(a*a)%MOD;\n\t\t\t}\n\t\t\treturn result%MOD;\n\t\t}\n\t\tlong inverseModullo(long numerator, long denominator, long MOD){\n\t\t\treturn ((numerator )*(expo(denominator, MOD-2, MOD))) ;\n\t\t}\n\t}\n\n\tstatic class Task2{\n\t\tpublic void solve(InputReader in, PrintWriter out){\n\t\t\t//\n\t\t}\n\t}\n \tstatic class DijkstraSP {\n\t\tlong[] distTo;\n\t\tDirectedEdge[] edgeTo;\n\t\tIndexMinPQ<Long> pq;\n\t\t\n\t\tpublic DijkstraSP(EdgeWeightedDigraph G, int s){\n\t\t\tdistTo= new long[G.V()];\n\t\t\tedgeTo= new DirectedEdge[G.V()];\n\t\t\tpq= new IndexMinPQ<Long>(G.V());\t\t\t//maxN = G.V()\n\t\t\t\n\t\t\tfor(int i=0; i<G.V(); i++){\n\t\t\t\tdistTo[i]=Long.MAX_VALUE;\n\t\t\t}\n\t\t\tdistTo[s]=0;\n\t\t\t\n\t\t\tpq.insert(s, 0L);\n\t\t\twhile(!pq.isEmpty()){\n\t\t\t\tint v = pq.delMin();\n\t\t\t\tfor(DirectedEdge e: G.adj(v)){\n\t\t\t\t\trelax(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate void relax(DirectedEdge e){\n\t\t\tint v=e.from(), w=e.to();\n\t\t\tif(distTo[w] > distTo[v]+e.weight()){\n\t\t\t\tdistTo[w]= distTo[v]+e.weight();\n\t\t\t\tedgeTo[w]= e;\n\t\t\t\t\n\t\t\t\tif(pq.contains(w)){\n\t\t\t\t\tif(pq.keyOf(w)>distTo[w]) pq.changeKey(w, distTo[w]);\n\t\t\t\t}\n\t\t\t\telse pq.insert(w, distTo[w]);\n\t\t\t}\n\t\t}\n\t}\n\tstatic class EdgeWeightedDigraph {\n\t\tprivate final int V;\n\t\tprivate LinkedList<DirectedEdge>[] adj;\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic EdgeWeightedDigraph(int V){\n\t\t\tthis.V=V;\n\t\t\tadj=(LinkedList<DirectedEdge>[])new LinkedList[V];\n\t\t\tfor(int i=0; i<V; i++){\n\t\t\t\tadj[i]=new LinkedList<DirectedEdge>();\n\t\t\t}\n\t\t}\n\t\tpublic void addEdge(DirectedEdge e){\n\t\t\tadj[e.from()].add(e);\n\t\t}\n\t\tpublic Iterable<DirectedEdge> adj(int v){\n\t\t\treturn adj[v];\n\t\t}\n\t\tpublic int V(){\n\t\t\treturn V;\t//number of vertices\n\t\t}\n\t}\n\tstatic class DirectedEdge {\n\t\tprivate int v, w;\n\t\tprivate long weight;\n\t\tpublic DirectedEdge(int v, int w, long weight){\n\t\t\tthis.v=v;\n\t\t\tthis.w=w;\n\t\t\tthis.weight=weight;\n\t\t}\n\t\tpublic int from(){\n\t\t\treturn v;\n\t\t}\n\t\tpublic int to(){\n\t\t\treturn w;\n\t\t}\n\t\tpublic long weight(){\n\t\t\treturn weight;\n\t\t}\n\t}\n\tstatic class IndexMinPQ<Key extends Comparable<Key>>{\n\t\tprivate int[] a, b;\n\t\tprivate Key[] keys;\n\t\tprivate int N, maxN;\n\t\t\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tpublic IndexMinPQ(int capacity){\n\t\t\tthis.maxN=capacity-1; this.N=0;\n\t\t\tthis.a=new int[maxN+1];\tthis.b=new int[maxN+1];\n\t\t\tthis.keys=(Key[])new Comparable[maxN+1];\n\t\t\tfor(int i=0; i<maxN+1; i++) a[i]=-1;\t\n\t\t}\n\t\t\n\t\tpublic boolean isEmpty(){ return N==0; }\n\n\t\tpublic int size(){ return N; }\n\n\t\tpublic boolean contains(int index){ return a[index] != -1; }\n\n\t\tpublic void insert(int index, Key key){\n\t\t\tN++;\n\t\t\ta[index]=N-1; b[N-1]=index;\n\t\t\tkeys[index]=key;\n\t\t\tswim(N-1);\n\t\t}\n\n\t\tpublic int minIndex(){ return b[0]; }\n\n\t\tpublic Key minKey(){ return keys[b[0]]; }\n\n\t\tpublic Key keyOf(int index){ return keys[index]; }\n\n\t\tpublic int delMin(){\n\t\t\tint min=b[0];\n\t\t\texch(0,--N);\n\t\t\tsink(0);\n\t\t\ta[min]= -1;\n\t\t\tb[N]= -1;\n\t\t\treturn min;\n\t\t}\n\n\t\tpublic void changeKey(int index, Key newKey){\n\t\t\tif(contains(index)){\n\t\t\t\tkeys[index]=newKey;\n\t\t\t\tswim(a[index]);\n\t\t\t\tsink(a[index]);\n\t\t\t}\n\t\t\telse throw new IllegalArgumentException(\"There is no key associated with this index.\");\n\t\t}\n\n\t\t/* General Helper Functions */\n\t\tprivate boolean greater(int i, int j){\n\t\t\treturn keys[b[i]].compareTo( keys[b[j]] ) > 0;\n\t\t}\n\n\t\tprivate void exch(int i, int j){\n\t\t\tint swap=b[i];\n\t\t\tb[i]=b[j];\tb[j]=swap;\n\t\t\ta[b[i]]=i;\ta[b[j]]=j;\n\t\t}\n\n\t\t/* Heap Helper Functions */\n\t\tprivate void swim(int child){\n\t\t\tint root=(child-1)/2;\n\t\t\twhile(greater(root, child)){\n\t\t\t\texch(root, child);\n\t\t\t\tchild=root;\n\t\t\t\troot=(child-1)/2;\n\t\t\t}\n\t\t}\n\n\t\tprivate void sink(int root){\n\t\t\tint child=2*root +1;\n\t\t\twhile(child<N){\n\t\t\t\tif(child<N-1)\n\t\t\t\t\tif(greater(child, child+1)) child++;\n\t\t\t\tif(greater(root, child))\n\t\t\t\t\texch(root, child);\n\t\t\t\telse break;\n\n\t\t\t\troot=child;\n\t\t\t\tchild=2*root+1;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class InputReader{\n\t\tfinal InputStream stream;\n\t\tfinal byte[] buf = new byte[8192];\n\t\tint curChar, numChars;\n\t\tSpaceCharFilter filter;\n\t\tpublic InputReader(){\n\t\t\tthis.stream = System.in;\n\t\t}\n\t\tpublic int read(){\n\t\t\tif(numChars == -1) throw new InputMismatchException();\n\t\t\tif(curChar >= numChars){\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry{\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch(IOException e){\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif(numChars <= 0) return -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\t\tpublic int nextInt(){\n\t\t\tint c = read();\n\t\t\twhile(isSpaceChar(c)) c = read();\n\t\t\tint sgn = 1;\n\t\t\tif(c == '-'){\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo{\n\t\t\t\tif(c<'0' || c>'9') throw new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while(!isSpaceChar(c));\n\t\t\treturn res*sgn;\n\t\t}\n\t\tpublic long nextLong(){\n\t\t\tint c = read();\n\t\t\twhile(isSpaceChar(c)) c = read();\n\t\t\tint sgn = 1;\n\t\t\tif(c == '-'){\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo{\n\t\t\t\tif(c<'0' || c>'9') throw new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while(!isSpaceChar(c));\n\t\t\treturn res*sgn;\n\t\t}\n\t\tpublic String next(){\n\t\t\tint c = read();\n\t\t\twhile(isSpaceChar(c)) c = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo{\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t}while(!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\t\tpublic boolean isSpaceChar(int c){\n\t\t\tif(filter != null) return filter.isSpaceChar(c);\n\t\t\treturn c==' ' || c=='\\n' || c=='\\r' || c=='\\t' || c==-1;\n\t\t}\n\t\tpublic interface SpaceCharFilter{\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n}", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.PriorityQueue;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.AbstractCollection;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskH solver = new TaskH();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskH {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int[] count = new int[200];\n            int n = in.nextInt();\n            String x = in.nextLine();\n            for (int i = 0; i < n; i++) {\n                int p = (int) x.charAt(i);\n                count[p]++;\n            }\n            int pair = 0;\n            int odd = 0;\n            PriorityQueue<Character> arg = new PriorityQueue<>();\n            PriorityQueue<Character> odds = new PriorityQueue<>();\n            for (int i = 0; i < 200; i++) {\n                if (count[i] != 0) {\n                    if (count[i] % 2 != 0) {\n                        odd++;\n                        odds.add((char) i);\n                    }\n                    pair = pair + count[i] / 2;\n                    for (int j = 0; j < count[i] / 2; j++) {\n                        arg.add((char) i);\n                    }\n                }\n            }\n            if (pair != 0 && odd == 0) {\n                out.println(\"1\");\n                StringBuilder front = new StringBuilder();\n                while (!arg.isEmpty()) {\n                    front.append(arg.poll());\n                }\n                out.println(front.toString() + front.reverse().toString());\n                return;\n            } else if (pair % odd == 0) {\n                out.println(odd);\n                int each = pair / odd;\n                boolean first = true;\n                for (int i = 0; i < odd; i++) {\n                    StringBuilder front = new StringBuilder();\n                    for (int j = 0; j < each; j++) {\n                        front.append(arg.poll());\n                    }\n                    if (!first) out.print(\" \");\n                    first = false;\n                    out.print(front.toString() + odds.poll() + front.reverse().toString());\n                }\n                out.println();\n                return;\n            }\n            while (pair > 0) {\n                pair = pair - 1;\n                char ap = arg.poll();\n                odd = odd + 2;\n                odds.add(ap);\n                odds.add(ap);\n                if (pair % odd == 0) {\n                    out.println(odd);\n                    int each = pair / odd;\n                    boolean first = true;\n                    for (int i = 0; i < odd; i++) {\n                        StringBuilder front = new StringBuilder();\n                        for (int j = 0; j < each; j++) {\n                            front.append(arg.poll());\n                        }\n                        if (!first) out.print(\" \");\n                        first = false;\n                        out.print(front.toString() + odds.poll() + front.reverse().toString());\n                    }\n                    out.println();\n                    return;\n                }\n            }\n            out.println(n);\n            boolean first = true;\n            for (int i = 0; i < 200; i++) {\n                if (count[i] != 0) {\n                    int c = count[i];\n                    char p = (char) i;\n                    for (int j = 0; j < c; j++) {\n                        if (!first) out.print(\" \");\n                        out.print(p);\n                        first = false;\n                    }\n                }\n            }\n            out.println();\n        }\n\n    }\n\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public InputReader(InputStream a) {\n            br = new BufferedReader(new InputStreamReader(a));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                } catch (NullPointerException e) {\n                    return null;\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.lang.*;\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.net.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n    \n    int getInd(char c) {\n        if ('0' <= c && c <= '9')\n            return c - '0';\n        if ('A' <= c && c <= 'Z')\n            return c - 'A' + 10;\n        return c - 'a' + 36;\n    }\n    \n    char getChar(int ind) {\n        if (ind < 10) {\n            return (char)('0' + ind);\n        } else if (ind < 36) {\n            return (char)('A' + ind - 10);\n        } else {\n            return (char)('a' + ind - 36);\n        }\n    }\n    \n    void solve() throws Exception {\n        int n = sc.nextInt();\n        String s = sc.nextToken();\n        int[] c = new int[100];\n        for (int i = 0; i < n; i++) {\n            c[getInd(s.charAt(i))]++;\n        }\n        int kOdd = 0;\n        for (int i = 0; i < 100; i++) {\n            kOdd += (c[i] & 1);\n        }\n        int len = n;\n        while (len > 1) {\n            if (n % len == 0) {\n                int m = n / len;\n                if (len % 2 == 0) {\n                    if (kOdd == 0) {\n                        break;\n                    }\n                } else {\n                    if (kOdd <= m && (m - kOdd) % 2 == 0) {\n                        break;\n                    }\n                }\n            }\n            --len;\n        }\n        int m = (n / len);\n        out.println(m);\n        char[] res = new char[len];\n        for (int i = 0; i < m; i++) {\n            if (i > 0) {\n                out.print(\" \");\n            }\n            int l = 0;\n            for (int j = 0; j < 100 && 2 * l < len - 1; j++) {\n                while (c[j] > 1 && 2 * l < len - 1) {\n                    res[l] = res[len - 1 - l] = getChar(j);\n                    c[j] -= 2;\n                    l++;\n                }\n            }\n            if ((len & 1) == 1) {\n                boolean found = false;\n                for (int j = 0; j < 100; j++) {\n                    if ((c[j] & 1) == 1) {\n                        res[l] = getChar(j);\n                        c[j]--;\n                        found = true;\n                        break;\n                    }\n                }\n                if (!found) {\n                    for (int j = 0; j < 100; j++) {\n                        if (c[j] > 0) {\n                            res[l] = getChar(j);\n                            c[j]--;\n                            break;\n                        }\n                    }\n                }\n            }\n            out.print(res);\n        }\n        out.println();\n    }\n\n    BufferedReader in;\n    PrintWriter out;\n    FastScanner sc;\n\n    final String INPUT_FILE = \"\";\n    final String OUTPUT_FILE = \"\";\n\n    static Throwable throwable;\n\n    public static void main(String[] args) throws Throwable {\n        Thread thread = new Thread(null, new Solution(), \"\", (1 << 26));\n        thread.start();\n        thread.join();\n        thread.run();\n        if (Solution.throwable != null)\n            throw Solution.throwable;\n    }\n\n    public void run() {\n        try {\n            if (INPUT_FILE.equals(\"\")) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n            } else {\n                in = new BufferedReader(new FileReader(INPUT_FILE));\n            }\n            if (OUTPUT_FILE.equals(\"\")) {\n                out = new PrintWriter(System.out);\n            } else {\n                out = new PrintWriter(OUTPUT_FILE);\n            }\n            sc = new FastScanner(in);\n            solve();\n        } catch (Exception e) {\n            throwable = e;\n        } finally {\n            out.close();\n        }\n    }\n\n}\n\nclass FastScanner {\n\t\n    BufferedReader reader;\n    StringTokenizer strTok;\n\n    FastScanner(BufferedReader reader) {\n        this.reader = reader;\n    }\n\n    public String nextToken() throws Exception {\n        while (strTok == null || !strTok.hasMoreTokens()) {\n            strTok = new StringTokenizer(reader.readLine());\n        }\n        return strTok.nextToken();\n    }\n\n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n}", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.AbstractCollection;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.LinkedList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastScanner in = new FastScanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskH solver = new TaskH();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskH {\n        private int num(char c) {\n            if (c >= 'a' && c <= 'z') {\n                return c - 'a';\n            } else if (c >= 'A' && c <= 'Z') {\n                return c - 'A' + 26;\n            } else {\n                return c - '0' + 52;\n            }\n        }\n\n        private char rev(int n) {\n            if (n < 26)\n                return (char) (n + 'a');\n            else if (n < 52)\n                return (char) (n - 26 + 'A');\n            else\n                return (char) (n - 52 + '0');\n        }\n\n        public void solve(int testNumber, FastScanner in, PrintWriter out) {\n            int N = in.ni();\n            int[] cnt = new int[100];\n            String s = in.ns();\n            for (int i = 0; i < N; i++) {\n                cnt[num(s.charAt(i))]++;\n            }\n\n            LinkedList<Character> even = new LinkedList<>();\n            LinkedList<Character> odd = new LinkedList<>();\n            for (int i = 0; i < 100; i++) {\n                if (cnt[i] == 0)\n                    continue;\n                if (cnt[i] % 2 == 1) {\n                    odd.add(rev(i));\n                }\n                for (int j = 0; j < cnt[i] / 2; j++) {\n                    even.add(rev(i));\n                }\n            }\n            if (odd.size() <= 1) {\n                out.println(1);\n                StringBuilder pal = new StringBuilder();\n                for (Character c : even) {\n                    pal.append(c);\n                }\n                out.print(pal);\n                if (!odd.isEmpty())\n                    out.print(odd.pollFirst());\n                out.print(pal.reverse());\n                out.println();\n            } else {\n                for (int div = 1; div <= N; div++) {\n                    if (N % div == 0 && (N / div) % 2 == 1) {\n                        if (odd.size() > div || (div - odd.size()) % 2 == 1)\n                            continue;\n                        char[] center = new char[div];\n                        for (int i = 0; i < div; i++) {\n                            if (!odd.isEmpty()) {\n                                center[i] = odd.pollFirst();\n                            } else {\n                                center[i] = center[i + 1] = even.pollFirst();\n                                i++;\n                            }\n                        }\n                        out.println(div);\n                        int size = (N / div - 1) / 2;\n                        for (int i = 0; i < div; i++) {\n                            StringBuilder pal = new StringBuilder();\n                            for (int j = 0; j < size; j++) {\n                                pal.append(even.pollFirst());\n                            }\n                            out.print(pal);\n                            out.print(center[i]);\n                            out.print(pal.reverse());\n                            out.print(' ');\n                        }\n                        return;\n                    }\n                }\n            }\n        }\n\n    }\n\n    static class FastScanner {\n        private BufferedReader in;\n        private StringTokenizer st;\n\n        public FastScanner(InputStream stream) {\n            in = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String ns() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    String rl = in.readLine();\n                    if (rl == null) {\n                        return null;\n                    }\n                    st = new StringTokenizer(rl);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int ni() {\n            return Integer.parseInt(ns());\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.PriorityQueue;\nimport java.io.StringWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Pradyumn\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskH solver = new TaskH();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskH {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            int n = in.nextInt();\n            char[] s = in.nextCharacterArray(n);\n            int[] ct = StringUtils.countAll(s);\n            int sum = 0;\n            PriorityQueue<Integer> odd = new PriorityQueue<>(new Comparator<Integer>() {\n\n                public int compare(Integer o1, Integer o2) {\n                    return Integer.compare(ct[o2], ct[o1]);\n                }\n            });\n            PriorityQueue<Integer> even = new PriorityQueue<>(new Comparator<Integer>() {\n\n                public int compare(Integer o1, Integer o2) {\n                    return Integer.compare(ct[o2], ct[o1]);\n                }\n            });\n            for (int i = 0; i < 128; ++i) {\n                if (ct[i] == 0) continue;\n                if (ct[i] % 2 == 0) {\n                    even.add(i);\n                } else {\n                    odd.add(i);\n                }\n                sum += ct[i];\n            }\n            int oddcount = odd.size();\n            String ans = null;\n            if (oddcount == 0) {\n                out.println(solveForThis(odd, even, ct, 1, sum));\n                return;\n            }\n            for (int i = oddcount; i <= sum; ++i) {\n                if (sum % i == 0) {\n                    odd.clear();\n                    even.clear();\n                    for (int j = 0; j < 128; ++j) {\n                        if (ct[j] == 0) continue;\n                        if (ct[j] % 2 == 0) {\n                            even.add(j);\n                        } else {\n                            odd.add(j);\n                        }\n                    }\n                    ans = (solveForThis(odd, even, ct.clone(), i, sum));\n                    if (ans != null) {\n                        out.println(ans);\n                        return;\n                    }\n                }\n            }\n        }\n\n        private String solveForThis(PriorityQueue<Integer> odd, PriorityQueue<Integer> even, int[] ct, int grp, int sum) {\n            StringWriter sw = new StringWriter();\n            PrintWriter out = new PrintWriter(sw);\n            int[] cct = ct.clone();\n            out.println(grp);\n            int size = sum / grp;\n            for (int groups = 1; groups <= grp; ++groups) {\n                int[] s = new int[size];\n                int i = 0;\n                int j = size - 1;\n                Integer val;\n                while (i <= j) {\n                    boolean ev = false, od = false;\n                    if (j - i == 0) {\n                        val = odd.poll();\n                        od = true;\n                    } else if (j - i > 0) {\n                        val = even.poll();\n                        ev = true;\n                    } else {\n                        break;\n                    }\n                    if (val == null) {\n                        if (od) val = even.poll();\n                        else if (ev) val = odd.poll();\n                        else throw new RuntimeException();\n                    }\n                    if (i == j) {\n                        s[i] = val;\n                        ct[val] -= 1;\n                        if (ct[val] != 0) {\n                            if (ct[val] % 2 == 0) even.add(val);\n                            else odd.add(val);\n                        }\n                    } else {\n                        s[i] = s[j] = val;\n                        ct[val] -= 2;\n                        if (ct[val] != 0) {\n                            if (ct[val] % 2 == 0) even.add(val);\n                            else odd.add(val);\n                        }\n                    }\n                    ++i;\n                    --j;\n                }\n                for (int p = 0; p < size; ++p) {\n                    out.print((char) (s[p]));\n                    cct[s[p]]--;\n                }\n                out.print(\" \");\n            }\n            boolean flag = true;\n            for (int i = 0; i < cct.length; ++i) {\n                flag &= cct[i] == 0;\n            }\n            if (!flag) {\n                return null;\n            }\n            return sw.toString();\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n        private FastReader.SpaceCharFilter filter;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        private static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public char nextCharacter() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            return (char) c;\n        }\n\n        public char[] nextCharacterArray(int n) {\n            char[] chars = new char[n];\n            for (int i = 0; i < n; i++) {\n                chars[i] = nextCharacter();\n            }\n            return chars;\n        }\n\n        private interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class StringUtils {\n        public static int[] countAll(char[] string) {\n            int[] c = new int[128];\n            for (char s : string) {\n                c[s]++;\n            }\n            return c;\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Aman Kumar Singh\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        HPalindromicCut solver = new HPalindromicCut();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class HPalindromicCut {\n        PrintWriter out;\n        InputReader in;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.out = out;\n            this.in = in;\n            int n = ni();\n            String st = n();\n            int i = 0;\n            int[] freq = new int[256];\n            int last = 0;\n            ArrayList<Integer> ar = new ArrayList<>();\n            int cnt_odd = 0;\n            int mn = n + 5;\n            for (i = 0; i < n; i++)\n                freq[(int) st.charAt(i)]++;\n            for (i = 0; i < 256; i++)\n                cnt_odd += freq[i] % 2;\n            for (i = 1; i <= (int) Math.sqrt(n); i++) {\n                if (n % i == 0) {\n                    int x = i;\n                    int y = n / i;\n                    if (cnt_odd > 0) {\n                        if (x % 2 != 0 && y >= cnt_odd && (y - cnt_odd) % 2 == 0)\n                            mn = Math.min(mn, y);\n                        if (y % 2 != 0 && x >= cnt_odd && (x - cnt_odd) % 2 == 0)\n                            mn = Math.min(mn, x);\n                    } else {\n                        if (y % 2 == 0)\n                            mn = Math.min(x, mn);\n                        if (x % 2 == 0)\n                            mn = Math.min(y, mn);\n                    }\n                }\n            }\n            int len = n / mn;\n            int[] hola = new int[n];\n            if (cnt_odd > 0) {\n                int lol = len / 2;\n                for (i = 0; i < 256; i++) {\n                    if (freq[i] % 2 != 0) {\n                        ar.add(i);\n                        freq[i]--;\n                    }\n                }\n                for (int x : ar) {\n                    hola[lol] = x;\n                    lol += len;\n                }\n                ar.clear();\n                for (i = 0; i < 256; i++) {\n                    if (freq[i] % 2 == 0 && freq[i] > 0)\n                        ar.add(i);\n                }\n                int x = 0;\n                while (lol < n) {\n                    if (freq[ar.get(x)] == 0) {\n                        x++;\n                        continue;\n                    }\n                    hola[lol] = ar.get(x);\n                    lol += len;\n                    freq[ar.get(x)]--;\n                }\n                ar.clear();\n                for (i = 0; i < 256; i++) {\n                    if (freq[i] > 0)\n                        ar.add(i);\n                }\n                x = 0;\n                for (i = 0; i < mn; i++) {\n                    int lo = i * len, hi = len * (i + 1) - 1;\n                    for (int j = 0; j < (len - 1) / 2; j++) {\n                        if (freq[ar.get(x)] == 0)\n                            x++;\n                        hola[lo++] = ar.get(x);\n                        hola[hi--] = ar.get(x);\n                        freq[ar.get(x)] -= 2;\n                    }\n                }\n            } else {\n                int x = 0;\n                ar.clear();\n                for (i = 0; i < 256; i++) {\n                    if (freq[i] > 0)\n                        ar.add(i);\n                }\n                //pn(ar);\n                x = 0;\n                for (i = 0; i < mn; i++) {\n                    int lo = i * len, hi = len * (i + 1) - 1;\n                    for (int j = 0; j < len / 2; j++) {\n                        if (freq[ar.get(x)] == 0)\n                            x++;\n                        hola[lo++] = ar.get(x);\n                        hola[hi--] = ar.get(x);\n                        freq[ar.get(x)] -= 2;\n                    }\n                }\n            }\n            pn(mn);\n            for (i = 0; i < n; i++) {\n                if (i % len == 0 && i != 0)\n                    p(\" \");\n                p((char) hola[i]);\n            }\n        }\n\n        String n() {\n            return in.next();\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        void pn(long zx) {\n            out.println(zx);\n        }\n\n        void p(Object o) {\n            out.print(o);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new UnknownError();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.*;\n\nimport static java.lang.Math.abs;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.util.Arrays.copyOf;\nimport static java.util.Arrays.fill;\nimport static java.util.Arrays.sort;\nimport static java.util.Collections.asLifoQueue;\nimport static java.util.Collections.reverseOrder;\nimport static java.util.Collections.sort;\n\npublic class Main {\n    private FastScanner in;\n    private PrintWriter out;\n\n    private void solve() throws IOException {\n        // 48 57 97 122 65 90\n        int[] k = new int[123];\n        int n = in.nextInt();\n        char[] t = in.nextLine().toCharArray();\n        for (char c : t)\n            k[c]++;\n\n        int cnt = 0;\n        ArrayList<Character> c = new ArrayList<>();\n        for (int i = 48; i < k.length; i++)\n            if (k[i] % 2 == 1) {\n                k[i]--;\n                c.add((char) i);\n                cnt++;\n            }\n\n        if (cnt < 2) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 48; i < k.length; i++)\n                if (k[i] > 0)\n                    for (int j = 0; j < k[i] / 2; j++)\n                        sb.append((char) i);\n\n            if (cnt == 1) sb.append(c.get(0));\n\n            for (int i = k.length - 1; i >= 48; i--)\n                if (k[i] > 0)\n                    for (int j = 0; j < k[i] / 2; j++)\n                        sb.append((char) i);\n\n            out.println(\"1\\n\" + sb.toString());\n            return;\n        }\n\n        n = (n - cnt) / 2;\n        while (n % cnt != 0)\n            for (int i = 48; i < k.length; i++)\n                if (k[i] > 0) {\n                    k[i] -= 2;\n                    cnt += 2;\n                    n--;\n                    c.add((char) i);\n                    c.add((char) i);\n                    break;\n                }\n\n        out.println(cnt);\n        StringBuilder sb = new StringBuilder();\n        int kk = 0, len = n / cnt;\n        for (char cc : c) {\n            sb.delete(0, sb.length());\n            kk = 0;\n            for (int i = 0; i < k.length; i++)\n                while (kk < len && k[i] > 0) {\n                    kk++;\n                    sb.append((char) i);\n                    sb.insert(0, (char) i);\n                    k[i] -= 2;\n                }\n\n            sb.insert(len, cc);\n            out.print(sb.toString() + \" \");\n        }\n    }\n\n    class FastScanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        FastScanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        boolean hasNext() throws IOException {\n            return br.ready() || (st != null && st.hasMoreTokens());\n        }\n\n        int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() throws IOException {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        boolean hasNextLine() throws IOException {\n            return br.ready();\n        }\n\n    }\n\n    private void run() throws IOException {\n        in = new FastScanner(System.in); // in = new FastScanner(new FileInputStream(\".in\"));\n        out = new PrintWriter(System.out); // out = new PrintWriter(new FileOutputStream(\".out\"));\n\n        solve();\n\n        out.flush();\n        out.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n}", "label": 3}
{"src": "\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n/**\n *\n * @author rokk-\n */\npublic class ACM2017H {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        // TODO code application logic here\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        scanner.nextLine();\n        String string = scanner.nextLine();\n        int numPairs = 0, numSingles = 0;\n        HashMap<Character, Integer> charCounts = new HashMap<Character, Integer>();\n        Queue<Character> pairs = new LinkedList<Character>();\n        Queue<Character> singles = new LinkedList<Character>();\n        for (int i = 0; i < n; i++) {\n            char c = string.charAt(i);\n            if (!charCounts.containsKey(c)) {\n                charCounts.put(c, 0);\n            }\n            int count = charCounts.get(c) + 1;\n            charCounts.put(c, count);\n            if (count % 2 == 0) {\n                numPairs++;\n                pairs.add(c);\n            }\n        }\n        for (char key : charCounts.keySet()) {\n            if (charCounts.get(key) % 2 == 1) {\n                numSingles++;\n                singles.add(key);\n            }\n        }\n        int numPalindromes = 0;\n        if (numSingles < numPairs) {\n            while (numSingles > 0) {\n                if (numPairs % numSingles == 0) {\n                    break;\n                }\n                numPairs--;\n                numSingles+=2;\n                char c= pairs.remove();\n                singles.add(c);\n                singles.add(c);\n                \n            }\n        }\n        if (numSingles == 0) {\n            numPalindromes = 1;\n            System.out.println(\"\" + numPalindromes);\n            char[] temp = new char[n];\n            for (int j = 0; j < temp.length / 2; j++) {\n                char c = pairs.remove();\n                temp[j] = c;\n                temp[temp.length - 1 - j] = c;\n            }\n            System.out.print(new String(temp) + \" \");\n        } else if (numPairs >= numSingles && numPairs % numSingles == 0) {\n            numPalindromes = numSingles;\n            System.out.println(\"\" + numPalindromes);\n            for (int i = 0; i < numPalindromes; i++) {\n                char[] temp = new char[numPairs / numSingles * 2 + 1];\n                temp[(temp.length - 1) / 2] = singles.remove();\n                for (int j = 0; j < (temp.length - 1) / 2; j++) {\n                    char c = pairs.remove();\n                    temp[j] = c;\n                    temp[temp.length - 1 - j] = c;\n                }\n                System.out.print(new String(temp) + \" \");\n            }\n        } else if (numPairs != numSingles) {\n\n            numPalindromes = n;\n            System.out.println(\"\" + numPalindromes);\n            for (int i = 0; i < n; i++) {\n                System.out.print(string.charAt(i) + \" \");\n            }\n        }\n\n    }\n\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class CF_883_H {\n\tpublic static void main(String[] args) {\n\t\t// #stopthecleancode\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n = scan.nextInt();\n\t\tString s = scan.next();\n\t\tint[] fre = new int[150];\n\t\tfor(int i = 0 ; i < n ; i++) {\n\t\t\tfre[s.charAt(i)]++;\n\t\t}\n\t\tint odd = 0;\n\t\tfor(int i = 0 ; i < 150 ; i++)\n\t\t\tif(fre[i]%2 == 1)\n\t\t\t\todd++;\n\t\tif(odd > 0) {\n\t\t\tint addOn = 0;\n\t\t\twhile(n%(odd+addOn) != 0 || (n%(odd+addOn) == 0 && (n/(odd+addOn)%2 == 0)))\n\t\t\t\taddOn+=2;\n\t\t\tint length = n/(odd+addOn);\n\t\t\tchar[][] res = new char[odd+addOn][length];\n\t\t\tint idx = 0;\n\t\t\tfor(char i = 0 ; i < 150 ; i++) {\n\t\t\t\tif(fre[i]%2 == 1) {\n\t\t\t\t\tres[idx++][length/2] = i;\n\t\t\t\t\tfre[i]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(char i = 0 ; i < 150 ; i++) {\n\t\t\t\twhile(idx < res.length && fre[i] > 0) {\n\t\t\t\t\tres[idx++][length/2] = i;\n\t\t\t\t\tres[idx++][length/2] = i;\n\t\t\t\t\tfre[i]-=2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidx = 0;\n\t\t\tint idx2 = 0;\n\t\t\tfor(char k = 0 ; k < 150 ; k++) {\n\t\t\t\tfor(int i = 0 ; i < fre[k] ; i+=2) {\n\t\t\t\t\twhile(res[idx][idx2] > 0) {\n\t\t\t\t\t\tidx2 = 0;\n\t\t\t\t\t\tidx++;\n\t\t\t\t\t}\n\t\t\t\t\tres[idx][idx2] = k;\n\t\t\t\t\tres[idx][length-idx2-1] = k;\n\t\t\t\t\tidx2++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(res.length);\n\t\t\tfor(int i = 0 ; i < res.length ; i++)\n\t\t\t\tout.print(new String(res[i]) + \" \");\n\t\t} else {\n\t\t\tchar[] res = new char[n];\n\t\t\tint idx = 0;\n\t\t\tfor(char k = 0 ; k < 150 ; k++) {\n\t\t\t\tfor(int i = 0 ; i < fre[k] ; i+=2) {\n\t\t\t\t\tres[idx] = k;\n\t\t\t\t\tres[n-idx-1] = k;\n\t\t\t\t\tidx++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(1);\n\t\t\tout.println(new String(res));\n\t\t}\n\t\tout.close();\n\t}\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class pr883H {\n    public static void main(String[] args) {\n        FastScanner in = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        char[] c = in.next().toCharArray();\n\n\n        solve(n, c, out);\n        out.flush();\n        out.close();\n    }\n\n    private static void solve(int n, char[] c, PrintWriter out) {\n        int[] cnt = new int[256 + 3];\n\n        for (int i = 0; i < n; i++) {\n            cnt[(int)c[i]]++;\n        }\n\n        char[] ans;\n        StringBuilder oddChar = new StringBuilder();\n        StringBuilder evenChar = new StringBuilder();\n        for (int i = 0; i <= 256 ; i++) {\n            if(cnt[i] > 0) {\n                if(cnt[i] % 2 == 1) {\n                    oddChar.append((char)i);\n                    cnt[i]--;\n                }\n                while(cnt[i] > 0) {\n                    evenChar.append((char)i);\n                    cnt[i] -= 2;\n                }\n            }\n        }\n        char[] odd;\n        char[] even;\n        if(oddChar.length() == 0) {\n            even = evenChar.toString().toCharArray();\n            out.println(1);\n            ans = new char[n];\n            for (int i = 0; i < n / 2; i++) {\n                ans[i] = ans[n-i-1] = even[i];\n            }\n            out.println(new String(ans));\n            return;\n        }\n        while(evenChar.length() % oddChar.length() != 0) {\n            int l = evenChar.length()-1;\n            oddChar.append(evenChar.charAt(l));\n            oddChar.append(evenChar.charAt(l));\n            evenChar.deleteCharAt(l);\n        }\n\n        even = evenChar.toString().toCharArray();\n        odd = oddChar.toString().toCharArray();\n        int len = n / odd.length;\n        out.println(n / len);\n        ans = new char[len];\n        int j = 0;\n        for (int i = 0; i < odd.length; i++) {\n            ans[len/2] = odd[i];\n\n            for (int k = 0; k < len / 2; k++) {\n                ans[k] = ans[len-k-1] = even[j++];\n            }\n            out.print(new String(ans) + \" \");\n        }\n\n    }\n\n    static class FastScanner\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner()\n        {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n", "label": 3}
{"src": "import java.io.*;\n\n\npublic class palindromeCut {\n\tstatic int[] freq;\n\tstatic void print(int n, int mid) {\n\t\tint[] printed = new int[150];\n\t\tStringBuilder res = new StringBuilder();\n\t\tfor (int i = 0; i < 150; i++) {\n\t\t\tint x = freq[i] / 2;\n\t\t\tfor (int j = 0; j < x && n > 0; j++) {\n\t\t\t\tres.append((char) i);\n\t\t\t\tprinted[i]++;\n\t\t\t\tfreq[i] -= 2;\n\t\t\t\tn -= 2;\n\t\t\t}\n\t\t}\n\t\tif (mid != 0)\n\t\t\tres.append(((char)mid));\n\t\tfor (int i = 149; i >= 0; i--) {\n\t\t\tfor (int j = 0; j < printed[i]; j++)\n\t\t\t\tres.append(((char) i));\n\t\t}\n\t\tSystem.out.print(res+\" \");\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint n = Integer.parseInt(br.readLine());\n\t\tString str = br.readLine();\n\t\tfreq = new int[150];\n\t\tfor (char c:str.toCharArray())\n\t\t{\n\t\t\tfreq[c]++;\n\t\t}\n\t\tint o =0;\n\t\tfor (int i =0;i<150;i++)\n\t\t{\n\t\t\tif (freq[i]%2!=0)\n\t\t\t{\n\t\t\t\to++;\n\t\t\t}\n\t\t}\n\n\t\tif (o==0)\n\t\t{\n\t\t\tStringBuilder s1 = new StringBuilder();\n\t\t\tStringBuilder s2 = new StringBuilder();\n\t\t\t\n\t\t\tfor (int i =0;i<150;i++)\n\t\t\t{\n\t\t\t\twhile (freq[i]>0)\n\t\t\t\t{\n\t\t\t\t\ts1.append((char)i);\n\t\t\t\t\ts2.append((char)i);\n\t\t\t\t\tfreq[i] = freq[i]-2;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts2.reverse();\n\t\t\tSystem.out.println(1);\n\t\t\tSystem.out.print(s1+\"\"+s2);\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint m = o;\n\t\t\twhile (n%m!=0 || (n/m)%2==0)\n\t\t\t\tm++;\n\t\t\tint ml = n/m;\n\t\t\tSystem.out.println(m);\n\t\t\tfor (int i = 0; i < 150; i++) {\n\t\t\t\tif (freq[i] % 2 != 0) {\n\t\t\t\t\tfreq[i]--;\n\t\t\t\t\tprint(ml-1, i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int i = 0; i < 150; i++) {\n\t\t\t\twhile (freq[i] > 0) {\n\t\t\t\t\tfreq[i] -= 2;\n\t\t\t\t\tprint(ml-1, i);\n\t\t\t\t\tprint(ml-1, i);\n\t\t\t\t}\n\t\t\t}\t\t\t\n\t\t}\n\t\t\n\t}\n\n}", "label": 3}
{"src": "import java.awt.geom.Line2D;\nimport java.io.*;\nimport java.util.*;\n\npublic class C339D\n{\n\nprivate static StringTokenizer st;\n    \n    public static void nextLine(BufferedReader br) throws IOException\n    {\n        st = new StringTokenizer(br.readLine());\n    }\n    \n    public static int nextInt()\n    {\n        return Integer.parseInt(st.nextToken());\n    }\n    \n    public static String next()\n    {\n        return st.nextToken();\n    }\n    \n    public static long nextLong()\n    {\n        return Long.parseLong(st.nextToken());\n    }\n\n    public static double nextDouble()\n    {\n        return Double.parseDouble(st.nextToken());\n    }\n    \n    static int n;\n    static Pair[] pairs;\n    \n    public static void main(String[] args) throws IOException\n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        nextLine(br);\n        n = nextInt();\n        long A = nextInt();\n        long cf = nextInt();\n        long cm = nextInt();\n        long m = nextLong();\n        nextLine(br);\n        pairs = new Pair[n];\n        for (int i = 0; i < n; i++)\n        {\n            pairs[i] = new Pair(i, nextLong());\n        }\n        Arrays.sort(pairs);\n        // cost to perfect i skills\n        long[] costf = new long[n + 1];\n        costf[0] = 0;\n        for (int i = 1; i <= n; i++)\n        {\n            costf[i] = costf[i-1] + (A - pairs[n-i].val);\n        }\n        // cost to bring bottom i-1 skills to the same level\n        long[] costm = new long[n+1];\n        costm[0] = 0;\n        for (int i = 1; i < n; i++)\n        {\n            costm[i] = costm[i-1] + (pairs[i].val - pairs[i-1].val) * i;\n        }\n        long best = -1;\n        int besti = -1;\n        for (int i = 0; i <= n; i++)\n        {\n            if (costf[i] > m) break;\n            long temp = bsearch(costm, m - costf[i], n-i, A);\n            \n            if (temp * cm + i * cf > best)\n            {\n                best = temp * cm + i * cf;\n                besti = i;\n            }\n        }\n        System.out.println(best);\n        long temp = bsearch(costm, m - costf[besti], n-besti, A);\n        long[] ans = new long[n];\n        for (int i = 0; i < n-besti; i++)\n        {\n            if (pairs[i].val < temp) \n            {\n                ans[pairs[i].index] = temp; \n            }\n            else\n            {\n                ans[pairs[i].index] = pairs[i].val;\n            }\n        }\n        for (int i = n-besti; i < n; i++)\n        {\n            ans[pairs[i].index] = A; \n        }\n        StringBuffer sb = new StringBuffer();\n        for (int i = 0; i < n; i++)\n        {\n            sb.append(ans[i] + \" \");\n        }\n        System.out.println(sb.toString());\n    }\n\n    public static long bsearch(long[] cost, long v, int cap, long A)\n    {\n        if (cap == 0)\n        {\n            return A;\n        }\n        int left = 0;\n        int right = cap-1;\n        while (left < right)\n        {\n            int mid = (left + right + 1) / 2;\n            if (cost[mid] > v)\n            {\n                right = mid - 1;\n            }\n            else\n            {\n                left = mid;\n            }\n        }\n        long ans = pairs[left].val + (v - cost[left]) / (left + 1);\n        \n        return Math.min(ans, A);\n    }\n    \n    static class Pair implements Comparable<Pair>\n    {\n        int index;\n        long val;\n        \n        public Pair (int ind, long v)\n        {\n            index = ind; val = v;\n        }\n        \n        @Override\n        public int compareTo(Pair p)\n        {\n            return Long.valueOf(val).compareTo(p.val);\n        }\n    }\n    \n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Map;\nimport java.util.TreeMap;\n\npublic class ProblemB2 {\n    BufferedReader rd;\n    long cf, cm;\n\n    ProblemB2() throws IOException {\n        rd = new BufferedReader(new InputStreamReader(System.in));\n        compute();\n    }\n\n    private void compute() throws IOException {\n        long[] a = longarr();\n        int n = (int)a[0];\n        long A = a[1];\n        cf = a[2];\n        cm = a[3];\n        long m = a[4];\n        a = longarr();\n        long[] orig = Arrays.copyOf(a, a.length);\n        Integer[] pp = new Integer[a.length];\n        for(int i=0;i<n;i++) {\n            pp[i] = i;\n        }\n        Arrays.sort(pp, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer x, Integer y) {\n                return Long.compare(orig[x], orig[y]);\n            }\n        });\n        sort(a);\n\n        int p = n-1;\n        while(p >= 0 && a[p] == A) {\n            p--;\n        }\n        long bestMin = a[0];\n        long bestAcount = n-1-p;\n        long bestForce = computeForce(bestMin, bestAcount);\n\n        if(p >= 0) {\n\n            long[] s = new long[n+1];\n            for(int i=0;i<n;i++) {\n                long next = i+1<n?a[i+1]:A;\n                long df = next - a[i];\n                s[i+1] = s[i] + (i+1) * df;\n            }\n\n            int i = p+1;\n            long used = 0;\n            while (i >= 0) {\n                if (i < n) {\n                    long cost = A - a[i];\n                    if (used + cost > m) {\n                        break;\n                    }\n                    used += cost;\n                }\n                long aCount = n - i;\n                long left = m - used;\n                int y = Arrays.binarySearch(s, left);\n                long minA;\n                if(y >= 0) {\n                    if(y < i) {\n                        minA = a[y];\n                    } else {\n                        long rest = left -  s[i];\n                        long restSpace = (A - a[i]) * y;\n                        if(rest < restSpace) {\n                            minA = a[i] + (rest / i);\n                        } else {\n                            minA = A;\n                            aCount = n;\n                        }\n                    }\n                } else {\n                    y = Math.min(n, -1-y);\n                    if(y < i) {\n                        long rest = left -  s[y-1];\n                        long restSpace = (A - a[y-1]) * y;\n                        if(rest < restSpace) {\n                            minA = a[y-1] + (rest / y);\n                        } else {\n                            minA = A;\n                            aCount = n;\n                        }\n                    } else if(i == 0) {\n                        minA = A;\n                        aCount = n;\n                    } else {\n                        int u = i-1;\n                        long rest = left - s[u];\n                        long restSpace = (A - a[u]) * i;\n                        if(rest < restSpace) {\n                            minA = a[u] + (rest / i);\n                        } else {\n                            minA = A;\n                            aCount = n;\n                        }\n                    }\n                }\n                long force = computeForce(minA, aCount);\n                if(force > bestForce) {\n                    bestForce = force;\n                    bestMin = minA;\n                    bestAcount = aCount;\n                }\n\n                i--;\n            }\n        }\n\n        out(bestForce);\n        StringBuilder buf = new StringBuilder();\n        if(bestMin == A) {\n            Arrays.fill(orig, A);\n        } else {\n            for (int i = 0; i < bestAcount; i++) {\n                orig[pp[n-i-1]] = A;\n            }\n            for(int i=0;i<n;i++) {\n                orig[i] = Math.max(bestMin, orig[i]);\n            }\n        }\n        for(int i=0;i<n;i++) {\n            if(i > 0) {\n                buf.append(' ');\n            }\n            buf.append(orig[i]);\n        }\n        out(buf);\n    }\n\n    private long computeForce(long aMin, long maxAcount) {\n        return aMin * cm + maxAcount * cf;\n    }\n\n    private void sort(long[] a) {\n        Map<Long, Integer> b = new TreeMap<>();\n        for(long x: a) {\n            Integer cur = b.get(x);\n            if(cur == null) {\n                b.put(x, 1);\n            } else {\n                b.put(x, cur+1);\n            }\n        }\n        int p = 0;\n        for(Map.Entry<Long, Integer> e: b.entrySet()) {\n            long key = e.getKey();\n            int s = e.getValue();\n            for(int i=0;i<s;i++) {\n                a[p] = key;\n                p++;\n            }\n        }\n    }\n\n    private long[] longarr() throws IOException {\n        return longarr(rd.readLine());\n    }\n\n    private long[] longarr(String s) {\n        String[] q = split(s);\n        int n = q.length;\n        long[] a = new long[n];\n        for(int i=0;i<n;i++) {\n            a[i] = Long.parseLong(q[i]);\n        }\n        return a;\n    }\n\n    public String[] split(String s) {\n        if(s == null) {\n            return new String[0];\n        }\n        int n = s.length();\n        int start = -1;\n        int end = 0;\n        int sp = 0;\n        boolean lastWhitespace = true;\n        for(int i=0;i<n;i++) {\n            char c = s.charAt(i);\n            if(isWhitespace(c)) {\n                lastWhitespace = true;\n            } else {\n                if(lastWhitespace) {\n                    sp++;\n                }\n                if(start == -1) {\n                    start = i;\n                }\n                end = i;\n                lastWhitespace = false;\n            }\n        }\n        if(start == -1) {\n            return new String[0];\n        }\n        String[] res = new String[sp];\n        int last = start;\n        int x = 0;\n        lastWhitespace = true;\n        for(int i=start;i<=end;i++) {\n            char c = s.charAt(i);\n            boolean w = isWhitespace(c);\n            if(w && !lastWhitespace) {\n                res[x++] = s.substring(last,i);\n            } else if(!w && lastWhitespace) {\n                last = i;\n            }\n            lastWhitespace = w;\n        }\n        res[x] = s.substring(last,end+1);\n        return res;\n    }\n\n    private boolean isWhitespace(char c) {\n        return c==' ' || c=='\\t';\n    }\n\n    private static void out(Object x) {\n        System.out.println(x);\n    }\n\n    public static void main(String[] args) throws IOException {\n        new ProblemB2();\n    }\n}\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskB {\n\t\tpublic void solve(int testNumber, FastScanner in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tlong A = in.nextInt();\n\t\t\tlong cf = in.nextInt();\n\t\t\tlong cm = in.nextInt();\n\t\t\tlong m = in.nextLong();\n\t\t\tSkill[] a = new Skill[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = new Skill();\n\t\t\t\ta[i].val = in.nextInt();\n\t\t\t\ta[i].id = i;\n\t\t\t}\n\t\t\tArrays.sort(a);\n\t\t\tlong[] s = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\ts[i] += s[i - 1];\n\t\t\t\t}\n\t\t\t\ts[i] += a[i].val;\n\t\t\t}\n\t\t\tlong bestSum = 0;\n\t\t\tint bestLast = -1;\n\t\t\tint bestMin = -1;\n\t\t\tfor (int lastMax = n; lastMax >= 0; lastMax--) {\n\t\t\t\tlong have = getSum(s, lastMax, n - 1);\n\t\t\t\tlong need = A * (n - lastMax);\n\t\t\t\tlong m1 = m - Math.max(0, need - have);\n\t\t\t\tif (m1 < 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint left = 0;\n\t\t\t\tint right = (int) (A + 1);\n\t\t\t\twhile (right - left > 1) {\n\t\t\t\t\tint mid = (left + right) / 2;\n\t\t\t\t\tSkill t = new Skill();\n\t\t\t\t\tt.val = mid;\n\t\t\t\t\tt.id = n;\n\t\t\t\t\tint j = Arrays.binarySearch(a, t);\n\t\t\t\t\tif (j < 0) {\n\t\t\t\t\t\tj = -j - 2;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new AssertionError();\n\t\t\t\t\t}\n\t\t\t\t\tj = Math.min(j, lastMax - 1);\n\t\t\t\t\thave = getSum(s, 0, j);\n\t\t\t\t\tneed = mid * (long) (j + 1);\n\t\t\t\t\tlong m2 = m1 - Math.max(0, need - have);\n\t\t\t\t\tif (m2 < 0) {\n\t\t\t\t\t\tright = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tleft = mid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlong curSum = left * cm + (n - lastMax) * cf;\n\t\t\t\tif (left == A) {\n\t\t\t\t\tcurSum = A * cm + n * cf;\n\t\t\t\t}\n\t\t\t\tif (bestLast < 0 || bestSum < curSum) {\n\t\t\t\t\tbestSum = curSum;\n\t\t\t\t\tbestLast = lastMax;\n\t\t\t\t\tbestMin = left;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (bestLast < 0) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tfor (int i = n - 1; i >= bestLast; i--) {\n\t\t\t\tm -= A - a[i].val;\n\t\t\t\ta[i].val = (int) A;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (a[i].val < bestMin) {\n\t\t\t\t\tm -= bestMin - a[i].val;\n\t\t\t\t\ta[i].val = bestMin;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (m < 0) {\n\t\t\t\tthrow new AssertionError();\n\t\t\t}\n\t\t\tout.println(bestSum);\n\t\t\tint[] r = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tr[a[i].id] = a[i].val;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (i > 0) {\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\tout.print(r[i]);\n\t\t\t}\n\t\t\tout.println();\n\t\t}\n\n\t\tprivate long getSum(long[] s, int l, int r) {\n\t\t\tif (l > r) {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\treturn s[r] - (l == 0 ? 0 : s[l - 1]);\n\t\t}\n\n\t\tclass Skill implements Comparable<Skill> {\n\t\t\tint val;\n\t\t\tint id;\n\n\t\t\tpublic int compareTo(Skill o) {\n\t\t\t\tif (val != o.val) {\n\t\t\t\t\treturn val - o.val;\n\t\t\t\t}\n\t\t\t\treturn id - o.id;\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic class FastScanner {\n\t\tprivate BufferedReader in;\n\t\tprivate StringTokenizer st;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tString rl = in.readLine();\n\t\t\t\t\tif (rl == null) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tst = new StringTokenizer(rl);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t}\n}\n\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Egor Kulikov (egor@egork.net)\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tOutputWriter out = new OutputWriter(outputStream);\n\t\tTaskB solver = new TaskB();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class TaskB {\n\t\tpublic void solve(int testNumber, InputReader in, OutputWriter out) {\n\t\t\tint n = in.readInt();\n\t\t\tint A = in.readInt();\n\t\t\tint cf = in.readInt();\n\t\t\tint cm = in.readInt();\n\t\t\tlong m = in.readLong();\n\t\t\tint[] a = IOUtils.readIntArray(in, n);\n\t\t\tlong total = 0;\n\t\t\tfor (int i : a) {\n\t\t\t\ttotal += A - i;\n\t\t\t}\n\t\t\tif (total <= m) {\n\t\t\t\tout.printLine((long) cf * n + (long) cm * A);\n\t\t\t\tout.printLine(ArrayUtils.createArray(n, A));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint[] order = ArrayUtils.order(a);\n\t\t\tint cMin = 0;\n\t\t\tint price = 0;\n\t\t\tint cFull = ArrayUtils.count(a, A);\n\t\t\tlong current = (long) cFull * cf;\n\t\t\tfor (int i : order) {\n\t\t\t\tlong delta = (long) (a[i] - cMin) * price;\n\t\t\t\tif (delta <= m) {\n\t\t\t\t\tm -= delta;\n\t\t\t\t\tcurrent += (long) (a[i] - cMin) * cm;\n\t\t\t\t\tcMin = a[i];\n\t\t\t\t\tprice++;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcMin += m / price;\n\t\t\tcurrent += m / price * cm;\n\t\t\tm %= price;\n\t\t\tint bestFull = cFull;\n\t\t\tint bestMin = cMin;\n\t\t\tlong best = current;\n\t\t\tfor (int i = n - 1; i >= 0; i--) {\n\t\t\t\tint j = order[i];\n\t\t\t\tif (a[j] == A) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint delta = A - Math.max(cMin, a[j]);\n\t\t\t\tm -= delta;\n\t\t\t\tcurrent += cf;\n\t\t\t\tprice = Math.min(price, i);\n\t\t\t\tcFull++;\n\t\t\t\twhile (m < 0) {\n\t\t\t\t\tif (price == 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tint floor = a[order[price - 1]];\n\t\t\t\t\tlong t = (long) (cMin - floor) * price;\n\t\t\t\t\tif (t <= -m) {\n\t\t\t\t\t\tm += t;\n\t\t\t\t\t\tcurrent -= (long) (cMin - floor) * cm;\n\t\t\t\t\t\tcMin = floor;\n\t\t\t\t\t\tprice--;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlong qty = (-m + price - 1) / price;\n\t\t\t\t\t\tm += qty * price;\n\t\t\t\t\t\tcurrent -= qty * cm;\n\t\t\t\t\t\tcMin -= qty;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (m < 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (current > best) {\n\t\t\t\t\tbest = current;\n\t\t\t\t\tbestFull = cFull;\n\t\t\t\t\tbestMin = cMin;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.printLine(best);\n\t\t\tfor (int i = n - 1; i >= n - bestFull; i--) {\n\t\t\t\tm -= A - a[order[i]];\n\t\t\t\ta[order[i]] = A;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = Math.max(a[i], bestMin);\n\t\t\t}\n\t\t\tout.printLine(a);\n\t\t}\n\n\t}\n\n\tstatic abstract class IntAbstractStream implements IntStream {\n\n\t\tpublic String toString() {\n\t\t\tStringBuilder builder = new StringBuilder();\n\t\t\tboolean first = true;\n\t\t\tfor (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n\t\t\t\tif (first) {\n\t\t\t\t\tfirst = false;\n\t\t\t\t} else {\n\t\t\t\t\tbuilder.append(' ');\n\t\t\t\t}\n\t\t\t\tbuilder.append(it.value());\n\t\t\t}\n\t\t\treturn builder.toString();\n\t\t}\n\n\n\t\tpublic boolean equals(Object o) {\n\t\t\tif (!(o instanceof IntStream)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tIntStream c = (IntStream) o;\n\t\t\tIntIterator it = intIterator();\n\t\t\tIntIterator jt = c.intIterator();\n\t\t\twhile (it.isValid() && jt.isValid()) {\n\t\t\t\tif (it.value() != jt.value()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\tit.advance();\n\t\t\t\tjt.advance();\n\t\t\t}\n\t\t\treturn !it.isValid() && !jt.isValid();\n\t\t}\n\n\n\t\tpublic int hashCode() {\n\t\t\tint result = 0;\n\t\t\tfor (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n\t\t\t\tresult *= 31;\n\t\t\t\tresult += it.value();\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t}\n\n\tstatic interface IntReversableCollection extends IntCollection {\n\t}\n\n\tstatic class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int readInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long readLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn isWhitespace(c);\n\t\t}\n\n\t\tpublic static boolean isWhitespace(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\n\t\t}\n\n\t}\n\n\tstatic interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n\t\tpublic IntIterator intIterator();\n\n\t\tdefault public Iterator<Integer> iterator() {\n\t\t\treturn new Iterator<Integer>() {\n\t\t\t\tprivate IntIterator it = intIterator();\n\n\t\t\t\tpublic boolean hasNext() {\n\t\t\t\t\treturn it.isValid();\n\t\t\t\t}\n\n\t\t\t\tpublic Integer next() {\n\t\t\t\t\tint result = it.value();\n\t\t\t\t\tit.advance();\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t\tdefault public int compareTo(IntStream c) {\n\t\t\tIntIterator it = intIterator();\n\t\t\tIntIterator jt = c.intIterator();\n\t\t\twhile (it.isValid() && jt.isValid()) {\n\t\t\t\tint i = it.value();\n\t\t\t\tint j = jt.value();\n\t\t\t\tif (i < j) {\n\t\t\t\t\treturn -1;\n\t\t\t\t} else if (i > j) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t\tit.advance();\n\t\t\t\tjt.advance();\n\t\t\t}\n\t\t\tif (it.isValid()) {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\tif (jt.isValid()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\n\t\tdefault public int count(int value) {\n\t\t\tint result = 0;\n\t\t\tfor (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n\t\t\t\tif (it.value() == value) {\n\t\t\t\t\tresult++;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t}\n\n\tstatic class Sorter {\n\t\tprivate static final int INSERTION_THRESHOLD = 16;\n\n\t\tprivate Sorter() {\n\t\t}\n\n\t\tpublic static void sort(IntList list, IntComparator comparator) {\n\t\t\tquickSort(list, 0, list.size() - 1, (Integer.bitCount(Integer.highestOneBit(list.size()) - 1) * 5) >> 1, comparator);\n\t\t}\n\n\t\tprivate static void quickSort(IntList list, int from, int to, int remaining, IntComparator comparator) {\n\t\t\tif (to - from < INSERTION_THRESHOLD) {\n\t\t\t\tinsertionSort(list, from, to, comparator);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (remaining == 0) {\n\t\t\t\theapSort(list, from, to, comparator);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tremaining--;\n\t\t\tint pivotIndex = (from + to) >> 1;\n\t\t\tint pivot = list.get(pivotIndex);\n\t\t\tlist.swap(pivotIndex, to);\n\t\t\tint storeIndex = from;\n\t\t\tint equalIndex = to;\n\t\t\tfor (int i = from; i < equalIndex; i++) {\n\t\t\t\tint value = comparator.compare(list.get(i), pivot);\n\t\t\t\tif (value < 0) {\n\t\t\t\t\tlist.swap(storeIndex++, i);\n\t\t\t\t} else if (value == 0) {\n\t\t\t\t\tlist.swap(--equalIndex, i--);\n\t\t\t\t}\n\t\t\t}\n\t\t\tquickSort(list, from, storeIndex - 1, remaining, comparator);\n\t\t\tfor (int i = equalIndex; i <= to; i++) {\n\t\t\t\tlist.swap(storeIndex++, i);\n\t\t\t}\n\t\t\tquickSort(list, storeIndex, to, remaining, comparator);\n\t\t}\n\n\t\tprivate static void heapSort(IntList list, int from, int to, IntComparator comparator) {\n\t\t\tfor (int i = (to + from - 1) >> 1; i >= from; i--) {\n\t\t\t\tsiftDown(list, i, to, comparator, from);\n\t\t\t}\n\t\t\tfor (int i = to; i > from; i--) {\n\t\t\t\tlist.swap(from, i);\n\t\t\t\tsiftDown(list, from, i - 1, comparator, from);\n\t\t\t}\n\t\t}\n\n\t\tprivate static void siftDown(IntList list, int start, int end, IntComparator comparator, int delta) {\n\t\t\tint value = list.get(start);\n\t\t\twhile (true) {\n\t\t\t\tint child = ((start - delta) << 1) + 1 + delta;\n\t\t\t\tif (child > end) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tint childValue = list.get(child);\n\t\t\t\tif (child + 1 <= end) {\n\t\t\t\t\tint otherValue = list.get(child + 1);\n\t\t\t\t\tif (comparator.compare(otherValue, childValue) > 0) {\n\t\t\t\t\t\tchild++;\n\t\t\t\t\t\tchildValue = otherValue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (comparator.compare(value, childValue) >= 0) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tlist.swap(start, child);\n\t\t\t\tstart = child;\n\t\t\t}\n\t\t}\n\n\t\tprivate static void insertionSort(IntList list, int from, int to, IntComparator comparator) {\n\t\t\tfor (int i = from + 1; i <= to; i++) {\n\t\t\t\tint value = list.get(i);\n\t\t\t\tfor (int j = i - 1; j >= from; j--) {\n\t\t\t\t\tif (comparator.compare(list.get(j), value) <= 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tlist.swap(j, j + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class Range {\n\t\tpublic static IntList range(int from, int to) {\n\t\t\tint[] result = new int[Math.abs(from - to)];\n\t\t\tint current = from;\n\t\t\tif (from <= to) {\n\t\t\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\t\t\tresult[i] = current++;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\t\t\tresult[i] = current--;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new IntArray(result);\n\t\t}\n\n\t}\n\n\tstatic class ArrayUtils {\n\t\tpublic static int[] range(int from, int to) {\n\t\t\treturn Range.range(from, to).toArray();\n\t\t}\n\n\t\tpublic static int[] createOrder(int size) {\n\t\t\treturn range(0, size);\n\t\t}\n\n\t\tpublic static int[] sort(int[] array, IntComparator comparator) {\n\t\t\treturn sort(array, 0, array.length, comparator);\n\t\t}\n\n\t\tpublic static int[] sort(int[] array, int from, int to, IntComparator comparator) {\n\t\t\tif (from == 0 && to == array.length)\n\t\t\t\tnew IntArray(array).sort(comparator);\n\t\t\telse\n\t\t\t\tnew IntArray(array).subList(from, to).sort(comparator);\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic static int[] order(final int[] array) {\n\t\t\treturn sort(createOrder(array.length), new IntComparator() {\n\t\t\t\tpublic int compare(int first, int second) {\n\t\t\t\t\tif (array[first] < array[second])\n\t\t\t\t\t\treturn -1;\n\t\t\t\t\tif (array[first] > array[second])\n\t\t\t\t\t\treturn 1;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\tpublic static int count(int[] array, int value) {\n\t\t\treturn new IntArray(array).count(value);\n\t\t}\n\n\t\tpublic static int[] createArray(int count, int value) {\n\t\t\tint[] array = new int[count];\n\t\t\tArrays.fill(array, value);\n\t\t\treturn array;\n\t\t}\n\n\t}\n\n\tstatic class IOUtils {\n\t\tpublic static int[] readIntArray(InputReader in, int size) {\n\t\t\tint[] array = new int[size];\n\t\t\tfor (int i = 0; i < size; i++)\n\t\t\t\tarray[i] = in.readInt();\n\t\t\treturn array;\n\t\t}\n\n\t}\n\n\tstatic interface IntCollection extends IntStream {\n\t\tpublic int size();\n\n\t\tdefault public void add(int value) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\tdefault public int[] toArray() {\n\t\t\tint size = size();\n\t\t\tint[] array = new int[size];\n\t\t\tint i = 0;\n\t\t\tfor (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n\t\t\t\tarray[i++] = it.value();\n\t\t\t}\n\t\t\treturn array;\n\t\t}\n\n\t\tdefault public IntCollection addAll(IntStream values) {\n\t\t\tfor (IntIterator it = values.intIterator(); it.isValid(); it.advance()) {\n\t\t\t\tadd(it.value());\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t}\n\n\tstatic class IntArrayList extends IntAbstractStream implements IntList {\n\t\tprivate int size;\n\t\tprivate int[] data;\n\n\t\tpublic IntArrayList() {\n\t\t\tthis(3);\n\t\t}\n\n\t\tpublic IntArrayList(int capacity) {\n\t\t\tdata = new int[capacity];\n\t\t}\n\n\t\tpublic IntArrayList(IntCollection c) {\n\t\t\tthis(c.size());\n\t\t\taddAll(c);\n\t\t}\n\n\t\tpublic IntArrayList(IntStream c) {\n\t\t\tthis();\n\t\t\tif (c instanceof IntCollection) {\n\t\t\t\tensureCapacity(((IntCollection) c).size());\n\t\t\t}\n\t\t\taddAll(c);\n\t\t}\n\n\t\tpublic IntArrayList(IntArrayList c) {\n\t\t\tsize = c.size();\n\t\t\tdata = c.data.clone();\n\t\t}\n\n\t\tpublic IntArrayList(int[] arr) {\n\t\t\tsize = arr.length;\n\t\t\tdata = arr.clone();\n\t\t}\n\n\t\tpublic int size() {\n\t\t\treturn size;\n\t\t}\n\n\t\tpublic int get(int at) {\n\t\t\tif (at >= size) {\n\t\t\t\tthrow new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size);\n\t\t\t}\n\t\t\treturn data[at];\n\t\t}\n\n\t\tprivate void ensureCapacity(int capacity) {\n\t\t\tif (data.length >= capacity) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tcapacity = Math.max(2 * data.length, capacity);\n\t\t\tdata = Arrays.copyOf(data, capacity);\n\t\t}\n\n\t\tpublic void addAt(int index, int value) {\n\t\t\tensureCapacity(size + 1);\n\t\t\tif (index > size || index < 0) {\n\t\t\t\tthrow new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n\t\t\t}\n\t\t\tif (index != size) {\n\t\t\t\tSystem.arraycopy(data, index, data, index + 1, size - index);\n\t\t\t}\n\t\t\tdata[index] = value;\n\t\t\tsize++;\n\t\t}\n\n\t\tpublic void removeAt(int index) {\n\t\t\tif (index >= size || index < 0) {\n\t\t\t\tthrow new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n\t\t\t}\n\t\t\tif (index != size - 1) {\n\t\t\t\tSystem.arraycopy(data, index + 1, data, index, size - index - 1);\n\t\t\t}\n\t\t\tsize--;\n\t\t}\n\n\t\tpublic void set(int index, int value) {\n\t\t\tif (index >= size) {\n\t\t\t\tthrow new IndexOutOfBoundsException(\"at = \" + index + \", size = \" + size);\n\t\t\t}\n\t\t\tdata[index] = value;\n\t\t}\n\n\t}\n\n\tstatic class IntArray extends IntAbstractStream implements IntList {\n\t\tprivate int[] data;\n\n\t\tpublic IntArray(int[] arr) {\n\t\t\tdata = arr;\n\t\t}\n\n\t\tpublic int size() {\n\t\t\treturn data.length;\n\t\t}\n\n\t\tpublic int get(int at) {\n\t\t\treturn data[at];\n\t\t}\n\n\t\tpublic void addAt(int index, int value) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\tpublic void removeAt(int index) {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\tpublic void set(int index, int value) {\n\t\t\tdata[index] = value;\n\t\t}\n\n\t}\n\n\tstatic interface IntComparator {\n\t\tpublic int compare(int first, int second);\n\n\t}\n\n\tstatic interface IntIterator {\n\t\tpublic int value() throws NoSuchElementException;\n\n\t\tpublic boolean advance();\n\n\t\tpublic boolean isValid();\n\n\t}\n\n\tstatic class OutputWriter {\n\t\tprivate final PrintWriter writer;\n\n\t\tpublic OutputWriter(OutputStream outputStream) {\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t\t}\n\n\t\tpublic OutputWriter(Writer writer) {\n\t\t\tthis.writer = new PrintWriter(writer);\n\t\t}\n\n\t\tpublic void print(int[] array) {\n\t\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\twriter.print(' ');\n\t\t\t\twriter.print(array[i]);\n\t\t\t}\n\t\t}\n\n\t\tpublic void printLine(int[] array) {\n\t\t\tprint(array);\n\t\t\twriter.println();\n\t\t}\n\n\t\tpublic void close() {\n\t\t\twriter.close();\n\t\t}\n\n\t\tpublic void printLine(long i) {\n\t\t\twriter.println(i);\n\t\t}\n\n\t}\n\n\tstatic interface IntList extends IntReversableCollection {\n\t\tpublic abstract int get(int index);\n\n\t\tpublic abstract void set(int index, int value);\n\n\t\tpublic abstract void addAt(int index, int value);\n\n\t\tpublic abstract void removeAt(int index);\n\n\t\tdefault public void swap(int first, int second) {\n\t\t\tif (first == second) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tint temp = get(first);\n\t\t\tset(first, get(second));\n\t\t\tset(second, temp);\n\t\t}\n\n\t\tdefault public IntIterator intIterator() {\n\t\t\treturn new IntIterator() {\n\t\t\t\tprivate int at;\n\t\t\t\tprivate boolean removed;\n\n\t\t\t\tpublic int value() {\n\t\t\t\t\tif (removed) {\n\t\t\t\t\t\tthrow new IllegalStateException();\n\t\t\t\t\t}\n\t\t\t\t\treturn get(at);\n\t\t\t\t}\n\n\t\t\t\tpublic boolean advance() {\n\t\t\t\t\tat++;\n\t\t\t\t\tremoved = false;\n\t\t\t\t\treturn isValid();\n\t\t\t\t}\n\n\t\t\t\tpublic boolean isValid() {\n\t\t\t\t\treturn !removed && at < size();\n\t\t\t\t}\n\n\t\t\t\tpublic void remove() {\n\t\t\t\t\tremoveAt(at);\n\t\t\t\t\tat--;\n\t\t\t\t\tremoved = true;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\n\t\tdefault public void add(int value) {\n\t\t\taddAt(size(), value);\n\t\t}\n\n\t\tdefault public IntList sort(IntComparator comparator) {\n\t\t\tSorter.sort(this, comparator);\n\t\t\treturn this;\n\t\t}\n\n\t\tdefault public IntList subList(final int from, final int to) {\n\t\t\treturn new IntList() {\n\t\t\t\tprivate final int shift;\n\t\t\t\tprivate final int size;\n\n\t\t\t\t{\n\t\t\t\t\tif (from < 0 || from > to || to > IntList.this.size()) {\n\t\t\t\t\t\tthrow new IndexOutOfBoundsException(\"from = \" + from + \", to = \" + to + \", size = \" + size());\n\t\t\t\t\t}\n\t\t\t\t\tshift = from;\n\t\t\t\t\tsize = to - from;\n\t\t\t\t}\n\n\t\t\t\tpublic int size() {\n\t\t\t\t\treturn size;\n\t\t\t\t}\n\n\t\t\t\tpublic int get(int at) {\n\t\t\t\t\tif (at < 0 || at >= size) {\n\t\t\t\t\t\tthrow new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n\t\t\t\t\t}\n\t\t\t\t\treturn IntList.this.get(at + shift);\n\t\t\t\t}\n\n\t\t\t\tpublic void addAt(int index, int value) {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\tpublic void removeAt(int index) {\n\t\t\t\t\tthrow new UnsupportedOperationException();\n\t\t\t\t}\n\n\t\t\t\tpublic void set(int at, int value) {\n\t\t\t\t\tif (at < 0 || at >= size) {\n\t\t\t\t\t\tthrow new IndexOutOfBoundsException(\"at = \" + at + \", size = \" + size());\n\t\t\t\t\t}\n\t\t\t\t\tIntList.this.set(at + shift, value);\n\t\t\t\t}\n\n\t\t\t\tpublic IntList compute() {\n\t\t\t\t\treturn new IntArrayList(this);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\n\t}\n}\n\n", "label": 3}
{"src": "//package codeforces;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\n/**\n * Created by nitin.s on 27/03/16.\n */\npublic class Skills {\n    static class O implements Comparable<O> {\n        int id;\n        int value;\n        int nValue;\n\n        public O(int id, int value) {\n            this.id = id;\n            this.value = value;\n        }\n\n        @Override\n        public int compareTo(O o) {\n            return Integer.compare(value, o.value);\n        }\n    }\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int A = in.nextInt();\n        int cf = in.nextInt();\n        int cm = in.nextInt();\n        long m = in.nextLong();\n        O[] a = new O[n];\n        for(int i = 0; i < n; ++i) {\n            a[i] = new O(i, in.nextInt());\n        }\n        Arrays.sort(a);\n        long[] sum = new long[n + 1];\n        for(int i = 0; i < n; ++i) {\n            sum[i + 1] = sum[i] + a[i].value;\n        }\n        long best = -1;\n        int bestCntA = -1;\n        int minValue = -1;\n        for(int cntA = 0; cntA <= n; ++cntA) {\n            long cur = cf * cntA;\n            int tmpMax = 0;\n            if(cntA == n) {\n                cur += A * 1L * cm;\n            } else {\n                int left = 1, right = n - cntA + 1;\n                while(right - left > 1) {\n                    int mid = (left + right) >> 1;\n                    long need = a[mid - 1].value * 1L * mid;\n                    long have = sum[mid];\n                    if(need - have > m) {\n                        right = mid;\n                    } else {\n                        left = mid;\n                    }\n                }\n                long need = a[left - 1].value * 1L * left;\n                long have = sum[left];\n                long more = m - (need - have);\n                long maxCan = a[left - 1].value +  more / left;\n                maxCan = Math.min(maxCan, A);\n                tmpMax = (int) maxCan;\n                cur += maxCan * cm;\n            }\n            if(cur > best) {\n                best = cur;\n                bestCntA = cntA;\n                minValue = tmpMax;\n            }\n            if(cntA == n) {\n                break;\n            }\n            m -= A - a[n - 1 - cntA].value;\n            if(m < 0) {\n                break;\n            }\n        }\n        for(int i = 0; i < bestCntA; ++i) {\n            a[n - 1 - i].nValue = A;\n        }\n        for(int i = 0; i < n; ++i) {\n            if(a[i].nValue != A) {\n                a[i].nValue = Math.max(a[i].value, minValue);\n            }\n        }\n        Arrays.sort(a, new Comparator<O>() {\n            @Override\n            public int compare(O o1, O o2) {\n                return Integer.compare(o1.id, o2.id);\n            }\n        });\n        System.out.println(best);\n        for(O o : a) {\n            System.out.print(o.nValue +  \" \");\n        }\n    }\n}\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author AlexFetisov\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB_339 solver = new TaskB_339();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB_339 {\n        int maxValue;\n        int L;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int maxLevel = in.nextInt();\n            maxValue = maxLevel;\n            int cMax = in.nextInt();\n            int cMin = in.nextInt();\n            long money = in.nextLong();\n\n            Item[] a = new Item[n];\n            int countMax = 0;\n            for (int i = 0; i < n; ++i) {\n                int x = in.nextInt();\n                if (x == maxLevel) {\n                    ++countMax;\n                }\n                a[i] = new Item(x, i);\n            }\n            if (countMax == n) {\n                out.println(cMax * 1L * countMax + a[0].a * 1L * cMin);\n                for (Item i : a) {\n                    out.print(i.a + \" \");\n                }\n                out.println();\n                return;\n            }\n\n            Arrays.sort(a);\n            long needToSpendOnMax = 0;\n\n            int ptr = 0;\n            long[] S = new long[n];\n            for (int i = 0; i < n; ++i) {\n                S[i] = a[i].a;\n                if (i > 0) S[i] += S[i - 1];\n            }\n            for (; ptr < n - countMax; ++ptr) {\n                if (a[ptr].a * 1L * (ptr + 1) - getSum(0, ptr, S) <= money) {\n                    continue;\n                } else {\n                    break;\n                }\n            }\n            --ptr;\n\n            long res = calc(a[ptr].a, countMax, cMin, cMax, getSum(0, ptr, S), money, ptr);\n            int bestMax = countMax, bestLeft = ptr;\n            int bestLevel = L;\n\n            for (int cm = 1 + countMax; cm <= n; ++cm) {\n                needToSpendOnMax += (maxLevel - a[n - cm].a);\n                if (needToSpendOnMax > money) {\n                    break;\n                }\n                long moneyLeft = money - needToSpendOnMax;\n                while (ptr >= n - cm) {\n                    --ptr;\n                }\n                while (ptr >= 0 && a[ptr].a * 1L * (ptr + 1) - getSum(0, ptr, S) > moneyLeft) {\n                    --ptr;\n                }\n                long newRes;\n                if (ptr < 0) {\n                    newRes = cMax * 1L * cm + maxLevel * 1L * cMin;\n                    L = 0;\n                } else {\n                    newRes = calc(a[ptr].a, cm, cMin, cMax, getSum(0, ptr, S), moneyLeft, ptr);\n                }\n                if (res < newRes) {\n                    res = newRes;\n                    bestMax = cm;\n                    bestLeft = ptr;\n                    bestLevel = L;\n                }\n            }\n            for (int i = 0; i < bestMax; ++i) {\n                a[n - 1 - i].a = maxLevel;\n            }\n            for (int i = bestLeft; i >= 0; --i) {\n                a[i].a = bestLevel;\n            }\n            int[] r = new int[n];\n            for (Item i : a) {\n                r[i.id] = i.a;\n            }\n            out.println(res);\n            out.println(ArrayUtils.toString(r));\n        }\n\n        private long calc(int minValue, int cm, int cMin, int cMax, long sum, long moneyLeft, int ptr) {\n            if (ptr < 0) {\n                return cMax * 1L * cm;\n            }\n            moneyLeft -= (minValue * 1L * (ptr + 1) - sum);\n            minValue += (moneyLeft / (ptr + 1));\n            minValue = Math.min(minValue, maxValue);\n            L = minValue;\n            return cMax * 1L * cm + minValue * 1L * cMin;\n        }\n\n        private long getSum(int left, int right, long[] s) {\n            if (left < 0) return 0;\n            if (left == 0) return s[right];\n            return s[right] - s[left - 1];\n        }\n\n        class Item implements Comparable<Item> {\n            int a;\n            int id;\n\n            public Item(int a, int id) {\n                this.a = a;\n                this.id = id;\n            }\n\n\n            public int compareTo(Item o) {\n                if (a != o.a) return Integer.compare(a, o.a);\n                return Integer.compare(id, o.id);\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer stt;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public String nextString() {\n            while (stt == null || !stt.hasMoreTokens()) {\n                stt = new StringTokenizer(nextLine());\n            }\n            return stt.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextString());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextString());\n        }\n\n    }\n\n    static class ArrayUtils {\n        public static String toString(int[] a) {\n            StringBuilder result = new StringBuilder(\"\");\n            for (int x : a) result.append(x).append(' ');\n            return result.substring(0, result.length() - 1);\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\n\npublic class Main {\n    class Node implements Comparable<Node> {\n        long val;\n        int id;\n\n        @Override\n        public int compareTo(Node o) {\n            // TODO Auto-generated method stub\n            if (val < o.val) {\n                return -1;\n            } else if (val == o.val) {\n                return 0;\n            } else {\n                return 1;\n            }\n        }\n\n    }\n\n    int n;\n    long A, cf, cm;\n    long m;\n    Node[] a;\n    long[] sum;\n    int MIN = 0;\n    int left = 0;\n\n    boolean judge(long mm, long target, int r) {\n        for (int i = 0; i <= r; i++) {\n            if (target > a[i].val) {\n                mm -= (target - a[i].val);\n                if (mm < 0)\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    long calc(int pos) {\n        long mm = m - sum[pos];\n        long l = a[0].val;\n        long r = A;\n        long res = 0;\n        while (l <= r) {\n            long mid = (l + r) >> 1;\n            if (judge(mm, mid, pos - 1)) {\n                l = mid + 1;\n                res = Math.max(res, (n - pos) * cf + mid * cm);\n                MIN = (int) mid;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return res;\n    }\n\n    //ternary search\n    long Search(int l, int r) {\n        left = l;\n        int mid_left;\n        int mid_right;\n        long res = 0;\n        while (l +64<= r) {\n            int d = (r - l + 1) / 3;\n            mid_left = l + d;\n            mid_right = r - d;\n\n            int oldMIN = MIN;\n            long ansl = calc(mid_left);\n            long lmin = MIN;\n            long ansr = calc(mid_right);\n            long rmin = MIN;\n            if (ansl < ansr) {\n                l = mid_left + 1;\n                if(ansr>res){\n                    res = ansr;\n                    left = mid_right;\n                    MIN = (int) rmin;\n                }else{\n                    MIN =oldMIN;\n                }\n            } else {\n                r = mid_right - 1;\n                if(ansl>res){\n                    res = ansl;\n                    left = mid_left;\n                    MIN = (int) lmin;\n                }else{\n                    MIN =oldMIN;\n                }\n            }\n        }\n\n        for (int i = l; i <= r; i++) {\n            int pMIN = MIN;\n            long ans = calc(i);\n            if (ans > res) {\n                res = ans;\n                left = i;\n            }else{\n                MIN = pMIN;\n            }\n        }\n\n        return res;\n    }\n\n    void solve() {\n        FastScanner scan = new FastScanner();\n        n = scan.nextInt();\n        A = scan.nextLong();\n        cf = scan.nextLong();\n        cm = scan.nextLong();\n        m = scan.nextLong();\n        a = new Node[n + 1];\n        sum = new long[n + 1];\n\n        for (int i = 0; i < n; i++) {\n            a[i] = new Node();\n            a[i].val = scan.nextLong();\n            a[i].id = i;\n        }\n\n        Arrays.sort(a, 0, n);\n        int leftMost = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            sum[i] = sum[i + 1] + (A - a[i].val);\n            if (sum[i] > m) {\n                leftMost = i + 1;\n                break;\n            }\n        }\n        long ans = Search(leftMost, n);\n        long[] ansA = new long[n + 1];\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < n; i++) {\n            int id = a[i].id;\n            ansA[id] = a[i].val;\n            \n            if (i >= left) {\n                ansA[id] = A;\n            }else if (ansA[id] < MIN) {\n                ansA[id] = MIN;\n            }\n        }\n\n        out.println(ans);\n        for (int i = 0; i < n; i++) {\n            out.print(ansA[i] + \" \");\n        }\n        out.println();\n\n        out.flush();\n    }\n\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public boolean EOF() {\n            if (st != null && st.hasMoreTokens()) {\n                return false;\n            } else {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (line == null)\n                    return true;\n                st = new StringTokenizer(line);\n                return false;\n            }\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Div339C {\n    static class N implements Comparable<N> {\n        long val;\n        int index;\n\n        N(int val, int i) {\n            this.val = val;\n            index = i;\n        }\n\n        @Override\n        public int compareTo(N o) {\n            return Long.compare(val, o.val);\n        }\n\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        String[] l = bf.readLine().split(\" \");\n        int n = Integer.parseInt(l[0]);\n        long N = n;\n        long A = Integer.parseInt(l[1]);\n        long cf = Integer.parseInt(l[2]);\n        long cm = Integer.parseInt(l[3]);\n        long m = Long.parseLong(l[4]);\n        N[] nums = new N[n + 1];\n        l = bf.readLine().split(\" \");\n        nums[0] = new N(0, 0);\n        for (int i = 1; i < nums.length; i++) {\n            nums[i] = new N(Integer.parseInt(l[i - 1]), i);\n        }\n        Arrays.sort(nums);\n        long needToA[] = new long[n + 2];\n        for (int i = n; i >= 0; i--) {\n            needToA[i] += A - nums[i].val;\n            needToA[i] += needToA[i + 1];\n        }\n        long sums[] = new long[n + 1];\n        for (int i = 1; i < sums.length; i++) {\n            sums[i] = sums[i - 1] + nums[i].val;\n        }\n        long lo, hi, mid;\n        int lo2, hi2, mid2, ind;\n        int bestInd = 0;\n        int bestInd2 = n + 1;\n        long bestMin = 0;\n        long best = 0;\n        long left;\n        long c;\n        long costNeeded;\n        for (int i = n + 1; i > 0; i--) {\n            if (needToA[i] > m)\n                break;\n            left = m - needToA[i];\n            lo = ind = 0;\n            hi = A;\n            while (lo + 1 < hi) {\n                mid = (lo + hi) >> 1;\n                lo2 = 0;\n                hi2 = i;\n                while (lo2 + 1 < hi2) {\n                    mid2 = (lo2 + hi2) >> 1;\n                    if (nums[mid2].val <= mid) {\n                        lo2 = mid2;\n                    } else {\n                        hi2 = mid2;\n                    }\n                }\n                costNeeded = lo2 * mid - sums[lo2];\n                if (left >= costNeeded) {\n                    lo = mid;\n                    ind = lo2;\n                } else {\n                    hi = mid;\n                }\n            }\n            costNeeded = ind * lo - sums[ind];\n            if (left >= costNeeded) {\n                c = (n - i + 1) * cf;\n                if (i == 1)\n                    c += A * cm;\n                else\n                    c += lo * cm;\n                if (c > best) {\n                    best = c;\n                    bestMin = lo;\n                    bestInd = ind;\n                    bestInd2 = i;\n                }\n            }\n        }\n        for (int i = bestInd; i > 0; i--) {\n            nums[i].val = bestMin;\n        }\n        for (int i = bestInd2; i < nums.length; i++) {\n            nums[i].val = A;\n        }\n        long ans[] = new long[n + 1];\n        for (int i = 1; i < ans.length; i++) {\n            ans[nums[i].index] = nums[i].val;\n        }\n        StringBuffer sb = new StringBuffer();\n        for (int i = 1; i < ans.length; i++) {\n            sb.append(ans[i] + \" \");\n        }\n        System.out.println(best);\n        System.out.println(sb);\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class R339qB {\n\n\tpublic static void main(String args[]) throws Exception {\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter w = new PrintWriter(System.out);\n\n\t\tint n = in.nextInt();\n\t\tlong A = in.nextLong();\n\t\tlong cf = in.nextInt();\n\t\tlong cm = in.nextInt();\n\t\tlong m = in.nextLong();\n\n\t\tPair p[] = new Pair[n + 2];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tp[i] = new Pair(i, in.nextInt());\n\t\tp[0] = new Pair(0, -1);\n\t\tp[n + 1] = new Pair(n + 1, (int) A + 1);\n\n\t\tArrays.sort(p);\n\n\t\tint a[] = new int[n + 2];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\ta[i] = p[i].val;\n\n\t\tlong pre[] = new long[n + 2];\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tpre[i] = pre[i - 1] + a[i];\n\n\t\tlong suf[] = new long[n + 2];\n\t\tfor (int i = n; i >= 1; i--)\n\t\t\tsuf[i] = suf[i + 1] + a[i];\n\n\t\tlong ans[] = new long[n + 2];\n\t\tlong min[] = new long[n + 2];\n\t\tint bestAns = -1;\n\t\tlong maxAns = -1;\n\n\t\tif (n * A - pre[n] <= m) {\n\t\t\tmaxAns = n * cf + A * cm;\n\t\t\tbestAns = n;\n\t\t\tmin[n] = A;\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong start = 0, end = A + 1;\n\t\t\tint last = n - i;\n\t\t\tlong needed = i * A - suf[n + 1 - i];\n\t\t\tif (needed > m)\n\t\t\t\tbreak;\n\t\t\tlong left = m - needed;\n\t\t\tleft = Math.min(left, m);\n\t\t\twhile (start < end) {\n\t\t\t\tlong mid = (start + end) >> 1;\n\t\t\t\tint ss = 1, ee = last + 1;\n\t\t\t\tint aa = 0;\n\t\t\t\twhile (ss < ee) { // last element smaller than mid\n\t\t\t\t\tint mm = (ss + ee) >> 1;\n\t\t\t\t\tif (a[mm] < mid) {\n\t\t\t\t\t\taa = mm;\n\t\t\t\t\t\tss = mm + 1;\n\t\t\t\t\t} else\n\t\t\t\t\t\tee = mm;\n\t\t\t\t}\n\t\t\t\tif (mid * aa - pre[aa] <= left) {\n\t\t\t\t\tmin[i] = mid;\n\t\t\t\t\tstart = mid + 1;\n\t\t\t\t} else\n\t\t\t\t\tend = mid;\n\t\t\t}\n\t\t\tlong nowAns = i * cf + min[i] * cm;\n\t\t\tif (nowAns > maxAns) {\n\t\t\t\tmaxAns = nowAns;\n\t\t\t\tbestAns = i;\n\t\t\t}\n\t\t}\n\n\t\tw.println(maxAns);\n\n\t\tif (bestAns == -1) {\n\t\t\tbestAns = 0;\n\t\t\tmin[0] = a[1];\n\t\t}\n\n\t\tfor (int i = 1; i <= n - bestAns; i++)\n\t\t\tans[p[i].idx] = Math.max(a[i], min[bestAns]);\n\t\tfor (int i = n - bestAns + 1; i <= n; i++)\n\t\t\tans[p[i].idx] = A;\n\t\tfor (int i = 1; i <= n; i++)\n\t\t\tw.print(ans[i] + \" \");\n\t\tw.println();\n\n\t\tw.close();\n\t}\n\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint idx, val;\n\n\t\tPair(int i, int v) {\n\t\t\tidx = i;\n\t\t\tval = v;\n\t\t}\n\n\t\tpublic int compareTo(Pair o) {\n\t\t\tif (val != o.val)\n\t\t\t\treturn Integer.compare(val, o.val);\n\t\t\treturn Integer.compare(idx, o.idx);\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn idx + \" \" + val;\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int snext() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n}\n", "label": 3}
{"src": "\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class D {\n\t\n\tpublic static class skill implements Comparable{\n\t\tlong v;\n\t\t\n\t\tskill(long a){\n\t\t\tv=a;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Object o){\n\t\t\tif(v  - ((skill)o).v > 0)\n\t\t\treturn 1;\n\t\t\treturn -1;\n\t\t}\n\t\t\n\t}\n\tpublic static long[] maxC,minC;\n\t\n\tpublic static void main(String[] args){\n\t\tScanner in = new Scanner (System.in);\n\t\t\n\t\tint n = in.nextInt();\n\t\tlong A = in.nextLong();\n\t\tlong cf = in.nextLong();\n\t\tlong cm = in.nextLong();\n\t\tlong m = in.nextLong();\n\t\t\n\t\tminC = new long[n];\n\t\tmaxC = new long[n+1];\n\t\t\n\t\tArrayList<skill> orig = new ArrayList<skill>();\n\t\tArrayList<skill> sorted = new ArrayList<skill>();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tskill temp = new skill(in.nextInt());\n\t\t\torig.add(temp);\n\t\t\tsorted.add(temp);\n\t\t}\n\t\tCollections.sort(sorted);\n\t\t//build minC;\n\t\tfor(int i=1;i<n;i++){\n\t\t\tminC[i]=minC[i-1] + i*(sorted.get(i).v-sorted.get(i-1).v);\n\t\t//\tSystem.out.print(minC[i] + \" \" );\n\t\t}\n\t\t//build maxC;\n\t\tfor(int i=n-1;i>-1;i--){\n\t\t\tlong temp = A - sorted.get(i).v;\n\t\t\ttemp+=maxC[i+1];\n\t\t\tmaxC[i] = temp;\n\t\t\t\n\t//\t\tSystem.out.print(temp + \" \");\n\t\t\t\n\t\t}\n\t\t\n\t\tlong maxForce = 0;\n\t\tlong mCount = 0;\n\t\tlong minValue =0;\n\t\tint tMaxCount = 0;\n\t\tint L = n-1;\n\t\t\n\t\tfor(int i= 0;i<n;i++){\n\t\t\tlong toUse=m - maxC[n-i];\n\t\t\tif(toUse <0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\twhile(L > (n-i-1) || minC[L] > toUse) L--;\n\t\t\t\n\t\t\tlong extra = toUse-minC[L];\n\t\t\tlong min = Math.min(A,sorted.get(L).v + extra/(L+1));\n\t\t\tif(i==n)\n\t\t\t\tmin=A;\n\t\t//\tSystem.out.println(i + \" \" + min);\n\t\t\tlong tScore = i*cf + min*cm;\n\t\t\tif(tScore > maxForce){\n\t\t\t\tmaxForce = tScore;\n\t\t\t\tmCount = i;\n\t\t\t\tminValue = min;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(maxC[0] <=m){\n\t\t\tmCount = n;\n\t\t\tminValue =A;\n\t\t\tmaxForce = n*cf + A*cm;\n\t\t}\n\t\t\n\t\tint i = 0;\n\t\twhile(i < n && sorted.get(i).v < minValue){\n\t\t\tsorted.get(i).v=minValue;\n\t\t\ti++;\n\t\t}\n\t\tfor(i =0;i<mCount;i++){\n\t\t\tsorted.get(n-i-1).v=A;\n\t\t}\n\t\tSystem.out.println(maxForce);\n\t\tfor(skill s: orig)\n\t\t\tSystem.out.print(s.v + \" \");\n\t\t\n\t\t\n\t}\n\n}\n", "label": 3}
{"src": "//package CodeForces.Round339;\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * @author iisergeev ilya_sergeev@rgs.ru\n */\npublic class D614 {\n\n    public static void main(String[] args) {\n        sc sc = new sc();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt();\n        long A = sc.nextLong();\n        long cf = sc.nextLong();\n        long cm = sc.nextLong();\n        long m = sc.nextLong();\n\n        Node[] nd = new Node[n];\n        for (int i = 0; i < n; i++) {\n            nd[i] = new Node(i, sc.nextInt());\n        }\n        Arrays.sort(nd);\n\n        long[] a = new long[n];\n        long[] b = new long[n + 1];\n\n        for (int i = 1; i < n; i++) {\n            a[i] = a[i - 1] + i * (nd[i].val - nd[i - 1].val);\n        }\n\n        for (int i = 1; i <= n; i++) {\n            b[i] = b[i - 1] + A - nd[n - i].val;\n        }\n\n        long ans = -1;\n        long minVal = 0;\n        for (int i = 0; i <= n; i++) {\n            if (b[i] > m) break;\n            long val = getMin(a, n - i - 1, m - b[i], A, nd);\n            long t = i * cf + val * cm;\n            if (t > ans) {\n                ans = t;\n                minVal = val;\n            }\n        }\n\n        out.println(ans);\n        for (int i = 0; i < n; i++) {\n            if (nd[i].val < minVal) {\n                m -= (minVal - nd[i].val);\n                nd[i].val = minVal;\n            }\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (A - nd[i].val <= m) {\n                m -= (A - nd[i].val);\n                nd[i].val = A;\n            } else {\n                break;\n            }\n        }\n        long[] res = new long[n];\n        for (Node node : nd) {\n            res[node.key] = node.val;\n        }\n        out.print(res[0]);\n        for (int i = 1; i < n; i++) {\n            out.print(\" \" + res[i]);\n        }\n        out.close();\n    }\n\n    static class Node implements Comparable<Node> {\n        long val;\n        int key;\n\n        public Node(int p, long val) {\n            this.key = p;\n            this.val = val;\n        }\n\n        @Override\n        public int compareTo(Node o) {\n            return (int) (val - o.val);\n        }\n    }\n\n    private static long getMin(long[] a, int lastP, long m, long A, Node[] nd) {\n        if (lastP < 0) return A;\n        long val = 0;\n        if (a[lastP] <= m) {\n            val = (nd[lastP].val + (m - a[lastP]) / (lastP + 1));\n        } else {\n            int st = 0, ed = lastP;\n            while (st + 1 < ed) {\n                int md = (st + ed) / 2;\n                if (a[md] <= m) st = md;\n                else ed = md;\n            }\n            val = (nd[st].val + (m - a[st]) / (st + 1));\n        }\n        return val > A ? A : val;\n    }\n\n    public static class sc {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public sc() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        Integer nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class Skills {\n    void solve() {\n        int n = in.nextInt();\n        long M = in.nextLong(), cf = in.nextLong(), cm = in.nextLong(), m = in.nextLong();\n        long[] A = new long[n];\n        for (int i = 0; i < n; i++) A[i] = in.nextLong();\n\n        // make a copy of A and sort\n        long[] B = new long[n];\n        System.arraycopy(A, 0, B, 0, n);\n        Arrays.sort(B);\n\n        // sum[i] = sum of range [i,n)\n        long[] sum = new long[n + 1];\n        sum[n] = 0;\n        for (int i = n - 1; i >= 0; i--) sum[i] = sum[i + 1] + B[i];\n\n        long ans = 0;\n        int cnt = 0, min = 0;\n        int p = 0;\n        // enum i, the number of maximized elements\n        for (int i = n; i >= 0; i--) {\n            long cost = i * M - sum[n - i];\n            if (cost > m) continue;\n            if (i == n) {\n                if (ans < i * cf + M * cm) {\n                    ans = i * cf + M * cm;\n                    cnt = i;\n                    min = (int) M;\n                    break;\n                }\n            } else {\n                long remaining = m - cost;\n                // make min = B[p] as larger as possible\n                while (p + 1 < n - i && B[p + 1] * (p + 1) - (sum[0] - sum[p + 1]) <= remaining) p++;\n                long v = B[p] + (remaining - (B[p] * p - (sum[0] - sum[p]))) / (1 + p);\n                if (ans < i * cf + v * cm) {\n                    ans = i * cf + v * cm;\n                    cnt = i;\n                    min = (int) v;\n                }\n            }\n        }\n\n        // update skills\n        if (cnt == n) {\n            for (int i = 0; i < n; i++) A[i] = M;\n        } else {\n            long t = B[n - cnt - 1];\n            for (int i = 0; i < n; i++) {\n                if (A[i] > t) {\n                    A[i] = M;\n                    cnt--;\n                }\n            }\n            for (int i = 0; i < n && cnt > 0; i++) {\n                if (A[i] == t) {\n                    A[i] = M;\n                    cnt--;\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                if (A[i] < min) A[i] = min;\n            }\n        }\n\n        out.println(ans);\n        for (int i = 0; i < n; i++) {\n            if (i > 0) out.print(' ');\n            out.print(A[i]);\n        }\n        out.println();\n    }\n\n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new Skills().solve();\n        out.close();\n    }\n\n    static FastScanner in;\n    static PrintWriter out;\n\n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n\n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n\n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class D {\n    FastScanner in;\n    PrintWriter out;\n\n    public void solve() throws IOException {\n        int n = in.nextInt();\n        int maxLevel = in.nextInt();\n        int cf = in.nextInt();\n        int cm = in.nextInt();\n        long money = in.nextLong();\n        final int[] a = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        Integer[] order = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            order[i] = i;\n        }\n        Arrays.sort(order, new Comparator<Integer>() {\n            public int compare(Integer x, Integer y) {\n                return Integer.compare(a[x], a[y]);\n            }\n        });\n        long[] b = new long[n];\n        for (int i = 0; i < n; i++) {\n            b[i] = a[order[i]];\n            if (i > 0) {\n                b[i] += b[i - 1];\n            }\n        }\n        long sumForMax = 0;\n        long answer = -1;\n        int when = -1;\n        long bestMin = -1;\n        for (int max = 0; max <= n; max++) {\n            long leftMoney = money - ((long) max * maxLevel - sumForMax);\n            if (leftMoney < 0) {\n                break;\n            }\n            if (max == n) {\n                long cur = (long) n * cf + (long) maxLevel * cm;\n                if (cur > answer) {\n                    answer = cur;\n                    when = n;\n                    bestMin = maxLevel; \n                }\n                break;\n            }\n            long l = -1;\n            long r = maxLevel;\n            while (l < r - 1) {\n                long mid = (l + r) >>> 1;\n                int left = -1;\n                int right = n - max;\n                while (left < right - 1) {\n                    int middle = (left + right) >>> 1;\n                    if (a[order[middle]] < mid) {\n                        left = middle;\n                    } else {\n                        right = middle;\n                    }\n                }\n                long sum = left < 0 ? 0 : b[left];\n                long needSum = mid * right - sum;\n                if (needSum > leftMoney) {\n                    r = mid;\n                } else {\n                    l = mid;\n                }\n            }\n            long cur = (long) cf * max + (long) cm * l;\n            if (cur > answer) {\n                answer = cur;\n                when = max;\n                bestMin = l;\n            }\n            sumForMax += a[order[n - max - 1]];\n        }\n        out.println(answer);\n        int[] c = a.clone();\n        for (int i = 0; i < when; i++) {\n            c[order[n - i - 1]] = maxLevel;\n        }\n        for (int i = 0; i < n; i++) {\n            if (c[i] < bestMin) {\n                c[i] = (int) bestMin;\n            }\n        } \n        for (int i = 0; i < n; i++) {\n            if (i > 0) {\n                out.print(' ');\n            }\n            out.print(c[i]);\n        }\n        out.println();\n    }\n\n    public void run() {\n        try {\n            in = new FastScanner();\n            out = new PrintWriter(System.out);\n\n            solve();\n\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n    public static void main(String[] arg) {\n        new D().run();\n    }\n}", "label": 3}
{"src": "import com.sun.javafx.geom.Line2D;\nimport com.sun.javafx.geom.Point2D;\n\nimport java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n    FastScanner in;\n    PrintWriter out;\n\n    static final String FILE = \"\";\n\n    int n;\n    long A, cf, cm, m;\n    long ms[];\n    long tmp[];\n    long sum[];\n    PairInt index[];\n\n    boolean can(long a, int to) {\n        int l = 0, r = to - 1;\n        if (r < 0)\n            return true;\n        while (l != r) {\n            int ll = l, lr = r;\n            int mid = (l + r) / 2;\n            if (ms[mid] <= a) {\n                l = mid;\n            } else {\n                r = mid;\n            }\n            if (ll == l && lr == r) {\n                if (ms[r] <= a) {\n                    l = r;\n                } else {\n                    r = l;\n                }\n            }\n        }\n\n        long raz = (l + 1) * a - sum[l];\n        return (raz <= m);\n    }\n\n    /*boolean can(long a, int to) {\n        long nada = 0;\n        for (int i = 0; i < to; i++) {\n            nada += max(0, a - ms[i]);\n        }\n        return (nada <= m);\n    }*/\n\n    public void solve() {\n        n = in.nextInt();\n        A = in.nextLong();\n        cf = in.nextLong();\n        cm = in.nextLong();\n        m = in.nextLong();\n        ms = new long[n];\n        index = new PairInt[n];\n        tmp = new long[n];\n        sum = new long[n];\n        for (int i = 0; i < n; i++) {\n            ms[i] = in.nextLong();\n            index[i] = new PairInt((int)ms[i], i);\n        }\n        Arrays.sort(ms);\n        Arrays.sort(index);\n\n        for (int i = 0; i < n; i++) {\n            sum[i] = ms[i];\n            if (i > 0)\n                sum[i] += sum[i - 1];\n        }\n\n        long oldM = m;\n\n        long all = -1;\n        long ans = 0;\n        int heh = n, to = 0;\n        for (int i = n; i >= 0; i--) {\n            all++;\n            if (i < n) {\n                m -= (A - ms[i]);\n                if (m < 0)\n                    break;\n            }\n\n            long a = 0, b = A - 1;\n            if (i == 0)\n                b = A;\n            while (a != b) {\n                long la = a, lb = b;\n                long mid = (a + b) / 2;\n                if (can(mid, i)) {\n                    a = mid;\n                } else {\n                    b = mid;\n                }\n                if (la == a && lb == b) {\n                    if (can(b, i)) {\n                        a = b;\n                    } else {\n                        b = a;\n                    }\n                }\n            }\n\n            ans = max(ans, all * cf + a * cm);\n            if (ans == all * cf + a * cm) {\n                heh = i;\n                to = (int)a;\n            }\n        }\n\n        for (int i = n - 1; i >= heh; i--) {\n            tmp[index[i].b] = A;\n        }\n\n        for (int i = heh - 1; i >= 0; i--) {\n            tmp[index[i].b] = max(to, index[i].a);\n        }\n\n        out.println(ans);\n        for (int i = 0; i < n; i++)\n            out.print(tmp[i] + \" \");\n    }\n\n    public void run() {\n        if (FILE.equals(\"\")) {\n            in = new FastScanner(System.in);\n            out = new PrintWriter(System.out);\n        } else {\n            try {\n                in = new FastScanner(new FileInputStream(FILE +\n                        \".in\"));\n                out = new PrintWriter(new FileOutputStream(FILE +\n                        \".out\"));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n        solve();\n        out.close();\n    }\n\n    public static void main(String[] args) {\n        (new Main()).run();\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n                return \"\";\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public float nextFloat() {\n            return Float.parseFloat(next());\n        }\n    }\n\n    class Pair<A extends Comparable<A>, B extends Comparable<B>>\n            implements Comparable<Pair<A, B>> {\n        public A a;\n        public B b;\n\n        public Pair(A a, B b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Pair<A, B> o) {\n            if (o == null || o.getClass() != getClass())\n                return 1;\n            int cmp = a.compareTo(o.a);\n            if (cmp == 0)\n                return b.compareTo(o.b);\n            return cmp;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Pair<?, ?> pair = (Pair<?, ?>) o;\n\n            if (a != null ? !a.equals(pair.a) : pair.a != null) return\n                    false;\n            return !(b != null ? !b.equals(pair.b) : pair.b != null);\n        }\n    }\n\n    class PairInt extends Pair<Integer, Integer> {\n        public PairInt(Integer u, Integer v) {\n            super(u, v);\n        }\n    }\n\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Div339C {\n    static class N implements Comparable<N> {\n        long val;\n        int index;\n\n        N(int val, int i) {\n            this.val = val;\n            index = i;\n        }\n\n        @Override\n        public int compareTo(N o) {\n            return Long.compare(val, o.val);\n        }\n\n    }\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        String[] l = bf.readLine().split(\" \");\n        int n = Integer.parseInt(l[0]);\n        long N = n;\n        long A = Integer.parseInt(l[1]);\n        long cf = Integer.parseInt(l[2]);\n        long cm = Integer.parseInt(l[3]);\n        long m = Long.parseLong(l[4]);\n        N[] nums = new N[n + 1];\n        l = bf.readLine().split(\" \");\n        nums[0] = new N(0, 0);\n        for (int i = 1; i < nums.length; i++) {\n            nums[i] = new N(Integer.parseInt(l[i - 1]), i);\n        }\n        Arrays.sort(nums);\n        long needToA[] = new long[n + 2];\n        for (int i = n; i >= 0; i--) {\n            needToA[i] += A - nums[i].val;\n            needToA[i] += needToA[i + 1];\n        }\n        long sums[] = new long[n + 1];\n        for (int i = 1; i < sums.length; i++) {\n            sums[i] = sums[i - 1] + nums[i].val;\n        }\n        int lo, hi, mid;\n        int bestInd = 0;\n        int bestInd2 = n + 1;\n        long bestMin = 0;\n        long best = 0;\n        long left;\n        long c;\n        long maxMin;\n        for (int i = n + 1; i > 0; i--) {\n            if (needToA[i] > m)\n                break;\n            left = m - needToA[i];\n            lo = 0;\n            hi = i;\n            maxMin = 0;\n            while (lo + 1 < hi) {\n                mid = (lo + hi) >> 1;\n                if (nums[mid].val * mid - sums[mid] <= left) {\n                    lo = mid;\n                } else {\n                    hi = mid;\n                }\n            }\n            if (lo != 0) {\n                maxMin = nums[lo].val;\n                left -= nums[lo].val * lo - sums[lo];\n                maxMin += left / lo;\n                if (lo < n && lo + 1 < i) {\n                    maxMin = Math.min(maxMin, nums[lo + 1].val);\n                }\n                maxMin = Math.min(maxMin, A);\n            }\n            if (i == 1)\n                maxMin = A;\n            c = cf * (n + 1 - i) + cm * maxMin;\n            if (c > best) {\n                best = c;\n                bestMin = maxMin;\n                bestInd = lo;\n                bestInd2 = i;\n            }\n        }\n        for (int i = bestInd; i > 0; i--) {\n            nums[i].val = bestMin;\n        }\n        for (int i = bestInd2; i < nums.length; i++) {\n            nums[i].val = A;\n        }\n        long ans[] = new long[n + 1];\n        for (int i = 1; i < ans.length; i++) {\n            ans[nums[i].index] = nums[i].val;\n        }\n        StringBuffer sb = new StringBuffer();\n        for (int i = 1; i < ans.length; i++) {\n            sb.append(ans[i] + \" \");\n        }\n        System.out.println(best);\n        System.out.println(sb);\n    }\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * @author Don Li\n */\npublic class Skills {\n    \n    void solve() {\n        int n = in.nextInt(), A = in.nextInt();\n        long cf = in.nextInt(), cm = in.nextInt(), m = in.nextLong();\n        int[] S = new int[n];\n        for (int i = 0; i < n; i++) S[i] = in.nextInt();\n        \n        // make a copy of skills and sort them\n        int[] B = new int[n];\n        System.arraycopy(S, 0, B, 0, n);\n        Arrays.sort(B);\n        \n        // pre-process: sum[i] = the sum of the first i skills\n        long[] sum = new long[n + 1];\n        sum[0] = 0;\n        for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + B[i];\n        \n        // calc the force for init state\n        int cnt = 0, min = B[0];\n        for (int i = n - 1; i >= 0; i--) {\n            if (B[i] == A) cnt++;\n            else break;\n        }\n        long ans = cnt * cf + min * cm;\n        \n        // enum the number of elements to maximize (greedy: always maximize the top i elements)\n        int j = 0;\n        for (int i = n; i >= 0; i--) {\n            // the cost to maximize the top i elements\n            long c = (long) i * A - (sum[n] - sum[n - i]);\n            if (c > m) continue;\n            long r = m - c;\n            \n            // greedy: set the min value as larger as possible\n            while (j + 1 < n - i && r >= (long) B[j + 1] * (j + 1) - sum[j + 1]) j++;\n            int val = i < n ? (int) Math.min(B[j] + (r - ((long) B[j] * j - sum[j])) / (j + 1), A) : A;\n            \n            // update the answer\n            if (ans < i * cf + val * cm) {\n                cnt = i;\n                min = val;\n                ans = cnt * cf + min * cm;\n            }\n        }\n        \n        // update the original skills\n        if (cnt == n) {\n            for (int i = 0; i < n; i++) S[i] = A;\n        } else {\n            int t = B[n - cnt - 1];\n            for (int i = 0; i < n; i++) {\n                if (S[i] > t) {\n                    S[i] = A;\n                    cnt--;\n                }\n            }\n            for (int i = 0; i < n && cnt > 0; i++) {\n                if (S[i] == t) {\n                    S[i] = A;\n                    cnt--;\n                }\n            }\n            for (int i = 0; i < n; i++) {\n                if (S[i] < min) {\n                    S[i] = min;\n                }\n            }\n        }\n        \n        // print the answer\n        out.println(ans);\n        for (int i = 0; i < n; i++) {\n            if (i > 0) out.print(' ');\n            out.print(S[i]);\n        }\n        out.println();\n    }\n    \n    public static void main(String[] args) {\n        in = new FastScanner(new BufferedReader(new InputStreamReader(System.in)));\n        out = new PrintWriter(System.out);\n        new Skills().solve();\n        out.close();\n    }\n    \n    static FastScanner in;\n    static PrintWriter out;\n    \n    static class FastScanner {\n        BufferedReader in;\n        StringTokenizer st;\n        \n        public FastScanner(BufferedReader in) {\n            this.in = in;\n        }\n        \n        public String nextToken() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        \n        public int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n        \n        public long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n        \n        public double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\n\npublic class D {\n    \n    public static void main(String[] args) throws IOException \n    {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = sc.nextInt(), A = sc.nextInt(), cf = sc.nextInt(), cm = sc.nextInt();\n        long m = sc.nextLong();\n        \n        Skill[] a = new Skill[n];\n        for(int i = 0; i < n; ++i)\n            a[i] = new Skill(sc.nextInt(), i);\n        shuffle(a);\n        Arrays.sort(a);\n        long[] prePerf = new long[n+1];\n        prePerf[n-1] = A - a[n-1].val;\n        for(int i = n - 2; i >= 0; --i)\n            prePerf[i] = prePerf[i+1] + A - a[i].val;\n        \n        long[] preRaise = new long[n];\n        for(int i = 1; i < n; ++i)\n            preRaise[i] = (long)(a[i].val - a[i-1].val) * i + preRaise[i-1];\n        \n        int bestPerf = -1, bestRaise = -1;\n        long bestRVal = -1;\n        long maxVal = 0;\n        for(int i = 0; i <= n; ++i)\n            if(m >= prePerf[i])\n            {\n                long curVal = (long)(n - i) * cf;\n                long curRVal = 0;\n                long k = m - prePerf[i];\n                int ans = -1, lo = 0, hi = i - 1;\n                while(lo <= hi)\n                {\n                    int mid = lo + (hi - lo) / 2;\n                    if(preRaise[mid] <= k)\n                    {\n                        ans = mid;\n                        lo = mid + 1;\n                    }\n                    else\n                        hi = mid - 1;\n                }\n                if(ans != -1)\n                {\n                    long cur = a[ans].val + (curRVal = Math.min((k - preRaise[ans]) / (ans + 1), A - a[ans].val));\n                    curVal += cur * cm;\n                }\n                else\n                    curVal += (long) A * cm;\n                if(maxVal <= curVal)\n                {\n                    bestRVal = curRVal;\n                    maxVal = curVal;\n                    bestPerf = i;\n                    bestRaise = ans;\n                }\n            }\n        \n        out.println(maxVal);\n        for(int i = 0; i < n; ++i)\n        {\n            if(i <= bestRaise)\n                a[i].val = a[bestRaise].val + (int)bestRVal;\n            if(i >= bestPerf)\n                a[i].val = A;\n                \n        }\n        Arrays.sort(a, new Indexer());\n        for(int i = 0; i < n - 1; ++i)\n            out.format(\"%d \", a[i].val);\n        out.format(\"%d\\n\", a[n-1].val);\n        out.flush();\n        out.close();\n        \n    }\n\n\n    static void shuffle(Skill[] a)\n    {\n        int n = a.length;\n        for(int i = 0; i < n; i++)\n        {\n            int r = i + (int)(Math.random() * (n - i));\n            Skill tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n    static class Skill implements Comparable<Skill>\n    {\n        int val, idx;\n        \n        Skill(int x, int y)\n        {\n            val = x;\n            idx = y;\n        }\n        \n        public int compareTo(Skill s)\n        {\n            if(val != s.val)\n                return val - s.val;\n            return idx - s.idx;\n        }\n    }\n    \n    static class Indexer implements Comparator<Skill>\n    {\n        public int compare(Skill s1, Skill s2)\n        {\n            return s1.idx - s2.idx; \n        }\n    }\n    \n    static class Scanner \n    {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(InputStream s){  br = new BufferedReader(new InputStreamReader(s));}\n\n        public String next() throws IOException \n        {\n            while (st == null || !st.hasMoreTokens()) \n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {return Integer.parseInt(next());}\n        \n        public long nextLong() throws IOException {return Long.parseLong(next());}\n\n        public String nextLine() throws IOException {return br.readLine();}\n        \n        public double nextDouble() throws IOException\n        {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if(x.charAt(0) == '-')\n            {\n                neg = true;\n                start++;\n            }\n            for(int i = start; i < x.length(); i++)\n                if(x.charAt(i) == '.')\n                {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                }\n                else\n                {\n                    sb.append(x.charAt(i));\n                    if(dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg?-1:1);\n        }\n        \n        public boolean ready() throws IOException {return br.ready();}\n\n\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class Task {\n\n    public static void main(String[] args) throws IOException {\n        new Task().solve();\n    }\n\n    int mod = 1000000007;\n\n    PrintWriter out;\n\n    int n;\n    int m;\n\n    int inf = 2000000000;\n\n    ArrayList<Integer>[] g;\n\n    void solve() throws IOException {\n\n        Reader in;\n\n        try {\n\n            in = new Reader(\"input.txt\");\n            out = new PrintWriter( new BufferedWriter(new FileWriter(\"output.txt\")) );\n        }\n        catch (Exception e) {\n\n            in = new Reader();\n            out = new PrintWriter( new BufferedWriter(new OutputStreamWriter(System.out)) );\n        }\n\n        //BufferedReader br = new BufferedReader( new FileReader(\"in.txt\") );\n        //BufferedReader br = new BufferedReader( new InputStreamReader( System.in ) );\n\n        int n = in.nextInt();\n        int A = in.nextInt();\n        int f1 = in.nextInt();\n        int f2 = in.nextInt();\n        long m = in.nextLong();\n        long ans = 0;\n\n        Pair[] a = new Pair[n];\n        int[] f = new int[n];\n        for (int i = 0; i < n; i++) {\n\n            int x = in.nextInt();\n            a[i] = new Pair(x, i);\n            f[i] = x;\n        }\n\n        Arrays.sort(a);\n\n        long sum = 0;\n        int k = 0;\n        while (k < n && sum+(A - a[k].a) <= m) {\n            sum += (A - a[k].a);\n            a[k].a = A;\n            k++;\n        }\n\n        int[] b = new int[n];\n\n        int ansK = 0;\n        int ansA = 0;\n\n        if (k == n) {\n\n            ans = 1l*n*f1+1l*A*f2;\n            Arrays.fill(b, A);\n        }\n        else {\n\n            long min = a[n-1].a;\n            int l = n-1;\n            long r = m - sum;\n\n            while (l >= 0 && a[l].a == min)\n                l--;\n\n            for (int i = k-1; i >= -1; i--) {\n\n                long x = i+1;\n\n                while (l >= 0 && r > 0 && 1l*(a[l].a - min)*(n-1-l) <= r) {\n\n                    r -= 1l*(a[l].a - min)*(n-1-l);\n                    min = a[l].a;\n                    while (l >= 0 && a[l].a == min)\n                        l--;\n                }\n\n                long y = min + r/(n-1-l);\n\n                if (1l*x*f1+1l*y*f2 > ans) {\n\n                    ans = 1l*x*f1+1l*y*f2;\n                    ansK = i;\n                    ansA = (int) y;\n                }\n\n                if (i == -1)\n                    break;\n\n                a[i].a = f[a[i].b];\n                r += (A - f[a[i].b]);\n            }\n\n            for (int i = 0; i <= ansK; i++)\n                a[i].a = A;\n\n            for (int i = n-1; i >= 0; i--) {\n\n                a[i].a = Math.max(a[i].a, ansA);\n            }\n\n            for (int i = 0; i < n; i++)\n                b[a[i].b] = a[i].a;\n\n\n        }\n\n        out.println(ans);\n        for (int i = 0; i < n; i++)\n            out.print(b[i]+\" \");\n\n        out.flush();\n        out.close();\n    }\n\n\n    class Edge { int v, u; int w, c; Edge(int v, int u, int w, int c) { this.v = v; this.u = u; this.w = w; this.c = c; } }\n\n    class Pair implements Comparable<Pair>{\n\n        int a;\n        int b;\n\n        Pair(int a, int b) {\n\n            this.a = a;\n            this.b = b;\n        }\n\n        public int compareTo(Pair p) {\n\n            if (a < p.a)\n                return 1;\n\n            if (a > p.a)\n                return -1;\n\n            return 0;\n        }\n    }\n\n    class Item {\n\n        int a;\n        int b;\n        int c;\n\n        Item(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n    }\n\n    class Reader {\n\n        BufferedReader  br;\n        StringTokenizer tok;\n\n        Reader(String file) throws IOException {\n            br = new BufferedReader( new FileReader(file) );\n        }\n\n        Reader() throws IOException {\n            br = new BufferedReader( new InputStreamReader(System.in) );\n        }\n\n        String next() throws IOException {\n\n            while (tok == null || !tok.hasMoreElements())\n                tok = new StringTokenizer(br.readLine());\n            return tok.nextToken();\n        }\n\n        int nextInt() throws NumberFormatException, IOException {\n            return Integer.valueOf(next());\n        }\n\n        long nextLong() throws NumberFormatException, IOException {\n            return Long.valueOf(next());\n        }\n\n        double nextDouble() throws NumberFormatException, IOException {\n            return Double.valueOf(next());\n        }\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n    }\n\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class TaskD {\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer st;\n\n    public static void main(String[] args) throws IOException {\n        TaskD solver = new TaskD();\n        solver.open();\n        solver.solve();\n        solver.close();\n    }\n\n    class Skill {\n        int index;\n        long value;\n\n        public Skill(int index, long value) {\n            this.index = index;\n            this.value = value;\n        }\n\n        public long getValue() {\n            return value;\n        }\n\n        public int getIndex() {\n            return index;\n        }\n    }\n\n    private void solve() throws IOException {\n        int n = nextInt();\n        long a = nextLong();\n        int cMax = nextInt();\n        int cMin = nextInt();\n        long m = nextLong();\n        Skill[] skills = new Skill[n];\n        for (int i = 0; i < n; i++) {\n            skills[i] = new Skill(i, nextInt());\n        }\n        Arrays.sort(skills, Comparator.comparing((Skill s) -> -s.value));\n        long[] maxMoneyMin = new long[n];\n        TreeMap<Long, Integer> moneyToMin = new TreeMap<>();\n        moneyToMin.put(0L, n - 1);\n        for (int i = n - 2; i >= 0; i--) {\n            maxMoneyMin[i] = maxMoneyMin[i + 1] + 1L * (skills[i].value - skills[i + 1].value) * (n - (i + 1));\n            moneyToMin.put(maxMoneyMin[i], i);\n        }\n\n        int leftPos;\n        int outputLeftPos;\n        int rightPos = -1;\n        long minVal;\n        long answ;\n\n        for (leftPos = 0; leftPos < n; leftPos++) {\n            if (skills[leftPos].value != a) break;\n        }\n\n        int lastAPos = leftPos;\n        answ = 1L * leftPos * cMax + 1L * skills[n - 1].value * cMin;\n        outputLeftPos = leftPos - 1;\n        minVal = skills[n - 1].value;\n\n        long needMoney = 0;\n        for (int i = leftPos; i < n; i++) {\n            needMoney += (a - skills[i].value);\n            long moneyLeft = m - needMoney;\n\n            if (moneyLeft < 0) break;\n            long curPower = 1L * cMax * (i + 1);\n\n            if (i == n - 1) {\n                curPower += 1L * a * cMin;\n                if (answ < curPower) {\n                    answ = curPower;\n                    outputLeftPos = n - 1;\n                    rightPos = -1;\n                    minVal = a;\n                }\n                break;\n            }\n\n            Long moneySpentRight = moneyToMin.floorKey(moneyLeft);\n\n            int minInd;\n            long min;\n            moneyLeft -= moneySpentRight;\n            minInd = moneyToMin.get(moneySpentRight);\n            if (minInd <= i) {\n                minInd = i + 1;\n                moneyLeft += moneySpentRight;\n                moneyLeft -= maxMoneyMin[minInd];\n            }\n            min = skills[minInd].value;\n            long k = moneyLeft / (n - minInd);\n            min += k;\n            if (min > a) {\n                min = a;\n                curPower = 1L * cMax * n;\n            }\n            curPower += 1L * min * cMin;\n\n\n            if (curPower > answ) {\n                answ = curPower;\n                outputLeftPos = i;\n                rightPos = minInd;\n                minVal = min;\n            }\n        }\n\n        //if (leftPos == n) leftPos--;\n\n        if (lastAPos == n) lastAPos--;\n        if (skills[lastAPos].value != a) {\n            Long key = moneyToMin.floorKey(m);\n            int ind = moneyToMin.get(key);\n            long left = m - key;\n            long k = left / (n - ind);\n            long l = skills[ind].value + k;\n            long tmp;\n            if (l >= a) {\n                l = a;\n                tmp = 1L * n * cMax;\n            } else tmp = 1L * (lastAPos) * cMax;\n            tmp += 1L * cMin * l;\n            if (tmp > answ) {\n                answ = tmp;\n                rightPos = ind;\n                outputLeftPos = -1;\n                minVal = l;\n\n            }\n        }\n\n        out.println(answ);\n\n        for (int i = 0; i <= outputLeftPos; i++) {\n            skills[i].value = a;\n        }\n\n        if (rightPos != -1)\n            for (int i = rightPos; i < n; i++) {\n                skills[i].value = minVal;\n            }\n\n        Arrays.sort(skills, Comparator.comparing(Skill::getIndex));\n        for (Skill skill : skills) {\n            out.print(skill.value + \" \");\n        }\n        ;\n    }\n\n    private void close() throws IOException {\n        out.close();\n    }\n\n    private void open() {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n    }\n\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    private String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            String str = in.readLine();\n            if (str == null) return null;\n            st = new StringTokenizer(str);\n        }\n        return st.nextToken();\n    }\n\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n//     Test.testing();\n        ConsoleIO io = new ConsoleIO();\n        new Main(io).solve();\n        io.flush();\n    }\n    ConsoleIO io;\n    Main(ConsoleIO io) {\n        this.io = io;\n    }\n\n    ArrayList<ArrayList<Integer>> gr1;\n    boolean[] visit;\n    //\n\n    class Edge{\n        public Edge(int u,int v) {\n            this.u = u;\n            this.v = v;\n        }\n        public int u;\n        public int v;\n    }\n\n    long mod = 1_000_000_007;\n    int n,fn;\n    long[] sumf;\n    long[] summ, sump;\n    long A,cf,cm, m;\n    Edge[] all;\n    public void solve() {\n        long[] l = io.readLongArray();\n        int[] nums = io.readIntArray();\n        n = (int)l[0];\n        A = l[1];\n        cf = l[2];cm = l[3];\n        m = l[4];\n\n        all = new Edge[n];\n        for(int i = 0;i<n;i++)\n            all[i] = new Edge(i, nums[i]);\n        Arrays.sort(all, (e1,e2)->e2.v-e1.v);\n        for(int i = 0;i<n;i++)\n            nums[i] = all[i].v;\n\n        int left = 0;\n        int right = n;\n\n        sumf= new long[n+1];\n        for(int i = 1;i<=n;i++) {\n            sumf[i] = sumf[i - 1] + (A - nums[i-1]);\n            if(sumf[i]>m){right = i-1;break;}\n        }\n        summ = new long[n+1];\n        for(int i = n-1;i>=0;i--)summ[i] = summ[i+1]+nums[i];\n\n        sump = new long[n];\n        for(int i = n-2;i>=0;i--)sump[i] = sump[i+1] + (long)(nums[i]-nums[i+1]) * (n-1-i);\n//\n//        while(left<right-9) {\n//            int tr = (right - left) / 3;\n//            int ll = left + tr;\n//            int rr = ll + tr;\n//            if (calc(ll) < calc(rr)) {\n//                left = ll;\n//            } else right = rr;\n//        }\n        long res = 0;\n        int take = 0;\n        for(int i = left;i<=right;i++){\n            long cur = calc(i);\n            if(cur>res){\n                res = cur;\n                take = i;\n            }\n        }\n        io.writeLine(\"\" + res);\n        long have = m - sumf[take];\n        left = take;\n        right = n - 1;\n        while (left < right) {\n            int k = (left + right) / 2;\n            if (have >= sump[k]) right = k;\n            else left = k + 1;\n        }\n        long min = n > left?(summ[left] + have) / (n - left):0;\n        long upto = Math.min(A, min);\n        int[] ans = new int[n];\n        for(int i = 0;i<n;i++) {\n            if (i < take) {\n                ans[all[i].u] = (int) A;\n            } else if (i >= left)\n                ans[all[i].u] = (int) upto;\n            else\n                ans[all[i].u] = all[i].v;\n        }\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0;i<n;i++) {\n            if (i > 0) sb.append(' ');\n            sb.append(ans[i]);\n        }\n        io.writeLine(sb.toString());\n    }\n\n    long calc(int t) {\n        long have = m - sumf[t];\n        int left = t;\n        int right = n - 1;\n        while (left < right) {\n            int k = (left + right) / 2;\n            if (have >= sump[k]) right = k;\n            else left = k + 1;\n        }\n        long res = t*cf;\n        if(n>left)\n            res += Math.min(A, (summ[left] + have) / (n - left))*cm;\n        else{\n            res+=A*cm;\n        }\n        return res;\n    }\n\n}\n\nclass ConsoleIO {\n    BufferedReader br;\n    PrintWriter out;\n    public ConsoleIO(){br = new BufferedReader(new InputStreamReader(System.in));out = new PrintWriter(System.out);}\n    public void flush(){this.out.close();}\n    public void writeLine(String s) {this.out.println(s);}\n    public void writeInt(int a) {this.out.print(a);this.out.print(' ');}\n    public void writeWord(String s){\n        this.out.print(s);\n    }\n    public String readLine() {try {return br.readLine();}catch (Exception ex){ return \"\";}}\n    public long readLong() {\n        return Long.parseLong(this.readLine());\n    }\n    public int readInt() {\n        return Integer.parseInt(this.readLine().trim());\n    }\n    public long[] readLongArray() {\n        String[]n=this.readLine().trim().split(\" \");long[]r=new long[n.length];\n        for(int i=0;i<n.length;i++)r[i]=Long.parseLong(n[i]);\n        return r;\n    }\n    public int[] readIntArray() {\n        String[]n=this.readLine().trim().split(\"\\\\s+\");int[]r=new int[n.length];\n        for(int i=0;i<n.length;i++)r[i]=Integer.parseInt(n[i]);\n        return r;\n    }\n}\n\n", "label": 3}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.BitSet;\nimport java.util.Calendar;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.SortedSet;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\n/**\n * #\n * @author pttrung\n */\npublic class D_Round_339_Div2 {\n\n    public static long MOD = 1000000007;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        // PrintWriter out = new PrintWriter(new FileOutputStream(new File(\n        // \"output.txt\")));\n        PrintWriter out = new PrintWriter(System.out);\n        Scanner in = new Scanner();\n        int n = in.nextInt();\n        long A = in.nextInt();\n        long f = in.nextInt();\n        long m = in.nextInt();\n        long v = in.nextLong();\n        Point[] data = new Point[n];\n        for (int i = 0; i < n; i++) {\n            data[i] = new Point(in.nextInt(), i);\n        }\n        Arrays.sort(data);\n        long[] pre = new long[n];\n        long[] post = new long[n];\n        for (int i = 0; i < n; i++) {\n            pre[i] = data[i].x;\n            if (i > 0) {\n                pre[i] += pre[i - 1];\n            }\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            post[i] = data[i].x;\n            if (i + 1 < n) {\n                post[i] += post[i + 1];\n            }\n        }\n        long mx = -1;\n        int ix = n - 1;\n        long a = data[0].x;\n        for (int i = n - 1; i >= 0; i--) {\n            long left = v;\n            if (i + 1 < n) {\n                long need = (long)(n - i - 1) * A - post[i + 1];\n                if (need > v) {\n                    break;\n                }\n                left -= need;\n            }\n            long s = data[0].x;\n            long e = A;\n            long result = s;\n            while (s <= e) {\n                long mid = (s + e) >> 1;\n                int st = 0;\n                int ed = i;\n                int index = -1;\n                while (st <= ed) {\n                    int md = (st + ed) >> 1;\n                    if (data[md].x < mid) {\n                        if (index == -1 || index < md) {\n                            index = md;\n                        }\n                        st = md + 1;\n                    } else {\n                        ed = md - 1;\n                    }\n                }\n                if (index == -1) {\n                    if (result == -1 || result < mid) {\n                        result = mid;\n                    }\n                    s = mid + 1;\n                } else {\n                    long need = (long)(index + 1) * mid - pre[index];\n                    if (need <= left) {\n                        if (result < mid) {\n                            result = mid;\n                        }\n                        s = mid + 1;\n                    } else {\n                        e = mid - 1;\n                    }\n                }\n\n            }\n            long tmp = (long)(n - i - 1) * f + result * m;\n            if (mx < tmp) {\n                mx = tmp;\n                ix = i;\n                a = result;\n            }\n        }\n        long need = A * n - post[0];\n        if (need <= v) {\n            out.println((long)n*f + m*A);\n            for (int i = 0; i < n; i++) {\n                out.print(A + \" \");\n            }\n        } else {\n            out.println(mx);\n            long[] result = new long[n];\n            for (int i = 0; i <= ix; i++) {\n                if (data[i].x < a) {\n                    result[data[i].y] = a;\n                }else{\n                    result[data[i].y] = data[i].x;\n                }\n            }\n            for(int i = ix + 1; i < n; i++){\n                result[data[i].y] =  A;\n            }\n            for(long o : result){\n                out.print(o + \" \");\n            }\n        }\n\n        out.close();\n    }\n\n    public static int[] KMP(String val) {\n        int i = 0;\n        int j = -1;\n        int[] result = new int[val.length() + 1];\n        result[0] = -1;\n        while (i < val.length()) {\n            while (j >= 0 && val.charAt(j) != val.charAt(i)) {\n                j = result[j];\n            }\n            j++;\n            i++;\n            result[i] = j;\n        }\n        return result;\n\n    }\n\n    public static boolean nextPer(int[] data) {\n        int i = data.length - 1;\n        while (i > 0 && data[i] < data[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return false;\n        }\n        int j = data.length - 1;\n        while (data[j] < data[i - 1]) {\n            j--;\n        }\n        int temp = data[i - 1];\n        data[i - 1] = data[j];\n        data[j] = temp;\n        Arrays.sort(data, i, data.length);\n        return true;\n    }\n\n    public static int digit(long n) {\n        int result = 0;\n        while (n > 0) {\n            n /= 10;\n            result++;\n        }\n        return result;\n    }\n\n    public static double dist(long a, long b, long x, long y) {\n        double val = (b - a) * (b - a) + (x - y) * (x - y);\n        val = Math.sqrt(val);\n        double other = x * x + a * a;\n        other = Math.sqrt(other);\n        return val + other;\n\n    }\n\n    public static class Point implements Comparable<Point> {\n\n        int x, y;\n\n        public Point(int start, int end) {\n            this.x = start;\n            this.y = end;\n        }\n\n        @Override\n        public int hashCode() {\n            int hash = 5;\n            hash = 47 * hash + this.x;\n            hash = 47 * hash + this.y;\n            return hash;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final Point other = (Point) obj;\n            if (this.x != other.x) {\n                return false;\n            }\n            if (this.y != other.y) {\n                return false;\n            }\n            return true;\n        }\n\n        @Override\n        public int compareTo(Point o) {\n            return Integer.compare(x, o.x);\n        }\n    }\n\n    public static class FT {\n\n        long[] data;\n\n        FT(int n) {\n            data = new long[n];\n        }\n\n        public void update(int index, long value) {\n            while (index < data.length) {\n                data[index] += value;\n                index += (index & (-index));\n            }\n        }\n\n        public long get(int index) {\n            long result = 0;\n            while (index > 0) {\n                result += data[index];\n                index -= (index & (-index));\n            }\n            return result;\n\n        }\n    }\n\n    public static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static long pow(long a, long b, long MOD) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b == 1) {\n            return a;\n        }\n        long val = pow(a, b / 2, MOD);\n        if (b % 2 == 0) {\n            return val * val % MOD;\n        } else {\n            return val * (val * a % MOD) % MOD;\n\n        }\n    }\n\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() throws FileNotFoundException {\n            // System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            br = new BufferedReader(new InputStreamReader(System.in));\n            //  br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"input.txt\"))));\n        }\n\n        public String next() {\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}\n", "label": 3}
{"src": "// practice with rainboy\nimport java.io.*;\nimport java.util.*;\n\npublic class CF613B extends PrintWriter {\n\tCF613B() { super(System.out, true); }\n\tScanner sc = new Scanner(System.in);\n\tpublic static void main(String[] $) {\n\t\tCF613B o = new CF613B(); o.main(); o.flush();\n\t}\n\n\tvoid main() {\n\t\tint n = sc.nextInt();\n\t\tint a_ = sc.nextInt();\n\t\tint cf = sc.nextInt();\n\t\tint cm = sc.nextInt();\n\t\tlong m = sc.nextLong();\n\t\tint[] aa = new int[n];\n\t\tInteger[] ii = new Integer[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\taa[i] = sc.nextInt();\n\t\t\tii[i] = i;\n\t\t}\n\t\tArrays.sort(ii, (i, j) -> aa[i] - aa[j]);\n\t\tlong[] dd = new long[n];\n\t\tlong sum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint a = aa[ii[i]];\n\t\t\tdd[i] = (long) i * a - sum;\n\t\t\tsum += a;\n\t\t}\n\t\tlong ans;\n\t\tif ((long) a_ * n - sum <= m) {\n\t\t\tans = (long) n * cf + (long) a_ * cm;\n\t\t\tArrays.fill(aa, a_);\n\t\t} else {\n\t\t\tlong c = 0;\n\t\t\tint i_ = -1, j_ = -1, b_ = 0;\n\t\t\tans = -1;\n\t\t\tfor (int i = n - 1, j = n - 1; i >= 0; i--) {\n\t\t\t\tif (j > i)\n\t\t\t\t\tj = i;\n\t\t\t\twhile (j >= 0 && dd[j] > m)\n\t\t\t\t\tj--;\n\t\t\t\tlong b = Math.min(aa[ii[j]] + (m - dd[j]) / (j + 1), a_);\n\t\t\t\tlong f = c + b * cm;\n\t\t\t\tif (ans < f) {\n\t\t\t\t\tans = f;\n\t\t\t\t\ti_ = i; j_ = j; b_ = (int) b;\n\t\t\t\t}\n\t\t\t\tif ((m -= a_ - aa[ii[i]]) < 0)\n\t\t\t\t\tbreak;\n\t\t\t\tc += cf;\n\t\t\t}\n\t\t\twhile (++i_ < n)\n\t\t\t\taa[ii[i_]] = a_;\n\t\t\twhile (j_ >= 0)\n\t\t\t\taa[ii[j_--]] = b_;\n\t\t}\n\t\tprintln(ans);\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tprint(aa[i] + \" \");\n\t\tprintln();\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.jar.Pack200;\n\npublic class SolutionCF613B {\n\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer tok = new StringTokenizer(\"\");\n\n\tvoid solve() throws IOException {\n\t\tint t = 1;\n\t\twhile (t-- > 0) {\n\t\t\tsolveTest();\n\t\t}\n\t}\n\n\tclass Skill implements Comparable<Skill> {\n\t\tint x;\n\t\tint index;\n\n\t\tpublic Skill(int x, int index) {\n\t\t\tthis.x = x;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Skill o) {\n\t\t\treturn -Integer.compare(this.x, o.x);\n\t\t}\n\t}\n\n\tvoid solveTest() throws IOException {\n\t\tint n = readInt();\n\t\tint max = readInt();\n\t\tint cf = readInt();\n\t\tint cm = readInt();\n\t\tlong m = readLong();\n\t\tSkill[] a = new Skill[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = new Skill(readInt(), i);\n\t\t}\n\n\t\tArrays.sort(a);\n\t\tlong ans = -1;\n\t\tint fullCount = -1;\n\t\tlong min = -1;\n\t\tint pointer = 0;\n\n\t\tlong sufSum = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsufSum += a[i].x;\n\t\t}\n\t\tlong prefSum = 0;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlong firstNeed = i * 1l * max - prefSum;\n\t\t\tlong firstSum = i * 1l * cf;\n\t\t\tif (firstNeed > m) {\n\t\t\t\tprefSum += a[i].x;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlong rest = m - firstNeed;\n\t\t\twhile (pointer < i) {\n\t\t\t\tsufSum -= a[pointer].x;\n\t\t\t\tpointer++;\n\t\t\t}\n\n\t\t\tlong secondNeed = 0;\n\t\t\twhile (pointer < n) {\n\t\t\t\tsecondNeed = (n - pointer) * 1l * a[pointer].x - sufSum;\n\t\t\t\tif (secondNeed <= rest) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tsufSum -= a[pointer].x;\n\t\t\t\tpointer++;\n\t\t\t}\n\t\t\trest -= secondNeed;\n\t\t\tlong add = rest / (n-pointer);\n\t\t\tlong maxPoss = (pointer == i) ? max : a[pointer-1].x;\n\n\n\t\t\tlong curMin = a[pointer].x + add;\n\t\t\tif(curMin > maxPoss) {\n\t\t\t\tcurMin = maxPoss;\n\t\t\t}\n\n\t\t\tlong secondSum = curMin * 1l * cm;\n\t\t\tif(firstSum + secondSum > ans) {\n\t\t\t\tans = firstSum + secondSum;\n\t\t\t\tfullCount = i;\n\t\t\t\tmin = curMin;\n\t\t\t}\n\t\t\tprefSum += a[i].x;\n\t\t}\n\n\t\tif(n * 1l * max - prefSum <= m) {\n\t\t\tans = n * 1l * cf + max * 1l * cm;\n\t\t\tfullCount = n;\n\t\t\tmin = max;\n\t\t}\n\n\t\tout.println(ans);\n\t\tlong[] res = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (i < fullCount) {\n\t\t\t\tres[a[i].index] = max;\n\t\t\t} else if (a[i].x < min) {\n\t\t\t\tres[a[i].index] = min;\n\t\t\t} else {\n\t\t\t\tres[a[i].index] = a[i].x;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tout.print(res[i] + \" \");\n\t\t}\n\n\t}\n\n\tvoid init() throws FileNotFoundException {\n\t\tif (ONLINE_JUDGE) {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(System.out);\n\t\t} else {\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new PrintWriter(\"output.txt\");\n\t\t}\n\t}\n\n\tString readString() throws IOException {\n\t\twhile (!tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tint readInt() throws IOException {\n\t\treturn Integer.parseInt(readString());\n\t}\n\n\tlong readLong() throws IOException {\n\t\treturn Long.parseLong(readString());\n\t}\n\n\tdouble readDouble() throws IOException {\n\t\treturn Double.parseDouble(readString());\n\t}\n\n\tint[] readArr(int n) throws IOException {\n\t\tint[] res = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres[i] = readInt();\n\t\t}\n\t\treturn res;\n\t}\n\n\tlong[] readArrL(int n) throws IOException {\n\t\tlong[] res = new long[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tres[i] = readLong();\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew SolutionCF613B().run();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tlong t1 = System.currentTimeMillis();\n\t\t\tinit();\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t\tlong t2 = System.currentTimeMillis();\n\t\t\tSystem.err.println(\"Time = \" + (t2 - t1));\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace(System.err);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n}", "label": 3}
{"src": "import java.util.*;\n\npublic class D {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner qwe = new Scanner(System.in);\n\t\t\n\t\t//n, A, cf, cm and m \n\t\tint N= qwe.nextInt();\n\t\tint A = qwe.nextInt();\n\t\tlong cf = qwe.nextLong();\n\t\tlong cm = qwe.nextLong();\n\t\tlong m = qwe.nextLong();\n\t\t\n\t\tlong[] powers = new long[N];\n\t\tfor (int i = 0; i < powers.length; i++) {\n\t\t\tpowers[i] =   qwe.nextInt();\n\t\t}\n\t\t\n\t\tpair[] ps = new pair[N];\n\t\tfor (int i = 0; i < ps.length; i++) {\n\t\t\tps[i] = new pair(powers[i],i);\n\t\t}\n\t\t\n\t\tArrays.sort(ps);\n\t\t\n\t\tlong min = 0;\n\t\tlong max = A;\n\t\t\n\t\twhile(max - min > 100){\n\t\t\tlong lo = (2*min+max)/3;\n\t\t\tlong hi = (min+2*max)/3;\n\t\t\t\n\t\t\tlong trylo = tryit(copy(ps),  lo,  m,  A,  cf,  cm);\n\t\t\tlong tryhi = tryit(copy(ps),  hi,  m,  A,  cf,  cm);\n\t\t\t\n\t\t\t\n\t\t\tif(trylo < tryhi) min = lo;\n\t\t\telse max = hi;\n\t\t\t\t\n\t\t}\n\t\t\n\t\tlong best = tryit(copy(ps),  min,  m,  A,  cf,  cm);\n\t\tlong bquery = min;\n\t\tfor(long i =min; i <= max; i++)\n\t\t{\n\t\t\tlong cont = tryit(copy(ps),  i,  m,  A,  cf,  cm);\n\t\t\tif(cont > best){\n\t\t\t\tbquery = i;\n\t\t\t\tbest = cont;\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\t\n\t\t\n\t\ttryit(ps,  bquery,  m,  A,  cf,  cm);\n\t\t\n\t\tpair.byindex = true;\n\t\t\n\t\tArrays.sort(ps);\n\t\t\n\t\tSystem.out.println(best);\n\t\tfor (int i = 0; i < ps.length; i++) {\n\t\t\tSystem.out.print(ps[i].val + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tqwe.close();\n\t}\n\t\n\tstatic class pair implements Comparable<pair>{\n\t\tlong val;\n\t\tint index;\n\t\tstatic boolean byindex = false;\n\t\tpublic pair(long val, int index){\n\t\t\tthis.val = val;\n\t\t\tthis.index  = index;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(pair o) {\n\t\t\tif(byindex) return index - o.index;\n\t\t\treturn (int)(val - o.val);\n\t\t}\n\t\t\n\t}\n\t\n\tstatic pair[] copy(pair[] ps){\n\t\tpair[] ret =new pair[ps.length];\n\t\t\n\t\tfor (int i = 0; i < ret.length; i++) {\n\t\t\tret[i] = new pair(ps[i].val,ps[i].index);\n\t\t}\n\t\treturn ret;\n\t\t\n\t}\n\t\n\t //powers needs to be a copy\n\tstatic long tryit(pair[] powers, long min, long m, int A, long cf, long cm){\n\t\t\t\t\n\t\tfor (int i = 0; i < powers.length; i++) {\n\t\t\tif(powers[i].val > min) break;\n\t\t\tm -= min - powers[i].val;\n\t\t\tpowers[i].val = min;\n\t\t}\n\t\t\n\t\tif(m < 0) return -1;\n\t\t\n\t\tlong ret = cm*min;\n\t\t\n\t\tfor (int i = 0; i < powers.length; i++) {\n\t\t\tlong at = powers[powers.length-1-i].val;\n\t\t\tif(A-at > m) break;\n\t\t\tpowers[powers.length-1-i].val = A;\n\t\t\tm -= A-at;\n\t\t\tret += cf;\n\t\t}\n\t\t\n\t\treturn ret;\n\t\t\n\t\t\n\t}\n\n}\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            long N = in.nextInt();\n            long A = in.nextInt();\n            long cf = in.nextInt();\n            long cm = in.nextInt();\n            long m = in.nextLong();\n            long[] pref = new long[(int) N];\n            ArrayList<long[]> arr = new ArrayList<>();\n            for (int i = 0; i < N; i++) {\n                arr.add(new long[]{in.nextInt(), i});\n            }\n            Collections.sort(arr, new Comparator<long[]>() {\n\n                public int compare(long[] ints, long[] t1) {\n                    return Long.compare(ints[0], t1[0]);\n                }\n            });\n            pref[0] = arr.get(0)[0];\n            for (int i = 1; i < N; i++) {\n                pref[i] = pref[i - 1] + arr.get(i)[0];\n            }\n            long res = -1;\n            ArrayList<long[]> resArr = new ArrayList<>();\n            if (A * N - pref[(int) N - 1] <= m) {\n                res = cf * N + A * cm;\n                resArr = new ArrayList<>();\n                resArr.add(new long[]{-1, -1});\n                resArr.add(new long[]{A, 0});\n            } else {\n                for (long notMax = N; notMax >= 1; notMax--) {\n                    long low = 0;\n                    long high = notMax - 1;\n                    while (low < high) {\n                        long mid = (low + high + 1) / 2;\n                        if (arr.get((int) mid)[0] * (mid + 1) - pref[(int) mid] <= m) {\n                            low = mid;\n                        } else {\n                            high = mid - 1;\n                        }\n                    }\n                    int mid = (int) (low);\n                    long newMin = Math.min(A, (m - (arr.get(mid)[0] * (low + 1) - pref[mid])) / (low + 1) + arr.get(mid)[0]);\n                    if (m >= 0 && newMin * cm + cf * (N - notMax) > res) {\n                        res = Math.max(res, newMin * cm + cf * (N - notMax));\n                        resArr = new ArrayList<>();\n                        resArr.add(new long[]{newMin, mid});\n                        resArr.add(new long[]{A, notMax});\n                    }\n                    m -= A - arr.get((int) notMax - 1)[0];\n                }\n            }\n            out.println(res);\n            long[] fState = new long[(int) N];\n            for (int i = 0; i <= resArr.get(0)[1]; i++) {\n                fState[(int) arr.get(i)[1]] = resArr.get(0)[0];\n            }\n            for (int i = (int) resArr.get(0)[1] + 1; i < resArr.get(1)[1]; i++) {\n                fState[(int) arr.get(i)[1]] = arr.get(i)[0];\n            }\n            for (int i = (int) resArr.get(1)[1]; i < N; i++) {\n                fState[(int) arr.get(i)[1]] = A;\n            }\n            for (long j : fState) {\n                out.println(j);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "//package CodeForces.Round339;\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * Created by ilya\n */\n\npublic class D614 {\n\n    public static void main(String[] args) {\n        sc sc = new sc();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt();\n        long A = sc.nextLong();\n        long cf = sc.nextLong();\n        long cm = sc.nextLong();\n        long m = sc.nextLong();\n\n        Skill[] skills = new Skill[n];\n        for (int i = 0; i < n; i++) {\n            skills[i] = new Skill(i, sc.nextInt());\n        }\n        Arrays.sort(skills);\n\n        long[] postfix = new long[n + 1];\n        postfix[n - 1] = A - skills[n - 1].val;\n        for (int i = n - 2; i >= 0; i--) {\n            postfix[i] = postfix[i + 1] + (A - skills[i].val);\n        }\n\n        long[] prefix = new long[n];\n        for (int i = 1; i < n; i++) {\n            prefix[i] = prefix[i -1] + (i) * (skills[i].val - skills[i-1].val);\n        }\n\n        int minI = n - 1, c = 0;\n        long minL = 0, remain = 0, max = 0, l = 0, tmp = 0;\n        for (int i = 0; i < n; i++) {\n            long spareMoney = m - postfix[n-i];\n            if (spareMoney < 0) break;\n\n            while (minI > n-i-1 || prefix[minI] > spareMoney) minI--;\n\n            remain = spareMoney - prefix[minI];\n            minL = Math.min(A, skills[minI].val + remain / (minI+1));\n\n            tmp = i*cf + minL*cm;\n            if (max < tmp) {\n                c = i;\n                l = minL;\n                max = tmp;\n            }\n        }\n        if(postfix[0] <= m){\n            c = n;\n            l =A;\n            max = n*cf + A*cm;\n        }\n        out.println(max);\n        for (int i = 0; i < c; i++) {\n            skills[n-1-i].val = A;\n        }\n        for (int i = c; i < n; i++) {\n            if (skills[n-1-i].val < l) skills[n-1-i].val = l;\n        }\n        Arrays.sort(skills, (Skill a, Skill b) -> Integer.compare(a.key, b.key));\n        for (Skill skill : skills) {\n            out.print(skill.val + \" \");\n        }\n        out.close();\n    }\n\n    static class Skill implements Comparable<Skill> {\n        long val;\n        int key;\n\n        public Skill(int p, long val) {\n            this.key = p;\n            this.val = val;\n        }\n\n        @Override\n        public int compareTo(Skill o) {\n            return Long.compare(this.val, o.val);\n        }\n    }\n\n    public static class sc {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public sc() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        Integer nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}\n\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class TaskD {\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer st;\n\n    public static void main(String[] args) throws IOException {\n        TaskD solver = new TaskD();\n        solver.open();\n        solver.solve();\n        solver.close();\n    }\n\n    class Skill {\n        int index;\n        long value;\n\n        public Skill(int index, long value) {\n            this.index = index;\n            this.value = value;\n        }\n\n        public long getValue() {\n            return value;\n        }\n\n        public int getIndex() {\n            return index;\n        }\n    }\n\n    private void solve() throws IOException {\n        int n = nextInt();\n        long a = nextLong();\n        int cMax = nextInt();\n        int cMin = nextInt();\n        long m = nextLong();\n        Skill[] skills = new Skill[n];\n        for (int i = 0; i < n; i++) {\n            skills[i] = new Skill(i, nextInt());\n        }\n        Arrays.sort(skills, Comparator.comparing((Skill s) -> -s.value));\n        long[] maxMoneyMin = new long[n];\n        TreeMap<Long, Integer> moneyToMin = new TreeMap<>();\n        moneyToMin.put(0L, n - 1);\n        for (int i = n - 2; i >= 0; i--) {\n            maxMoneyMin[i] = maxMoneyMin[i + 1] + 1L * (skills[i].value - skills[i + 1].value) * (n - (i + 1));\n            moneyToMin.put(maxMoneyMin[i], i);\n        }\n\n        int outputLeftPos;\n        int rightPos = -1;\n        long minVal;\n        long answ;\n\n        int lastAPos;\n        for (lastAPos = 0; lastAPos < n; lastAPos++) {\n            if (skills[lastAPos].value != a) break;\n        }\n\n        answ = 1L * lastAPos * cMax + 1L * skills[n - 1].value * cMin;\n        outputLeftPos = lastAPos - 1;\n        minVal = skills[n - 1].value;\n\n        long needMoney = 0;\n        for (int i = lastAPos; i < n; i++) {\n            needMoney += (a - skills[i].value);\n            long moneyLeft = m - needMoney;\n\n            if (moneyLeft < 0) break;\n            long curPower = 1L * cMax * (i + 1);\n\n            if (i == n - 1) {\n                curPower += 1L * a * cMin;\n                if (answ < curPower) {\n                    answ = curPower;\n                    outputLeftPos = n - 1;\n                    rightPos = -1;\n                    minVal = a;\n                }\n                break;\n            }\n\n            Long moneySpentRight = moneyToMin.floorKey(moneyLeft);\n\n            int minInd;\n            long min;\n            moneyLeft -= moneySpentRight;\n            minInd = moneyToMin.get(moneySpentRight);\n            if (minInd <= i) {\n                minInd = i + 1;\n                moneyLeft += moneySpentRight;\n                moneyLeft -= maxMoneyMin[minInd];\n            }\n            min = skills[minInd].value;\n            long k = moneyLeft / (n - minInd);\n            min += k;\n            if (min > a) {\n                min = a;\n                curPower = 1L * cMax * n;\n            }\n            curPower += 1L * min * cMin;\n\n\n            if (curPower > answ) {\n                answ = curPower;\n                outputLeftPos = i;\n                rightPos = minInd;\n                minVal = min;\n            }\n        }\n\n        //if (leftPos == n) leftPos--;\n\n        if (lastAPos == n) lastAPos--;\n        if (skills[lastAPos].value != a) {\n            Long key = moneyToMin.floorKey(m);\n            int ind = moneyToMin.get(key);\n            long left = m - key;\n            long k = left / (n - ind);\n            long l = skills[ind].value + k;\n            long tmp;\n            if (l >= a) {\n                l = a;\n                tmp = 1L * n * cMax;\n            } else tmp = 1L * (lastAPos) * cMax;\n            tmp += 1L * cMin * l;\n            if (tmp > answ) {\n                answ = tmp;\n                rightPos = ind;\n                outputLeftPos = -1;\n                minVal = l;\n\n            }\n        }\n\n        out.println(answ);\n\n        for (int i = 0; i <= outputLeftPos; i++) {\n            skills[i].value = a;\n        }\n\n        if (rightPos != -1)\n            for (int i = rightPos; i < n; i++) {\n                skills[i].value = minVal;\n            }\n\n        Arrays.sort(skills, Comparator.comparing(Skill::getIndex));\n        for (Skill skill : skills) {\n            out.print(skill.value + \" \");\n        }\n    }\n\n    private void close() throws IOException {\n        out.close();\n    }\n\n    private void open() {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n    }\n\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    private String nextToken() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            String str = in.readLine();\n            if (str == null) return null;\n            st = new StringTokenizer(str);\n        }\n        return st.nextToken();\n    }\n\n}", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Artem Gilmudinov\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskD solver = new TaskD();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskD {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.readInt();\n            long A = in.readLong();\n            int cf, cm;\n            cf = in.readInt();\n            cm = in.readInt();\n            long m = in.readLong();\n            PairInt[] a = new PairInt[n];\n            int cntOfMax = 0;\n            for (int i = 0; i < n; i++) {\n                a[i] = new PairInt(i, in.readInt());\n                if (a[i].y == A) {\n                    ++cntOfMax;\n                }\n            }\n            Arrays.sort(a, new Comparator<PairInt>() {\n\n                public int compare(PairInt o1, PairInt o2) {\n                    return o1.y - o2.y;\n                }\n            });\n            long[] sum = new long[n + 1];\n            for (int i = 1; i <= n; i++) {\n                sum[i] = sum[i - 1] + a[i - 1].y;\n            }\n\n            long max = 0;\n            long maxCnt, minVal;\n            maxCnt = minVal = 0;\n            for (int i = cntOfMax; i <= n; i++) {\n                long money = m;\n                int need = (i - cntOfMax);\n                money -= (need * A - (sum[n - cntOfMax] - sum[n - cntOfMax - need]));\n                long left = 0;\n                long right = A;\n                long mid;\n                int val;\n                while (left < right) {\n                    mid = left + (right - left) / 2;\n                    val = bs(a, mid, n - i - 1) + 1;\n                    if (money - (val * mid - sum[val]) >= 0) {\n                        left = mid + 1;\n                    } else {\n                        right = mid;\n                    }\n                }\n                val = bs(a, left, n - i - 1) + 1;\n                if (money - (val * left - sum[val]) < 0) {\n                    --left;\n                    val = bs(a, left, n - i - 1) + 1;\n                }\n                money -= (val * left - sum[val]);\n                int temp = i;\n                if (left == A) {\n                    temp = n;\n                }\n                if (money >= 0) {\n                    if (max < temp * cf + left * cm) {\n                        maxCnt = temp;\n                        minVal = left;\n                        max = temp * cf + left * cm;\n                    }\n                }\n            }\n            int cnt = bs(a, minVal, n - (int) maxCnt - 1) + 1;\n            out.println(max);\n            if (minVal == A) {\n                for (int i = 0; i < n; i++) {\n                    out.print(A + \" \");\n                }\n            } else {\n                int[] ans = new int[n];\n                for (int i = 0; i < cnt; i++) {\n                    ans[a[i].x] = (int) minVal;\n                }\n                for (int i = cnt; i < n - maxCnt; i++) {\n                    ans[a[i].x] = a[i].y;\n                }\n                for (int i = n - (int) maxCnt; i < n; i++) {\n                    ans[a[i].x] = (int) A;\n                }\n                for (int i = 0; i < n; i++) {\n                    out.print(ans[i] + \" \");\n                }\n            }\n        }\n\n        public int bs(PairInt[] a, long val, int max) {\n            int left, right, mid;\n            left = 0;\n            right = max;\n            while (left < right) {\n                mid = left + (right - left) / 2;\n                if (a[mid].y <= val) {\n                    left = mid + 1;\n                } else {\n                    right = mid;\n                }\n            }\n            if (a[left].y > val) {\n                return left - 1;\n            }\n            return left;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class PairInt {\n        public int x;\n        public int y;\n\n        public PairInt(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n\n        public boolean equals(Object obj) {\n            PairInt pairInt = (PairInt) obj;\n            return pairInt.x == x && pairInt.y == y;\n        }\n\n        public String toString() {\n            return x + \" \" + y;\n        }\n\n        public PairInt clone() {\n            return new PairInt(x, y);\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class MainB {\n\tstatic final StdIn in = new StdIn();\n\tstatic final PrintWriter out = new PrintWriter(System.out);\n\tstatic int n;\n\tstatic long[] a, pa;\n\tstatic long A,m;\n\t\n\tpublic static void main(String[] args) {\n\t\tn=in.nextInt();\n\t\tA=in.nextLong();\n\t\tlong cf=in.nextLong(), cm=in.nextLong();\n\t\tm=in.nextLong();\n\t\tlong[] oa = in.readLongArray(n, 0);\n\t\ta = new long[n+1];\n\t\tpa = new long[n+1];\n\t\tlong ans1=-1;\n\t\tint ans2=-1;\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\ta[i]=oa[i];\n\t\t\tint j=(int)(Math.random()*(i+1));\n\t\t\ta[i]^=a[j]^(a[j]=a[i]);\n\t\t}\n\t\ta[n]=A;\n\t\tArrays.sort(a);\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tpa[i+1]=a[i]+pa[i];\n//\t\tSystem.out.println(fmsl(0));\n//\t\tSystem.out.println(fmsl(1));\n//\t\tif(n>0)\n//\t\t\treturn;\n\t\tfor(int i=n; i>=0; --i) {\n\t\t\tlong msl=fmsl(i);\n\t\t\tif(msl<0)\n\t\t\t\tbreak;\n\t\t\tif((n-i)*cf+msl*cm>ans1) {\n\t\t\t\tans1=(n-i)*cf+msl*cm;\n\t\t\t\tans2=i;\n\t\t\t}\n\t\t}\n\t\tout.println(ans1);\n//\t\tout.println(ans2);\n\t\tPriorityQueue<Integer> pq = new PriorityQueue<Integer>(new Comparator<Integer>() {\n\t\t\tpublic int compare(Integer i, Integer j) {\n\t\t\t\treturn -Long.compare(oa[i], oa[j]);\n\t\t\t}\n\t\t});\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tpq.add(i);\n\t\tfor(int i=0; i<n-ans2; ++i)\n\t\t\toa[pq.poll()]=A;\n\t\tlong msl=fmsl(ans2);\n\t\tfor(int i=0; i<n; ++i)\n\t\t\tout.print(Math.max(msl, oa[i])+\" \");\n\t\tout.close();\n\t}\n\t\n\tstatic long fmsl(int i) {\n\t\tlong lb1=0, rb1=A;\n\t\twhile(lb1<=rb1) {\n\t\t\tlong mb1=(lb1+rb1)/2;\n\t\t\tint lb2=0, rb2=i-1;\n\t\t\twhile(lb2<=rb2) {\n\t\t\t\tint mb2=(lb2+rb2)/2;\n\t\t\t\tif(a[mb2]>=mb1)\n\t\t\t\t\trb2=mb2-1;\n\t\t\t\telse\n\t\t\t\t\tlb2=mb2+1;\n\t\t\t}\n\t\t\tif(mb1*lb2-pa[lb2]<=m-((n-i)*A-(pa[n]-pa[i])))\n\t\t\t\tlb1=mb1+1;\n\t\t\telse\n\t\t\t\trb1=mb1-1;\n\t\t}\n\t\treturn rb1;\n\t}\n\t\n\tstatic class StdIn {\n\t\tfinal private int BUFFER_SIZE = 1 << 16;\n\t\tprivate DataInputStream din;\n\t\tprivate byte[] buffer;\n\t\tprivate int bufferPointer, bytesRead;\n\t\tpublic StdIn() {\n\t\t\tdin = new DataInputStream(System.in);\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\t\tpublic StdIn(InputStream in) {\n\t\t\ttry{\n\t\t\t\tdin = new DataInputStream(in);\n\t\t\t} catch(Exception e) {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t\tbuffer = new byte[BUFFER_SIZE];\n\t\t\tbufferPointer = bytesRead = 0;\n\t\t}\n\t\tpublic String next() {\n\t\t\tint c;\n\t\t\twhile((c=read())!=-1&&(c==' '||c=='\\n'||c=='\\r'));\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\twhile (c != -1)\n\t\t\t{\n\t\t\t\tif (c == ' ' || c == '\\n'||c=='\\r')\n\t\t\t\t\tbreak;\n\t\t\t\ts.append((char)c);\n\t\t\t\tc=read();\n\t\t\t}\n\t\t\treturn s.toString();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\tint c;\n\t\t\twhile((c=read())!=-1&&(c==' '||c=='\\n'||c=='\\r'));\n\t\t\tStringBuilder s = new StringBuilder();\n\t\t\twhile (c != -1)\n\t\t\t{\n\t\t\t\tif (c == '\\n'||c=='\\r')\n\t\t\t\t\tbreak;\n\t\t\t\ts.append((char)c);\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\treturn s.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\tint ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\twhile ((c = read()) >= '0' && c <= '9');\n\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic int[] readIntArray(int n, int os) {\n\t\t\tint[] ar = new int[n];\n\t\t\tfor(int i=0; i<n; ++i)\n\t\t\t\tar[i]=nextInt()+os;\n\t\t\treturn ar;\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tlong ret = 0;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\twhile ((c = read()) >= '0' && c <= '9');\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic long[] readLongArray(int n, long os) {\n\t\t\tlong[] ar = new long[n];\n\t\t\tfor(int i=0; i<n; ++i)\n\t\t\t\tar[i]=nextLong()+os;\n\t\t\treturn ar;\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\tdouble ret = 0, div = 1;\n\t\t\tbyte c = read();\n\t\t\twhile (c <= ' ')\n\t\t\t\tc = read();\n\t\t\tboolean neg = (c == '-');\n\t\t\tif (neg)\n\t\t\t\tc = read();\n\t\t\tdo\n\t\t\t\tret = ret * 10 + c - '0';\n\t\t\twhile ((c = read()) >= '0' && c <= '9');\n\t\t\tif (c == '.')\n\t\t\t\twhile ((c = read()) >= '0' && c <= '9')\n\t\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\tif (neg)\n\t\t\t\treturn -ret;\n\t\t\treturn ret;\n\t\t}\n\t\tprivate void fillBuffer() throws IOException {\n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\t\tif (bytesRead == -1)\n\t\t\t\tbuffer[0] = -1;\n\t\t}\n\t\tprivate byte read() {\n\t\t\ttry{\n\t\t\t\tif (bufferPointer == bytesRead)\n\t\t\t\t\tfillBuffer();\n\t\t\t\treturn buffer[bufferPointer++];\n\t\t\t} catch(IOException e) {\n\t\t\t\tthrow new RuntimeException();\n\t\t\t}\n\t\t}\n\t\tpublic void close() throws IOException {\n\t\t\tif (din == null)\n\t\t\t\treturn;\n\t\t\tdin.close();\n\t\t}\n\t}\n}", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\npublic class B\n{\n\tpublic static long cf;\n\tpublic static long cm;\n\tpublic static long m;\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n//\t\tint n = in.nextInt();\n//\t\tfor(int t = 0; t < 100000; t++)\n\t\t{\n\t\t\t\n\t\t\tint n = in.nextInt();\n\t\t\tlong a = in.nextInt();\n\t\t\tcf = in.nextInt();\n\t\t\tcm = in.nextInt();\n\t\t\tm = in.nextLong();\n\t\t\t\n//\t\t\tRandom rand = new Random();\n\t\t\t\n//\t\t\tint n = in.nextInt();\n//\t\t\tlong a = rand.nextInt(1000000000) + 1;\n//\t\t\tlong cf = rand.nextInt(1001);\n//\t\t\tlong cm = rand.nextInt(1001);\n//\t\t\tlong m = rand.nextInt(10000001);\n\t\t\t\n\t\t\tSkill[] skills = new Skill[n];\n//\t\t\tint[] input = new int[n];\n\t\t\tfor(int x = 0; x < n; x++)\n\t\t\t{\n\t\t\t\tskills[x] = new Skill(in.nextInt(), x);\n//\t\t\t\tinput[x] = rand.nextInt((int)(a + 1));\n//\t\t\t\tskills[x] = new Skill(input[x], x);\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(skills);\n\t\t\t\n\t\t\tlong[] sum = new long[n + 1];\n\t\t\tfor(int y = 0; y < skills.length; y++)\n\t\t\t{\n\t\t\t\tsum[y + 1] = sum[y] + (a - skills[y].value);\n\t\t\t}\n\t\t\t\n\t\t\tlong force = -1;\n\t\t\tint best = -1;\n\t\t\tlong bestMin = -1;\n\t\t\t\n\t\t\tint index = 0;\n\t\t\tlong low = 0;\n\t\t\tfor(int z = n; z >= 0; z--)\n\t\t\t{\n\t\t\t\tlong top = sum[n] - sum[n - z];\n\t\t\t\tif(top <= m)\n\t\t\t\t{\n\t\t\t\t\twhile(index < n - z - 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(index < skills.length - 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(low + (index + 1) * (skills[index + 1].value - skills[index].value) <= m - top)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlow += (index + 1) * (skills[index + 1].value - skills[index].value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(low + n * (a - skills[index].value) <= m - top)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tlow += n * (a - skills[index].value);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tindex++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tlong min = a;\n\t\t\t\t\tif(index < n - z)\n\t\t\t\t\t{\n\t\t\t\t\t\tmin = Math.min(a, skills[index].value + (m - top - low) / (index + 1));\n\t\t\t\t\t}\n\t\t\t\t\t\n//\t\t\t\t\tSystem.out.println(z + \" \" + min);\n\t\t\t\t\t\n\t\t\t\t\tlong current = z * cf + min * cm;\n\t\t\t\t\t\n\t\t\t\t\tif(current > force)\n\t\t\t\t\t{\n\t\t\t\t\t\tforce = current;\n\t\t\t\t\t\tbest = z;\n\t\t\t\t\t\tbestMin = min;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n//\t\t\tlong ans = -1;\n//\t\t\tfor(int i = 0; i <= n; i++)\n//\t\t\t{\n//\t\t\t\tlong top = 0;\n//\t\t\t\tfor(int j = 0; j < i; j++)\n//\t\t\t\t{\n//\t\t\t\t\ttop += a - skills[n - j - 1].value;\n//\t\t\t\t}\n//\t\t\t\t\n//\t\t\t\tif(top <= m)\n//\t\t\t\t{\n//\t\t\t\t\tlong l = 0;\n//\t\t\t\t\tlong h = a;\n//\t\t\t\t\twhile(l < h)\n//\t\t\t\t\t{\n//\t\t\t\t\t\tlong mid = (l + h + 1) / 2;\n//\t\t\t\t\t\t\n//\t\t\t\t\t\tlong bot = 0;\n//\t\t\t\t\t\tfor(int j = 0; j < skills.length; j++)\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tif(skills[j].value < mid)\n//\t\t\t\t\t\t\t{\n//\t\t\t\t\t\t\t\tbot += mid - skills[j].value;\n//\t\t\t\t\t\t\t}\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\t\n//\t\t\t\t\t\tif(top + bot <= m)\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\tl = mid;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t\telse\n//\t\t\t\t\t\t{\n//\t\t\t\t\t\t\th = mid - 1;\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t\t\n//\t\t\t\t\tans = Math.max(ans, cf * i + cm * l);\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\t\n//\t\t\tif(ans != force)\n//\t\t\t{\n//\t\t\t\tSystem.out.println(ans + \" \" + force);\n//\t\t\t\tSystem.out.println(Arrays.toString(input));\n//\t\t\t}\n\t\t\t\n\t\t\tout.println(force);\n\t\t\t\n\t\t\tlong[] result = new long[n];\n\t\t\tfor(int b = 0; b < skills.length; b++)\n\t\t\t{\n\t\t\t\tif(b >= n - best)\n\t\t\t\t{\n\t\t\t\t\tresult[skills[b].index] = a;\n\t\t\t\t}\n\t\t\t\telse if(skills[b].value < bestMin)\n\t\t\t\t{\n\t\t\t\t\tresult[skills[b].index] = bestMin;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tresult[skills[b].index] = skills[b].value;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int c = 0; c < result.length; c++)\n\t\t\t{\n\t\t\t\tif(c > 0)\n\t\t\t\t{\n\t\t\t\t\tout.print(\" \");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tout.print(result[c]);\n\t\t\t}\n\t\t\t\n\t\t\tout.println();\n\t\t}\n\t\t\n\t\tout.close();\n\t}\n\t\n\tstatic class Skill implements Comparable<Skill>\n\t{\n\t\tlong value;\n\t\tint index;\n\t\t\n\t\tpublic Skill(long v, int i)\n\t\t{\n\t\t\tvalue = v;\n\t\t\tindex = i;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Skill o)\n\t\t{\n\t\t\treturn Long.compare(value, o.value);\n\t\t}\n\t}\n\t\n\tstatic class FastScanner\n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\t\n\t\tpublic FastScanner(InputStream input)\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(input));\n\t\t\tst = new StringTokenizer(\"\");\n\t\t}\n\t\t\n\t\tpublic String next() throws IOException\n\t\t{\n\t\t\tif(st.hasMoreTokens())\n\t\t\t{\n\t\t\t\treturn st.nextToken();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\treturn next();\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong() throws IOException\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\n/**\n * @author Pavel Mavrin\n */\npublic class B {\n\n    private void solve() throws IOException {\n        int n = nextInt();\n        long A = Long.parseLong(next());\n        long cf = Long.parseLong(next());\n        long cm = Long.parseLong(next());\n        long m = Long.parseLong(next());\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = Long.parseLong(next());\n        }\n\n        this.x = a;\n        p = new int[n];\n        for (int i = 0; i < n; i++) {\n            p[i] = i;\n        }\n        sort(0, n - 1);\n//        Arrays.sort(a);\n\n        long s1 = 0;\n        for (int i = 0; i < n; i++) {\n            s1 += (A - a[i]);\n        }\n\n        long res = 0;\n\n        int na = 0;\n        int nb = 0;\n        long nr = 0;\n\n        if (s1 <= m) {\n            res = n * cf + A * cm;\n            na = n;\n        } else {\n            int j = 0;\n            long s2 = 0;\n            for (int i = 0; i < n; i++) {\n                s1 -= (A - a[p[i]]);\n                if (s1 <= m) {\n                    while (j <= i && (a[p[j]] * j - s2) <= m - s1) {\n                        s2 += a[p[j]];\n                        j++;\n                    }\n                    long s = (s2 + m - s1) / j;\n                    long r = s * cm + (n - i - 1) * cf;\n                    if (r > res) {\n                        res = r;\n                        na = n - i - 1;\n                        nb = j;\n                        nr = s;\n                    }\n                }\n            }\n        }\n        out.println(res);\n        for (int i = 0; i < na; i++) {\n            a[p[n - 1 - i]] = A;\n        }\n        for (int i = 0; i < nb; i++) {\n            a[p[i]] = nr;\n        }\n        for (int i = 0; i < n; i++) {\n            out.print(a[i] + \" \");\n        }\n        out.println();\n    }\n\n\n    long[] x;\n    int[] p;\n\n    Random random = new Random();\n\n    private void sort(int l, int r) {\n        int i = l;\n        int j = r;\n        long xx = x[p[l + random.nextInt(r - l + 1)]];\n        while (i <= j) {\n            while (x[p[i]] < xx) i++;\n            while (x[p[j]] > xx) j--;\n            if (i <= j) {\n                int t = p[i]; p[i] = p[j]; p[j] = t;\n                i++; j--;\n            }\n        }\n        if (i < r) sort(i, r);\n        if (l < j) sort(l, j);\n    }\n\n\n    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer st;\n    PrintWriter out = new PrintWriter(System.out);\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(br.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new B().run();\n    }\n\n    private void run() throws IOException {\n        solve();\n        out.close();\n    }\n\n}\n", "label": 3}
{"src": "//package CodeForces.Round339;\n\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n/**\n * @author iisergeev ilya_sergeev@rgs.ru\n */\npublic class D614 {\n\n    public static void main(String[] args) {\n        sc sc = new sc();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int n = sc.nextInt();\n        long A = sc.nextLong();\n        long cf = sc.nextLong();\n        long cm = sc.nextLong();\n        long m = sc.nextLong();\n\n        Node[] nd = new Node[n];\n        for (int i = 0; i < n; i++) {\n            nd[i] = new Node(i, sc.nextInt());\n        }\n        Arrays.sort(nd);\n\n        long[] a = new long[n];\n        long[] b = new long[n + 1];\n\n        for (int i = 1; i < n; i++) {\n            a[i] = a[i - 1] + i * (nd[i].val - nd[i - 1].val);\n        }\n\n        for (int i = 1; i <= n; i++) {\n            b[i] = b[i - 1] + A - nd[n - i].val;\n        }\n\n        long ans = -1;\n        long minVal = 0;\n        for (int i = 0; i <= n; i++) {\n            if (b[i] > m) break;\n            long val = getMin(a, n - i - 1, m - b[i], A, nd);\n            long t = i * cf + val * cm;\n            if (t > ans) {\n                ans = t;\n                minVal = val;\n            }\n        }\n\n        out.println(ans);\n        for (int i = 0; i < n; i++) {\n            if (nd[i].val < minVal) {\n                m -= (minVal - nd[i].val);\n                nd[i].val = minVal;\n            }\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (A - nd[i].val <= m) {\n                m -= (A - nd[i].val);\n                nd[i].val = A;\n            } else {\n                break;\n            }\n        }\n        long[] res = new long[n];\n        for (Node node : nd) {\n            res[node.key] = node.val;\n        }\n        out.print(res[0]);\n        for (int i = 1; i < n; i++) {\n            out.print(\" \" + res[i]);\n        }\n        out.close();\n    }\n\n    static class Node implements Comparable<Node> {\n        long val;\n        int key;\n\n        public Node(int p, long val) {\n            this.key = p;\n            this.val = val;\n        }\n\n        @Override\n        public int compareTo(Node o) {\n            return Long.compare(val, o.val);\n        }\n    }\n\n    private static long getMin(long[] a, int lastP, long m, long A, Node[] nd) {\n\n        if (lastP < 0) return A;\n\n        long val = 0;\n        if (a[lastP] <= m) {\n            val = (nd[lastP].val + (m - a[lastP]) / (lastP + 1));\n        } else {\n            int st = 0, ed = lastP;\n            while (st + 1 < ed) {\n                int md = (st + ed) / 2;\n                if (a[md] <= m) st = md;\n                else ed = md;\n            }\n            val = (nd[st].val + (m - a[st]) / (st + 1));\n        }\n        return val > A ? A : val;\n    }\n\n    public static class sc {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public sc() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        Integer nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}\n", "label": 3}
{"src": "//package round339;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class B {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni(), A = ni(), cf = ni(), cm = ni();\n\t\tlong m = nl();\n\t\tint[] a = na(n);\n\t\tint[][] ai = new int[n][];\n\t\tfor(int i = 0;i < n;i++)ai[i] = new int[]{a[i], i};\n\t\tArrays.sort(ai, new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn a[0] - b[0];\n\t\t\t}\n\t\t});\n\t\tint[] as = new int[n];\n\t\tlong[] cum = new long[n+1];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tas[i] = ai[i][0];\n\t\t\tcum[i+1] = cum[i] + ai[i][0];\n\t\t}\n\t\t\n\t\tlong max = -1L;\n\t\tint argmax = -1;\n\t\tint arglow = -1;\n\t\t\n\t\tlong rem = m;\n\t\tfor(int perfected = 0;perfected <= n;perfected++){\n\t\t\tif(perfected > 0){\n\t\t\t\trem -= A-ai[n-perfected][0];\n\t\t\t}\n\t\t\tif(rem < 0)break;\n\t\t\t\n\t\t\tint low = 0, high = A+1; // val level\n\t\t\twhile(high - low > 1){\n\t\t\t\tint h = high+low>>>1;\n\t\t\t\tint lb = lowerBound(as, 0, n-perfected, h);\n\t\t\t\tlong cost = (long)h*lb - cum[lb-1+1];\n\t\t\t\tif(cost <= rem){\n\t\t\t\t\tlow = h;\n\t\t\t\t}else{\n\t\t\t\t\thigh = h;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong val = (long)low*cm + (long)cf*perfected;\n\t\t\tif(val > max){\n\t\t\t\tmax = val;\n\t\t\t\targmax = perfected;\n\t\t\t\targlow = low;\n\t\t\t}\n\t\t}\n\t\tout.println(max);\n\t\tint[] last = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(i >= n-argmax){\n\t\t\t\tlast[ai[i][1]] = A;\n\t\t\t}else{\n\t\t\t\tlast[ai[i][1]] = Math.max(ai[i][0], arglow);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tout.print(last[i] + \" \");\n\t\t}\n\t\tout.println();\n\t}\n\t\n\tpublic static int lowerBound(int[] a, int l, int r, int v)\n\t{\n\t\tif(l > r || l < 0 || r > a.length)throw new IllegalArgumentException();\n\t\tint low = l-1, high = r;\n\t\twhile(high-low > 1){\n\t\t\tint h = high+low>>>1;\n\t\t\tif(a[h] >= v){\n\t\t\t\thigh = h;\n\t\t\t}else{\n\t\t\t\tlow = h;\n\t\t\t}\n\t\t}\n\t\treturn high;\n\t}\n\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new B().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n\n    static void shuffleArray(int[][] ar) {\n        Random rnd = new Random();\n        for (int i = ar.length - 1; i > 0; i--) {\n            int index = rnd.nextInt(i + 1);\n            int[] a = ar[index];\n            ar[index] = ar[i];\n            ar[i] = a;\n        }\n    }\n\n    static void solve(InputReader in, OutputWriter out) {\n        int n, a, cf, cm;\n        n = in.nextInt();\n        a = in.nextInt();\n        cf = in.nextInt();\n        cm = in.nextInt();\n        long m = in.nextLong();\n\n        int[][] ar = new int[n][2];\n        for (int i = 0; i < n; i++) {\n            ar[i][0] = in.nextInt();\n            ar[i][1] = i;\n        }\n\n        shuffleArray(ar);\n        Arrays.sort(ar, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] o1, int[] o2) {\n                if (o1[0] > o2[0])\n                    return -1;\n                else if (o1[0] < o2[0])\n                    return 1;\n                else\n                    return 0;\n            }\n        });\n\n        long[] suffix = new long[n];\n        for (int i = n - 2; i >= 0; i--)\n            suffix[i] = suffix[i + 1] + (n - i - 1) * (ar[i][0] - ar[i + 1][0]);\n\n        long left = m, sum, maxSum = -1, minLvl, maxCnt = 0, ansMaxCnt = 0, ansMinLvl = 0;\n        int minIndex = 0;\n        while (maxCnt <= n && left >= 0) {\n            while (minIndex < n && (minIndex < maxCnt || left < suffix[minIndex]))\n                minIndex++;\n\n            if (minIndex == n)\n                minLvl = a;\n            else\n                minLvl = Math.min(a, ar[minIndex][0] + (left - suffix[minIndex]) / (n - minIndex));\n\n            sum = maxCnt * cf + minLvl * cm;\n            if (sum > maxSum) {\n                maxSum = sum;\n                ansMaxCnt = maxCnt;\n                ansMinLvl = minLvl;\n            }\n\n            if (maxCnt < n) {\n                maxCnt++;\n                left -= (a - ar[(int) maxCnt - 1][0]);\n            } else\n                maxCnt++;\n        }\n\n        int[] ans = new int[n];\n        for (int i = 0; i < n; i++) {\n            if (i < ansMaxCnt) ar[i][0] = a;\n            if (ar[i][0] < ansMinLvl) ar[i][0] = (int) ansMinLvl;\n\n            ans[ar[i][1]] = ar[i][0];\n        }\n\n        out.println(maxSum);\n        for (int i = 0; i < n; i++)\n            out.print(ans[i] + \" \");\n    }\n\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n        solve(in, out);\n        in.close();\n        out.close();\n    }\n\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        InputReader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n            st = null;\n        }\n\n        String nextLine() {\n            String line = null;\n            try {\n                line = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return line;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                String line = nextLine();\n                if (line == null) return null;\n                st = new StringTokenizer(line);\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        void close() {\n            try {\n                br.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    static class OutputWriter {\n        BufferedWriter bw;\n\n        OutputWriter(OutputStream os) {\n            bw = new BufferedWriter(new OutputStreamWriter(os));\n        }\n\n        void print(int i) {\n            print(Integer.toString(i));\n        }\n\n        void println(int i) {\n            println(Integer.toString(i));\n        }\n\n        void print(long l) {\n            print(Long.toString(l));\n        }\n\n        void println(long l) {\n            println(Long.toString(l));\n        }\n\n        void print(double d) {\n            print(Double.toString(d));\n        }\n\n        void println(double d) {\n            println(Double.toString(d));\n        }\n\n        void print(boolean b) {\n            print(Boolean.toString(b));\n        }\n\n        void println(boolean b) {\n            println(Boolean.toString(b));\n        }\n\n        void print(char c) {\n            try {\n                bw.write(c);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(char c) {\n            println(Character.toString(c));\n        }\n\n        void print(String s) {\n            try {\n                bw.write(s);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n\n        void println(String s) {\n            print(s);\n            print('\\n');\n        }\n\n        void close() {\n            try {\n                bw.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        FastScanner in = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        new Main().run(in, out);\n        out.close();\n    }\n\n    public static long mod = 17352642619633L;\n\n    int N;\n    long A;\n    long CF, CM;\n    long M;\n    long[][] a;\n    void run(FastScanner in, PrintWriter out) {\n\n        N = in.nextInt();\n        A = in.nextInt();\n        CF = in.nextLong();\n        CM = in.nextLong();\n        M = in.nextLong();\n\n        a = new long[N+1][2];\n        for (int i = 0; i < N; i++) {\n            a[i][0] = in.nextInt();\n            a[i][1] = i;\n        }\n\n        Arrays.sort(a, 0, N, (aa, bb) -> Long.compare(aa[0], bb[0]));\n        a[N][0] = A;\n        a[N][1] = N;\n\n        long[] p = new long[N+1];\n        for (int i = 0; i < N; i++) p[i+1] = p[i] + a[i][0];\n\n        int l = N-1;\n        long currcost = 0;\n\n        long maxScore = 0;\n        long minAtMaxScore = -1;\n        long iAtMaxScore = N;\n\n        for (int i = N; i >= 0; i--) {\n\n            long c = a[i][0];\n\n            if (l == i) l--;\n            currcost += A-c;\n\n            long remainingBudget = M-currcost;\n            if (remainingBudget < 0) break;\n\n            // what is the max value i can bring the remaining elements to?\n            long min = 0;\n\n            while (l >= 0 && (l+1)*a[l][0]-p[l+1] > remainingBudget) {\n                l--;\n            }\n            if (l == -1) {\n                min = A;\n            } else {\n                // (l+1)*min - p[l+1] = budget\n                min = Math.min(A-1, (remainingBudget + p[l+1]) / (l+1));\n            }\n\n            long currScore = (N-i)*CF + min*CM;\n\n            if (currScore > maxScore) {\n                maxScore = currScore;\n                minAtMaxScore = min;\n                iAtMaxScore = i;\n            }\n        }\n\n        long[] ret = new long[N+1];\n        for (int i = 0; i < N; i++) {\n            if (i >= iAtMaxScore) ret[(int)a[i][1]] = A;\n            else if (minAtMaxScore != -1 && a[i][0] < minAtMaxScore) ret[(int)a[i][1]] = minAtMaxScore;\n            else ret[(int)a[i][1]] = a[i][0];\n        }\n\n        out.println(maxScore);\n        for (int i = 0; i < N; i++) out.print(ret[i] + \" \");\n        out.println();\n    }\n\n    static class FastScanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n            st = null;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n/**\n * @auther chao\n * @date 16/1/15\n */\npublic class CF1 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n        int n = in.nextInt();\n        long A = in.nextLong();\n        long c1 = in.nextLong();\n        long c2 = in.nextLong();\n        long m = in.nextLong();\n        Node[] nd = new Node[n];\n        for (int i = 0; i < n; i++) {\n            nd[i] = new Node(i, in.nextInt());\n        }\n        Arrays.sort(nd);\n\n        long[] a = new long[n];\n        long[] b = new long[n+1];\n        for (int i = 1; i < n ;i++) {\n            a[i] = a[i-1]+i*(nd[i].val-nd[i-1].val);\n        }\n        for (int i = 1; i <= n; i++) {\n            b[i] = b[i-1] + A - nd[n-i].val;\n        }\n\n        long ans = -1;\n        long minVal = 0;\n        for (int i = 0; i <= n; i++) {\n            if (b[i] > m) break;\n            long val = getMin(a, n-i-1, m-b[i], A, nd);\n            long t = i*c1 + val*c2;\n            if (t > ans){\n                ans = t;\n                minVal = val;\n            }\n        }\n\n        pw.println(ans);\n        for (int i = 0; i < n ;i++) {\n            if (nd[i].val < minVal) {\n                m -= (minVal - nd[i].val);\n                nd[i].val = minVal;\n            }\n        }\n        for (int i = n-1; i >= 0; i--) {\n            if (A-nd[i].val <= m) {\n                m -= (A - nd[i].val);\n                nd[i].val = A;\n            } else {\n                break;\n            }\n        }\n        long[] res = new long[n];\n        for (Node node : nd) {\n            res[node.p] = node.val;\n        }\n        pw.print(res[0]);\n        for (int i = 1; i < n; i++) {\n            pw.print(\" \"+res[i]);\n        }\n        pw.close();\n    }\n    private static long getMin(long[] a, int lastP, long m, long A, Node[] nd) {\n        if (lastP < 0)  return A;\n        long val = 0;\n        if (a[lastP] <= m) {\n            val = (nd[lastP].val + (m-a[lastP])/(lastP+1));\n        } else {\n            int st = 0, ed = lastP;\n            while (st + 1 < ed) {\n                int md = (st+ed)/2;\n                if (a[md] <= m) st = md;\n                else ed = md;\n            }\n            val = (nd[st].val + (m-a[st])/(st+1));\n        }\n        return val > A ? A : val;\n    }\n}\nclass Node implements Comparable<Node>{\n    long val;\n    int p;\n    public Node(int p, long val) {\n        this.p = p;\n        this.val = val;\n    }\n\n    @Override\n    public int compareTo(Node o) {\n        return (int)(val - o.val);\n    }\n}", "label": 3}
{"src": "/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Node implements Comparable<Node>\n{\n\n        public long val;\n        public int index;\n        \n        public Node(long _v, int _i){\n            val = _v;\n            index = _i;\n        }\n        \n        public int compareTo(Node sec){\n            return (int) (val - sec.val);\n        }\n\n    public static void main (String[] args) throws java.lang.Exception\n    {\n        // your code goes here\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        long A = sc.nextLong();\n        int cf = sc.nextInt();\n        int cm = sc.nextInt();\n        long m = sc.nextLong();\n        \n        long[] arr = new long[n];\n        Node[] nodes = new Node[n];\n        long[] dprev = new long[n];\n        long[] dp = new long[n];\n        for (int i = 0; i < n; ++i){\n            arr[i] = sc.nextLong();      \n            nodes[i] = new Node(arr[i], i);\n        }\n        Arrays.sort(nodes);\n        for (int i = n-1; i >=0; --i){\n            dprev[i] = nodes[i].val;\n            if (i < n - 1) dprev[i] += dprev[i+1];\n        }\n        \n        for (int i = 0; i < n; ++i){\n            dp[i] = nodes[i].val;\n            if (i > 0 ) dp[i] += dp[i-1];\n        }\n        long best = 0, minLevBest = 0;\n        int maxNum = 0, minNum = 0;\n        \n        for (int i = n; i >=0; --i){\n            long rem = m;\n            if (i < n){\n                long need = (n - i) * A - dprev[i];\n                if (need > m) break;\n                rem = m - need;\n            }\n            //if (i == n -1 ) System.out.println(rem);\n            long minLev = -1;\n            int cntNum = -1;\n            if (i > 0){\n                long l = nodes[0].val, r = A;\n                \n                \n                while (l <= r){\n                    long mid = (l + r) / 2;\n                    int zl = 0, zr = i - 1;\n                    int pos = -1;                   \n                    while (zl <= zr){\n                        int zm = (zl + zr) / 2;\n                        if (nodes[zm].val > mid){\n                            zr = zm - 1;\n                        }else{\n                            pos = zm;\n                            zl = zm + 1;\n                        }\n                    }\n                    long needMin = mid * (pos + 1) - dp[pos];\n                    if (needMin <= rem){\n                        minLev = mid;\n                        cntNum = pos + 1;\n                        l = mid + 1;\n                    }else{\n                        r = mid - 1;\n                    }\n                }\n                \n            }else{\n                minLev = A;\n                cntNum = n;\n            }\n            // calculate result\n            long res = (n - i) * cf + minLev * cm;\n            if (res > best){\n                best = res;\n                maxNum = n - i;\n                minNum = cntNum;\n                minLevBest = minLev;\n                //System.out.println(best + \" \" + maxNum + \" \" + minNum + \" \" + minLev + \" \" + cf + \" \" + cm);\n            }\n        }\n        \n        // ouput best\n        System.out.println(best);\n\n        // Assign Value\n        int z = n - 1;\n        for (int i = maxNum; i > 0; --i){\n            arr[nodes[z].index] = A;\n            z--;            \n        }\n        \n        z = 0;\n        for (int i= 0; i < minNum; ++i){\n            arr[nodes[z].index] = minLevBest;\n            z++;\n        }\n        \n        for (int i = 0; i < n; ++i){\n            System.out.print(arr[i] + \" \");\n        }\n        \n        sc.close();\n    }\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    class Node implements Comparable<Node> {\n        long val;\n        int id;\n\n        @Override\n        public int compareTo(Node o) {\n            // TODO Auto-generated method stub\n            if (val < o.val) {\n                return -1;\n            } else if (val == o.val) {\n                return 0;\n            } else {\n                return 1;\n            }\n        }\n\n    }\n\n    int n;\n    long A, cf, cm;\n    long m;\n    Node[] a;\n    long[] rsum;\n    long[] lsum;\n\n    long BinerySearch(int l, int r, long val) {\n        int mid;\n        int pos = 0;\n        while (l <= r) {\n            mid = (l + r) >> 1;\n            if (lsum[mid] <= val) {\n                pos = mid;\n                l = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n        val -= lsum[pos];\n        long res = a[pos].val + val / (pos + 1);\n        res = Math.min(res, A);\n        return res;\n    }\n\n    void Solve() {\n        FastScanner scan = new FastScanner();\n        n = scan.nextInt();\n        A = scan.nextLong();\n        cf = scan.nextLong();\n        cm = scan.nextLong();\n        m = scan.nextLong();\n        a = new Node[n + 1];\n        lsum = new long[n + 1];\n        rsum = new long[n + 1];\n\n        for (int i = 0; i < n; i++) {\n            a[i] = new Node();\n            a[i].val = scan.nextLong();\n            a[i].id = i;\n        }\n\n        Arrays.sort(a, 0, n);\n\n        for (int i = 1; i < n; i++) {\n            lsum[i] = lsum[i - 1] + (a[i].val - a[i - 1].val) * i;\n        }\n        lsum[n] = Long.MAX_VALUE;\n\n        int leftMost = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            rsum[i] = rsum[i + 1] + (A - a[i].val);\n            if (rsum[i] > m) {\n                leftMost = i + 1;\n                break;\n            }\n        }\n\n        long maxP = 0;\n        int left = leftMost;\n        long MIN = A;\n        for (int i = n; i >= leftMost; i--) {\n            long mm = m - rsum[i];\n            long tmp = BinerySearch(0, i - 1, mm);\n\n            long power = tmp * cm + (n - i) * cf;\n            if (tmp == A) {\n                power = A * cm + n * cf;\n            }\n            if (power >= maxP) {\n                maxP = power;\n                left = i;\n                MIN = tmp;\n            }\n        }\n\n        long[] ans = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            int id = a[i].id;\n            ans[id] = a[i].val;\n            if (i >= left) {\n                ans[id] = A;\n            } else if (ans[id] < MIN) {\n                ans[id] = MIN;\n            }\n        }\n        \n    \n        \n        \n        PrintWriter out = new PrintWriter(System.out);\n        out.println(maxP);\n        for (int i = 0; i < n; i++) {\n            out.print(ans[i] + \" \");\n        }\n        out.println();\n        out.flush();\n    }\n\n    public static void main(String[] args) {\n        new Main().Solve();\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public boolean EOF() {\n            if (st != null && st.hasMoreTokens()) {\n                return false;\n            } else {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (line == null)\n                    return true;\n                st = new StringTokenizer(line);\n                return false;\n            }\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}", "label": 3}
{"src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport java.util.Arrays;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class ValentineProject {\n\n    int a[] = new int[100005];\n    long dp[] = new long[100005];\n    int aa[] = new int[100005];\n    long ans = 0, A2;\n    int n, cf , cm, A, mnA, tmp;\n\n    \n\n    private void solve() throws IOException {\n        n = nextInt();\n        A = nextInt();\n        cf = nextInt();\n        cm = nextInt();\n        A2 = 20000000L;\n        long m = nextLong();\n        mnA = A;\n        for(int i=1;i<=n;++i){\n            aa[i] = nextInt();\n            a[i] = aa[i];\n            mnA = min(mnA, a[i]);\n        }\n        Arrays.sort(a,1,n+1);\n        dp[0] = 0;\n        for(int i=1;i<=n;++i)\n            dp[i] = dp[i-1] + a[i];\n\n        long m2;\n        go(m, 0, n);\n        int Aindx = n + 1;\n        long prev;\n        int minimum = tmp;\n    \n        for(int i=n;i>=1;i--){\n            m2 = 1L*(n-i +1)*A - (dp[n] - dp[i-1]);\n            m2 = m - m2;\n            if( m2 < 0)\n                break;\n            prev = ans ;\n            go(m2, 1L * cf * (n-i+1), i - 1);\n            if( ans > prev){\n                Aindx = i;\n                minimum = tmp;\n            }\n        }\n        int cut = A + 1, zero = 0 ;\n        if( Aindx <= n){\n            cut = a[Aindx];\n            for(int i=Aindx;i<=n;++i){\n                if( a[i] == cut)\n                    zero ++ ;\n            }\n        }\n       System.out.println( ans );\n       for(int i=1;i<=n;++i){\n            if( aa[i] < cut)\n                aa[i] = max( aa[i], minimum);\n            else if( aa[i] > cut){\n                aa[i] = A;\n            }\n            else{\n                if( zero > 0){\n                    zero --;\n                    aa[i] = A;\n                }\n                else{\n                    aa[i] = max( aa[i] , minimum);\n                }\n            }\n       }\n        \n       for(int i=1;i<=n;++i){\n            System.out.print(aa[i] + \" \");\n       }\n       System.out.print(\"\\n\");\n    }\n\n    public void go(long m,long ans2,int idx)\n    {\n        int it = mnA, f = A, mid;\n\n        while ( it != f){\n            mid = (it + f)/2 ;\n            if( check ( mid + 1, m, idx) == true)\n                it = mid + 1;\n            else\n                f = mid;\n        }\n        tmp = f;\n        ans = max( ans, ans2 + 1L * f * cm);\n    }\n\n    public boolean check(int mn, long m,int idx)\n    {\n        if( idx == 0)\n            return true;\n        int it = 1, f = n, mid ;\n        while( it != f){\n            mid = (it + f)/2;\n            if( a[mid + 1] <= mn)\n                it = mid + 1;\n            else f = mid;\n        }\n        if(f>idx) f = idx;\n        if( 1L * f * mn - dp[f] <= m){\n             return true;\n        }\n         \n        \n         \n        return false;\n\n    }\n\n    public static void main(String[] args) {\n        // TODO code application logic here\n        new ValentineProject().run();\n    }\n    \n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer;\n    \n    public void run() {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            tokenizer = null;\n            writer = new PrintWriter(System.out);\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n    \n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n    \n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    private static int n;\n    private static long m, A, cf, cm;\n    private static Node[] a;\n    private static long[] fCost, mCost;\n\n    public static void main(String[] args) throws Exception {\n        Reader in = new Reader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n\n        n = in.nextInt();\n        A = in.nextLong();\n        cf = in.nextLong();\n        cm = in.nextLong();\n        m = in.nextLong();\n        a = new Node[n];\n        fCost = new long[n];\n        mCost = new long[n];\n\n        for (int i = 0; i < n; i++) {\n            a[i] = new Node();\n            a[i].result = a[i].value = in.nextLong();\n            a[i].index = i;\n        }\n        Arrays.sort(a, (Comparator.comparingLong(o -> o.value)));\n\n        for (int i = 1; i < n; i++) {\n            mCost[i] = mCost[i - 1] + (a[i].value - a[i - 1].value) * i;\n        }\n        for (int i = n - 1; i >= 0; i--) {\n            fCost[i] = A - a[i].value + (i != n - 1 ? fCost[i + 1] : 0);\n        }\n\n        Result result = null;\n        int mPos = -1;\n        for (int i = 0; i < n; i++) {\n            if (fCost[i] > m) continue;\n            while (mPos + 1 < i && mCost[mPos + 1] + fCost[i] <= m) {\n                mPos++;\n            }\n\n            long limit = a[mPos + 1].value;\n            if (mPos + 1 == i) limit = A;\n            Result now = getResult(mPos, i, limit);\n            if (result == null || result.ans < now.ans) {\n                result = now;\n            }\n        }\n\n        while (mPos + 1 < n && mCost[mPos + 1] <= m) {\n            mPos++;\n        }\n        Result now = getResult(mPos, n, mPos != n - 1 ? a[mPos + 1].value : A);\n        if (result == null || result.ans < now.ans) {\n            result = now;\n        }\n\n        out.println(result.ans);\n        for (int i = 0; i <= result.minPos; i++) {\n            a[i].result = result.minValue;\n        }\n        for (int i = result.APos; i < n; i++) {\n            a[i].result = A;\n        }\n        Arrays.sort(a, Comparator.comparingInt(o -> o.index));\n        for (int i = 0; i < n; i++) {\n            out.print(a[i].result);\n            out.print(' ');\n        }\n        out.println();\n\n        out.flush();\n        in.close();\n        out.close();\n    }\n\n    private static Result getResult(int minEndAt, int AStartAt, long minLimit) {\n        if (minEndAt == -1) {\n            return getAllAResult();\n        } else if (AStartAt == n) {\n            return getNoAResult(minEndAt, minLimit);\n        }\n\n        long minValue = Math.min(a[minEndAt].value + (m - fCost[AStartAt] - mCost[minEndAt]) / (minEndAt + 1), minLimit);\n        long fAns = cf * (n - AStartAt);\n        long mAns = cm * minValue;\n\n        return new Result(fAns + mAns, minEndAt, AStartAt, minValue);\n    }\n\n    private static Result getNoAResult(int minEndAt, long minLimit) {\n        long minValue = Math.min(a[minEndAt].value + (m - mCost[minEndAt]) / (minEndAt + 1), minLimit);\n        long mAns = cm * minValue;\n        return new Result(mAns, minEndAt, n, minValue);\n    }\n\n    private static Result getAllAResult() {\n        return new Result(cf * n + cm * A, -1, 0, A);\n    }\n\n    static class Result {\n        long ans;\n        int minPos, APos;\n        long minValue;\n\n        public Result(long ans, int minPos, int APos, long minValue) {\n            this.ans = ans;\n            this.minPos = minPos;\n            this.APos = APos;\n            this.minValue = minValue;\n        }\n    }\n\n    static class Node {\n        long value, result;\n        int index;\n    }\n\n    static class Reader {\n        BufferedReader reader;\n        StringTokenizer st;\n\n        Reader(InputStreamReader stream) {\n            reader = new BufferedReader(stream);\n            st = null;\n        }\n\n        void close() throws IOException {\n            reader.close();\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        String nextLine() throws IOException {\n            return reader.readLine();\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n    }\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringTokenizer;\n\n\npublic class SkillsScore {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line = in.readLine();\n\t\tStringTokenizer st = new StringTokenizer(line);\n\n\t\tfinal int n = Integer.parseInt(st.nextToken());\n\t\tfinal int A = Integer.parseInt(st.nextToken());\n\t\tfinal int cj = Integer.parseInt(st.nextToken());\n\t\tfinal int cm = Integer.parseInt(st.nextToken());\n\t\tfinal long m = Long.parseLong(st.nextToken());\n\n\t\tint[][] a = new int[n][2];\n\t\tline = in.readLine();\n\t\tst = new StringTokenizer(line);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i][0] = Integer.parseInt(st.nextToken());\n\t\t\ta[i][1] = i;\n\t\t}\n\n\t\tArrays.sort(a, new ArrayComp(0));\n\t\t\n\t\tlong[] runningSum = new long[n];\n\t\tlong last = 0;\n\t\tlong lastLevel = a[0][0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tlast += (a[i][0] - lastLevel) * (i);\n\t\t\trunningSum[i] = last;\n\t\t\tlastLevel = a[i][0];\n\t\t}\n\t\t\n\t\tlong max = 0;\n\t\tint maxNum = 0, maxIdx = -1;\n\t\tlong left = m, bestInc = 0;\n\t\tint perfNum = 0;\n\t\tfor ( int i = 0; i <= n && left >= 0; i++) {\n\t\t\t\n\t\t\tif ( i > 0) {\n\t\t\t\tleft -= (A - a[n-i][0]);\n\t\t\t\tperfNum++;\n\t\t\t}\n\t\t\t\n\t\t\tif ( left < 0 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tlong score = perfNum * cj;\n\t\t\tint idx = Arrays.binarySearch(runningSum, left);\n\t\t\tif ( idx < 0 ) {\n\t\t\t\tidx = - idx  - 2;\n\t\t\t}\n\t\t\tif ( idx < 0) {\n\t\t\t\t// should not happen\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tif (idx >= n - i ) {\n\t\t\t\tidx = n - i - 1;\n\t\t\t}\n\t\t\tlong inc = A;\n\t\t\tif ( idx >= 0 ) \n\t\t\t\tinc = a[idx][0] + (left - runningSum[idx])/(idx+1);\n\t\t\tif ( inc > A ) {\n\t\t\t\tinc = A;\n\t\t\t}\n\t\t\tscore += inc * cm;\n\t\t\t\n\t\t\tif ( score > max) {\n\t\t\t\tmax = score;\n\t\t\t\tmaxNum = i;\n\t\t\t\tmaxIdx = idx;\n\t\t\t\tbestInc = inc;\n\t\t\t\t//System.out.format(\"max = %d, i = %d, idx = %d, perfNum = %d\\n\", max, i, idx, perfNum);\n\t\t\t}\n\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= maxNum; i++) {\n\t\t\ta[n-i][0] = A;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i <= maxIdx; i++) {\n\t\t\ta[i][0] = (int) bestInc;\n\t\t}\n\t\t\n\t\tArrays.sort(a, new ArrayComp(1));\n\t\tSystem.out.println(max);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(a[0][0]);\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tsb.append(\" \").append(a[i][0]);\n\t\t}\n\t\tSystem.out.println(sb.toString());\n\t}\n\n\tprivate static class ArrayComp implements Comparator<int[]> {\n\n\t\tprivate final int idx;\n\t\tprivate ArrayComp(int idx) {\n\t\t\tthis.idx = idx;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn o1[idx] - o2[idx];\n\t\t}\n\t\t\n\t}\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.*;\n\n/*2A*/\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tMain mainClass = new Main();\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st;\n\n\tpublic String next() throws Exception {\n\t\tif (st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() throws Exception {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\n\n\tpublic double nextDouble() throws Exception {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic long nextLong() throws Exception {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic Main() throws Exception {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n\n\t\tsolve();\n\t\tout.close();\n\t}\n\n\n\tint n;\n\tint [] a;\n\tlong [] s;\n\tlong m;\n\tint A;\n\tint cf, cm;\n\tEntry [] e ;\n\tlong getSum(int from, int to) {\n\t\tif (from > to)\n\t\t\treturn 0L;\n\t\treturn s[to] - s[from-1];\n\t}\n\tstatic class Entry {\n\t\tint val, idx, req;\n\t\tEntry(int _val, int _idx) {\n\t\t\tval = _val; idx = _idx;\n\t\t}\n\t}\n\n\n\tpublic void solve() throws Exception {\n\n\t\tn = nextInt();\n\t\tA = nextInt();\n\t\tcf = nextInt();\n\t\tcm = nextInt();\n\t\tm = nextLong();\n\t\ta = new int [n + 1];\n\t\ts = new long [n + 1];\n\t\te = new Entry [n+1];\n\t\tfor (int i = 1 ; i <= n ; i++) {\n\t\t\ta[i] = nextInt();\n\t\t\te[i] = new Entry(a[i], i);\n\t\t}\n\t\tArrays.sort(a, 1, n+1);\n\t\tComparator<Entry> byVal = new Comparator<Entry>() {\n\t\t\tpublic int compare(Entry l, Entry r) {\n\t\t\t\treturn l.val - r.val;\n\t\t\t}\n\t\t};\n\t\tComparator<Entry> byIdx = new Comparator<Entry>() {\n\t\t\tpublic int compare(Entry l, Entry r) {\n\t\t\t\treturn l.idx - r.idx;\n\t\t\t}\n\t\t};\n\t\tArrays.sort(e, 1, n + 1, byVal);\n\t\tfor (int i = 1 ; i <= n ; i++) {\n\t\t\ts[i] = s[i-1] + a[i];\n\t\t}\n\t\tlong best = 0;\n\t\tint p = n;\n\t\tint bb = 0, kk = 0;\n\t\tfor (int k = 0 ; k <= n ; k++) {\n\t\t\tlong mRemaining = m - (1L * A * k - getSum(n-k+1, n));\n\t\t\tif (mRemaining < 0)\n\t\t\t\tbreak;\n\t\t\t\n\t\t\t//out.println(\"k = \" + k);\n\t\t\t//out.println(\"mRemaining = \" + mRemaining);\n\t\t\t/*b = a[p];\n\t\t\twhile (getSum(1, p) + mRemaining < 1L*A*b) {\n\t\t\t\tb --;\n\t\t\t\twhile (b < a[p])\n\t\t\t\t\tp--;\n\t\t\t}*/\n\n\t\t\tp = Math.min(n - k, p);\n\t\t\tif (p == 0) {\n\t\t\t\tif (best < 1L*n*cf + 1L*A*cm) {\n\t\t\t\t\tbest = 1L*n*cf + 1L*A*cm;\n\t\t\t\t\tbb = A;\n\t\t\t\t\tkk = n;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (a[p] >= A)\n\t\t\t\tcontinue;\n\t\t\twhile (getSum(1, p) + mRemaining < 1L * a[p] * p) {\n\t\t\t\tp --;\n\t\t\t}\n\t\t\t//out.println(\"p = \" + p);\n\t\t\tlong required = 1L * p * a[p] - getSum(1, p); // <= mRemaining\n\n\t\t\tlong rest = mRemaining - required;\n\t\t\tint b = (int)(rest / p) + a[p];\n\t\t\tif (b > A)\n\t\t\t\tb = A;\n\t\t\t//out.println(\"b = \" + b);\n\t\t\tif (best < 1L * b * cm + 1l* k * cf) {\n\t\t\t\tbest = \t1L * b * cm + 1l* k * cf;\n\t\t\t\tbb = b;\n\t\t\t\tkk = k;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tout.println(best);\n\t\tfor (int i = 1 ; i <= n ; i++) {\n\t\t\tif (e[i].val < bb)\n\t\t\t\te[i].val = bb;\n\t\t\tif (i + kk - 1 >= n) {\n\t\t\t\te[i].val = A;\n\t\t\t}\n\t\t}\n\t\tArrays.sort(e, 1, n + 1, byIdx);\n\t\tfor (int i = 1 ; i <= n ; i ++) {\n\t\t\tout.print(e[i].val + \" \");\n\t\t}\n\t}\n}", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n\n\npublic class Main {\n\n    public static void main(String[] args)\n    {\n        InputReader in = new InputReader(System.in);\n        OutputWriter out = new OutputWriter(System.out);\n        int n = in.nextInt();\n        long A = in.nextLong();\n        long cf = in.nextLong();\n        long cm = in.nextLong();\n        long m = in.nextLong();\n        long[]a = new long[n];\n        long[]index= new long[n];\n\n        for (int i =0;i<n;i++)\n        {\n            a[i]=in.nextLong();\n            index[i]=i;\n        }\n        MergeSort(a,index,0,n-1);\n        long[] preMin= new long[n];\n        long[]postMax = new long[n+1];\n        for (int i =1;i<n;i++)\n        {\n            preMin[i]+=(long)(preMin[i-1]+(i*(a[i]-a[i-1])));\n        }\n        postMax[n-1]= A-a[n-1];\n        for (int i =n-2;i>=0;i--)\n        {\n            postMax[i]=(long)(postMax[i+1]+(A-a[i]));\n        }\n        int t1=-1;\n        int t2=-1;\n        long max=0;\n    long incMin=0;\n        for (int i=n;i>=0;i--)\n        {\n            int start=0;\n            int end=i-1;\n            int h =-1;\n            long min=0;\n            long k = m-postMax[i];\n\n                if (k >= 0) {\n                    while (end >= start) {\n                        int mid = (start + end) / 2;\n                        if (preMin[mid] <= k) {\n                            h = mid;\n                            start = mid + 1;\n\n                        } else\n                            end = mid - 1;\n                    }\n                    long current=0;\n                    if (h>-1) {\n                        min = Math.min((k - preMin[h]) / (h + 1) + a[h], A);\n                        current = (long) (min * cm);\n                        current += (long) ((n - i) * cf);\n\n                    }\n                    else\n                    {\n                        current=(long)(A*cm);\n                        current+=(long)((n-i)*cf);\n                    }\n\n\n\n                    if (current >= max) {\n                        max = current;\n                        t1 = i;\n                        t2 = h;\n                        incMin = min;\n                    }\n                }\n\n\n        }\n\n    out.printLine(max);\n        for (int i =0;i<=t2;i++)\n            a[i]=(long)incMin;\n        for (int i =t1;i<n;i++)\n            a[i]=A;\n\n        MergeSort(index,a,0,n-1);\n        for (long item:a\n             ) {\n            out.print(item+\" \");\n        }\n        out.flush();\n    }\n    static void MergeSort(long[] a, long[] b,  int p, int r)\n    {\n        if (p < r)\n        {\n            int q = (r + p) / 2;\n            MergeSort(a, b,  p, q);\n            MergeSort(a, b,  q + 1, r);\n            Merge(a, b, p, q, r);\n        }\n    }\n    static void Merge(long[] a, long[] b,int p, int q, int r)\n    {\n        int n1 = q - p + 1;\n        int n2 = r - q;\n        long[] R = new long[n1 + 1];\n        long[] L = new long[n2 + 1];\n        long[] R1 = new long[n1];\n        long[] L1 = new long[n2];\n\n        for (int i = 0; i < n1; i++)\n        {\n            R[i] = a[p + i];\n            R1[i] = b[p + i];\n\n        }\n        R[n1] = Integer.MAX_VALUE;\n        for (int i = 0; i < n2; i++)\n        {\n            L[i] = a[q + i + 1];\n            L1[i] = b[q + i + 1];\n\n        }\n        L[n2] =Integer.MAX_VALUE;\n        int n = a.length;\n        int j = 0;\n        int k = 0;\n        for (int i = p; i <= r; i++)\n        {\n            if (L[j] < R[k])\n            {\n                a[i] = L[j];\n                b[i] = L1[j];\n\n                j++;\n            }\n            else if (L[j]>R[k])\n            {\n                a[i] = R[k];\n                b[i] = R1[k];\n\n                k++;\n            }\n            else\n            {\n                if (L1[j] < R1[k])\n                {\n                    a[i] = L[j];\n                    b[i] = L1[j];\n\n                    j++;\n                }\n                else\n                {\n                    a[i] = R[k];\n                    b[i] = R1[k];\n\n                    k++;\n                }\n            }\n\n        }\n    }\n}\n\n\n\n\n\n\n\nclass pair  implements Comparable\n{\n\n    int key;\n    int value;\n    public pair(Object key, Object value) {\n\n        this.key = (int)key;\n        this.value=(int)value;\n    }\n\n    @Override\n    public int compareTo(Object o) {\n        pair temp =(pair)o;\n        return  key-temp.key;\n    }\n}\nclass Graph {\n\n\n    int n;\n    ArrayList<Integer>[] adjList;\n\n    public Graph(int n) {\n        this.n = n;\n        adjList = new ArrayList[n];\n        for (int i = 0; i < n; i++)\n            adjList[i] = new ArrayList<>();\n    }\n\n}\n\n\nclass InputReader {\n\n    private final InputStream stream;\n    private final byte[] buf = new byte[8192];\n    private int curChar, snumChars;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (snumChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= snumChars) {\n            curChar = 0;\n            try {\n                snumChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (snumChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public long nextLong() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        long res = 0;\n        do {\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public int[] nextIntArray(int n) {\n        int a[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = nextInt();\n        }\n        return a;\n    }\n\n    public String readString() {\n        int c = read();\n        while (isSpaceChar(c)) {\n            c = read();\n        }\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isSpaceChar(c));\n        return res.toString();\n    }\n\n    public String nextLine() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        StringBuilder res = new StringBuilder();\n        do {\n            res.appendCodePoint(c);\n            c = read();\n        } while (!isEndOfLine(c));\n        return res.toString();\n    }\n\n    public boolean isSpaceChar(int c) {\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    private boolean isEndOfLine(int c) {\n        return c == '\\n' || c == '\\r' || c == -1;\n    }\n\n}\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object... objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n\n    public void printLine(Object... objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n    public void flush() {\n        writer.flush();\n    }\n\n}", "label": 3}
{"src": "// package codeforces.cr339.div1;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\n/**\n * Created by hama_du on 2016/01/21.\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n        long upto = in.nextLong();\n        long perfectV = in.nextLong();\n        long minimumV = in.nextLong();\n        long money = in.nextLong();\n        long[][] skills = new long[n][2];\n        for (int i = 0; i < n ; i++) {\n            skills[i][0] = i;\n            skills[i][1] = in.nextLong();\n        }\n        Arrays.sort(skills, (o1, o2) -> Long.compare(o1[1], o2[1]));\n\n\n        long[] s = new long[n];\n        for (int i = 0 ; i < n ; i++) {\n            s[i] = skills[i][1];\n        }\n\n        long[] imos = new long[n];\n        for (int i = 0 ; i < n ; i++) {\n            imos[i] = ((i >= 1) ? imos[i-1] : 0) + s[i];\n        }\n\n        long best = 0;\n        int bestPerfectIdx = n;\n        long bestMinimum = 0;\n\n        long makePerfect = 0;\n        for (int i = n ; i >= 0 ; i--) {\n            if (i < n) {\n                makePerfect += upto-s[i];\n            }\n            if (makePerfect > money) {\n                break;\n            }\n            long score = (n-i)*perfectV;\n            long min = upto;\n            if (i >= 1) {\n                min = solveMinimum(s, imos, i, money-makePerfect, upto);\n                score += min * minimumV;\n            } else {\n                score += upto * minimumV;\n            }\n            if (score > best) {\n                best = score;\n                bestPerfectIdx = i;\n                bestMinimum = min;\n            }\n        }\n\n        for (int i = n-1 ; i >= bestPerfectIdx ; i--) {\n            skills[i][1] = upto;\n        }\n        for (int i = 0 ; i < n ; i++) {\n            if (skills[i][1] < bestMinimum) {\n                skills[i][1] = bestMinimum;\n            }\n        }\n        Arrays.sort(skills, (o1, o2) -> Long.compare(o1[0], o2[0]));\n\n        out.println(best);\n        StringBuilder line = new StringBuilder();\n        for (int i = 0 ; i < n ; i++) {\n            line.append(' ').append(skills[i][1]);\n        }\n        out.println(line.substring(1));\n        out.flush();\n    }\n\n    private static long solveMinimum(long[] s, long[] lsum, int to, long money, long limit) {\n        long max = limit+1;\n        long min = s[0];\n        while (max - min > 1) {\n            long med = (max+min)/2;\n\n            int left = 0;\n            int right = to;\n            while (right - left > 1) {\n                int m = (right + left) / 2;\n                if (s[m] > med) {\n                    right = m;\n                } else {\n                    left = m;\n                }\n            }\n            long need = med * (left+1);\n            need -= lsum[left];\n            if (need > money) {\n                max = med;\n            } else {\n                min = med;\n            }\n        }\n        return min;\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int next() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public char nextChar() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            if ('a' <= c && c <= 'z') {\n                return (char) c;\n            }\n            if ('A' <= c && c <= 'Z') {\n                return (char) c;\n            }\n            throw new InputMismatchException();\n        }\n\n        public String nextToken() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = next();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public int nextInt() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = next();\n            while (isSpaceChar(c))\n                c = next();\n            long sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = next();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c-'0';\n                c = next();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    static void debug(Object... o) {\n        System.err.println(Arrays.deepToString(o));\n    }\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\npublic class skills {\n    static int n,cf,cm;\n    static long a,m;\n    static pair[] arr;\n    static long[] suffix,prefix,arr2;\n    public static void main(String[] args) throws Exception\n    {\n        InputReader in=new InputReader(System.in);\n        PrintWriter pw=new PrintWriter(System.out);\n        n=in.nextInt();\n        a=in.nextLong();\n        cf=in.nextInt();\n        cm=in.nextInt();\n         m=in.nextLong();\n         arr=new pair[n];\n         for(int i=0;i<n;i++)\n         {\n             arr[i]=new pair(i,in.nextLong());\n         }\n         Arrays.sort(arr);\n         prefix=new long[n];\n         arr2=new long[n];\n         suffix=new long[n+1];\n         prefix[0]=arr[0].val;\n         arr2[0]=prefix[0];\n         for(int i=1;i<n;i++)\n         {\n             prefix[i]=prefix[i-1]+arr[i].val;\n             arr2[i]=arr[i].val;\n         }\n         suffix[n-1]=arr[n-1].val;\n         for(int i=n-2;i>=0;i--)\n         {\n             suffix[i]=suffix[i+1]+arr[i].val;\n         }\n         long[] ans=new long[n+1];\n         long[] t2=new long[n+1];\n         for(int i=0;i<n;i++)\n         {\n             long money=i*a-suffix[n-i];\n             long rem=m-money;\n             if(rem>=0 )\n             {\n                 ans[i]=i*cf;\n                 long val=binarysearch(rem,n-i-1);\n                 ans[i]+=val*cm;\n                 t2[i]=val;\n                 \n             }\n             else\n             {\n                 ans[i]=0;\n             }\n         }\n         long temp4=n*a-suffix[0];\n         long rem4=m-temp4;\n         if(rem4>=0)\n         {\n             ans[n]=n*cf+a*cm;\n         }\n        int ma=0;\n        for(int i=1;i<=n;i++)\n        {\n            if(ans[i]>ans[ma])\n            {\n                ma=i;\n            }\n        }\n        /*System.out.println(\"ans array is\");\n        for(int i=0;i<=n;i++)\n        {\n            System.out.println(ans[i]+\" \"+t2[i]);\n        }\n        System.out.println(\"ans closed\");*/\n        \n        pw.println(ans[ma]);\n        long[] temp=new long[n];\n        for(int i=1;i<=ma;i++)\n        {\n            temp[arr[n-i].index]=a;\n        }\n        for(int i=0;i<n-ma;i++)\n        {\n            if(arr[i].val<t2[ma])\n            {\n                temp[arr[i].index]=t2[ma];\n            }\n            else\n            {\n                temp[arr[i].index]=arr[i].val;\n            }\n        }\n        for(int i=0;i<n;i++)\n        {\n            pw.print(temp[i]+\" \");\n        }\n        \n        \n         \n         \n        \n        pw.close();\n    }\n    public static long binarysearch(long rem,int im)\n    {\n        long left=0;\n        long right=a;\n        while(left<right)\n        {\n            if(right==left+1)\n            {\n                int index=binarysearch2(right,im);\n                long req=(index+1)*right-prefix[index];\n                if(req<=rem)\n                {\n                    return right;\n                }\n                else\n                {\n                    return left;\n                }\n                \n            }\n            long mid=(left+right)>>1;\n            int index=binarysearch2(mid,im);\n            if(index==-1)\n            {\n                left=mid+1;\n            }\n            else\n            {\n                long req=(index+1)*mid-prefix[index];\n                if(req<=rem)\n                {\n                    left=mid;\n                }\n                else\n                {\n                    right=mid-1;\n                }\n            }\n            \n        }\n        return left;\n    }\n    public static int binarysearch2(long val,int im)\n    {\n        if(arr2[0]>val)\n        {\n            return -1;\n        }\n        int l=0;\n        int r=im;\n        while(l<r)\n        {\n            if(r==l+1)\n            {\n                if(arr2[r]<=val)\n                {\n                    return r;\n                }\n                else\n                {\n                    return l;\n                }\n            }\n            int mid=(l+r)>>1;\n                if(arr2[mid]<=val)\n                {\n                    l=mid;\n                }\n                else\n                {\n                    r=mid-1;\n                }\n            \n        }\n        return l;\n        \n    }\n    \n    \n    static class pair implements Comparable<pair>\n    {\n        int index;\n        long val;\n        public pair(int i,long val)\n        {\n            this.index=i;\n            this.val=val;\n        }\n        public int compareTo(pair p1) {\n            return Long.compare(this.val, p1.val);\n        }\n        \n    }\n    \n    \n    \n    \n    \n    \n    \n     static class InputReader {\n\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int snumChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int snext() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n\n            int res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n        \n        public long nextLong() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = snext();\n            }\n\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n        \n        public String readString() {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n}\n", "label": 3}
{"src": "import java.awt.*;\nimport java.io.*;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.util.List;\n\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\n\n\npublic class B implements Runnable{\n\n    // SOLUTION!!!\n    // HACK ME PLEASE IF YOU CAN!!!\n    // PLEASE!!!\n    // PLEASE!!!\n    // PLEASE!!!\n\n    private final static Random rnd = new Random();\n    private final static String fileName = \"\";\n\n    private void solve() {\n        final int n = readInt();\n        final int maxSkill = readInt();\n\n        final long costFull = readInt();\n        final long costMin = readInt();\n\n        final long money = readLong();\n\n        final int[] skills = readIntArray(n);\n\n        final NavigableMap<Integer, Integer> counts = new TreeMap<>();\n        counts.put(0, 0);\n        counts.put(maxSkill, 0);\n\n        for (int skill : skills) {\n            inc(counts, skill);\n        }\n\n        final NavigableMap<Integer, Integer> prefixCounts = new TreeMap<>();\n\n        int curCount = 0;\n        for (Map.Entry<Integer, Integer> e : counts.entrySet()) {\n            curCount += e.getValue();\n            prefixCounts.put(e.getKey(), curCount);\n        }\n\n        final IntIndexPair[] sortedSkills = IntIndexPair.from(skills);\n        Arrays.sort(sortedSkills, IntIndexPair.increaseComparator);\n\n        final long[] costsToMax = new long[n + 1];\n        for (int i = n - 1; i >= 0; --i) {\n            costsToMax[i] = costsToMax[i + 1] + maxSkill - sortedSkills[i].value;\n        }\n\n        final long[] prefixSums = new long[n];\n        for (int i = 0; i < n; ++i) {\n            prefixSums[i] = (i == 0 ? 0 : prefixSums[i - 1]) + sortedSkills[i].value;\n        }\n\n        if (money >= costsToMax[0]) {\n            long totalSum = power(maxSkill, costMin, n, costFull);\n            out.println(totalSum);\n\n            for (int i = 0; i < n; ++i) {\n                out.print(maxSkill + \" \");\n            }\n            out.println();\n        } else {\n            long answer = -1;\n            int answerMinRaisedToMaxSkillIndex = -1;\n            int answerMinTotalSkill = -1;\n\n            final int curMaxSkillCount = counts.get(maxSkill);\n            for (int maxSkillCount = curMaxSkillCount; maxSkillCount < n; ++maxSkillCount) {\n                int minRaisedToMaxSkillIndex = n - maxSkillCount;\n\n                long costToMax = costsToMax[minRaisedToMaxSkillIndex];\n                if (costToMax > money) {\n                    continue;\n                }\n\n                long moneyForMinRaising = money - costToMax;\n\n                int minTotalSkill = -1;\n                for (int left = sortedSkills[0].value, right = maxSkill; left <= right; ) {\n                    int mid = ((left + right) >> 1);\n\n                    int midCount = prefixCounts.floorEntry(mid).getValue();\n                    midCount = min(midCount, minRaisedToMaxSkillIndex);\n\n                    long needMoney = mid * 1L * midCount - prefixSums[midCount - 1];\n                    if (needMoney <= moneyForMinRaising) {\n                        minTotalSkill = mid;\n                        left = mid + 1;\n                    } else {\n                        right = mid - 1;\n                    }\n                }\n\n                long curPower = power(minTotalSkill, costMin, maxSkillCount, costFull);\n                if (answer < curPower) {\n                    answer = curPower;\n                    answerMinRaisedToMaxSkillIndex = minRaisedToMaxSkillIndex;\n                    answerMinTotalSkill = minTotalSkill;\n                }\n            }\n\n            out.println(answer);\n\n            int[] updatedSkills = new int[n];\n            for (int i = 0; i < answerMinRaisedToMaxSkillIndex; ++i) {\n                updatedSkills[sortedSkills[i].index] = answerMinTotalSkill;\n            }\n\n            for (int i = answerMinRaisedToMaxSkillIndex; i < n; ++i) {\n                updatedSkills[sortedSkills[i].index] = maxSkill;\n            }\n            \n            for (int i = 0; i < n; ++i) {\n                updatedSkills[i] = max(updatedSkills[i], skills[i]);\n            }\n\n            for (int skill : updatedSkills) {\n                out.print(skill + \" \");\n            }\n            out.println();\n        }\n    }\n\n    long power(int minSkill, long costMin, int maxCount, long costFull) {\n        return minSkill * costMin + maxCount * costFull;\n    }\n\n    void inc(Map<Integer, Integer> counts, int value) {\n        int count = counts.getOrDefault(value, 0);\n        counts.put(value, count + 1);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private final static boolean FIRST_INPUT_STRING = false;\n    private final static boolean MULTIPLE_TESTS = true;\n    private final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n    private final static int MAX_STACK_SIZE = 128;\n\n    private final static boolean OPTIMIZE_READ_NUMBERS = false;\n\n    /////////////////////////////////////////////////////////////////////\n\n    public void run(){\n        try{\n            timeInit();\n            Locale.setDefault(Locale.US);\n\n            init();\n\n            if (ONLINE_JUDGE) {\n                solve();\n            } else {\n                do {\n                    try {\n                        timeInit();\n                        solve();\n                        time();\n\n                        out.println();\n                    } catch (NumberFormatException e) {\n                        break;\n                    } catch (NullPointerException e) {\n                        if (FIRST_INPUT_STRING) break;\n                        else throw e;\n                    }\n                } while (MULTIPLE_TESTS);\n            }\n\n            out.close();\n            time();\n        }catch (Exception e){\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private BufferedReader in;\n    private OutputWriter out;\n    private StringTokenizer tok = new StringTokenizer(\"\");\n\n    public static void main(String[] args){\n        new Thread(null, new B(), \"\", MAX_STACK_SIZE * (1L << 20)).start();\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private void init() throws FileNotFoundException{\n        Locale.setDefault(Locale.US);\n\n        if (ONLINE_JUDGE){\n            if (fileName.isEmpty()) {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new OutputWriter(System.out);\n            } else {\n                in = new BufferedReader(new FileReader(fileName + \".in\"));\n                out = new OutputWriter(fileName + \".out\");\n            }\n        }else{\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new OutputWriter(\"output.txt\");\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////\n\n    private long timeBegin;\n\n    private void timeInit() {\n        this.timeBegin = System.currentTimeMillis();\n    }\n\n    private void time(){\n        long timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    private void debug(Object... objects){\n        if (ONLINE_JUDGE){\n            for (Object o: objects){\n                System.err.println(o.toString());\n            }\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private String delim = \" \";\n\n    private String readLine() {\n        try {\n            return in.readLine();\n        } catch (IOException e) {\n            throw new RuntimeIOException(e);\n        }\n    }\n\n    private String readString() {\n        try {\n            while(!tok.hasMoreTokens()){\n                tok = new StringTokenizer(readLine());\n            }\n\n            return tok.nextToken(delim);\n        } catch (NullPointerException e) {\n            return null;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////\n\n    private final char NOT_A_SYMBOL = '\\0';\n\n    private char readChar() {\n        try {\n            int intValue = in.read();\n\n            if (intValue == -1){\n                return NOT_A_SYMBOL;\n            }\n\n            return (char) intValue;\n        } catch (IOException e) {\n            throw new RuntimeIOException(e);\n        }\n    }\n\n    private char[] readCharArray() {\n        return readLine().toCharArray();\n    }\n\n    private char[][] readCharField(int rowsCount) {\n        char[][] field = new char[rowsCount][];\n        for (int row = 0; row < rowsCount; ++row) {\n            field[row] = readCharArray();\n        }\n\n        return field;\n    }\n\n    /////////////////////////////////////////////////////////////////\n\n    private long optimizedReadLong() {\n        int sign = 1;\n        long result = 0;\n        boolean started = false;\n        while (true) {\n            try {\n                int j = in.read();\n                if (-1 == j) {\n                    if (started) return sign * result;\n                    throw new NumberFormatException();\n                }\n\n                if (j == '-') {\n                    if (started) throw new NumberFormatException();\n                    sign = -sign;\n                }\n\n                if ('0' <= j && j <= '9') {\n                    result = result * 10 + j - '0';\n                    started = true;\n                } else if (started) {\n                    return sign * result;\n                }\n            } catch (IOException e) {\n                throw new RuntimeIOException(e);\n            }\n        }\n    }\n\n    private int readInt() {\n\n        if (!OPTIMIZE_READ_NUMBERS) {\n            return Integer.parseInt(readString());\n        } else {\n            return (int) optimizedReadLong();\n        }\n    }\n\n    private int[] readIntArray(int size) {\n        int[] array = new int[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readInt();\n        }\n\n        return array;\n    }\n\n    private int[] readSortedIntArray(int size) {\n        Integer[] array = new Integer[size];\n\n        for (int index = 0; index < size; ++index) {\n            array[index] = readInt();\n        }\n        Arrays.sort(array);\n\n        int[] sortedArray = new int[size];\n        for (int index = 0; index < size; ++index) {\n            sortedArray[index] = array[index];\n        }\n\n        return sortedArray;\n    }\n\n    private int[] readIntArrayWithDecrease(int size) {\n        int[] array = readIntArray(size);\n\n        for (int i = 0; i < size; ++i) {\n            array[i]--;\n        }\n\n        return array;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n\n    private int[][] readIntMatrix(int rowsCount, int columnsCount) {\n        int[][] matrix = new int[rowsCount][];\n\n        for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n            matrix[rowIndex] = readIntArray(columnsCount);\n        }\n\n        return matrix;\n    }\n\n    private int[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) {\n        int[][] matrix = new int[rowsCount][];\n\n        for (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n            matrix[rowIndex] = readIntArrayWithDecrease(columnsCount);\n        }\n\n        return matrix;\n    }\n\n    ///////////////////////////////////////////////////////////////////\n\n    private long readLong() {\n        if (!OPTIMIZE_READ_NUMBERS) {\n            return Long.parseLong(readString());\n        } else {\n            return optimizedReadLong();\n        }\n    }\n\n    private long[] readLongArray(int size) {\n        long[] array = new long[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readLong();\n        }\n\n        return array;\n    }\n\n    ////////////////////////////////////////////////////////////////////\n\n    private double readDouble() {\n        return Double.parseDouble(readString());\n    }\n\n    private double[] readDoubleArray(int size) {\n        double[] array = new double[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readDouble();\n        }\n\n        return array;\n    }\n\n    ////////////////////////////////////////////////////////////////////\n\n    private BigInteger readBigInteger() {\n        return new BigInteger(readString());\n    }\n\n    private BigDecimal readBigDecimal() {\n        return new BigDecimal(readString());\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private Point readPoint() {\n        int x = readInt();\n        int y = readInt();\n        return new Point(x, y);\n    }\n\n    private Point[] readPointArray(int size) {\n        Point[] array = new Point[size];\n\n        for (int index = 0; index < size; ++index){\n            array[index] = readPoint();\n        }\n\n        return array;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    @Deprecated\n    private List<Integer>[] readGraph(int vertexNumber, int edgeNumber) {\n        @SuppressWarnings(\"unchecked\")\n        List<Integer>[] graph = new List[vertexNumber];\n\n        for (int index = 0; index < vertexNumber; ++index){\n            graph[index] = new ArrayList<>();\n        }\n\n        while (edgeNumber-- > 0){\n            int from = readInt() - 1;\n            int to = readInt() - 1;\n\n            graph[from].add(to);\n            graph[to].add(from);\n        }\n\n        return graph;\n    }\n\n    private static class GraphBuilder {\n\n        final int size;\n        final List<Integer>[] edges;\n\n        static GraphBuilder createInstance(int size) {\n            List<Integer>[] edges = new List[size];\n            for (int v = 0; v < size; ++v) {\n                edges[v] = new ArrayList<>();\n            }\n\n            return new GraphBuilder(edges);\n        }\n\n        private GraphBuilder(List<Integer>[] edges) {\n            this.size = edges.length;\n            this.edges = edges;\n        }\n\n        public void addEdge(int from, int to) {\n            addDirectedEdge(from, to);\n            addDirectedEdge(to, from);\n        }\n\n        public void addDirectedEdge(int from, int to) {\n            edges[from].add(to);\n        }\n\n        public int[][] build() {\n            int[][] graph = new int[size][];\n            for (int v = 0; v < size; ++v) {\n                List<Integer> vEdges = edges[v];\n                graph[v] = castInt(vEdges);\n            }\n\n            return graph;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class IntIndexPair {\n\n        static Comparator<IntIndexPair> increaseComparator = new Comparator<B.IntIndexPair>() {\n\n            @Override\n            public int compare(B.IntIndexPair indexPair1, B.IntIndexPair indexPair2) {\n                int value1 = indexPair1.value;\n                int value2 = indexPair2.value;\n\n                if (value1 != value2) return value1 - value2;\n\n                int index1 = indexPair1.index;\n                int index2 = indexPair2.index;\n\n                return index1 - index2;\n            }\n        };\n\n        static Comparator<IntIndexPair> decreaseComparator = new Comparator<B.IntIndexPair>() {\n\n            @Override\n            public int compare(B.IntIndexPair indexPair1, B.IntIndexPair indexPair2) {\n                int value1 = indexPair1.value;\n                int value2 = indexPair2.value;\n\n                if (value1 != value2) return -(value1 - value2);\n\n                int index1 = indexPair1.index;\n                int index2 = indexPair2.index;\n\n                return index1 - index2;\n            }\n        };\n\n        static IntIndexPair[] from(int[] array) {\n            IntIndexPair[] iip = new IntIndexPair[array.length];\n            for (int i = 0; i < array.length; ++i) {\n                iip[i] = new IntIndexPair(array[i], i);\n            }\n\n            return iip;\n        }\n\n        int value, index;\n\n        IntIndexPair(int value, int index) {\n            super();\n            this.value = value;\n            this.index = index;\n        }\n\n        int getRealIndex() {\n            return index + 1;\n        }\n    }\n\n    private IntIndexPair[] readIntIndexArray(int size) {\n        IntIndexPair[] array = new IntIndexPair[size];\n\n        for (int index = 0; index < size; ++index) {\n            array[index] = new IntIndexPair(readInt(), index);\n        }\n\n        return array;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class OutputWriter extends PrintWriter {\n\n        final int DEFAULT_PRECISION = 12;\n\n        private int precision;\n        private String format, formatWithSpace;\n\n        {\n            precision = DEFAULT_PRECISION;\n\n            format = createFormat(precision);\n            formatWithSpace = format + \" \";\n        }\n\n        OutputWriter(OutputStream out) {\n            super(out);\n        }\n\n        OutputWriter(String fileName) throws FileNotFoundException {\n            super(fileName);\n        }\n\n        int getPrecision() {\n            return precision;\n        }\n\n        void setPrecision(int precision) {\n            precision = max(0, precision);\n            this.precision = precision;\n\n            format = createFormat(precision);\n            formatWithSpace = format + \" \";\n        }\n\n        String createFormat(int precision){\n            return \"%.\" + precision + \"f\";\n        }\n\n        @Override\n        public void print(double d){\n            printf(format, d);\n        }\n\n        void printWithSpace(double d){\n            printf(formatWithSpace, d);\n        }\n\n        void printAll(double...d){\n            for (int i = 0; i < d.length - 1; ++i){\n                printWithSpace(d[i]);\n            }\n\n            print(d[d.length - 1]);\n        }\n\n        @Override\n        public void println(double d){\n            printlnAll(d);\n        }\n\n        void printlnAll(double... d){\n            printAll(d);\n            println();\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class RuntimeIOException extends RuntimeException {\n\n        /**\n         *\n         */\n        private static final long serialVersionUID = -6463830523020118289L;\n\n        RuntimeIOException(Throwable cause) {\n            super(cause);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n    //////////////// Some useful constants and functions ////////////////\n    /////////////////////////////////////////////////////////////////////\n\n    private static final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    private static final int[][] steps8 = {\n            {-1, 0}, {1, 0}, {0, -1}, {0, 1},\n            {-1, -1}, {1, 1}, {1, -1}, {-1, 1}\n    };\n\n    private static boolean checkCell(int row, int rowsCount, int column, int columnsCount) {\n        return checkIndex(row, rowsCount) && checkIndex(column, columnsCount);\n    }\n\n    private static boolean checkIndex(int index, int lim){\n        return (0 <= index && index < lim);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static boolean checkBit(int mask, int bit){\n        return (mask & (1 << bit)) != 0;\n    }\n    private static boolean checkBit(long mask, int bit){\n        return (mask & (1L << bit)) != 0;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static long getSum(int[] array) {\n        long sum = 0;\n        for (int value: array) {\n            sum += value;\n        }\n\n        return sum;\n    }\n\n    private static Point getMinMax(int[] array) {\n        int min = array[0];\n        int max = array[0];\n\n        for (int index = 0, size = array.length; index < size; ++index, ++index) {\n            int value = array[index];\n\n            if (index == size - 1) {\n                min = min(min, value);\n                max = max(max, value);\n            } else {\n                int otherValue = array[index + 1];\n\n                if (value <= otherValue) {\n                    min = min(min, value);\n                    max = max(max, otherValue);\n                } else {\n                    min = min(min, otherValue);\n                    max = max(max, value);\n                }\n            }\n        }\n\n        return new Point(min, max);\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static int[] getPrimes(int n) {\n        boolean[] used = new boolean[n];\n        used[0] = used[1] = true;\n\n        int size = 0;\n        for (int i = 2; i < n; ++i) {\n            if (!used[i]) {\n                ++size;\n                for (int j = 2 * i; j < n; j += i) {\n                    used[j] = true;\n                }\n            }\n        }\n\n        int[] primes = new int[size];\n        for (int i = 0, cur = 0; i < n; ++i) {\n            if (!used[i]) {\n                primes[cur++] = i;\n            }\n        }\n\n        return primes;\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static long lcm(long a, long b) {\n        return a / gcd(a, b) * b;\n    }\n\n    private static long gcd(long a, long b) {\n        return (a == 0 ? b : gcd(b % a, a));\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class MultiSet<ValueType> {\n\n        public static <ValueType> MultiSet<ValueType> createMultiSet() {\n            Map<ValueType, Integer> multiset = new HashMap<>();\n            return new MultiSet<>(multiset);\n        }\n\n        private final Map<ValueType, Integer> multiset;\n        private int size;\n\n        public MultiSet(Map<ValueType, Integer> multiset) {\n            this.multiset = multiset;\n            this.size = 0;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public void inc(ValueType value) {\n            int count = get(value);\n            multiset.put(value, count + 1);\n\n            ++size;\n        }\n\n        public void dec(ValueType value) {\n            int count = get(value);\n            if (count == 0) return;\n\n            if (count == 1) multiset.remove(value);\n            else multiset.put(value, count - 1);\n\n            --size;\n        }\n\n        public int get(ValueType value) {\n            Integer count = multiset.get(value);\n            return (count == null ? 0 : count);\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static class IdMap<KeyType> extends HashMap<KeyType, Integer> {\n\n        /**\n         *\n         */\n        private static final long serialVersionUID = -3793737771950984481L;\n\n        public IdMap() {\n            super();\n        }\n\n        int getId(KeyType key) {\n            Integer id = super.get(key);\n            if (id == null) {\n                super.put(key, id = size());\n            }\n\n            return id;\n        }\n    }\n\n    /////////////////////////////////////////////////////////////////////\n\n    private static int[] castInt(List<Integer> list) {\n        int[] array = new int[list.size()];\n        for (int i = 0; i < array.length; ++i) {\n            array[i] = list.get(i);\n        }\n\n        return array;\n    }\n\n    private static long[] castLong(List<Long> list) {\n        long[] array = new long[list.size()];\n        for (int i = 0; i < array.length; ++i) {\n            array[i] = list.get(i);\n        }\n\n        return array;\n    }\n}\n\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\npublic class b {\n    public static long[] sum;\n    public static skill[] ss;\n    public static long max;\n    public static int sorter = 0;\n    public static void main(String[] args) throws IOException{\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        \n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        max = Integer.parseInt(st.nextToken());\n        long multMax = Integer.parseInt(st.nextToken());\n        long multMin = Integer.parseInt(st.nextToken());\n        long money = Long.parseLong(st.nextToken());\n        \n        ss = new skill[n];\n        st = new StringTokenizer(br.readLine());\n        for(int i = 0;i<n;i++){\n            int cur = Integer.parseInt(st.nextToken());\n            ss[i] = new skill(cur, i);\n        }\n        \n        Arrays.sort(ss);\n        \n        sum = new long[n];\n        for(int i = 0;i<n;i++){\n            sum[i]+=ss[i].val;\n            if(i != 0){\n                sum[i]+=sum[i-1];\n            }\n        }\n        \n        long moneyLeft = money;\n        long best = calc(moneyLeft, n-1)*multMin;\n        int index = -1;\n        long bmin = calc(moneyLeft, n-1);\n        for(int i = 0;i<n;i++){\n            moneyLeft-=max-ss[n-i-1].val;\n            if(moneyLeft < 0){\n                break;\n            }\n            long min = calc(moneyLeft, n-i-2);\n            long val = multMax*(i+1) + multMin*min;\n            if(val > best){\n                index = i;\n                bmin = min;\n            }\n            best = Math.max(best, val);\n        }\n        System.out.println(best);\n        for(int i = n-1;i>=(n-1)-index;i--){\n            ss[i].val = max;\n        }\n        for(int i = 0;i<n;i++){\n            if(ss[i].val < bmin){\n                ss[i].val = bmin;\n            }\n        }\n        sorter = 1;\n        Arrays.sort(ss);\n        PrintWriter out = new PrintWriter(System.out);\n        for(int i = 0;i<n;i++){\n            out.print(ss[i].val+\" \");\n        }\n        out.println();\n        out.close();\n    }\n    public static long calc(long money, int bound){\n        if(bound < 0){\n            return max;\n        }\n        long low = ss[0].val;\n        long high = max;\n        while(high-low > 1){\n            long mid = (low+high)/2;\n            \n            int ll = 0;\n            int rr = bound+1;\n            while(rr-ll > 1){\n                int mm = (ll+rr)/2;\n                \n                if(ss[mm].val <= mid){\n                    ll = mm;\n                }\n                else{\n                    rr = mm;\n                }\n                \n            }\n            int index = ll;\n            long cost = (index+1)*mid - sum[index];\n            if(cost <= money){\n                low = mid;\n            }\n            else{\n                high = mid;\n            }\n        }\n        return low;\n    }\n    public static class skill implements Comparable<skill>{\n        long val;\n        int index;\n        public skill(int a, int b){\n            val = a;\n            index = b;\n        }\n        \n        public int compareTo(skill o){\n            if(sorter == 0)\n                return Long.compare(val, o.val);\n            else\n                return index-o.index;\n        }\n        \n    }\n}\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Random;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            long A = in.nextLong();\n            long cf = in.nextInt();\n            long cm = in.nextInt();\n            long m = in.nextLong();\n            long[] a = new long[n];\n            for (int i = 0; i < n; ++i) {\n                a[i] = in.nextLong() * n + i;\n            }\n            Random random = new Random(5431531543151L + System.currentTimeMillis());\n            for (int i = 0; i < n; ++i) {\n                int j = i + random.nextInt(n - i);\n                long t = a[i];\n                a[i] = a[j];\n                a[j] = t;\n            }\n            Arrays.sort(a);\n            int[] b = new int[n];\n            for (int i = 0; i < n; ++i) {\n                b[i] = (int) (a[i] % n);\n                a[i] /= n;\n            }\n            long[] growAllTo = new long[n];\n            for (int i = 1; i < n; ++i) {\n                growAllTo[i] = growAllTo[i - 1] + i * (a[i] - a[i - 1]);\n            }\n            long needForCap = 0;\n            int canGrow = n;\n            long maxPower = -1;\n            int maxCap = -1;\n            int maxCanGrow = -1;\n            long maxGrowTo = -1;\n            for (int cap = 0; cap <= n; ++cap) {\n                if (cap > 0) {\n                    needForCap += A - a[n - cap];\n                }\n                if (needForCap > m) break;\n                if (canGrow > n - cap) canGrow = n - cap;\n                while (canGrow > 0 && growAllTo[canGrow - 1] + needForCap > m) {\n                    --canGrow;\n                }\n                long power = cf * cap;\n                long growTo = 0;\n                if (cap == n) {\n                    power += cm * A;\n                } else if (canGrow > 0) {\n                    growTo = Math.min(A, a[canGrow - 1] + (m - growAllTo[canGrow - 1] - needForCap) / canGrow);\n                    power += cm * growTo;\n                }\n                if (power > maxPower) {\n                    maxPower = power;\n                    maxCap = cap;\n                    maxCanGrow = canGrow;\n                    maxGrowTo = growTo;\n                }\n            }\n            out.println(maxPower);\n            for (int i = 0; i < maxCanGrow; ++i) {\n                a[i] = maxGrowTo;\n            }\n            for (int i = 0; i < maxCap; ++i) {\n                a[n - 1 - i] = A;\n            }\n            long[] res = new long[n];\n            for (int i = 0; i < n; ++i) {\n                res[b[i]] = a[i];\n            }\n            for (int i = 0; i < n; ++i) {\n                if (i > 0) out.print(\" \");\n                out.print(res[i]);\n            }\n            out.println();\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class E{\n\tpublic static void main (String[] args) {\n\t\tnew E();\n\t}\n\t\n\tE() {\n\t\tFastScanner fs = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tSystem.err.println(\"\");\n\n\t\tint N = fs.nextInt(), max = fs.nextInt(), maxC = fs.nextInt(), minC = fs.nextInt();\n\t\tlong money = fs.nextLong();\n\t\tint[][] skills = new int[N][2];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tskills[i][0] = fs.nextInt();\n\t\t\tskills[i][1] = i;\n\t\t}\n\t\tArrays.sort(skills, (x, y) -> Integer.compare(x[0], y[0]));\n\t\tlong[] prefSum = new long[N];\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tprefSum[i] += skills[i][0];\n\t\t\tif(i > 0) prefSum[i] += prefSum[i-1];\n\t\t}\n\t\t\n\t\tint bestSuff = -1, bestMin = -1;\n\t\tlong bestCost = -1;\n\t\tlong curCountMax = 0;\n\t\tfor(int i = N-1; i >= -1; i--) {\n\t\t\tint lo = 0, hi = max;\n\t\t\tlong minVal = 0;\n\t\t\tfor(int bs = 0; bs < 50 && lo <= hi; bs++) {\n\t\t\t\tint mid = (lo+hi)/2;\n\t\t\t\tlong countLess = -1;\n\t\t\t\tint lo2 = 0, hi2 = i;\n\t\t\t\tfor(int bs2 = 0; bs2 < 50 && lo2 <= hi2; bs2++) {\n\t\t\t\t\tint mid2 = (lo2+hi2)/2;\n\t\t\t\t\tif(skills[mid2][0] < mid) {\n\t\t\t\t\t\tcountLess = mid2+1;\n\t\t\t\t\t\tlo2 = mid2+1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thi2 = mid2-1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlong costs = 0;\n\t\t\t\tif(countLess != -1) {\n\t\t\t\t\tcosts = mid*countLess - prefSum[(int)countLess-1];\n\t\t\t\t}\n\t\t\t\tif(costs <= money) {\n\t\t\t\t\tminVal = mid;\n\t\t\t\t\tlo = mid+1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thi = mid-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong ret = curCountMax*maxC;\n\t\t\tret += minVal*minC;\n\t\t\t\n\t\t\tif(ret > bestCost) {\n\t\t\t\tbestCost = ret;\n\t\t\t\tbestSuff = i;\n\t\t\t\tbestMin = (int)minVal;\n\t\t\t}\n\t\t\tif(i >= 0) money -= max-skills[i][0];\n\t\t\tcurCountMax++;\n\t\t\tif(money < 0) break;\n\t\t}\n\t\tint[] res = new int[N]; Arrays.fill(res, -1);\n\t\tfor(int i = bestSuff+1; i < N; i++) res[skills[i][1]] = max;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tint id = skills[i][1];\n\t\t\tif(res[id] != -1) continue;\n\t\t\tif(skills[i][0] < bestMin) res[id] = bestMin;\n\t\t\telse res[id] = skills[i][0];\n\t\t}\n\t\tout.println(bestCost);\n\t\tfor(int i = 0; i < N; i++) out.print(res[i] + \" \");\n\t\tout.println();\n\t\tout.close();\n\t}\n\t\n\tclass FastScanner {\n\t\tpublic int BS = 1<<16;\n\t\tpublic char NC = (char)0;\n\t\tbyte[] buf = new byte[BS];\n\t\tint bId = 0, size = 0;\n\t\tchar c = NC;\n\t\tdouble num = 1;\n\t\tBufferedInputStream in;\n\n\t\tpublic FastScanner() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t\t}\n\t\t}\n\n\t\tpublic char nextChar(){\n\t\t\twhile(bId==size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t}catch(Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}                \n\t\t\t\tif(size==-1)return NC;\n\t\t\t\tbId=0;\n\t\t\t}\n\t\t\treturn (char)buf[bId++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tnum=1;\n\t\t\tboolean neg = false;\n\t\t\tif(c==NC)c=nextChar();\n\t\t\tfor(;(c<'0' || c>'9'); c = nextChar()) {\n\t\t\t\tif(c=='-')neg=true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor(; c>='0' && c <='9'; c=nextChar()) {\n\t\t\t\tres = (res<<3)+(res<<1)+c-'0';\n\t\t\t\tnum*=10;\n\t\t\t}\n\t\t\treturn neg?-res:res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c!='.' ? cur:cur+nextLong()/num;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c>32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile(c<=32)c=nextChar();\n\t\t\twhile(c!='\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc=nextChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif(c>32)return true;\n\t\t\twhile(true) {\n\t\t\t\tc=nextChar();\n\t\t\t\tif(c==NC)return false;\n\t\t\t\telse if(c>32)return true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) res[i] = nextInt();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t}\n\n}\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            BSkills solver = new BSkills();\n            solver.solve(1, in, out);\n            out.close();\n        }\n    }\n\n    static class BSkills {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.readInt();\n            long A = in.readLong();\n            long x = in.readLong();\n            long y = in.readLong();\n            long m = in.readLong();\n\n            Item[] items = new Item[n];\n            for (int i = 0; i < n; i++) {\n                items[i] = new Item();\n                items[i].a = in.readInt();\n            }\n            Item[] snapshot = items.clone();\n            Arrays.sort(items, (a, b) -> Long.compare(a.a, b.a));\n\n            LongPreSum lps = new LongPreSum(i -> items[i].a, n);\n            if (A * n - lps.prefix(n) <= m) {\n                out.println(n * x + A * y);\n                for (int i = 0; i < n; i++) {\n                    out.append(A).append(' ');\n                }\n                return;\n            }\n\n            int r = n - 1;\n            long[] summary = new long[3];\n            long ans = -1;\n            for (int i = n; i >= 0; i--) {\n                long cost = A * (n - i) - lps.post(i);\n                long remain = m - cost;\n                while (r >= 0 && items[r].a * (r + 1) - lps.prefix(r) > remain || r >= i) {\n                    r--;\n                }\n                if (r < 0) {\n                    break;\n                }\n                long local = (items[r].a + (remain - (items[r].a * (r + 1) - lps.prefix(r))) / (r + 1)) * y + (n - i) * x;\n                if (local > ans) {\n                    ans = local;\n                    summary[0] = r;\n                    summary[1] = i;\n                    summary[2] = (items[r].a + (remain - (items[r].a * (r + 1) - lps.prefix(r))) / (r + 1));\n                }\n            }\n            out.println(ans);\n            for (int i = 0; i < n; i++) {\n                if (i <= summary[0]) {\n                    items[i].a = Math.max(items[i].a, summary[2]);\n                } else if (i >= summary[1]) {\n                    items[i].a = A;\n                } else {\n                }\n            }\n\n            for (Item s : snapshot) {\n                out.append(s.a).append(' ');\n            }\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 1 << 13;\n        private final Writer os;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(String c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append(System.lineSeparator());\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append(cache);\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class LongPreSum {\n        private long[] pre;\n        private int n;\n\n        public LongPreSum(int n) {\n            pre = new long[n];\n        }\n\n        public void populate(IntToLongFunction a, int n) {\n            this.n = n;\n            if (n == 0) {\n                return;\n            }\n            pre[0] = a.apply(0);\n            for (int i = 1; i < n; i++) {\n                pre[i] = pre[i - 1] + a.apply(i);\n            }\n        }\n\n        public LongPreSum(IntToLongFunction a, int n) {\n            this(n);\n            populate(a, n);\n        }\n\n        public long prefix(int i) {\n            i = Math.min(i, n - 1);\n            if (i < 0) {\n                return 0;\n            }\n            return pre[i];\n        }\n\n        public long post(int i) {\n            return prefix(n) - prefix(i - 1);\n        }\n\n    }\n\n    static interface IntToLongFunction {\n        long apply(int x);\n\n    }\n\n    static class Item {\n        long a;\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Objects;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Solution{\n\t\n\tstatic int n, cf, cm, A;\n\tstatic long  m;\n\tstatic final int maxn = (int)1e5+10;\n\tstatic long[] need;\n\tstatic int[][] arr;\n\tstatic long maxval;\n\tstatic int numi;\n\tstatic int final_min = 0;\n\n\t\n\t\n    public static void main(String[] args) throws IOException {\n     \n    \tFastScanner fs = new FastScanner();\n    \tPrintWriter out = new PrintWriter(System.out);\n    \t\n    \t\n    \t\t\n    \tint tt = 1;\n    \twhile(tt-->0) {\n    \t\t\n    \t\tn = fs.nextInt(); A = fs.nextInt(); cf = fs.nextInt(); cm = fs.nextInt(); m = fs.nextLong();\n    \t\tarr = new int[maxn][2];\n    \t\t\n    \t\tfor(int i=1;i<=n;i++) {\n    \t\t\tarr[i][0] = fs.nextInt(); arr[i][1] = i;\n    \t\t}\n    \t\tarr[n+1][0] = A; \n    \t\t\n    \t\tArrays.sort(arr, 1, n+1, (x, y) -> x[0]-y[0]);\n    \t\t\n    \t\tneed = new long[maxn];\n    \t\t\n    \t\tfor(int i=2;i<=n;i++) {\n    \t\t\tneed[i] = need[i-1] + (long)(i-1)*(arr[i][0]-arr[i-1][0]);\n    \t\t}\n    \t\t\n    \t\tlong taken = 0;\n    \t\t\n    \t\tfor(int i=0;i<=n;i++) {\n    \t\t\ttaken += (A-arr[n-i+1][0]);\n    \t\t\tif(taken>m) break;\n    \t\t\t\n    \t\t\tint min = bSearch(1, n-i, m-taken);\n    \t\t\tif(i==n) min = A;\n    \t\t\t\n    \t\t\t\n    \t\t\tif(i*cf + (long)min*cm>maxval) {\n    \t\t\t\tmaxval = i*cf + (long)min*cm;\n    \t\t\t\tfinal_min = min;\n    \t\t\t\tnumi = i;\n    \t\t\t}\n    \t\t\t\n    \t\t\t\n    \t\t}\n    \t\t\n    \t\t\n\t\t\tint[] ans =  new int[maxn];\n\t\t\tfor(int i=n;i>n-numi;i--) {\n\t\t\t\tans[arr[i][1]] = A;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=1;i<=n-numi;i++) {\n\t\t\t\tans[arr[i][1]] = Math.max(final_min, arr[i][0]);\n\t\t\t}\n\t\t\t\n\t\t\tout.println(maxval);\n\t\t\tfor(int i=1;i<=n;i++) out.print(ans[i]+\" \");\n\t\t\tout.println();\n\t\t\t\n\t\t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t\t\n    \t}\n    \t\n    \t\t\n    \t\t\n    \t\t\n    \tout.close();\n    \t\t\n    }\n    \n    \n  \n    static int bSearch(int l, int r, long x) {\n    \twhile(l<r) {\n    \t\tint mid = (l+r+1)/2;\n    \t\tif(need[mid]>x) r = mid - 1;\n    \t\telse l = mid;\n    \t}\n    \treturn (int) Math.min(A, arr[l][0] + (x - need[l])/l);\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    static final Random random=new Random();\n    \t\n    static void ruffleSort(int[] a) {\n    \tint n=a.length;//shuffle, then sort \n    \tfor (int i=0; i<n; i++) {\n    \t\tint oi=random.nextInt(n); int temp=a[oi];\n    \t\ta[oi]=a[i]; a[i]=temp;\n    \t}\n    \tArrays.sort(a);\n    }\n   \n  \n    \n    static void reverse(int[] arr, int l, int r) {\n    \tfor(int i=l;i<l+(r-l)/2;i++){\n    \t\tint temp = arr[i]; arr[i] = arr[r-i+l-1]; arr[r-i+l-1] = temp;\n    \t}\n    }\n    \n    \t\n    \t\n    static class FastScanner{\n    \tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    \tStringTokenizer st = new StringTokenizer(\"\");\n     \n    \tpublic String next(){\n    \t\twhile(!st.hasMoreElements()){\n    \t\t\ttry{\n    \t\t\t\tst = new StringTokenizer(br.readLine());\n    \t\t\t} catch(IOException e){\n    \t\t\t\te.printStackTrace();\n    \t\t\t}\n    \t\t}\n    \t\treturn st.nextToken();\n    \t}\n    \t\t\n    \tpublic String nextLine() throws IOException {\n    \t\treturn br.readLine();\n    \t}\n    \t\t\n    \tpublic int nextInt(){\n    \t\treturn Integer.parseInt(next());\n    \t}\n     \n    \tpublic int[] readArray(int n){\n    \t\tint[] a = new int[n];\n    \t\tfor(int i=0;i<n;i++)\n    \t\t\ta[i] = nextInt();\n    \t\treturn a;\n    \t}\n    \t\t\n    \tpublic long nextLong() {\n    \t\treturn Long.parseLong(next());\n    \t}\n    \t\t\n    \tpublic char nextChar() {\n    \t\treturn next().toCharArray()[0];\n    \t}\n    }\n   \t\n}\n", "label": 3}
{"src": "//package codeforces.cfr339div1;\n\nimport java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n/**\n * Created by raggzy on 4/18/2016.\n */\npublic class B {\n    private static class Reader implements Closeable {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        public Reader(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        public void readLine() {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public String next() {\n            if (st == null || !st.hasMoreTokens()) {\n                readLine();\n            }\n            return st.nextToken();\n        }\n\n        public <T> T next(Function<String, T> parser) {\n            return parser.apply(next());\n        }\n\n        public int nextInt() {\n            return next(Integer::valueOf);\n        }\n\n        public long nextLong() {\n            return next(Long::valueOf);\n        }\n\n        public double nexDouble() {\n            return next(Double::valueOf);\n        }\n\n        @Override\n        public void close() throws IOException {\n            br.close();\n        }\n    }\n\n    public static void main(String[] args) {\n        Reader in = new Reader(System.in);\n        int n = in.nextInt();\n        long A = in.nextInt();\n        long cf = in.nextInt();\n        long cm = in.nextInt();\n        long m = in.nextLong();\n        long[] a = new long[n];\n        Integer[] sortedToInitialIdx = new Integer[n];\n        IntStream.range(0, n).forEach(i -> {\n            a[i] = in.nextInt();\n            sortedToInitialIdx[i] = i;\n        });\n        int countFull = (int) Arrays.stream(a).filter(v -> v == A).count();\n        Arrays.sort(sortedToInitialIdx, (i1, i2) -> Long.compare(a[i1], a[i2]));\n        long[] sumTillEnd = new long[n];\n        sumTillEnd[n - 1] = a[sortedToInitialIdx[n - 1]];\n        for (int i = n - 2; i >= 0; i--) {\n            sumTillEnd[i] = sumTillEnd[i + 1] + a[sortedToInitialIdx[i]];\n        }\n        long[] pointsToReach = new long[n];\n        pointsToReach[0] = 0;\n        for (int i = 1; i < n; i++) {\n            pointsToReach[i] = pointsToReach[i - 1] + i * (a[sortedToInitialIdx[i]] - a[sortedToInitialIdx[i - 1]]);\n        }\n        long res = 0;\n        long resMin = 0;\n        int resFull = 0;\n        for (int full = countFull; full <= n; full++) {\n            long pointsForFull = full == 0 ? 0 : (A * full - sumTillEnd[n - full]);\n            long pointsLeft = m - pointsForFull;\n            if (pointsLeft < 0) break;\n            int idx = Arrays.binarySearch(pointsToReach, pointsLeft);\n            if (idx < 0) {\n                idx = -1 - idx;\n                idx--;\n            }\n            // increase only not full\n            if (idx >= n - full) {\n                idx = n - full - 1;\n            }\n            long min;\n            if (idx < 0) {\n                min = A;\n            } else {\n                min = a[sortedToInitialIdx[idx]];\n                pointsLeft -= pointsToReach[idx];\n                min += pointsLeft / (1 + idx);\n                min = Math.min(min, A - 1);\n            }\n            long currentRes = min * cm + full * cf;\n            if (currentRes > res) {\n                resMin = min;\n                resFull = full;\n                res = currentRes;\n            }\n        }\n        System.out.println(res);\n        long[] arr = new long[n];\n        for (int i = 0; i < n; i++) {\n            arr[sortedToInitialIdx[i]] = Math.max(i < n - resFull ? resMin : A, a[sortedToInitialIdx[i]]);\n        }\n        System.out.println(Arrays.stream(arr).mapToObj(String::valueOf).collect(Collectors.joining(\" \")));\n    }\n}\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\n\npublic class Main {\n    class Node implements Comparable<Node> {\n        long val;\n        int id;\n\n        @Override\n        public int compareTo(Node o) {\n            // TODO Auto-generated method stub\n            if (val < o.val) {\n                return -1;\n            } else if (val == o.val) {\n                return 0;\n            } else {\n                return 1;\n            }\n        }\n\n    }\n\n    int n;\n    long A, cf, cm;\n    long m;\n    Node[] a;\n    long[] sum;\n    int MIN = 0;\n    int left = 0;\n\n    boolean judge(long mm, long target, int r) {\n        for (int i = 0; i <= r; i++) {\n            if (target > a[i].val) {\n                mm -= (target - a[i].val);\n                if (mm < 0)\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    long calc(int pos) {\n        long mm = m - sum[pos];\n        long l = a[0].val;\n        long r = A;\n        long res = 0;\n        while (l <= r) {\n            long mid = (l + r) >> 1;\n            if (judge(mm, mid, pos - 1)) {\n                l = mid + 1;\n                res = Math.max(res, (n - pos) * cf + mid * cm);\n                MIN = (int) mid;\n            } else {\n                r = mid - 1;\n            }\n        }\n        return res;\n    }\n\n    long Search(int l, int r) {\n        left = l;\n        int mid_left;\n        int mid_right;\n        long res = 0;\n        while (l +64<= r) {\n            int d = (r - l + 1) / 3;\n            mid_left = l + d;\n            mid_right = r - d;\n            /*if (n == 8654 ) {\n                System.out.println(l+\" \" + r+ \" -- \"+mid_left + \" \" + mid_right);\n            }*/\n            int oldMIN = MIN;\n            long ansl = calc(mid_left);\n            long lmin = MIN;\n            long ansr = calc(mid_right);\n            long rmin = MIN;\n            if (ansl < ansr) {\n                l = mid_left + 1;\n                if(ansr>res){\n                    res = ansr;\n                    left = mid_right;\n                    MIN = (int) rmin;\n                }else{\n                    MIN =oldMIN;\n                }\n                \n                \n            } else {\n                r = mid_right - 1;\n                if(ansl>res){\n                    res = ansl;\n                    left = mid_left;\n                    MIN = (int) lmin;\n                }else{\n                    MIN =oldMIN;\n                }\n            }\n        }\n\n        for (int i = l; i <= r; i++) {\n            \n            int pMIN = MIN;\n            long ans = calc(i);\n            if (ans > res) {\n                res = ans;\n                left = i;\n            }else{\n                MIN = pMIN;\n            }\n            \n        }\n\n        return res;\n    }\n\n    void solve() {\n        FastScanner scan = new FastScanner();\n        n = scan.nextInt();\n        A = scan.nextLong();\n        cf = scan.nextLong();\n        cm = scan.nextLong();\n        m = scan.nextLong();\n        a = new Node[n + 1];\n        sum = new long[n + 1];\n\n        for (int i = 0; i < n; i++) {\n            a[i] = new Node();\n            a[i].val = scan.nextLong();\n            a[i].id = i;\n        }\n\n        Arrays.sort(a, 0, n);\n        int leftMost = 0;\n        for (int i = n - 1; i >= 0; i--) {\n            sum[i] = sum[i + 1] + (A - a[i].val);\n            if (sum[i] > m) {\n                leftMost = i + 1;\n                break;\n            }\n        }\n        long ans = Search(leftMost, n);\n        long[] ansA = new long[n + 1];\n        PrintWriter out = new PrintWriter(System.out);\n        for (int i = 0; i < n; i++) {\n            int id = a[i].id;\n            ansA[id] = a[i].val;\n            \n            if (i >= left) {\n                ansA[id] = A;\n            }else if (ansA[id] < MIN) {\n                ansA[id] = MIN;\n            }\n        }\n\n        // test\n\n        int cnt = 0;\n        long mmmin = 1000000000;\n        for (int i = 0; i < n; i++) {\n            if (ansA[i] == A)\n                cnt++;\n            if (ansA[i] < mmmin) {\n                mmmin = ansA[i];\n            }\n        }\n        long testa = 0;\n        testa = cnt * cf + mmmin * cm;\n        if (m == 300) {\n        //  out.println(testa + \" \" + cnt + \" \" + mmmin);\n        }\n        // test end\n\n        out.println(ans);\n        for (int i = 0; i < n; i++) {\n            out.print(ansA[i] + \" \");\n        }\n        out.println();\n\n        out.flush();\n    }\n\n    public static void main(String[] args) {\n        new Main().solve();\n    }\n\n    public static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner(String s) {\n            try {\n                br = new BufferedReader(new FileReader(s));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextToken() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public boolean EOF() {\n            if (st != null && st.hasMoreTokens()) {\n                return false;\n            } else {\n                String line = null;\n                try {\n                    line = br.readLine();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                if (line == null)\n                    return true;\n                st = new StringTokenizer(line);\n                return false;\n            }\n        }\n\n        int nextInt() {\n            return Integer.parseInt(nextToken());\n        }\n\n        long nextLong() {\n            return Long.parseLong(nextToken());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(nextToken());\n        }\n    }\n}", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class D2 {\n\tpublic static void main(String[] args) throws IOException{\n\t\tInputReader in = new InputReader(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t// InputReader in = new InputReader(new FileInputStream(new File(\"input.txt\")));\n\t\t// PrintWriter out = new PrintWriter(System.out);\n\t\tSolver solver = new Solver();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class Solver{\n\t\tint n, initPerfCnt;\n\t\tlong perfSkill, coefPerf, coefMin, money;\n\t\tlong[] skill, sortSkill, firstPerfSkillCost, lastMinSkillCost;\n\t\tInteger[] skillPos;\n\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\t\tinit(in);\n\t\t\tprepare();\n\t\t\t\n\t\t\tif (money >= firstPerfSkillCost[0]) {\n\t\t\t\t// all perfect\n\t\t\t\tout.println(power(n, perfSkill));\n\t\t\t\tfor (int i = 0; i < n; ++ i)\n\t\t\t\t\tout.print(perfSkill + \" \");\n\t\t\t\tout.println();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tlong ansPower = 0, ansPerfCnt = 0, ansMinSkillCnt = 0, ansMinSkill = sortSkill[0];\n\t\t\tfor (int perfCnt = 0; perfCnt < n; ++ perfCnt) {\n\t\t\t\tlong curMoney = money;\n\t\t\t\t// set perfects\n\t\t\t\tcurMoney -= firstPerfSkillCost[n-perfCnt];\n\t\t\t\tif (curMoney < 0) continue;\n\n\t\t\t\t// determine minSkill pos\n\t\t\t\tint minSkillPos = 0;\n\t\t\t\tint l = 0, r = n-perfCnt-1;\n\t\t\t\twhile (l < r) {\n\t\t\t\t\tint m = (l+r)/2;\n\t\t\t\t\tif (lastMinSkillCost[m] < curMoney) l = m+1;\n\t\t\t\t\telse r = m;\n\t\t\t\t}\n\t\t\t\tif (lastMinSkillCost[r] <= curMoney) minSkillPos = r;\n\t\t\t\telse if (r > 0) minSkillPos = r-1;\n\t\t\t\tcurMoney -= lastMinSkillCost[minSkillPos];\n\n\t\t\t\t// determine minSkill\n\t\t\t\tlong minSkill = sortSkill[minSkillPos] + curMoney / (minSkillPos+1);\n\t\t\t\tcurMoney %= (minSkillPos+1);\n\n\t\t\t\tlong pow = power(perfCnt, minSkill);\n\t\t\t\tif (pow > ansPower) {\n\t\t\t\t\tansPower = pow;\n\t\t\t\t\tansPerfCnt = perfCnt;\n\t\t\t\t\tansMinSkillCnt = minSkillPos+1;\n\t\t\t\t\tansMinSkill = minSkill;\n\t\t\t\t}\n\t\t\t}\t\n\n\t\t\t// answer\n\t\t\tout.println(ansPower);\n\t\t\tlong[] ans = new long[n];\n\t\t\tfor (int i = 0; i < n; ++ i) {\n\t\t\t\tlong skl = sortSkill[i];\n\t\t\t\tif (i < ansMinSkillCnt) skl = ansMinSkill;\n\t\t\t\telse if (i >= n - ansPerfCnt) skl = perfSkill;\n\t\t\t\tans[skillPos[i]] = skl;\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++ i)\n\t\t\t\tout.print(ans[i] + \" \");\n\t\t\tout.println();\n\t\t}\n\n\t\tpublic void init(InputReader in) {\n\t\t\tn = in.nextInt();\n\t\t\tperfSkill = in.nextLong();\n\t\t\tcoefPerf = in.nextLong();\n\t\t\tcoefMin = in.nextLong();\n\t\t\tmoney = in.nextLong();\n\t\t\tskill = new long[n];\n\t\t\tsortSkill = new long[n];\n\t\t\tfirstPerfSkillCost = new long[n+1];\n\t\t\tlastMinSkillCost = new long[n];\n\t\t\tskillPos = new Integer[n];\n\t\t\tfor (int i = 0; i < n; ++ i) {\n\t\t\t\tskill[i] = in.nextLong();\n\t\t\t\tskillPos[i] = i;\n\t\t\t\tif (skill[i] == perfSkill) initPerfCnt++;\n\t\t\t}\n\t\t}\n\n\t\tvoid prepare() {\n\t\t\tArrays.sort(skillPos, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer i, Integer j) {\n\t\t\t\t\treturn Long.compare(skill[i], skill[j]);\n\t\t\t\t}\n\t\t\t});\n\t\t\tfirstPerfSkillCost[n] = 0;\n\t\t\tfor (int i = n-1; i >= 0; -- i) {\n\t\t\t\tsortSkill[i] = skill[skillPos[i]];\n\t\t\t\tfirstPerfSkillCost[i] = firstPerfSkillCost[i+1] + (perfSkill - sortSkill[i]);\n\t\t\t}\n\t\t\tlastMinSkillCost[0] = 0;\n\t\t\tfor (int i = 1; i < n; ++ i)  {\n\t\t\t\tlastMinSkillCost[i] = lastMinSkillCost[i-1] + i*(sortSkill[i] - sortSkill[i-1]);\n\t\t\t}\n\t\t}\n\n\t\tpublic long power(int perfCnt, long minSkill) {\n\t\t\treturn perfCnt * coefPerf + minSkill * coefMin;\n\t\t}\n\t}\n\n\tstatic class InputReader{\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t}\n\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry{\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\t\t\t\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n}", "label": 3}
{"src": "\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class B {\n\n    public static void main(String[] args) throws Exception {\n        new B().run();\n        out.close();\n    }\n\n    int getCurBestMin(Integer[][] arr, int ind, int n, long money, int A) {\n        int curBestMin = A;\n        if (ind < n - 1) {\n            curBestMin = Math.min(curBestMin, arr[ind + 1][0]);\n        }\n        curBestMin = (int) Math.min(curBestMin, arr[ind][0] + money / (ind + 1));\n        return curBestMin;\n    }\n\n    int getBestMin(Integer[][] arr, long[] sum, int n, long money, int A) {\n        if (n == 0) {\n            return A;\n        }\n        int l = 0;\n        int r = n - 1;\n        int bestMin = getCurBestMin(arr, 0, n, money, A);\n        while (l < r) {\n            int m = (l + r + 1) / 2;\n            long needMoney = arr[m][0] * (long) (m + 1) - sum[m];\n            if (needMoney <= money) {\n                l = m;\n                int curRes = getCurBestMin(arr, m, n, money - needMoney, A);\n                bestMin = Math.max(bestMin, curRes);\n            } else {\n                r = m - 1;\n            }\n        }\n        return bestMin;\n    }\n\n    void run() throws Exception {\n        int n = nextInt();\n        int A = nextInt();\n        long cf = nextLong();\n        long cm = nextLong();\n        long m = nextLong();\n        Integer[][] arr = new Integer[n][2];\n        for (int i = 0; i < n; ++i) {\n            arr[i][0] = nextInt();\n            arr[i][1] = i;\n        }\n        Arrays.sort(arr, (Integer[] a, Integer[] b) -> {\n            return Integer.compare(a[0], b[0]);\n        });\n        long[] sum = new long[n];\n        sum[0] = arr[0][0];\n        for (int i = 1; i < n; ++i) {\n            sum[i] = sum[i - 1] + arr[i][0];\n        }\n        long needToFull = 0;\n        long res = 0;\n        int bestNFull = 0;\n        long bestNeedToFull = 0;\n        for (int nFull = 0; nFull <= n; ++nFull) {\n            if (needToFull > m) {\n                break;\n            }\n            int bestMin = getBestMin(arr, sum, n - nFull, m - needToFull, A);\n            long curPower = cf * nFull + cm * bestMin;\n            if (curPower > res) {\n                res = curPower;\n                bestNFull = nFull;\n                bestNeedToFull = needToFull;\n            }\n            if (nFull < n) {\n                needToFull += A - arr[n - 1 - nFull][0];\n            }\n        }\n        for (int i = 0; i < bestNFull; ++i) {\n            arr[n - 1 - i][0] = A;\n        }\n        int bestMin = getBestMin(arr, sum, n - bestNFull, m - bestNeedToFull, A);\n        for (int i = 0; i < n; ++i) {\n            arr[i][0] = Math.max(arr[i][0], bestMin);\n        }\n        int[] resVals = new int[n];\n        for (int i = 0; i < n; ++i) {\n            resVals[arr[i][1]] = arr[i][0];\n        }\n        out.println(res);\n        for (int i = 0; i < n; ++i) {\n            out.print(resVals[i] + \" \");\n        }\n    }\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~ template ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    int[] nextIntArray(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; ++i) {\n            res[i] = nextInt();\n        }\n        return res;\n    }\n\n    int[][] nextIntArray(int nx, int ny) throws IOException {\n        int[][] res = new int[nx][ny];\n        for (int i = 0; i < nx; ++i) {\n            for (int j = 0; j < ny; ++j) {\n                res[i][j] = nextInt();\n            }\n        }\n        return res;\n    }\n\n    long[] nextLongArray(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; ++i) {\n            res[i] = nextLong();\n        }\n        return res;\n    }\n\n    long[][] nextLongArray(int nx, int ny) throws IOException {\n        long[][] res = new long[nx][ny];\n        for (int i = 0; i < nx; ++i) {\n            for (int j = 0; j < ny; ++j) {\n                res[i][j] = nextLong();\n            }\n        }\n        return res;\n    }\n\n    void fill(int[][] arr, int val) {\n        for (int i = 0; i < arr.length; ++i) {\n            Arrays.fill(arr[i], val);\n        }\n    }\n\n    void fill(int[][][] arr, int val) {\n        for (int i = 0; i < arr.length; ++i) {\n            fill(arr[i], val);\n        }\n    }\n\n    int[][] newIntArray(int nx, int ny, int val) {\n        int[][] res = new int[nx][ny];\n        fill(res, val);\n        return res;\n    }\n\n    int[][][] newIntArray(int nx, int ny, int nz, int val) {\n        int[][][] res = new int[nx][ny][nz];\n        fill(res, val);\n        return res;\n    }\n\n    long[][] newLongArray(int nx, int ny, long val) {\n        long[][] res = new long[nx][ny];\n        for (int i = 0; i < nx; ++i) {\n            Arrays.fill(res[i], val);\n        }\n        return res;\n    }\n\n    long[][][] newLongArray(int nx, int ny, int nz, long val) {\n        long[][][] res = new long[nx][ny][nz];\n        for (int i = 0; i < nx; ++i) {\n            for (int j = 0; j < ny; ++j) {\n                Arrays.fill(res[i][j], val);\n            }\n        }\n        return res;\n    }\n\n    <T> ArrayList<T>[] newArrayListArray(int sz) {\n        ArrayList<T>[] res = new ArrayList[sz];\n        for (int i = 0; i < sz; ++i) {\n            res[i] = new ArrayList<>();\n        }\n        return res;\n    }\n\n    String nextToken() throws IOException {\n        while (strTok == null || !strTok.hasMoreTokens()) {\n            String line = in.readLine();\n            if (line == null) {\n                return null;\n            }\n            strTok = new StringTokenizer(line);\n        }\n        return strTok.nextToken();\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    static StringTokenizer strTok;\n    final static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    final static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Main {\n\tstatic int find(int val,int idx,Node array[]){\n\t\tint low = 1;\n\t\tint high = idx;\n\t\twhile(low < high){\n\t\t\tint mid = (low + high)/2;\n\t\t\tif(array[mid].value <= val)\n\t\t\t\tlow = mid + 1;\n\t\t\t\telse high = mid;\n\t\t}\n\t\treturn low - 1;\n\t}\npublic static void main(String [] args)throws Exception{\n\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tStringTokenizer st = new StringTokenizer(br.readLine());\n\tint n = Integer.parseInt(st.nextToken());\n\tint a = Integer.parseInt(st.nextToken());\n\tint cf = Integer.parseInt(st.nextToken());\n\tint cm = Integer.parseInt(st.nextToken());\n\tlong m = Long.parseLong(st.nextToken());\n\tNode array[] = new Node[n + 1];\n\tarray[0] = new Node(0,0);\n\tst = new StringTokenizer(br.readLine());\n\tfor(int i = 1;i <= n;i++){\n\t\tint value = Integer.parseInt(st.nextToken());\n\t\tarray[i] = new Node(i,value);\n\t}\n\tArrays.sort(array);\n\tlong temp[] = new long[n + 1];\n\tfor(int i = 1;i <= n;i++)\n\t\ttemp[i] = temp[i - 1] + array[i].value;\n\tlong ans = 0;\n\tint start = 0;\n\tlong curr = 0;\n\tboolean flag = false;\n\tint min = 0;\n\tfor(int i = n;i >= 0;i--){\n\t\tint low = 0;\n\t\tint high = a + 1;\n\t\tlong left = m - ((n - i)*1L*a - curr);\n\t\tif(left < 0)break;\n\t\tcurr += array[i].value;\n\t\twhile(low < high){\n\t\t\tint mid = (low + high)/2;\n\t\t\tint pos = find(mid,i + 1,array);\n\t\t\tif(pos*1L*mid - temp[pos] <= left)\n\t\t\t\tlow = mid + 1;\n\t\t\t\telse high = mid;\n\t//System.out.println(i + \" \" + low + \" \" + mid + \" \" + high + \" \" + pos + \" \" + pos*mid + \" \" + temp[pos]);\t\t\n\t\t}\n\t//System.out.println(i + \" \" + ((low - 1)*cm + (n - i)*cf) + \" \" + curr + \" \" + low + \" \" + left);\n\t\tif(ans < (low - 1)*1L*cm + (n - i)*1L*cf){\n\t\t                //System.out.println(ans);\n\t\t    ans = (low - 1)*1L*cm + (n - i)*1L*cf;\n\t\t\tstart = i;\n\t\t\tmin = low - 1;\n\t\t\tflag = true;\n\t}\n\t}\n\tlong index[] = new long[n + 1];\n\tfor(int i = 1;i <= n;i++)\n\tindex[array[i].idx] = array[i].value;\n\tif(flag){\n\tif(ans == 1938){\n\t                //System.out.println(min+ \" \" + a + \" \" + start);\n\t}\n\tfor(int i = start + 1;i <= n;i++)\n\t  index[array[i].idx] = a;\n                for(int i = 1;i <= start;i++){\n                                if(array[i].value < min)\n                                index[array[i].idx] = min;\n\t\t}\n\t}\n\tSystem.out.println(ans);\n\tStringBuilder sb = new StringBuilder();\n\tfor(int i = 1;i <= n;i++)\n\t\tsb.append(index[i] + \" \");\n\t\tSystem.out.print(sb);\n}\nstatic class Node implements Comparable<Node>{\n\tint idx;\n\tlong value;\n\tNode(int idx,long value){\n\t\tthis.idx = idx;\n\t\tthis.value = value;\n\t}\n\tpublic int compareTo(Node other){\n\t\treturn Long.compare(value,other.value);\n\t}\n}\n}", "label": 3}
{"src": "/*\nKeep solving problems.\n*/\n\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.io.*;\n\npublic class CFA {\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n    private static final long MOD = 1000 * 1000 * 1000 + 7;\n    private static final int[] dx = {0, -1, 0, 1};\n    private static final int[] dy = {1, 0, -1, 0};\n    private static final String yes = \"Yes\";\n    private static final String no = \"No\";\n\n    int n;\n    Node[] arr;\n    class Node implements Comparable<Node> {\n        long value;\n        int idx;\n        public Node(long value, int idx) {\n            this.value = value;\n            this.idx = idx;\n        }\n\n        @Override\n        public int compareTo(Node o) {\n            return Long.compare(o.value, this.value);\n        }\n    }\n    void solve() throws IOException {\n        n = nextInt();\n        int A = nextInt();\n        int cf = nextInt();\n        int cm = nextInt();\n        long m = nextLong();\n        arr = new Node[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = new Node(nextLong(), i);\n        }\n        Arrays.sort(arr);\n\n        long res = 0;\n        long[] pref = new long[1 + n];\n        for (int i = 1; i <= n; i++) {\n            pref[i] = pref[i - 1] + arr[i - 1].value;\n        }\n\n        int maxCnt = 0;\n        long lowest = 0;\n        for (int c = 0; c <= n; c++) {\n            long need = 1L * c * A - pref[c];\n            if (need > m) {\n                continue;\n            }\n\n            long left = m - need;\n            //[c, n - 1]\n            long low = 0;\n            long high = MOD;\n            while (low < high) {\n                long mid = (low + high) / 2;\n                int l1 = c;\n                int r1 = n;\n                while (l1 < r1) {\n                    int m1 = (l1 + r1) / 2;\n                    if (arr[m1].value > mid) {\n                        l1 = m1 + 1;\n                    }\n                    else {\n                        r1 = m1;\n                    }\n                }\n\n                //[l1, n - 1]\n                long sum;\n                if (l1 == n) {\n                    sum = 0;\n                }\n                else {\n                    sum = (n - l1) * mid - (pref[n] - pref[l1]);\n                }\n\n                if (sum <= left) {\n                    low = mid + 1;\n                }\n                else {\n                    high = mid;\n                }\n            }\n\n            long tp = Math.min(A, low - 1);\n            long tmp = c * cf + tp * cm;\n            if (res < tmp) {\n                res = tmp;\n                maxCnt = c;\n                lowest = tp;\n            }\n        }\n\n        outln(res);\n        long[] ret = new long[n];\n        for (int i = 0; i < maxCnt; i++) {\n            ret[arr[i].idx] = A;\n        }\n        for (int i = maxCnt; i < n; i++) {\n            if (arr[i].value >= lowest) {\n                ret[arr[i].idx] = arr[i].value;\n            }\n            else {\n                ret[arr[i].idx] = lowest;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            out(ret[i] + \" \");\n        }\n    }\n\n    void shuffle(int[] a) {\n        int n = a.length;\n        for(int i = 0; i < n; i++) {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n\n    long gcd(long a, long b) {\n        while(a != 0 && b != 0) {\n            long c = b;\n            b = a % b;\n            a = c;\n        }\n        return a + b;\n    }\n\n    private void outln(Object o) {\n        out.println(o);\n    }\n    private void out(Object o) {\n        out.print(o);\n    }\n    private void formatPrint(double val) {\n        System.out.format(\"%.9f%n\", val);\n    }\n    public CFA() throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n    public static void main(String[] args) throws IOException {\n        new CFA();\n    }\n\n    public long[] nextLongArr(int n) throws IOException{\n        long[] res = new long[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextLong();\n        return res;\n    }\n    public int[] nextIntArr(int n) throws IOException {\n        int[] res = new int[n];\n        for(int i = 0; i < n; i++)\n            res[i] = nextInt();\n        return res;\n    }\n    public String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return null;\n            }\n        }\n        return st.nextToken();\n    }\n    public String nextString() {\n        try {\n            return br.readLine();\n        } catch (IOException e) {\n            eof = true;\n            return null;\n        }\n    }\n    public int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    public long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class Codeforces implements Runnable {\n\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    void init() throws FileNotFoundException {\n        try {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        } catch (Throwable e) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            try {\n                tok = new StringTokenizer(in.readLine());\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    int[] readIntArray(int size) throws IOException {\n        int[] res = new int[size];\n        for (int i = 0; i < size; i++) {\n            res[i] = readInt();\n        }\n        return res;\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    public static void main(String[] args) {\n        new Thread(null, new Codeforces(), \"\", 1l * 200 * 1024 * 1024).start();\n        //new Codeforces().run();\n    }\n\n    long timeBegin, timeEnd;\n\n    void time() {\n        timeEnd = System.currentTimeMillis();\n        System.err.println(\"Time = \" + (timeEnd - timeBegin));\n    }\n\n    long memoryTotal, memoryFree;\n\n    void memory() {\n        memoryFree = Runtime.getRuntime().freeMemory();\n        System.err.println(\"Memory = \" + ((memoryTotal - memoryFree) >> 10)\n                + \" KB\");\n    }\n\n    public void run() {\n        try {\n            timeBegin = System.currentTimeMillis();\n            memoryTotal = Runtime.getRuntime().freeMemory();\n            init();\n            solve();\n            out.close();\n            if (System.getProperty(\"ONLINE_JUDGE\") == null) {\n                time();\n                memory();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(-1);\n        }\n    }\n\n    class pt implements Comparable<pt> {\n\n        int x;\n        int y;\n\n        pt(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        @Override\n        public int compareTo(pt o) {\n            if (x != o.x) return x - o.x;\n            return y - o.y;\n        }\n    }\n\n    boolean cw(pt a, pt b, pt c) {\n        return (long) a.x * (b.y - c.y) + (long) b.x * (c.y - a.y) + (long) c.x * (a.y - b.y) < 0;\n    }\n\n    boolean ccw(pt a, pt b, pt c) {\n        return (long) a.x * (b.y - c.y) + (long) b.x * (c.y - a.y) + (long) c.x * (a.y - b.y) > 0;\n    }\n\n    void convex_hull(ArrayList<pt> a) {\n        if (a.size() == 1) return;\n        Collections.sort(a);\n        pt p1 = a.get(0), p2 = a.get(a.size() - 1);\n        pt[] up = new pt[a.size()];\n        pt[] down = new pt[a.size()];\n        int upIndex = 1;\n        int downIndex = 1;\n        up[0] = p1;\n        down[0] = p1;\n        for (int i = 1; i < a.size(); ++i) {\n            if (i == a.size() - 1 || cw(p1, a.get(i), p2)) {\n                while (upIndex >= 2 && !cw(up[upIndex - 2], up[upIndex - 1], a.get(i)))\n                    upIndex--;\n                up[upIndex++] = a.get(i);\n            }\n            if (i == a.size() - 1 || ccw(p1, a.get(i), p2)) {\n                while (downIndex >= 2 && !ccw(down[downIndex - 2], down[downIndex - 1], a.get(i)))\n                    downIndex--;\n                down[downIndex++] = a.get(i);\n            }\n        }\n        a.clear();\n        for (int i = 0; i < upIndex; ++i)\n            a.add(up[i]);\n        for (int i = downIndex - 2; i > 0; --i)\n            a.add(down[i]);\n    }\n\n    class Skill implements Comparable<Skill> {\n        int level;\n        int index;\n\n        Skill(int x, int i) {\n            this.level = x;\n            this.index = i;\n        }\n\n        @Override\n        public int compareTo(Skill o) {\n            if (level != o.level) return level - o.level;\n            return index - o.index;\n        }\n    }\n\n    long sum(long[] prefix, int l, int r) {\n        long res = prefix[r];\n        if (l > 0) res -= prefix[l - 1];\n        return res;\n    }\n\n    void solve() throws IOException {\n        int n = readInt();\n        long A = readInt();\n        long cf = readInt();\n        long cm = readInt();\n        long m = readLong();\n        Skill[] skills = new Skill[n];\n        for (int i = 0; i < n; i++) skills[i] = new Skill(readInt(), i);\n        Arrays.sort(skills);\n        long[] prefix = new long[n];\n        prefix[0] = skills[0].level;\n        for (int i = 1; i < n; i++) {\n            prefix[i] = prefix[i - 1] + skills[i].level;\n        }\n        long maxPower = 0;\n        int cntToMaxInAnswer = 0;\n        int prefCnt = 0;\n        int prefVal = 0;\n        for (int countToMax = 0; countToMax <= n; countToMax++) {\n            long curm = m;\n            if (countToMax > 0) {\n                long already = sum(prefix, n - countToMax, n - 1);\n                curm -= A * countToMax - already;\n            }\n            if (curm < 0) break;\n\n            long curPower = cf * countToMax;\n            int pr = 0;\n            int prval = 0;\n\n            if (countToMax < n) {\n                int l = 1;\n                int r = n - countToMax;\n                int ans = 0;\n                int value = 0;\n                while (l <= r) {\n                    int mid = (l + r) >> 1;\n                    long sum = prefix[mid - 1] + curm;\n                    long val = Math.min(A, sum / mid);\n                    if (val >= skills[mid - 1].level) {\n                        ans = mid;\n                        value = (int) val;\n                        l = mid + 1;\n                    } else {\n                        r = mid - 1;\n                    }\n                }\n\n                if (ans < n - countToMax) {\n                    value = Math.min(value, skills[ans].level);\n                }\n                curPower += value * cm;\n                pr = ans;\n                prval = value;\n            } else {\n                curPower += A * cm;\n            }\n            if (curPower > maxPower) {\n                maxPower = curPower;\n                cntToMaxInAnswer = countToMax;\n                prefCnt = pr;\n                prefVal = prval;\n            }\n        }\n\n        out.println(maxPower);\n        int[] answer = new int[n];\n        for (int i = 0; i < n; i++) answer[skills[i].index] = skills[i].level;\n        for (int i = 0; i < prefCnt; i++) {\n            answer[skills[i].index] = prefVal;\n        }\n        for (int i = 0; i < cntToMaxInAnswer; i++) {\n            answer[skills[n - 1 - i].index] = (int) A;\n        }\n        for (int x : answer) {\n            out.print(x + \" \");\n        }\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.util.stream.Stream;\n\npublic class Main implements Runnable {\n    static final int MOD = (int) 1e9 + 7;\n    static final int MI = (int) 1e9;\n    static final long ML = (long) 1e18;\n    static final Reader in = new Reader();\n    static final PrintWriter out = new PrintWriter(System.out);\n    StringBuilder answer = new StringBuilder();\n\n    public static void main(String[] args) {\n        new Thread(null, new Main(), \"persefone\", 1 << 32).start();\n    }\n\n    @Override\n    public void run() {\n        solve();\n        printf();\n        flush();\n    }\n\n    void solve() {\n        int n = in.nextInt();\n        int A = in.nextInt();\n        long cf = in.nextInt();\n        long cm = in.nextInt();\n        long m = in.nextLong();\n        Pair[] pairs = new Pair[n + 1];\n        int[] a = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            pairs[i] = new Pair((int) (a[i] = in.nextInt()), i);\n        }\n        Arrays.sort(pairs, 1, n + 1, (p1, p2) -> p1.value - p2.value);\n\n        long[] sum = new long[n + 1];\n        for (int i = 1; i <= n; i++) {\n            sum[i] = sum[i - 1] + (a[i] = pairs[i].value);\n        }\n        long ans = 0;\n        int bestMin = a[1], bestPos = n + 1;\n        for (int i = n; i >= 0; i--) {\n            long lost = 1l * A * (n - i) - (sum[n] - sum[i]);\n            if (lost > m) break;\n            long remain = m - lost;\n            int low = a[1], high = A + 1, mid = 0, cur = 0;\n            while (low < high) {\n                mid = low + high >> 1;\n                int pos = Utils.upperBound(a, 1, i + 1, mid) - 1;\n                if (remain < 1l * mid * pos - (sum[pos] - sum[0])) {\n                    high = mid;\n                } else {\n                    low = (cur = mid) + 1;\n                }\n            }\n            long res = cf * (n - i) + cm * cur;\n            if (res > ans) {\n                ans = res;\n                bestPos = i + 1;\n                bestMin = cur;\n            }\n        }\n        printf(ans);\n        for (int i = 1; i <= n; i++) {\n            a[pairs[i].index] = i < bestPos ? Math.max(bestMin, pairs[i].value) : A;\n        }\n        printf(Arrays.stream(a).skip(1).toArray());\n    }\n\n    static class Utils {\n        public static int upperBound(int[] a, int l, int r, int k) {\n            int m = 0, ans = r;\n            while (l < r) if (a[m = l + r >> 1] > k) ans = r = m; else l = m + 1;\n            return ans;\n        }\n    }\n\n    static class Pair {\n        private int value, index;\n\n        public Pair(int value, int index) {\n            this.value = value;\n            this.index = index;\n        }\n    }\n\n    void printf() {\n        out.print(answer);\n    }\n\n    void close() {\n        out.close();\n    }\n\n    void flush() {\n        out.flush();\n    }\n\n    void printf(Stream<?> str) {\n        str.forEach(o -> add(o, \" \"));\n        add(\"\\n\");\n    }\n\n\n    void printf(Object... obj) {\n        printf(false, obj);\n    }\n\n    void printfWithDescription(Object... obj) {\n        printf(true, obj);\n    }\n\n\n    private void printf(boolean b, Object... obj) {\n\n        if (obj.length > 1) {\n            for (int i = 0; i < obj.length; i++) {\n                if (b) add(obj[i].getClass().getSimpleName(), \" - \");\n                if (obj[i] instanceof Collection<?>) {\n                    printf((Collection<?>) obj[i]);\n                } else if (obj[i] instanceof int[][]) {\n                    printf((int[][]) obj[i]);\n                } else if (obj[i] instanceof long[][]) {\n                    printf((long[][]) obj[i]);\n                } else if (obj[i] instanceof double[][]) {\n                    printf((double[][]) obj[i]);\n                } else printf(obj[i]);\n            }\n            return;\n        }\n\n        if (b) add(obj[0].getClass().getSimpleName(), \" - \");\n        printf(obj[0]);\n    }\n\n    void printf(Object o) {\n        if (o instanceof int[])\n            printf(Arrays.stream((int[]) o).boxed());\n        else if (o instanceof char[])\n            printf(new String((char[]) o));\n        else if (o instanceof long[])\n            printf(Arrays.stream((long[]) o).boxed());\n        else if (o instanceof double[])\n            printf(Arrays.stream((double[]) o).boxed());\n        else if (o instanceof boolean[]) {\n            for (boolean b : (boolean[]) o) add(b, \" \");\n            add(\"\\n\");\n        } else\n            add(o, \"\\n\");\n    }\n\n    void printf(int[]... obj) {\n        for (int i = 0; i < obj.length; i++) printf(obj[i]);\n    }\n\n    void printf(long[]... obj) {\n        for (int i = 0; i < obj.length; i++) printf(obj[i]);\n    }\n\n    void printf(double[]... obj) {\n        for (int i = 0; i < obj.length; i++) printf(obj[i]);\n    }\n\n    void printf(boolean[]... obj) {\n        for (int i = 0; i < obj.length; i++) printf(obj[i]);\n    }\n\n    void printf(Collection<?> col) {\n        printf(col.stream());\n    }\n\n    <T, K> void add(T t, K k) {\n        if (t instanceof Collection<?>) {\n            ((Collection<?>) t).forEach(i -> add(i, \" \"));\n        } else if (t instanceof Object[]) {\n            Arrays.stream((Object[]) t).forEach(i -> add(i, \" \"));\n        } else\n            add(t);\n        add(k);\n    }\n\n\n    <T> void add(T t) {\n        answer.append(t);\n    }\n\n    static class Reader {\n        private BufferedReader br;\n        private StringTokenizer st;\n\n        Reader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        Reader(String fileName) throws FileNotFoundException {\n            br = new BufferedReader(new FileReader(fileName));\n        }\n\n        boolean isReady() throws IOException {\n            return br.ready();\n        }\n\n        String next() {\n            try {\n                while (st == null || !st.hasMoreTokens()) {\n                    st = new StringTokenizer(br.readLine());\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = nextInt();\n            return arr;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        String nextLine() {\n            String s = \"\";\n            try {\n                s = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return s;\n        }\n    }\n}", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n/*\n\n */\npublic class d \n{\n\tpublic static void main(String[] arg) throws IOException\n\t{\n\t\tnew d();\n\t}\n\tint n;\n\tlong A;\n\tint cf, cm;\n\tlong m;\n\tpublic d() throws IOException\n\t{\n\t\tFastScanner in = new FastScanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tn = in.nextInt(); A = in.nextLong(); cf = in.nextInt(); cm = in.nextInt(); m = in.nextLong();\n\t\tint[] save = new int[n];\n\t\tint[] vs = new int[n];\n\t\tlong[] pre = new long[n];\n\t\tfor(int i = 0; i < n; i++) save[i] = vs[i] = in.nextInt();\n\t\tArrays.sort(vs);\n\t\tfor(int i = 1; i < n; i++)\n\t\t{\n\t\t\tpre[i] = pre[i-1]+(vs[i]-vs[i-1])*(i);\n\t\t}\n\t\tlong ret = 0;\n\t\tlong minV = 0;\n\t\tint maxV = n;\n\t\tlong maxCost = 0;\n\t\tfor(int i = n; i >= 0; i--)\n\t\t{\n\t\t\tif(i < n) maxCost += (A-vs[i]);\n\t\t\tif(maxCost > m) break;\n\t\t\tlong minCost = 0;\n\t\t\tlong l = vs[0];\n\t\t\tlong h = A;\n\t\t\twhile(l <= h)\n\t\t\t{\n\t\t\t\tlong mi = l + (h-l)/2;\n\t\t\t\tint lo = 0;\n\t\t\t\tint hi = i-1;\n\t\t\t\twhile(lo <= hi)\n\t\t\t\t{\n\t\t\t\t\tint mid = lo + (hi-lo)/2;\n\t\t\t\t\tif(vs[mid] <= mi) lo = mid+1;\n\t\t\t\t\telse hi = mid-1;\n\t\t\t\t}\n\t\t\t\t// hi is the number im looking for\n\t\t\t\tif(hi != -1) minCost = pre[hi] + (mi-vs[hi])*(hi+1);\n\t\t\t\telse minCost = 0;\n\t\t\t\tif(minCost+maxCost > m)\n\t\t\t\t{\n\t\t\t\t\th = mi-1;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tl = mi+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(h < vs[0]) continue;\n\t\t\t// h is the min V\n\t\t\tif((n-i)*cf + h*cm > ret)\n\t\t\t{\n\t\t\t\tret = (n-i)*cf + h*cm;\n\t\t\t\tminV = h;\n\t\t\t\tmaxV = i;\n\t\t\t}\n\t\t}\n\t\tHashMap<Integer, Integer> hm = new HashMap<Integer, Integer>();\n\t\tfor(int i = maxV; i < n; i++)\n\t\t{\n\t\t\tif(!hm.containsKey(vs[i])) hm.put(vs[i], 0);\n\t\t\thm.put(vs[i], hm.get(vs[i])+1);\n\t\t}\n\t\t\n\t\tout.println(ret);\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tif(i != 0) out.print(\" \");\n\t\t\tif(hm.containsKey(save[i]) && hm.get(save[i]) != 0)\n\t\t\t{\n\t\t\t\tout.print(A);\n\t\t\t\thm.put(save[i], hm.get(save[i])-1);\n\t\t\t\tif(hm.get(save[i]) == 0) hm.remove(save[i]);\n\t\t\t}\n\t\t\telse if(save[i] <= minV) out.print(minV);\n\t\t\telse\n\t\t\t{\n\t\t\t\tout.print(save[i]);\n\t\t\t}\n\t\t}\n\t\tout.println();\n\t\tin.close(); out.close();\n\t}\n\n\tclass FastScanner\n\t{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FastScanner(InputStream in)\n\t\t{\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t\tst = new StringTokenizer(\"\");\n\t\t}\n\t\tpublic String next() throws IOException\n\t\t{\n\t\t\twhile(!st.hasMoreTokens()) st = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int nextInt() throws IOException\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() throws IOException\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic void close() throws IOException\n\t\t{\n\t\t\tbr.close();\n\t\t}\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\npublic class B613 implements Comparable<B613>\n{\n    long val;int id;\n    static long a[],b[],A;\n    public B613(long v,int i)\n    {\n        this.val=v;\n        this.id=i;\n    }\n    public int compareTo(B613 ob)\n    {\n        return Long.compare(this.val,ob.val);\n    }\n    static long find(int last,long m,B613 arr[])\n    {\n        if(last<0)\n            return A;\n        long v=0;\n        if(a[last]<=m)\n        {\n            v=(arr[last].val+(m-a[last])/(last+1));\n        }\n        else\n        {\n            int lo=0,hi=last;\n            while(lo+1 < hi)\n            {\n                int mid=(lo+hi)/2;\n                if(a[mid]<=m)\n                    lo=mid;\n                else\n                    hi=mid;\n            }\n            v=(arr[lo].val+(m-a[lo])/(lo+1));\n        }\n        if(v>A)\n            return A;\n        else\n            return v;\n    }\n    public static void main(String args[])throws IOException\n    {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        A=sc.nextLong();\n        long cf=sc.nextLong();\n        long cm=sc.nextLong();\n        long m=sc.nextLong();\n        B613 arr[]=new B613[n];\n        for(int i=0;i<n;i++)\n        {\n            arr[i]=new B613(sc.nextLong(),i);\n        }\n        Arrays.sort(arr);\n        a=new long[n];\n        b=new long[n+1];\n        for(int i=1;i<=n;i++)\n        {\n            if(i==n)\n            {\n                b[i]=b[i-1]+A-arr[n-i].val;\n            }\n            else\n            {\n                a[i]=a[i-1]+ i*(arr[i].val-arr[i-1].val);\n                b[i]=b[i-1]+A-arr[n-i].val;\n            }\n        }\n        long res=-1,min=0;\n        for(int i=0;i<=n;i++)\n        {\n            if(b[i]>m)\n                break;\n            long v=find(n-i-1,m-b[i],arr);\n            long t=i*cf+ v*cm;\n            if(t>res)\n            {\n                res=t;min=v;\n            }\n        }\n        System.out.println(res);\n        for(int i=0;i<n;i++)\n        {\n            if(arr[i].val<min)\n            {\n                m=m-(min-arr[i].val);\n                arr[i].val=min;\n            }\n        }\n        for(int i=n-1;i>=0;i--)\n        {\n            if(A-arr[i].val <=m)\n            {\n                m-=(A-arr[i].val);\n                arr[i].val=A;\n            }\n            else\n                break;\n        }\n        long r[]=new long[n];\n        for(int i=0;i<n;i++)\n        {\n            r[arr[i].id]=arr[i].val;\n        }\n        for(int i=0;i<n;i++)\n        {\n            System.out.print(r[i]+\" \");\n        }\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class CF {\n\tFastScanner in;\n\tPrintWriter out;\n\n\tclass O implements Comparable<O> {\n\t\tint id;\n\t\tint value;\n\t\tint nvalue;\n\n\t\tpublic O(int id, int value) {\n\t\t\tsuper();\n\t\t\tthis.id = id;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(O arg0) {\n\t\t\treturn Integer.compare(value, arg0.value);\n\t\t}\n\n\t}\n\n\tvoid solve() {\n\t\tint n = in.nextInt();\n\t\tint A = in.nextInt();\n\t\tint cf = in.nextInt();\n\t\tint cm = in.nextInt();\n\t\tlong m = in.nextLong();\n\t\tO[] a = new O[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = new O(i, in.nextInt());\n\t\t}\n\t\tArrays.sort(a);\n\t\tlong[] sum = new long[n + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tsum[i + 1] = sum[i] + a[i].value;\n\t\t}\n\t\tlong best = -1;\n\t\tint bestCntA = -1;\n\t\tint minValue = -1;\n\t\tfor (int cntA = 0; cntA <= n; cntA++) {\n\t\t\tlong cur = cf * cntA;\n\t\t\tint tmpMax = 0;\n\t\t\tif (cntA == n) {\n\t\t\t\tcur += A * 1L * cm;\n\t\t\t} else {\n\t\t\t\tint left = 1, right = n - cntA + 1;\n\t\t\t\twhile (right - left > 1) {\n\t\t\t\t\tint mid = (left + right) >> 1;\n\t\t\t\t\tlong need = a[mid - 1].value * 1L * mid;\n\t\t\t\t\tlong have = sum[mid];\n\t\t\t\t\tif (have + m < need) {\n\t\t\t\t\t\tright = mid;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tleft = mid;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlong need = a[left - 1].value * 1L * left;\n\t\t\t\tlong have = sum[left];\n\t\t\t\tlong more = m - (need - have);\n\t\t\t\tlong maxCan = a[left - 1].value + more / left;\n\t\t\t\t//if (left != n) {\n\t\t\t\t\t//maxCan = Math.min(maxCan, a[left].value);\n\t\t\t\t//} else {\n\t\t\t\t\tmaxCan = Math.min(maxCan, A);\n\t\t\t\t//}\n\t\t\t\ttmpMax = (int) maxCan;\n\t\t\t\tcur += maxCan * cm;\n\t\t\t}\n\t\t\tif (cur > best) {\n\t\t\t\tbest = cur;\n\t\t\t\tbestCntA = cntA;\n\t\t\t\tminValue = tmpMax;\n\t\t\t}\n\t\t\tif (cntA == n) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm -= A - a[n - 1 - cntA].value;\n\t\t\tif (m < 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < bestCntA; i++) {\n\t\t\ta[n - 1 - i].nvalue = A;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (a[i].nvalue != A) {\n\t\t\t\ta[i].nvalue = Math.max(a[i].value, minValue);\n\t\t\t}\n\t\t}\n\t\tArrays.sort(a, new Comparator<O>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(O o1, O o2) {\n\t\t\t\treturn Integer.compare(o1.id, o2.id);\n\t\t\t}\n\t\t});\n\t\tout.println(best);\n\t\tfor (O o : a) {\n\t\t\tout.print(o.nvalue + \" \");\n\t\t}\n\t}\n\n\tvoid run() {\n\t\ttry {\n\t\t\tin = new FastScanner(new File(\"CF.in\"));\n\t\t\tout = new PrintWriter(new File(\"CF.out\"));\n\n\t\t\tsolve();\n\n\t\t\tout.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tvoid runIO() {\n\n\t\tin = new FastScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\n\t\tout.close();\n\t}\n\n\tclass FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastScanner(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\n\t\tpublic FastScanner(InputStream f) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(f));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tboolean hasMoreTokens() {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tString s = null;\n\t\t\t\ttry {\n\t\t\t\t\ts = br.readLine();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (s == null)\n\t\t\t\t\treturn false;\n\t\t\t\tst = new StringTokenizer(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew CF().runIO();\n\t}\n}", "label": 3}
{"src": "\nimport java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport static java.lang.Math.*;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Double.parseDouble;\nimport static java.lang.String.*;\n\npublic class Main {\n    \n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        StringBuilder out = new StringBuilder();\n        StringTokenizer tk;\n\n        tk = new StringTokenizer(in.readLine());\n        int n = parseInt(tk.nextToken());\n        long A = parseLong(tk.nextToken()),cf = parseLong(tk.nextToken()),cm = parseLong(tk.nextToken());\n        long m = parseLong(tk.nextToken());\n        \n        tk = new StringTokenizer(in.readLine());\n        skill [] s = new skill[n];\n        for(int i=0; i<n; i++)\n            s[i] = new skill(i,parseLong(tk.nextToken()));\n        Arrays.sort(s);\n        \n        long [] suff = new long[n];\n        suff[n-1] = s[n-1].level;\n        for(int i=n-2; i>=0; i--)\n            suff[i] = suff[i+1]+s[i].level;\n        \n        int ind = 0;\n        long ans = 0;\n        int at_p=0,at_ind=0;\n        long pre = 0;\n        \n        for(int i=0; i<n; i++) {\n            if(ind<i) ind=i;\n            while(ind<n) {\n                if(s[ind].level*(n-ind)-suff[ind] <= m-pre) break;\n                ind++;\n            }\n            \n            if(ind==n) break;\n            \n            long mn = min(A, s[ind].level+(m-pre-(s[ind].level*(n-ind)-suff[ind]))/(n-ind));\n            if(i*cf + mn*cm > ans) {\n                ans = (i+(mn==A ? n-ind : 0))*cf+mn*cm;\n                at_p = i;\n                at_ind = ind;\n            }\n            \n            if(A-s[i].level <= m-pre) \n                pre += A-s[i].level;\n            else break;\n        }\n        \n        for(int i=0; i<at_p; i++) {\n            m -= (A-s[i].level);\n            s[i].level = A;\n        }\n        \n        long mn = min(A, s[at_ind].level+(m-(s[at_ind].level*(n-at_ind)-suff[at_ind]))/(n-at_ind));\n        for(int i=at_ind; i<n; i++) \n            s[i].level = mn;\n        \n        //System.out.println(at_p+\" , \"+at_ind);\n        System.out.println(ans);\n        \n        long [] a = new long[n];\n        for(int i=0; i<n; i++)\n            a[s[i].i] = s[i].level;\n        \n        out.append(a[0]);\n        for(int i=1; i<n; i++)\n            out.append(\" \").append(a[i]);\n        \n        System.out.println(out);\n    }\n    \n}\n\nclass skill implements Comparable<skill> {\n    int i;\n    long level;\n    \n    public skill(int i,long l) {\n        this.i = i;\n        this.level = l;\n    }\n    \n    @Override\n    public int compareTo(skill s) {\n        if(s.level!=level)\n            return s.level<level ? -1 : 1;\n        return i-s.i;\n    }\n}", "label": 3}
{"src": "\nimport java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class B {\n\n    public static void main(String[] args) throws Exception {\n        new B().run();\n        out.close();\n    }\n\n    int getLastIndLessVal(Integer[][] arr, int n, int barrier) {\n        int l = 0;\n        int r = n - 1;\n        while (l < r) {\n            int m = (l + r + 1) / 2;\n            if (arr[m][0] >= barrier) {\n                r = m - 1;\n            } else {\n                l = m;\n            }\n        }\n        return l;\n    }\n\n    int getBestMin(Integer[][] arr, long[] sum, int n, long money, int A) {\n        if (n == 0) {\n            return A;\n        }\n        int l = arr[0][0];\n        int r = A;\n        while (l < r) {\n            int m = (l + r + 1) / 2;\n            int lastIndLessVal = getLastIndLessVal(arr, n, m);\n            long needMoney = m * (long) (lastIndLessVal + 1) - sum[lastIndLessVal];\n            if (needMoney <= money) {\n                l = m;\n            } else {\n                r = m - 1;\n            }\n        }\n        return l;\n    }\n\n    void run() throws Exception {\n        int n = nextInt();\n        int A = nextInt();\n        long cf = nextLong();\n        long cm = nextLong();\n        long m = nextLong();\n        Integer[][] arr = new Integer[n][2];\n        for (int i = 0; i < n; ++i) {\n            arr[i][0] = nextInt();\n            arr[i][1] = i;\n        }\n        Arrays.sort(arr, (Integer[] a, Integer[] b) -> {\n            return Integer.compare(a[0], b[0]);\n        });\n        long[] sum = new long[n];\n        sum[0] = arr[0][0];\n        for (int i = 1; i < n; ++i) {\n            sum[i] = sum[i - 1] + arr[i][0];\n        }\n        long needToFull = 0;\n        long res = 0;\n        int bestNFull = 0;\n        long bestNeedToFull = 0;\n        for (int nFull = 0; nFull <= n; ++nFull) {\n            if (needToFull > m) {\n                break;\n            }\n            int bestMin = getBestMin(arr, sum, n - nFull, m - needToFull, A);\n            long curPower = cf * nFull + cm * bestMin;\n            if (curPower > res) {\n                res = curPower;\n                bestNFull = nFull;\n                bestNeedToFull = needToFull;\n            }\n            if (nFull < n) {\n                needToFull += A - arr[n - 1 - nFull][0];\n            }\n        }\n        for (int i = 0; i < bestNFull; ++i) {\n            arr[n - 1 - i][0] = A;\n        }\n        int bestMin = getBestMin(arr, sum, n - bestNFull, m - bestNeedToFull, A);\n        for (int i = 0; i < n; ++i) {\n            arr[i][0] = Math.max(arr[i][0], bestMin);\n        }\n        int[] resVals = new int[n];\n        for (int i = 0; i < n; ++i) {\n            resVals[arr[i][1]] = arr[i][0];\n        }\n        out.println(res);\n        for (int i = 0; i < n; ++i) {\n            out.print(resVals[i] + \" \");\n        }\n    }\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~ template ~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    int[] nextIntArray(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; ++i) {\n            res[i] = nextInt();\n        }\n        return res;\n    }\n\n    int[][] nextIntArray(int nx, int ny) throws IOException {\n        int[][] res = new int[nx][ny];\n        for (int i = 0; i < nx; ++i) {\n            for (int j = 0; j < ny; ++j) {\n                res[i][j] = nextInt();\n            }\n        }\n        return res;\n    }\n\n    long[] nextLongArray(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; ++i) {\n            res[i] = nextLong();\n        }\n        return res;\n    }\n\n    long[][] nextLongArray(int nx, int ny) throws IOException {\n        long[][] res = new long[nx][ny];\n        for (int i = 0; i < nx; ++i) {\n            for (int j = 0; j < ny; ++j) {\n                res[i][j] = nextLong();\n            }\n        }\n        return res;\n    }\n\n    void fill(int[][] arr, int val) {\n        for (int i = 0; i < arr.length; ++i) {\n            Arrays.fill(arr[i], val);\n        }\n    }\n\n    void fill(int[][][] arr, int val) {\n        for (int i = 0; i < arr.length; ++i) {\n            fill(arr[i], val);\n        }\n    }\n\n    int[][] newIntArray(int nx, int ny, int val) {\n        int[][] res = new int[nx][ny];\n        fill(res, val);\n        return res;\n    }\n\n    int[][][] newIntArray(int nx, int ny, int nz, int val) {\n        int[][][] res = new int[nx][ny][nz];\n        fill(res, val);\n        return res;\n    }\n\n    long[][] newLongArray(int nx, int ny, long val) {\n        long[][] res = new long[nx][ny];\n        for (int i = 0; i < nx; ++i) {\n            Arrays.fill(res[i], val);\n        }\n        return res;\n    }\n\n    long[][][] newLongArray(int nx, int ny, int nz, long val) {\n        long[][][] res = new long[nx][ny][nz];\n        for (int i = 0; i < nx; ++i) {\n            for (int j = 0; j < ny; ++j) {\n                Arrays.fill(res[i][j], val);\n            }\n        }\n        return res;\n    }\n\n    <T> ArrayList<T>[] newArrayListArray(int sz) {\n        ArrayList<T>[] res = new ArrayList[sz];\n        for (int i = 0; i < sz; ++i) {\n            res[i] = new ArrayList<>();\n        }\n        return res;\n    }\n\n    String nextToken() throws IOException {\n        while (strTok == null || !strTok.hasMoreTokens()) {\n            String line = in.readLine();\n            if (line == null) {\n                return null;\n            }\n            strTok = new StringTokenizer(line);\n        }\n        return strTok.nextToken();\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    static StringTokenizer strTok;\n    final static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    final static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n}\n", "label": 3}
{"src": "\nimport java.io.File;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class A {\n    \n    private class Pair implements Comparable<Pair> {\n        long first, second;\n        \n        public Pair(long k, long v){\n            first = k;\n            second = v;\n        }\n        \n        public int compareTo(Pair o) {\n            return Long.compare(first, o.first);\n        }\n    \n    }\n    \n    \n    PrintStream cout = new PrintStream(System.out);\n    Scanner cin;\n    final int MAX_LIMIT = 100 * 1000 + 100;\n    \n    long[] arr = new long[MAX_LIMIT];\n    Pair[] orig = new Pair[MAX_LIMIT];\n    \n\n    void solve() {\n        int n = cin.nextInt();\n        long A = cin.nextLong();\n        long cf = cin.nextLong();\n        long cm = cin.nextLong();\n        long m = cin.nextLong();\n        \n        for(int i = 0; i < n; i++){\n            orig[i] = new Pair(cin.nextLong(), i);\n        }\n        \n        Arrays.sort(orig, 0, n);\n        \n        long ans = 0;\n        int bestlimit = n;\n        long bestleftmin = 0;\n        long aux = Long.MAX_VALUE;\n        for(int i = 0; i < n; i++){\n            arr[i] = orig[i].first;\n            aux = Math.min(arr[i], aux);\n            if(arr[i] == A) ans += cf;\n        }    \n        \n        ans += aux * cm;\n        \n        long allmoney = m;\n        int limit = n;\n        int j = 0;\n        long curmin = arr[0];\n        long nextmin = 0;\n\n        for(int i = n - 1; i >= 0; i--){\n            if(allmoney >= A - arr[i]){\n                allmoney -= A - arr[i];\n                limit = i;\n            }\n            else break;\n        }\n       \n\n        if(limit <= 0){ //all can be A\n            ans = n * cf + A * cm;\n            cout.println(ans);\n            for(int i = 0; i < n; i++){\n                if(i > 0) cout.print(\" \");\n                cout.print(A);\n            }\n            return;\n        }\n\n        while(true){\n            while(true){\n                while(j < limit && arr[j] == curmin){\n                    j++;\n                }\n\n                nextmin = (j < limit ? arr[j] : A);\n\n                if(allmoney >= j * (nextmin - curmin)){\n                    allmoney -= j * (nextmin - curmin);\n                    //if(cf == 51) cout.println(\"NO NO 1 \" + \"j= \" + j);\n                    curmin = nextmin;\n                }\n                else{\n                    curmin += allmoney / j;\n                    allmoney %= j;\n                    \n                    //if(cf == 51) cout.println(\"NO NO 2 \" + \"j= \" + j);\n                    break;\n                }\n            }\n\n            //get ans and best idx\n            long curans = curmin * cm + (n - limit) * cf;\n            if(curans > ans){\n//                if(cf== 51 && cm == 60){\n//                    cout.println(\"-> \" + curans + \" \" + curmin + \" \" + (n - limit));\n//                }\n                ans = curans;\n                bestlimit = limit;\n                bestleftmin = curmin;\n            }\n\n            if(limit == n){\n                break;\n            }\n            else{\n                allmoney += A - arr[limit];\n                if(arr[limit] < curmin){\n                    allmoney -= curmin - arr[limit];\n                    //if(allmoney < 0) cout.println(\"NO NO\");\n                    arr[limit] = curmin;\n                }\n                limit++;\n            }\n        }\n        \n        cout.println(ans);\n        \n        for(int i = n - 1; i >= 0; i--){\n            if(i >= bestlimit){\n                orig[i].first = A;\n            }\n            else if(orig[i].first < bestleftmin){\n                orig[i].first = bestleftmin;\n            }\n            arr[(int)orig[i].second] = orig[i].first;\n        } \n        \n        for(int i = 0; i < n; i++){\n            if(i > 0) cout.print(\" \");\n            cout.print(arr[i]);\n        }\n        \n    }\n\n    void run(String[] args) throws Exception {\n\n        boolean is_local = args.length > 0 && args[0].equals(\"MASHREGHI\");\n        if (is_local) {//this is local host\n            File inputFile = new File(System.getProperty(\"user.dir\")\n                    + \"\\\\src\\\\in.in\");\n            cin = new Scanner(inputFile);\n            cout.print(System.getProperty(\"user.dir\") + \"\\\\src\\\\\"\n                    + this.getClass().getName() + \".java\\n\"); //this is to be used when submitting code\n        } else {\n            cin = new Scanner(System.in);\n        }\n\n        solve();\n\n        if (is_local) {\n            cout.println();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        new A().run(args);\n    }\n\n}\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        ProblemBSkills solver = new ProblemBSkills();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ProblemBSkills {\n        int n;\n        int cf;\n        int cm;\n        long A;\n        long m;\n        Pair[] a;\n        long[] preSum;\n        int ansIdx;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            n = in.readInt();\n            A = in.readInt();\n            cf = in.readInt();\n            cm = in.readInt();\n            m = in.readLong();\n\n            a = new Pair[n];\n            for (int i = 0; i < n; i++) a[i] = new Pair(i, in.readInt());\n            Arrays.sort(a);\n            long[] sum = new long[n + 1];\n            preSum = new long[n + 1];\n            for (int i = n - 1; i >= 0; i--) sum[i] = sum[i + 1] + a[i].v;\n            preSum[0] = a[0].v;\n            for (int i = 1; i < n; i++) preSum[i] = preSum[i - 1] + a[i].v;\n\n            long ans = 0, post = n, pre = -1, val = 0;\n            for (int i = n; i >= 0; i--) {\n                long req = (n - i) * A - (sum[i] - sum[n]);\n                if (req > m) break;\n                long min = i == 0 ? A : max(m - req, i - 1);\n                long t = (n - i) * cf + min * cm;\n                if (ans < t) {\n                    ans = t;\n                    pre = ansIdx;\n                    post = i;\n                    val = min;\n                }\n            }\n            for (int i = 0; i <= pre; i++) a[i].v = (int) val;\n            for (int i = (int) post; i < n; i++) a[i].v = (int) A;\n            Arrays.sort(a, Comparator.comparingInt(o -> o.idx));\n            out.println(ans);\n            for (Pair p : a) out.print(p.v + \" \");\n        }\n\n        long max(long left, int limit) {\n            long low = 0, high = A;\n            while (low < high) {\n                long mid = (low + high + 1) / 2;\n                int idx = search((int) mid, limit);\n                if (idx < 0 || mid * (idx + 1) - preSum[idx] <= left) {\n                    low = mid;\n                    ansIdx = idx;\n                } else high = mid - 1;\n            }\n            return low;\n        }\n\n        int search(int v, int limit) {\n            int low = -1, high = limit;\n            while (low < high) {\n                int mid = (low + high + 1) / 2;\n                if (a[mid].v <= v) {\n                    low = mid;\n                } else high = mid - 1;\n            }\n            return low;\n        }\n\n    }\n\n    static class Pair implements Comparable<Pair> {\n        int idx;\n        int v;\n\n        public Pair(int ti, int tv) {\n            idx = ti;\n            v = tv;\n        }\n\n\n        public int compareTo(Pair o) {\n            return v - o.v;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long readLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.util.*;\n\npublic class Project\n{\n    public static void main(String[] args)\n    {\n        Scanner sc = new Scanner(System.in);\n        int k2 = sc.nextInt();\n        int k3 = sc.nextInt();\n        int k5 = sc.nextInt();\n        int k6 = sc.nextInt();\n        long sum = 0;\n        boolean is_continue = false;\n\n        if (k5 < k6) {\n            if (k5 < k2) {\n                sum = k5 * 256; k2 -= k5; is_continue = true;\n            } else {\n                System.out.println(k2 * 256);\n            }\n        } else {\n            if (k6 < k2) {\n                sum = k6 * 256; k2 -= k6; is_continue = true;\n            } else {\n                System.out.println(k2 * 256);\n            }\n        }\n\n        if (is_continue) {\n            if (k3 > k2) {\n                System.out.println(sum + (k2 * 32));\n            } else {\n                System.out.println(sum + (k3 * 32));\n            }\n        }\n    }\n}", "label": 0}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n\tpublic static PrintWriter w = new PrintWriter(System.out);\n\tpublic static void main(String args[] ) throws Exception {\n\t\tReader in = new Reader();\n\t\tint[] arr = in.nextIntArray(4);\n\t\tint min = arr[0];\n\t\tif(arr[2] < min)\n\t\t\tmin = arr[2];\n\t\tif(arr[3] < min)\n\t\t\tmin = arr[3];\n\t\tint cnt = min*(256);\n\t\tarr[0] -= min;\n\t\tif(arr[0] < arr[1])\n\t\t\tcnt += (32*arr[0]);\n\t\telse\n\t\t\tcnt += (32*arr[1]);\n\t\tw.println(cnt);\n\t\tw.flush();\n\t\treturn;\n\t}\n}\n\nclass Reader {\n\tfinal private int BUFFER_SIZE = 1 << 16;\n\tprivate DataInputStream din;\n\tprivate byte[] buffer;\n\tprivate int bufferPointer, bytesRead;\n\n\tpublic Reader() {\n\t\tdin = new DataInputStream(System.in);\n\t\tbuffer = new byte[BUFFER_SIZE];\n\t\tbufferPointer = bytesRead = 0;\n\t}\n\tpublic String nextLine() throws IOException {\n\t\tint c = read();\n\t\twhile(isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while(!isEndOfLine(c));\n\t\treturn res.toString();\n\t}\n\tpublic String next() throws IOException {\n\t\tint c = read();\n\t\twhile(isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while(!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\tpublic int nextInt() throws IOException {\n\t\tint ret = 0;\n\t\tbyte c = read();\n\t\twhile(c <= ' ')\n\t\t\tc = read();\n\t\tboolean neg = (c == '-');\n\t\tif(neg)\n\t\t\tc = read();\n\t\tdo {\n\t\t\tret = ret * 10 + c - '0';\n\t\t} while((c = read()) >= '0' && c <= '9');\n\t\tif (neg)\n\t\t\treturn -ret;\n\t\treturn ret;\n\t}\n\tpublic int[] nextIntArray(int n) throws IOException {\n\t\tint a[] = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\ta[i] = nextInt();\n\t\treturn a;\n\t}\n\tpublic int[][] next2dIntArray(int n, int m) throws IOException {\n\t\tint a[][] = new int[n][m];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tfor(int j = 0; j < m; j++)\n\t\t\t\ta[i][j] = nextInt();\n\t\treturn a;\n\t}\n\tpublic char nextChar() throws IOException {\n\t\treturn next().charAt(0);\n\t}\n\tpublic long nextLong() throws IOException {\n\t\tlong ret = 0;\n\t\tbyte c = read();\n\t\twhile(c <= ' ')\n\t\t\tc = read();\n\t\tboolean neg = (c == '-');\n\t\tif(neg)\n\t\t\tc = read();\n\t\tdo {\n\t\t\tret = ret * 10 + c - '0';\n\t\t} while((c = read()) >= '0' && c <= '9');\n\t\tif (neg)\n\t\t\treturn -ret;\n\t\treturn ret;\n\t}\n\tpublic double nextDouble() throws IOException {\n\t\tdouble ret = 0, div = 1;\n\t\tbyte c = read();\n\t\twhile(c <= ' ')\n\t\t\tc = read();\n\t\tboolean neg = (c == '-');\n\t\tif(neg)\n\t\t\tc = read();\n\t\tdo {\n\t\t\tret = ret * 10 + c - '0';\n\t\t} while((c = read()) >= '0' && c <= '9');\n\t\tif (c == '.') {\n\t\t\twhile((c = read()) >= '0' && c <= '9') {\n\t\t\t\tret += (c - '0') / (div *= 10);\n\t\t\t}\n\t\t}\n\t\tif(neg)\n\t\t\treturn -ret;\n\t\treturn ret;\n\t}\n\tprivate void fillBuffer() throws IOException {\n\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n\t\tif(bytesRead == -1)\n\t\t\tbuffer[0] = -1;\n\t}\n\tprivate byte read() throws IOException {\n\t\tif(bufferPointer == bytesRead)\n\t\t\tfillBuffer();\n\t\treturn buffer[bufferPointer++];\n\t}\n\tpublic void close() throws IOException {\n\t\tif(din == null)\n\t\t\treturn;\n\t\tdin.close();\n\t}\n\tpublic boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\tprivate boolean isEndOfLine(int c) {\n\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t}\n}", "label": 0}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Anton_And_Digits {\n\tpublic static void main(String[]args) {\n\t\tScanner sc= new Scanner(System.in);\n\t\tint two =sc.nextInt(),three=sc.nextInt(),five=sc.nextInt(),six=sc.nextInt();\n\t\tint min = Math.min(two, Math.min(five, six));\n\t\ttwo-=min;int min2=Math.min(two, three);\n\t\t\n\t\tSystem.out.println(min*256+min2*32);\n\t}\n}\n", "label": 0}
{"src": "\nimport java.util.Scanner;\npublic class codeforces_734B {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint[] arr = new int[4];\n\t\tfor(int i=0;i<4;i++) {\n\t\t\tarr[i]= sc.nextInt();\n\t\t\t//2 3 5 6\n\t\t}\n\t\t\n\t\tint twofs=0;\n\t\tint total=0;\n\t\tint threet=0;\n\t\tif(arr[0]<arr[2]) {\n\t\t\ttwofs = (arr[0]<arr[3])?arr[0]:arr[3];\n\t\t}else {\n\t\t\ttwofs = (arr[2]<arr[3])?arr[2]:arr[3];\n\t\t}\n\t\tarr[0]-=twofs;\n\t\tarr[2]-=twofs;\n\t\tarr[3]-=twofs;\n\t\tthreet = (arr[0]>arr[1])?arr[1]:arr[0];\n\t\tSystem.out.println(twofs*256+threet*32);\n\t\n\t\t\n\t\t\n\n\t}\n\n}\n", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class AntonDigits {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tString[] t = in.readLine().split(\" \");\n\t\t\n\t\tint a = Integer.parseInt(t[0]);\n\t\tint b = Integer.parseInt(t[1]);\n\t\tint c = Integer.parseInt(t[2]);\n\t\tint d = Integer.parseInt(t[3]);\n\n\t\tint cc = 0;\n\t\tif(a == 0){\n\t\t\tSystem.out.println(0);\n\t\t} else {\n\t\t\tif(c > 0 && d > 0){\n\t\t\t\tint min = Math.min(a,Math.min(c,d));\n\t\t\t\tcc+=(min*256);\n\t\t\t\ta-=min;\n\t\t\t\tc-=min;\n\t\t\t\td-=min;\n\t\t\t}\n\t\t\tif(a > 0 && b > 0){\n\t\t\t\tint min = Math.min(a, b);\n\t\t\t\tcc+=(min*32);\n\t\t\t\ta-=min;\n\t\t\t\tb-=min;\n\t\t\t}\n\t\t\tSystem.out.println(cc);\n\t\t}\n\t}\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\n/**\n * Created by Reem on 19/11/2016.\n */\npublic class AntonAndDigits {\n    public static void main(String[] args) {\n        int tmp1, tmp2, tmpK2;\n        Scanner scanner = new Scanner(System.in);\n        int k2 = scanner.nextInt();\n        int k3 = scanner.nextInt();\n        int k5 = scanner.nextInt();\n        int k6 = scanner.nextInt();\n        int lar = Math.min(k5, Math.min(k6, k2));\n        tmp1 = Math.min(k2, k3);\n        tmp2 = k2 - tmp1;\n        tmpK2 = k2 - lar;\n        System.out.println(Math.max((256 * lar) + (32 * Math.min(tmpK2, k3)),\n                (256 * Math.min(k5, Math.min(k6, tmp2))) + (32 * tmp1)));\n\n    }\n}\n", "label": 0}
{"src": "import java.util.*;\npublic class Main\n{\n    public static void main(String[] args) {\n        long k2, k3, k5, k6, sum;\n        sum = 0l;\n\n        Scanner sc = new Scanner(System.in);\n\n        k2 = sc.nextLong();\n        k3 = sc.nextLong();\n        k5 = sc.nextLong();\n        k6 = sc.nextLong();\n\n        long min1 = Math.min(k2, Math.min(k5, k6));\n        long min2 = Math.min(k3, k2-min1);\n\n        if (k2 == 1 && k3 == 1 && k5 == 1 && k6 == 1) {\n            System.out.println(\"256\");\n        }\n        else {\n            for (long i = 1; i <= min1; i++) {\n                sum = sum + 256;\n            }\n            for (long i = 1; i <= min2; i++) {\n                sum = sum + 32;\n            }\n            System.out.println(sum);\n        }\n    }\n}\n", "label": 0}
{"src": "import static java.lang.Integer.parseInt;\nimport static java.lang.System.exit;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n    static void solve() throws Exception {\n    \t\n    \tString [] a = in.readLine().split(\" \");\n    \tint [] t = new int[a.length];\n    \tfor (int i = 0; i < t.length; i++) {\n\t\t\tt[i] = Integer.parseInt(a[i]);\n\t\t}\n    \t\n\n    \tint result = 0;\n    \t\n    \tfor (int i = 0; i < Integer.MAX_VALUE; i++) {\n\t\t\tif(t[0] == 0 || t[2] == 0 || t[3] == 0)\n\t\t\t\tbreak;\n\t\t\tresult += 256;\n\t\t\tt[0]--;\n\t\t\tt[2]--;\n\t\t\tt[3]--;\n\t\t}\n    \t\n    \tif(t[0] > 0 && t[1] > 0){\n    \t\tfor (int i = 0; i < Integer.MAX_VALUE; i++) {\n\t\t\t\tif(t[0] == 0 || t[1] == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tresult += 32;\n\t    \t\tt[0]--;\n\t    \t\tt[1]--;\n\t\t\t}\n    \t\t\n    \t}\n    \t\n    \tSystem.out.println(result);\n    }\n\n    static int nextInt() throws IOException {\n        return parseInt(next());\n    }\n\n    static String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    public static void main(String[] args) {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n            solve();\n            in.close();\n            out.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            exit(0);\n        }\n    }\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n}", "label": 0}
{"src": "\nimport java.util.Scanner;\n\n/**\n * @Created by sbhowmik on 21/11/18\n */\npublic class AntonAndDigits {\n\n    public static void main(String []args) {\n\n        Scanner scanner = new Scanner(System.in);\n        int a = scanner.nextInt();\n        int b = scanner.nextInt();\n        int c = scanner.nextInt();\n        int d = scanner.nextInt();\n\n\n        if ((a - Math.min(a, Math.min(c,d))) > 0) {\n            System.out.println(Math.min(a, Math.min(c, d)) * 256 + Math.min(b,a - Math.min(a, Math.min(c,d)))*32);\n        } else {\n            System.out.println(Math.min(a, Math.min(c, d)) * 256);\n\n        }\n    }\n}\n", "label": 0}
{"src": "import java.io.*;\n\npublic class CF {\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    \n    public static void main(String[] args) throws IOException {\n        String[] split = br.readLine().split(\" \");\n        \n        int two = Integer.parseInt(split[0]);\n        int three = Integer.parseInt(split[1]);\n        int five = Integer.parseInt(split[2]);\n        int six = Integer.parseInt(split[3]);\n        \n        int twoFiveSix = Math.min(Math.min(two, five), six);\n        two -= twoFiveSix;\n        int threeTwo = Math.min(two, three);\n        \n        pw.println(256*twoFiveSix + 32*threeTwo);\n        \n        pw.close();\n    }\n}", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class p000734B {\n    static public void main(String[] args) throws IOException {\n        new Solver() {{{ nameIn = \"p000734B.in\"; singleTest = true;}}\n            @Override\n            public void process(BufferedReader br, PrintWriter pw) throws IOException {\n                int[] k = readIntArray(br);\n                solve(k[0], k[1], k[2], k[3], pw);\n            }\n\n            private void solve(int k2, int k3, int k5, int k6, PrintWriter pw) {\n                int max256 = Math.min(Math.min(k2, k5), k6);\n                long max = 0;\n                for(int i = 0; i <= max256; i++) {\n                    long sum = 256 * i + 32 * Math.min(k2 - i, k3);\n                    if(sum > max) {\n                        max = sum;\n                    }\n                }\n                pw.println(max);\n            }\n\n        }.run();\n    }\n// begin import package net.leksi.contest;\nstatic abstract class Solver{protected String nameIn=null;protected String nameOut=null\n;protected boolean singleTest=false;private void preProcess(final BufferedReader\nbr,final PrintWriter pw)throws IOException{if(!singleTest){int t=Integer.valueOf\n(br.readLine().trim());while(t-->0){process(br,pw);}}else{process(br,pw);}}abstract\npublic void process(final BufferedReader br,final PrintWriter pw)throws IOException\n;protected int[]readIntArray(final BufferedReader br)throws IOException{return Arrays\n.stream(br.readLine().trim().split(\"\\\\s+\")).mapToInt(v->Integer.valueOf(v)).toArray\n();}protected long[]readLongArray(final BufferedReader br)throws IOException{return\nArrays.stream(br.readLine().trim().split(\"\\\\s+\")).mapToLong(v->Long.valueOf(v)).toArray\n();}protected String readString(final BufferedReader br)throws IOException{return\nbr.readLine().trim();}protected String intArrayToString(final int[]a){return Arrays\n.stream(a).mapToObj(v->Integer.toString(v)).collect(Collectors.joining(\" \"));}protected\nString longArrayToString(final long[]a){return Arrays.stream(a).mapToObj(v->Long\n.toString(v)).collect(Collectors.joining(\" \"));}public void run()throws IOException\n{try{try(FileReader fr=new FileReader(nameIn);BufferedReader br=new BufferedReader\n(fr);PrintWriter pw=select_output();){preProcess(br,pw);}}catch(Exception ex){try\n(InputStreamReader fr=new InputStreamReader(System.in);BufferedReader br=new BufferedReader\n(fr);PrintWriter pw=select_output();){preProcess(br,pw);}}}private PrintWriter select_output\n()throws FileNotFoundException{if(nameOut !=null){return new PrintWriter(nameOut\n);}return new PrintWriter(System.out);}}\n// end import package net.leksi.contest;\n}\n", "label": 0}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.NoSuchElementException;\nimport java.io.InputStream;\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Alex\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int[] c = IOUtils.readIntArray(in, 4);\n            int t = ArrayUtils.minElement(new int[] {c[0], c[2], c[3]});\n            int o = ArrayUtils.minElement(new int[] {c[0] - t, c[1]});\n            out.printLine(256 * t + 32 * o);\n        }\n    }\n    static interface IntIterator {\n        public int value() throws NoSuchElementException;\n        public boolean advance();\n        public boolean isValid();\n    }\n    static class IOUtils {\n        public static int[] readIntArray(InputReader in, int size) {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = in.readInt();\n            }\n            return array;\n        }\n    }\n    static interface IntStream extends Iterable<Integer>, Comparable<IntStream> {\n        public IntIterator intIterator();\n        default public Iterator<Integer> iterator() {\n            return new Iterator<Integer>() {\n                private IntIterator it = intIterator();\n                public boolean hasNext() {\n                    return it.isValid();\n                }\n                public Integer next() {\n                    int result = it.value();\n                    it.advance();\n                    return result;\n                }\n            };\n        }\n        default public int compareTo(IntStream c) {\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                int i = it.value();\n                int j = jt.value();\n                if (i < j) {\n                    return -1;\n                } else if (i > j) {\n                    return 1;\n                }\n                it.advance();\n                jt.advance();\n            }\n            if (it.isValid()) {\n                return 1;\n            }\n            if (jt.isValid()) {\n                return -1;\n            }\n            return 0;\n        }\n        default public int min() {\n            int result = Integer.MAX_VALUE;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                int current = it.value();\n                if (current < result) {\n                    result = current;\n                }\n            }\n            return result;\n        }\n    }\n    static class ArrayUtils {\n        public static int minElement(int[] array) {\n            return new IntArray(array).min();\n        }\n    }\n    static class IntArray extends IntAbstractStream implements IntList {\n        private int[] data;\n        public IntArray(int[] arr) {\n            data = arr;\n        }\n        public int size() {\n            return data.length;\n        }\n        public int get(int at) {\n            return data[at];\n        }\n        public void removeAt(int index) {\n            throw new UnsupportedOperationException();\n        }\n    }\n    static interface IntReversableCollection extends IntCollection {\n    }\n    static interface IntCollection extends IntStream {\n        public int size();\n    }\n    static abstract class IntAbstractStream implements IntStream {\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            boolean first = true;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                if (first) {\n                    first = false;\n                } else {\n                    builder.append(' ');\n                }\n                builder.append(it.value());\n            }\n            return builder.toString();\n        }\n        public boolean equals(Object o) {\n            if (!(o instanceof IntStream)) {\n                return false;\n            }\n            IntStream c = (IntStream) o;\n            IntIterator it = intIterator();\n            IntIterator jt = c.intIterator();\n            while (it.isValid() && jt.isValid()) {\n                if (it.value() != jt.value()) {\n                    return false;\n                }\n                it.advance();\n                jt.advance();\n            }\n            return !it.isValid() && !jt.isValid();\n        }\n        public int hashCode() {\n            int result = 0;\n            for (IntIterator it = intIterator(); it.isValid(); it.advance()) {\n                result *= 31;\n                result += it.value();\n            }\n            return result;\n        }\n    }\n    static interface IntList extends IntReversableCollection {\n        public abstract int get(int index);\n        public abstract void removeAt(int index);\n        default public IntIterator intIterator() {\n            return new IntIterator() {\n                private int at;\n                private boolean removed;\n                public int value() {\n                    if (removed) {\n                        throw new IllegalStateException();\n                    }\n                    return get(at);\n                }\n                public boolean advance() {\n                    at++;\n                    removed = false;\n                    return isValid();\n                }\n                public boolean isValid() {\n                    return !removed && at < size();\n                }\n                public void remove() {\n                    removeAt(at);\n                    at--;\n                    removed = true;\n                }\n            };\n        }\n    }\n    static class OutputWriter {\n        private final PrintWriter writer;\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n        public void close() {\n            writer.close();\n        }\n        public void printLine(int i) {\n            writer.println(i);\n        }\n    }\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}\n\n", "label": 0}
{"src": "import java.util.Scanner;\nimport java.lang.Math;\n\n\npublic class B734{\n    public static void main(String args[]){\n        Scanner in = new Scanner(System.in);\n        int a = in.nextInt();\n        int b = in.nextInt();\n        int c = in.nextInt();\n        int d = in.nextInt();\n        int n1 = 0;\n        int n2 = 0;\n        int sum = 0;\n        int k=0;\n\n        n2=c;\n        if(d<n2){\n            n2=d;\n        }\n        n1=b;\n        \n        if((n1+n2)<=a){\n            sum=n1*32+n2*256;\n        }\n        else{\n            if(a>=n2){\n                if(n1-n2<=8){\n                    sum=n2*256+(Math.min((a-n2),b))*32;\n                }\n                else{\n                    while(n1-n2>=8 && a>=n2){\n                        n1=n1-8;\n                        a=a-8;\n                        k++;\n                    }\n                    sum=n2*256+Math.min(n1,a-n2)*32+8*k*32;\n                }\n            }\n            else{\n                sum=a*256;\n            }\n        }\n        System.out.println(sum);\n\n    }\n}", "label": 0}
{"src": "import java.util.*;\npublic class Div2b {\n\tpublic static void main(String [] args) {\n\t\tScanner input1 = new Scanner(System.in);\n\t\tint k2=input1.nextInt();\n\t\tint k3=input1.nextInt();\n\t\tint k5=input1.nextInt();\n\t\tint k6=input1.nextInt();\n\t\tlong score=0,f=1;\n\t\twhile (f!=0) {\n\t\tif (k2!=0&&k5!=0&&k6!=0) {\n\t\t\tk2--;k5--;k6--;\n\t\t\tscore+=256;\n\t\t}\n\t\telse if (k2!=0&&k3!=0) {\n\t\t\tk2--;k3--;\n\t\t\tscore+=32;\n\t\t}\n\t\telse f=0;\n\t\t}\n\t\tSystem.out.print(score);\n\t}\n\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\n\npublic class Main {\n\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\tScanner sc=new Scanner(System.in);\n\tint n,i,j,k2,k3,k5,k6;\n\t\n\tk2=sc.nextInt();k3=sc.nextInt();k5=sc.nextInt();k6=sc.nextInt();\n\t\n\tint k=Math.min(k2, Math.min(k5,k6));\n\t\n\tk2-=k;k5-=k;k6-=k;\n\t\n\tint l=Math.min(k3, k2);\n\t\n\tSystem.out.print(l*32+k*256);\n\t\n\t//System.out.println(a[n][n]);\n\t\t/*\n\t\tint b=2,i,sum=0,n;\n\t\t\n\t\tn=in.nextInt();\n\t\tString[] s= new String[n+1];\n\t\t\n\t\t\n\t\tint[] a=new int[6];\n\t\tboolean fl=false;\n\t\tin.nextLine();\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\ts[i]=in.nextLine();\n\t\t\tif(s[i].contains(\"OO\") && !fl) {fl=true; s[i].replaceFirst(\"OO\",\"++\");}\n\t\t}\n\t\t\n\t\t\n\t\tif(fl)\n\t\t{\n\t\t\tSystem.out.println(\"YES\");\n\t\t\tfor(i=1;i<=n;i++) System.out.println(s[i]);\n\t\t}\n\t\telse\n\t\t\tSystem.out.println(\"NO\");\n\t\t*/\n\t\t\n\t\t//System.out.print((s==0)?(s):(-1));\n\t}\n\n}\n", "label": 0}
{"src": "import java.util.*;\npublic class cf379b\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tint k2 = sc.nextInt();\n\t\tint k3 = sc.nextInt();\n\t\tint k5 = sc.nextInt();\n\t\tint k6 = sc.nextInt();\n\n\t\t//lets conver the case for 256\n\t\tint min1  = Math.min(k2,Math.min(k5,k6));\n\n\t\tint result1 = min1*256;\n\n\t\tk2-=min1;\n\t\tk5-=min1;\n\t\tk6-=min1;\n\n\t\t//lets conver the case for 32\n\t\tint min2 = Math.min(k3,k2);\n\t\tint result2=min2*32;\n\n\t\tSystem.out.println(result1+result2);\n\t}\n}\n\n", "label": 0}
{"src": "//package Codeforces;\n\nimport java.util.Scanner;\n\npublic class Digit {\n\t\n\tpublic static void main(String[] args)\n\t{\n\tScanner scn=new Scanner(System.in);\n\tString values[]=scn.nextLine().split(\" \");\n\tlong k2=Integer.parseInt(values[0]);\n\tlong k3=Integer.parseInt(values[1]);\n\tlong k5=Integer.parseInt(values[2]);\n\tlong k6=Integer.parseInt(values[3]);\n\tlong ans=0;\n\tlong num=Math.min(k2, Math.min(k5, k6));\n\tans+=num*256;\n\tk2-=num;\n\tk5-=num;\n\tk6-=num;\n\tnum=Math.min(k3, k2);\n\tans+=num*32;\n\tSystem.out.println(ans);\n\t}\n\t\n\n}\n", "label": 0}
{"src": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * @author ramilagger\n */\npublic class Main {\n\n    final static boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n    void solve() {\n        int[] a = nextArray(4);\n        int mint = Math.min(a[0],Math.min(a[2],a[3]));\n        long ans = 0;\n        for (int i = 0; i <= mint; i++) {\n            ans = Math.max(ans,i * 1l * 256);\n            if(Math.min(a[1],a[0] - i) >= 0)\n                ans = Math.max(ans,i * 1l * 256  + Math.min(a[1],a[0] - i) *1l * 32);\n        }\n        pw.println(ans);\n    }\n\n\n\n    public void run() throws IOException {\n        start = System.currentTimeMillis();\n        solve();\n        if (!ONLINE_JUDGE)\n            System.err.println(System.currentTimeMillis() - start + \" ms\");\n        br.close();\n        pw.close();\n    }\n\n    public Main() {\n        try {\n            br = (ONLINE_JUDGE) ? new BufferedReader(new InputStreamReader(System.in))\n                    : new BufferedReader(new FileReader(\"in.txt\"));\n            pw = (ONLINE_JUDGE) ? new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)))\n                    : new PrintWriter(new BufferedWriter(new FileWriter(\"out.txt\")));\n            this.run();\n        } catch (Exception e) {\n            e.printStackTrace();\n            throw new RuntimeException();\n        }\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n\n\n    public boolean hasNext() {\n        if (st != null && st.hasMoreTokens())\n            return true;\n        try {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    public String next() {\n        if (hasNext()) return st.nextToken();\n        return null;\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public BigInteger nextBigInteger() {\n        return new BigInteger(next());\n    }\n\n    public String nextLine() {\n        StringBuilder sb;\n        try {\n            while (st == null || !st.hasMoreTokens()) return br.readLine();\n            sb = new StringBuilder(st.nextToken());\n            while (st.hasMoreTokens()) sb.append(\" \" + st.nextToken());\n        } catch (IOException e) {\n            throw new RuntimeException();\n        }\n        return sb.toString();\n    }\n\n    public int[] nextArray(int n) {\n        int[] temp = new int[n];\n        for (int i = 0; i < n; i++)\n            temp[i] = nextInt();\n        return temp;\n    }\n\n    public long[] nextLArray(int n) {\n        long[] temp = new long[n];\n        for (int i = 0; i < n; i++)\n            temp[i] = nextLong();\n        return temp;\n    }\n\n    long start;\n    final BufferedReader br;\n    final PrintWriter pw;\n    StringTokenizer st;\n\n}", "label": 0}
{"src": "import java.util.Scanner;\n\n/**\n * Created by mar1 on 11/17/16.\n */\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        String s = scan.nextLine();\n        String[] str = s.split(\" \");\n        int[] i_256 = {\n                Integer.parseInt(str[0]),\n                Integer.parseInt(str[2]),\n                Integer.parseInt(str[3])\n        };\n        int res_256 = 256*min(i_256);\n        int[] i_32 = {\n                Integer.parseInt(str[1]),\n                Integer.parseInt(str[0])-min(i_256)\n        };\n\n        int res_32 = 32*min(i_32);\n\n        System.out.println(res_32+res_256);\n\n    }\n\n    public static int min(int[] tab){\n        int min = tab[0];\n        for(int i=1 ;i<tab.length;i++){\n            if(min > tab[i])\n                min = tab[i];\n        }\n\n        return min;\n    }\n\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class Main {\n    static Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        int a2 = scanner.nextInt();\n        int a3 = scanner.nextInt();\n        int a5 = scanner.nextInt();\n        int a6 = scanner.nextInt();\n        int min = Math.min(Math.min(a2, a5), a6);\n        int sum = min * 256 + Math.min(a2 - min, a3) * 32;\n        System.out.println(sum);\n    }\n\n\n}\n\n", "label": 0}
{"src": "\nimport java.util.Scanner;\n\npublic class Test {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint k1 = in.nextInt(); // 2\n\t\tint k2 = in.nextInt(); // 3\n\t\tint k3 = in.nextInt(); // 5\n\t\tint k4 = in.nextInt(); // 6\n\t\t\n\t\tint min = Math.min(k1, Math.min(k4, k3));\n\t\tint s = min * 256;\n\t\tk1 -= min;\n\t\t\n\t\tmin = Math.min(k1, k2);\n\t\ts += min * 32;\n\t\tSystem.out.println(s);\n\t\t\n\t}\n\t\n}", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class B379 {\n\tpublic static void main(String[] args) {\n\t\tMyScanner scan = new MyScanner();\n\t\t\n\t\tlong[] list = new long[4];\n\t\tfor(int i=0;i<4;i++)list[i] = scan.nextLong();\n\t\t\n\t\tlong tfs = Math.min(list[0], Math.min(list[2], list[3]));\n\t\tlong sol = 256*tfs;\n\t\tlist[0]-=tfs;\n\t\tlist[2]-=tfs;\n\t\tlist[3]-=tfs;\n\t\tsol+=32*Math.min(list[0], list[1]);\n\t\t\n\t\tSystem.out.println(sol);\n\t}\n\tprivate static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n           br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt(){\n            return Integer.parseInt(this.next());\n        }\n        long nextLong() {\n        \treturn Long.parseLong(next());\n        }\n     }\n}\n", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n        String read = reader.readLine();\n        String[] sarr = read.split(\" \");\n        int[] arr = new int[sarr.length];\n        for (int i = 0; i < sarr.length; i++) {\n            arr[i] = Integer.parseInt(sarr[i]);\n        }\n        int[] arr1 = {arr[0],arr[2],arr[3]};\n        Arrays.sort(arr1);\n        int summ = 0;\n        if (arr1[0]>0) {summ = 256*arr1[0];}\n        arr[0]-= arr1[0];\n        if (arr[0]>0 && arr[0]-arr[1]>0) {summ+= arr[1]*32;}\n        else {summ+= arr[0]*32;}\n        System.out.println(summ);\n    }\n}", "label": 0}
{"src": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Div2_587 {\n\n\tpublic static void A(int n, String s) {\n\t\tint ans = 0;\n\t\tchar[] c = s.toCharArray();\n\t\tfor (int i = 0; i + 1 <= c.length - 1; i += 2) {\n\t\t\tif (c[i] == c[i + 1]) {\n\t\t\t\tans++;\n\t\t\t\tif (c[i] == 'a') {\n\t\t\t\t\tc[i] = 'b';\n\t\t\t\t} else {\n\t\t\t\t\tc[i] = 'a';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t\tSystem.out.println(c);\n\t}\n\n\tpublic static boolean dead(int n, int d) {\n\n\t\tif (d <= n) {\n//\t\t\tSystem.out.println(\"YES\");\n\t\t\treturn true;\n\t\t}\n\t\tboolean flag = false;\n\n\t\tfor (int i = 1; i <= Math.sqrt(d); i++) {\n\n\t\t\tint c = (int) (i + Math.ceil((1.0 * d / (i + 1))));\n\n\t\t\tif (c <= n) {\n\t\t\t\tflag = true;\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (flag == true)\n\n\t\t\treturn true;\n\t\telse\n\n\t\t\treturn false;\n\n\t}\n\n\tpublic static int stairs(int n, int s, int[] arr) {\n\n\t\tint cnt = 0;\n\t\tfor (int i = 1; i <= n; i++) {\n\n\t\t\tfor (int j = s; j <= n; j++) {\n\t\t\t\tif (arr[i] == arr[j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\n\t\t\t\t\tcnt = Math.min(cnt, j - i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\treturn cnt;\n\n\t}\n\n\tpublic static void polycarp(int a, int b, int c, int n) {\n\n\t\tif (n == 0) {\n\t\t\tif ((a + b + c) % 3 == 0) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t} else {\n\t\t\tint sum = a + b + c + n;\n\t\t\tif (sum % 3 == 0) {\n\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic static int wrongsub(int n, int k) {\n\n\t\twhile (k != 0) {\n\n\t\t\tif (n % 10 != 0) {\n\t\t\t\tn--;\n\n\t\t\t} else {\n\t\t\t\tn = n / 10;\n\t\t\t}\n\t\t\tk--;\n\t\t}\n\t\treturn n;\n\t}\n\n\tpublic static boolean easy(int[] arr) {\n\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tif (arr[i] == 1) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tstatic int count = 0;\n\n\tpublic static int brobear(int a, int b) {\n\n\t\twhile (a <= b) {\n\t\t\ta = a * 3;\n\t\t\tb = b * 2;\n\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\n\tpublic static void restoring(int a, int b, int c, int d) {\n\n\t\tint max = a;\n\t\tmax = Math.max(max, Math.max(b, Math.max(c, d)));\n\t\ta = Math.abs(a - max);\n\t\tif (a != 0) {\n\t\t\tSystem.out.println(a);\n\t\t}\n\t\tb = Math.abs(b - max);\n\t\tif (b != 0) {\n\t\t\tSystem.out.println(b);\n\t\t}\n\t\tc = Math.abs(c - max);\n\t\tif (c != 0) {\n\t\t\tSystem.out.println(c);\n\t\t}\n\t\td = Math.abs(d - max);\n\t\tif (d != 0) {\n\t\t\tSystem.out.println(d);\n\t\t}\n\n\t}\n\n\tpublic static boolean gennedy(String tab, String[] hand) {\n\n\t\tString h = \"\";\n\t\tfor (String i : hand) {\n\t\t\th += i;\n\t\t}\n\t\tSystem.out.println(h);\n\t\tchar[] arr = h.toCharArray();\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tif (tab.charAt(0) != arr[i] || tab.charAt(1) != arr[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void suffix(String s) {\n\n\t\tif (s.endsWith(\"po\")) {\n\t\t\tSystem.out.println(\"FILIPINO\");\n\t\t} else if (s.endsWith(\"desu\") || s.endsWith(\"masu\")) {\n\t\t\tSystem.out.println(\"JAPANESE\");\n\t\t} else if (s.endsWith(\"mnida\")) {\n\t\t\tSystem.out.println(\"KOREAN\");\n\t\t}\n\n\t}\n\n\tpublic static int beautifulmat(int[][] arr) {\n\t\tint r = 0, c = 0;\n\t\tfor (int i = 0; i < 5; i++) {\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tif (arr[i][j] == 1) {\n\t\t\t\t\tr = i;\n\t\t\t\t\tc = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\tSystem.out.println(r + \" \" + c);\n\t\treturn Math.abs(2 - r) + Math.abs(2 - c);\n\t}\n\n\tpublic static int vanya(int[] arr, int h) {\n\t\tint count = 0;\n\t\tfor (int i = 0; i < arr.length; i++) {\n\t\t\tif (arr[i] > h) {\n\t\t\t\tcount += 2;\n\t\t\t} else {\n\t\t\t\tcount += 1;\n\t\t\t}\n\t\t}\n\n\t\treturn count;\n\t}\n\n\tpublic static int maxintab(int n) {\n\n\t\tint[][] strg = new int[n][n];\n\n\t\tfor (int i = 0; i < strg.length; i++) {\n\t\t\tfor (int j = 0; j < strg[0].length; j++) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tstrg[0][j] = 1;\n\t\t\t\t} else if (j == 0) {\n\t\t\t\t\tstrg[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tstrg[i][j] = strg[i - 1][j] + strg[i][j - 1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn strg[n - 1][n - 1];\n\t}\n\n\tpublic static int mezo(String s) {\n\t\tif (s.length() == 0) {\n\t\t\treturn 0;\n\t\t}\n\t\tint l = 0;\n\t\tint r = 0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tchar ch = s.charAt(i);\n\t\t\tif (ch == 'L') {\n\t\t\t\tl--;\n\t\t\t} else if (ch == 'R') {\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\treturn Math.abs(l) + Math.abs(r) + 1;\n\t}\n\n\tpublic static long frogjump(long a, long b, long k) {\n\n\t\treturn a * ((k + 1) / 2) - b * (k / 2);\n\t}\n\n\tpublic static String cipher(String s) {\n\t\tString ans = \"\";\n\t\tint i = 0;\n\t\tint count = 1;\n\t\twhile (i < s.length()) {\n\t\t\tans += s.charAt(i);\n\t\t\tcount += 1;\n\t\t\ti += count;\n\t\t}\n//\t\tSystem.out.println(ans);\n\t\treturn ans;\n\t}\n\n\tpublic static int erase(String s) {\n\t\tint f = s.indexOf(\"1\");\n\t\tint l = s.lastIndexOf(\"1\");\n\t\tint cnt = 0;\n\t\tif (f == l) {\n//\t\t\tSystem.out.println(0);\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int i = f; i <= l; i++) {\n\t\t\tif (s.charAt(i) == '0') {\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\n\tpublic static int bacterialover(int n) {\n\t\tint ans = 0;\n//\t\tSystem.out.println((int)Math.sqrt(n));\n\t\twhile (n != 0) {\n\t\t\tif ((n % 2) != 0)\n\t\t\t\tans++;\n//\t\t\tif (n % 2 != 0) {\n//\t\t\t\tn -= 1;\n//\t\t\t}\n//\t\t\tn -= 2;\n\t\t\tn >>= 1;\n\t\t}\n\t\treturn ans;\n\t}\n\n\tpublic static int limak(int n, int k) {\n\t\tint i;\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tk += i * 5;\n\t\t\tif (k > 240)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn i - 1;\n\t}\n\n\tpublic static int patrick(int a, int b, int c) {\n\t\treturn Math.min(a, b + c) + Math.min(b, a + c) + Math.min(c, a + b);\n\t}\n\n\tpublic static long digits(long a, long b, long c, long d) {\n\n\t\tlong m = Math.min(a, Math.min(c, d));\n\t\tlong n = Math.min(a - m > 0 ? a - m : 0, b);\n\n\t\treturn m * 256 + n * 32;\n\t}\n\n\tpublic static void main(String args[]) {\n\n\t\tScanner scn = new Scanner(System.in);\n\t\tlong a = scn.nextInt();\n\t\tlong b = scn.nextInt();\n\t\tlong c = scn.nextInt();\n//\t\tSystem.out.println(patrick(n, k, z));\n\t\tlong d = scn.nextInt();\n\t\tSystem.out.println(digits(a, b, c, d));\n\t}\n\n}\n", "label": 0}
{"src": "//package github;\n\nimport java.util.Scanner;\n\npublic class Main\n{\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner s = new Scanner(System.in);\n\t\tint a = s.nextInt();\n\t\tint b = s.nextInt();\n\t\tint c = s.nextInt();\n\t\tint d = s.nextInt();\n\n\t\tint min = Math.min(a, Math.min(c, d));\n\t\tlong ans = min * 256;\n\t\ta = a - min;\n\t\tmin = Math.min(a, b);\n\t\tans = ans + min * 32;\n\t\tSystem.out.println(ans);\n\n\t}\n\n}\n", "label": 0}
{"src": "import java.util.HashMap;\nimport java.util.Scanner;\n\n/**\n * Created by akshaysharma on 05/12/16.\n */\npublic class Problem734B {\n\n    public static void main(String[]args){\n        HashMap<Integer,Integer> map = new HashMap<>();\n        Scanner sc = new Scanner(System.in);\n        int index = sc.nextInt();\n        map.put(2,index);\n        index = sc.nextInt();\n        map.put(3,index);\n        index = sc.nextInt();\n        map.put(5,index);\n        index = sc.nextInt();\n        map.put(6,index);\n        int sum = 0;\n        while(true){\n            if(map.get(2)>=1&&map.get(5)>=1&&map.get(6)>=1){\n                sum+=256;\n                map.put(2,map.get(2)-1);\n                map.put(5,map.get(5)-1);\n                map.put(6,map.get(6)-1);\n            }\n            else if(map.get(2)>=1&&map.get(3)>=1){\n                sum+=32;\n                map.put(3,map.get(3)-1);\n                map.put(2,map.get(2)-1);\n            }\n            else\n                break;\n        }\n\n        System.out.print(sum);\n    }\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\n/**\n * 5 1 3 4\n \u0432\u044b\u0445\u043e\u0434\u043d\u044b\u0435 \u0434\u0430\u043d\u043d\u044b\u0435\n 800\n */\npublic class B_AntonAndDigits {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int k2 = in.nextInt();\n        int k3 = in.nextInt();\n        int k5 = in.nextInt();\n        int k6 = in.nextInt();\n        int numOf256 = Math.min(k2, Math.min(k5, k6));\n        k2 -= numOf256;\n        k5 -= numOf256;\n        k6 -= numOf256;\n        int numOf32 = Math.min(k2, k3);\n        System.out.println(numOf32 * 32 + numOf256 * 256);\n    }\n}\n", "label": 0}
{"src": "\nimport java.util.Scanner;\n\n/**\n *\n * @author gabriel\n */\npublic class Sample2 {\n public static void main(String[] args) {\n \n     int k2=0, k3=0,k5=0,k6=0;\n          \n     Scanner sc=new Scanner(System.in);\n     String val=sc.nextLine();\n     \n     \n     String[] vals=val.split(\" \");\n     \n     k2=   Integer.parseInt(vals[0]);\n     k3=   Integer.parseInt(vals[1]);\n     k5=   Integer.parseInt(vals[2]);\n     k6=   Integer.parseInt(vals[3]);\n             \n             \n     if (!((0<=k2 && k2<=5100000) && (0<=k3 && k3<=5100000) && (0<=k5 && k5<=5100000) && (0<=k6 && k6<=5100000) ))\n         return;\n     boolean nonumber=false;\n     int suma=0;\n        boolean no256=false;\n        boolean no32=false;\n         \n     while(!no256){\n         int num=0;\n\n         if (k2>0 )\n            if (k5>0)\n                if (k6>0){\n                    suma+=256;\n                    k2--;\n                    k5--;\n                    k6--;\n                }else\n                    no256=true;\n            else\n                no256=true;\n         else\n            no256=true;        \n     }\n     \n     while(!no32){\n     \n         if(k3>0)\n             if (k2>0){\n                 suma+=32;\n                 k3--;\n                 k2--;\n             }else\n                 no32=true;\n         else\n             no32=true;\n         \n         if (no32 && no256)\n             nonumber=true;\n     }      \n     \n     System.out.print(suma);\n     \n }    \n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class AntonAndDigits {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint k2 = sc.nextInt();\n\t\tint k3 = sc.nextInt();\n\t\tint k5 = sc.nextInt();\n\t\tint k6 = sc.nextInt();\n\t\tint output = 0;\n\t\twhile(k2>0&&k5>0&&k6>0) {\n\t\t\toutput+=256;\n\t\t\tk2--;\n\t\t\tk5--;\n\t\t\tk6--;\n\t\t\t//System.out.println(output);\n\t\t}\n\t\t//System.out.println(k6);\n\t\twhile(k3>0&&k2>0) {\n\t\t\toutput+=32;\n\t\t\tk3--;\n\t\t\tk2--;\n\t\t}\n\t\tSystem.out.println(output);\n\n\t}\n\n}\n", "label": 0}
{"src": "/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Main\n{\n\n\n         \n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n            Scanner in=new Scanner(System.in);\n            int tw=in.nextInt();\n            int th=in.nextInt();\n            int fi=in.nextInt();\n            int si=in.nextInt();\n            int sum=0;\n            int large=min(tw,fi,si);\n\n            sum+=large*256;\n\n            tw-=large;\n\n            int small=Math.min(tw,th);\n            sum+=small*32;\n\n            System.out.println(sum);\n\n\n    }\n\n    public static int min(int a,int b,int c)\n    {\n        int temp=Math.min(a,b);\n\n        return Math.min(temp,c);\n    }\n}\n", "label": 0}
{"src": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int k2 = s.nextInt();\n        int k3 = s.nextInt();\n        int k5 = s.nextInt();\n        int k6 = s.nextInt();\n        int response = 0;\n        List<Integer> p = new ArrayList<>();\n        p.add(k2);\n        p.add(k5);\n        p.add(k6);\n        k2 -= Collections.min(p);\n        response += Collections.min(p) * 256;\n        if(k3 < k2){\n            response += k3 * 32;\n        }\n        else{\n            response += k2 *32;\n        }\n        System.out.println(response);\n    }\n}\n", "label": 0}
{"src": "import java.util.*;\npublic class Main {\n    public static void main(String afzalkhan[] ) throws Exception {\n        Scanner sc = new Scanner(System.in);\n        long a = sc.nextInt();\n        long b = sc.nextInt();\n        long c = sc.nextInt();\n        long d = sc.nextInt();\n        long sum = 0;\n        int flag=0;\n        for(int i=0;flag!=1;i++){\n            if(a>0 && c>0 && d>0){\n                sum = sum + 256;\n                a--;c--;d--;\n            }            \n            if(a<=0 || c<=0 || d<=0){\n                flag=1;\n            }\n        }\n        if(a>0){\n            for(int i=0;flag!=0;i++){\n                if(a>0 && b>0){\n                    sum = sum + 32;\n                }\n                a--;b--;\n                if(a<=0 || b<=0){\n                    flag=0;\n                }\n            }\n        }\n        System.out.println(sum);\n    }\n}", "label": 0}
{"src": "\nimport java.util.Scanner;\n\npublic class JavaApplication12 {\n    \n    public static void main(String[] args) {\n        \n        Scanner input = new Scanner(System.in);\n        \n        int k2 = input.nextInt();\n        int k3 = input.nextInt();\n        int k5 = input.nextInt();\n        int k6 = input.nextInt();\n        \n        int min = k2;\n        if(min > k5)\n            min = k5;\n        if(min > k6)\n            min = k6;\n        \n        int count256 = min;\n        \n        k2 = k2 - min;\n        \n        if(k2 == 0)\n            System.out.println(256 * count256);\n        else\n        {\n            min = k2;\n            if(min > k3)\n                min = k3;\n            int count32 = min;\n            System.out.println(256 * count256 + 32 * count32);\n        }\n        \n    }\n}", "label": 0}
{"src": "\nimport java.util.*;\n\npublic class CP {\n\n    static Scanner sc = new Scanner(System.in);\n    static int n2;\n    static int n3;\n    static int n5;\n    static int n6;\n    static long c = 0;\n\n    static void solve() {\n        int min = Integer.min(Integer.min(n2, n5), n6);\n        n2 -= min;\n        n5 -= min;\n        n6 -= min;\n        c += min * 256;\n        \n        min = Integer.min(n2, n3);\n        c += min * 32;\n    }\n\n    public static void main(String[] args) {\n\n        n2 = sc.nextInt();\n        n3 = sc.nextInt();\n        n5 = sc.nextInt();\n        n6 = sc.nextInt();\n\n        solve();\n\n        System.out.println(c);\n    }\n\n}\n", "label": 0}
{"src": "\t\t\n\t\t\timport java.io.BufferedReader;\n\t\t\timport java.io.IOException;\n\t\t\timport java.io.InputStreamReader;\n\t\t\timport java.util.Arrays;\n\t\timport java.util.HashMap;\n\t\timport java.util.Random;\n\t\timport java.util.*;\n\t\timport java.util.StringTokenizer;\n\t\t\t import java.util.Scanner;\n\t\t\tpublic class Comptetive {\n\t\t\t\tstatic class Pair{\n\t\t\t\t\tint f;\n\t\t\t\t\tint s;\n\t\t\t\t\t\n\t\t\t\t\tPair(int f,int s){\n\t\t\t\t\t\tthis.f=f;\n\t\t\t\t\t\tthis.s=s;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tpublic static void main(String[] args) {\n\t\t\t\t\tFastScanner fs=new FastScanner();\n\t\t\t\t\tint k2=fs.nextInt(),k3=fs.nextInt(),k5=fs.nextInt(),k6=fs.nextInt();\n\t\t\t\t\tint min=Math.min(k2,Math.min(k5, k6));\n\t\t\t\t\tint total=0;\n\t\t\t\t\ttotal+=256*min;\n\t\t\t\t\tk2-=min;k5-=min;k6-=min;\n\t\t\t\t\tint amin=Math.min(k3, k2);\n\t\t\t\t\ttotal+=32*amin;\n\t\t\t\t\tSystem.out.println(total);\n\t\t\t\t}\n\t\t\t\t\n\t\t\tstatic int pow(int x,int y) {\n\t\t\t\tif(y==0) return 1;\n\t\t\t\tint res=pow(x,y/2);\n\t\t\t\tif(y%2==0) {\n\t\t\t\t\treturn res*res;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn res*res*x;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tstatic final Random random=new Random();\n\t\t\t\t\n\t\t\t\tstatic void ruffleSort(int[] a) {\n\t\t\t\t\tint n=a.length;//shuffle, then sort \n\t\t\t\t\tfor (int i=0; i<n; i++) {\n\t\t\t\t\t\tint oi=random.nextInt(n), temp=a[oi];\n\t\t\t\t\t\ta[oi]=a[i]; a[i]=temp;\n\t\t\t\t\t}\n\t\t\t\t\tArrays.sort(a);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tstatic class FastScanner {\n\t\t\t\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\t\t\t\tString next() {\n\t\t\t\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t\t\t\t} catch (IOException e) {\n\t\t\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\treturn st.nextToken();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint nextInt() {\n\t\t\t\t\t\treturn Integer.parseInt(next());\n\t\t\t\t\t}\n\t\t\t\t\tint[] readArray(int n) {\n\t\t\t\t\t\tint[] a=new int[n];\n\t\t\t\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\t\t\t\treturn a;\n\t\t\t\t\t}\n\t\t\t\t\tint[][] readArrayArray(int n,int m){\n\t\t\t\t\t\tint[][] a=new int[n][n];\n\t\t\t\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\t\t\t\ta[i][j]=nextInt();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn a;\n\t\t\t\t\t}\n\t\t\t\t\tlong nextLong() {\n\t\t\t\t\t\treturn Long.parseLong(next());\n\t\t\t\t\t}\n\t\t//\t\t\tlong[] readLongArray(long n) {\n\t\t//\t\t\t\tlong[] a=new long[n];\n\t\t//\t\t\t\tfor (int i=0; i<n; i++) a[i]=nextLong();\n\t\t//\t\t\t\treturn a;\n\t\t//\t\t\t}\n\t\t\t\t}\n\t\t\t \n\t\t\t\t\n\t\t\t}", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class _734A_AntonAndDigits {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int a = input.nextInt();\n        int b = input.nextInt();\n        int c = input.nextInt();\n        int d = input.nextInt();\n        int e = Math.min(a,Math.min(c,d));\n        int f = Math.min(a-e,b);\n        System.out.println(e*256 + f*32);    }\n}\n", "label": 0}
{"src": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class CodeForces {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int two = sc.nextInt();\n        int three = sc.nextInt();\n        int five = sc.nextInt();\n        int sex = sc.nextInt();\n        int min = Math.min(two, Math.min(five, sex));\n        int sum = min * 256;\n        two=two-min;\n        if (two > 0) {\n            min = Math.min(two, three);\n            sum += min * 32;\n        }\n        System.out.println(sum);\n    }\n}\n", "label": 0}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner scan = new Scanner(System.in);\n\t\tint twos= scan.nextInt();\n\t\tint threes = scan.nextInt();\n\t\tint fives = scan.nextInt();\n\t\tint sixes = scan.nextInt();\n\t\tint result = 0;\n\t\twhile(twos>0 && fives>0 && sixes>0)\n\t\t{\n\t\t\tresult+=256;\n\t\t\ttwos--;\n\t\t\tfives--;\n\t\t\tsixes--;\n\t\t}\n\t\twhile(twos>0&& threes>0)\n\t\t{\n\t\t\tresult+=32;\n\t\t\ttwos--;\n\t\t\tthrees--;\n\t\t}\n\t\tSystem.out.println(result);\n\t}\n}\n      \t\t \t\t\t \t  \t   \t  \t\t \t \t \t", "label": 0}
{"src": "\nimport java.io.PrintWriter;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class CF_734B {\n\tpublic static void main(String[] args) {\n\t\tnew CF_734B().run();\n\t}\n\tpublic void run(){\n\t\tFastScanner sc = new FastScanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint twoNum = sc.nextInt();\n\t\tint threeNum = sc.nextInt();\n\t\tint fiveNum = sc.nextInt();\n\t\tint sixNum = sc.nextInt();\n\t\t\n\t\tint min256 = Math.min(Math.min(twoNum, fiveNum), sixNum);\n\t\tint twoLeft = twoNum-min256;\n\t\tint min32 = Math.min(twoLeft, threeNum);\n\t\tout.println(min256*256L + min32*32L);\n\t\tout.close();\n\t}\n}\nclass FastScanner {\n\tpublic BufferedReader br;\n\tpublic StringTokenizer st;\n\t\n\tpublic FastScanner(InputStream in){\n\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\tst = null;\n\t}\n\t\n\tpublic boolean hasMoreTokens(){\n\t\twhile(st == null || !st.hasMoreTokens()){\n\t\t\tString line = null;\n\t\t\ttry {\n\t\t\t\tline = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif(line == null)\n\t\t\t\treturn false;\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic String next(){\n\t\tif(!hasMoreTokens())\n\t\t\treturn null;\n\t\treturn st.nextToken();\n\t}\n\t\n\tpublic int nextInt(){\n\t\treturn Integer.parseInt(next());\n\t}\n\t\n\tpublic long nextLong(){\n\t\treturn Long.parseLong(next());\n\t}\n\t\n\tpublic int[] readIntArray(int n){\n\t\tint[] array = new int[n];\n\t\tfor(int i = 0;i<n;i++){\n\t\t\tarray[i] = nextInt();\n\t\t}\n\t\treturn array;\n\t}\n\t\n\tpublic long[] readLongArray(int n){\n\t\tlong[] array = new long[n];\n\t\tfor(int i = 0;i<n;i++){\n\t\t\tarray[i] = nextLong();\n\t\t}\n\t\treturn array;\n\t}\n\t\n\tpublic String[] readStringArray(int n){\n\t\tString[] a = new String[n];\n\t\tfor(int i = 0;i<n;i++){\n\t\t\ta[i] = next();\n\t\t}\n\t\treturn a;\n\t}\n}\n", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\n\npublic class A {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\t// Scanner sc = new Scanner(\"in.txt\");\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint a=sc.nextInt();\n\t\tint b=sc.nextInt();\n\t\tint c=sc.nextInt();\n\t\tint d=sc.nextInt();\n\t\tint z=Math.min(a,Math.min(c, d));\n\t\tint sum=z*256;\n\t\tif((a-z)>0)\n\t\t\tsum+=32*Math.min((a-z),b);\n\t\tout.println(sum);\n\t\tout.flush();\n\t\tout.close();\n\t}\n\t\n\tpublic static long perfect(long low, long high, long y) {\n\t\tlong mid = (int) (high + low) / 2;\n\t\tif (low > high)\n\t\t\treturn 0;\n\t\telse if ((mid * mid) == y)\n\t\t\treturn mid;\n\t\telse if ((mid * mid) > y)\n\t\t\treturn perfect(low, mid - 1, y);\n\t\telse\n\t\t\treturn perfect(mid + 1, high, y);\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic Scanner(InputStream in) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\n\t\tpublic Scanner(String file) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tint nextInt() throws NumberFormatException, IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tboolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t}\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class AntonAndDigits {\n\n    public static void main(String[] args) {\n\n        Scanner scan = new Scanner(System.in);\n        int k2 = scan.nextInt();\n        int k3 = scan.nextInt();\n        int k5 = scan.nextInt();\n        int k6 = scan.nextInt();\n        int k256 = Math.min(Math.min(k2, k5), Math.min(k2, k6));\n        k2 -= k256;\n        k5 -= k256;\n        k6 -= k256;\n        int k32 = Math.min(k2, k3);\n        int ans = k256 * 256 + k32 * 32;\n        System.out.println(ans);\n    }\n}\n", "label": 0}
{"src": "import java.util.*;\n\npublic class prob\n{\n\n  public static void main(String[] args)\n  {\n    Scanner scan = new Scanner(System.in);\n    int[] nums = new int[4];\n    int min = (int)(5*1e6)+1;\n    for(int i = 0; i < 4; i++)\n    {\n      nums[i] = scan.nextInt();\n      if(nums[i] < min && i != 1)\n        min = nums[i];\n    }\n    int sum = min*256;\n    sum += 32*Math.min(nums[0] - min, nums[1]);\n    System.out.println(sum);\n  }\n}\n", "label": 0}
{"src": "import java.io.*;\nimport java.util.*; \npublic class Main\n{ \n    public static void main(String[] args) throws IOException \n    { \n        StdIn scn = new StdIn();\n        int k2 = scn.nextInt();\n        int k3 = scn.nextInt();\n        int k5 = scn.nextInt();\n        int k6 = scn.nextInt();\n        int n1 = Math.min(Math.min(k5, k6),k2);\n        int n2 = Math.min(k3,k2-n1);\n        if (n1>=0 && n2>=0) System.out.println(n1*256+n2*32);\n        else if (n1>=0 && n2<0) System.out.println(n1*256);\n        else if (n1<0 && n2>=0) System.out.println(n2*32);\n        else System.out.println(0);\n    } \n    interface Input {\n    \tpublic String next();\n    \tpublic String nextLine();\n    \tpublic int nextInt();\n    \tpublic long nextLong();\n    \tpublic double nextDouble();\n    }\n    static class StdIn implements Input {\n    \tfinal private int BUFFER_SIZE = 1 << 16;\n    \tprivate DataInputStream din;\n    \tprivate byte[] buffer;\n    \tprivate int bufferPointer, bytesRead;\n\n    \tpublic StdIn() {\n    \t\tdin = new DataInputStream(System.in);\n    \t\tbuffer = new byte[BUFFER_SIZE];\n    \t\tbufferPointer = bytesRead = 0;\n    \t}\n    \t\n    \tpublic StdIn(String filename) {\n    \t\ttry{\n    \t\t\tdin = new DataInputStream(new FileInputStream(filename));\n    \t\t} catch(Exception e) {\n    \t\t\tthrow new RuntimeException();\n    \t\t}\n    \t\tbuffer = new byte[BUFFER_SIZE];\n    \t\tbufferPointer = bytesRead = 0;\n    \t}\n    \t\n    \tpublic String next() {\n    \t\tint c;\n    \t\twhile((c=read())!=-1&&(c==' '||c=='\\n'||c=='\\r'));\n    \t\tStringBuilder s = new StringBuilder();\n    \t\twhile (c != -1)\n    \t\t{\n    \t\t\tif (c == ' ' || c == '\\n'||c=='\\r')\n    \t\t\t\tbreak;\n    \t\t\ts.append((char)c);\n    \t\t\tc=read();\n    \t\t}\n    \t\treturn s.toString();\n    \t}\n\n    \tpublic String nextLine() {\n    \t\tint c;\n    \t\twhile((c=read())!=-1&&(c==' '||c=='\\n'||c=='\\r'));\n    \t\tStringBuilder s = new StringBuilder();\n    \t\twhile (c != -1)\n    \t\t{\n    \t\t\tif (c == '\\n'||c=='\\r')\n    \t\t\t\tbreak;\n    \t\t\ts.append((char)c);\n    \t\t\tc = read();\n    \t\t}\n    \t\treturn s.toString();\n    \t}\n\n    \tpublic int nextInt() {\n    \t\tint ret = 0;\n    \t\tbyte c = read();\n    \t\twhile (c <= ' ')\n    \t\t\tc = read();\n    \t\tboolean neg = (c == '-');\n    \t\tif (neg)\n    \t\t\tc = read();\n    \t\tdo\n    \t\t{\n    \t\t\tret = ret * 10 + c - '0';\n    \t\t}  while ((c = read()) >= '0' && c <= '9');\n\n    \t\tif (neg)\n    \t\t\treturn -ret;\n    \t\treturn ret;\n    \t}\n    \t\n    \tpublic int[] readIntArray(int n) {\n    \t\tint[] ar = new int[n];\n    \t\tfor(int i=0; i<n; ++i)\n    \t\t\tar[i]=nextInt();\n    \t\treturn ar;\n    \t}\n\n    \tpublic long nextLong() {\n    \t\tlong ret = 0;\n    \t\tbyte c = read();\n    \t\twhile (c <= ' ')\n    \t\t\tc = read();\n    \t\tboolean neg = (c == '-');\n    \t\tif (neg)\n    \t\t\tc = read();\n    \t\tdo {\n    \t\t\tret = ret * 10 + c - '0';\n    \t\t}\n    \t\twhile ((c = read()) >= '0' && c <= '9');\n    \t\tif (neg)\n    \t\t\treturn -ret;\n    \t\treturn ret;\n    \t}\n    \t\n    \tpublic long[] readLongArray(int n) {\n    \t\tlong[] ar = new long[n];\n    \t\tfor(int i=0; i<n; ++i)\n    \t\t\tar[i]=nextLong();\n    \t\treturn ar;\n    \t}\n\n    \tpublic double nextDouble() {\n    \t\tdouble ret = 0, div = 1;\n    \t\tbyte c = read();\n    \t\twhile (c <= ' ')\n    \t\t\tc = read();\n    \t\tboolean neg = (c == '-');\n    \t\tif (neg)\n    \t\t\tc = read();\n\n    \t\tdo {\n    \t\t\tret = ret * 10 + c - '0';\n    \t\t}\n    \t\twhile ((c = read()) >= '0' && c <= '9');\n\n    \t\tif (c == '.')\n    \t\t{\n    \t\t\twhile ((c = read()) >= '0' && c <= '9')\n    \t\t\t{\n    \t\t\t\tret += (c - '0') / (div *= 10);\n    \t\t\t}\n    \t\t}\n\n    \t\tif (neg)\n    \t\t\treturn -ret;\n    \t\treturn ret;\n    \t}\n\n    \tprivate void fillBuffer() throws IOException {\n    \t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n    \t\tif (bytesRead == -1)\n    \t\t\tbuffer[0] = -1;\n    \t}\n\n    \tprivate byte read() {\n    \t\ttry{\n    \t\t\tif (bufferPointer == bytesRead)\n    \t\t\t\tfillBuffer();\n    \t\t\treturn buffer[bufferPointer++];\n    \t\t} catch(IOException e) {\n    \t\t\tthrow new RuntimeException();\n    \t\t}\n    \t}\n\n    \tpublic void close() throws IOException {\n    \t\tif (din == null)\n    \t\t\treturn;\n    \t\tdin.close();\n    \t}\n    }\n} \n", "label": 0}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Code {\n\n\t\n\tstatic Scanner sr = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tint k2 = sr.nextInt();\n\t\tint k3 = sr.nextInt();\n\t\tint k5 = sr.nextInt();\n\t\tint k6 = sr.nextInt();\n\t\t\n\t\tint result = 0;\n\t\tint val256 = Math.min(k2, Math.min(k5, k6));\n\t\tk2 -= val256;\n\t\tk5 -= val256;\n\t\tk6 -= val256;\n\t\tresult += 256 * val256;\n\t\tint val32 = Math.min(k2, k3);\n\t\tresult += 32* val32;\n\t\tSystem.out.println(result);\n\t}\n}", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class Anton {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int k2 = sc.nextInt();\n        int k3 = sc.nextInt();\n        int k5 = sc.nextInt();\n        int k6 = sc.nextInt();\n\n        int min1 = Math.min(k2, Math.min(k5, k6));\n        k2 = k2 - min1;\n        int min2 = Math.min(k2, k3);\n\n        System.out.println((256*min1)+(32*min2));\n    }\n}", "label": 0}
{"src": "import java.util.*;\npublic class Solution{\npublic static void main(String args[]){\n\tScanner src = new Scanner(System.in);\n\tint a2 = src.nextInt();\n\tint a3 = src.nextInt();\n\tint a5 = src.nextInt();\n\tint a6 = src.nextInt();\n\t\n\tint min = Math.min(Math.min(a2,a5),a6);\n\tint ans = 256*min;\n\t\n\ta2-=min;\n\ta5-=min;\n\ta6-=min;\n\t\n\tif(a2>0){\n\t    min = Math.min(a2,a3);\n\t    ans+=32*min;\n\t}\n\t\n\tSystem.out.println(ans);\n}\n}", "label": 0}
{"src": "import java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint k2=in.nextInt();\n\t\tint k3=in.nextInt();\n\t\tint k5=in.nextInt();\n\t\tint k6=in.nextInt();\n\t\tint sum=0;\n\t\tint kmin256=Math.min(Math.min(k2,k5),k6);\n\t\tsum+=256*kmin256;\n\t\tint kmin32=Math.min(k3,k2-kmin256);\n\t\tsum+=32*kmin32;\n\t\tSystem.out.println(sum);\n\t}\n}\n\t  \t\t\t\t \t \t \t\t \t \t \t  \t\t\t  \t\t", "label": 0}
{"src": "import java.util.*;\nimport java.math.*;\n\npublic class Main\n{\n\tpublic static void main( String[] args )\n\t{\n\t\tScanner is = new Scanner( System.in );\n\t\tint k2 = is.nextInt();\n\t\tint k3 = is.nextInt();\n\t\tint k5 = is.nextInt();\n\t\tint k6 = is.nextInt();\n\t\tint min256 = Math.min( k2, Math.min( k5, k6 ) );\n\t\tint answer = min256 * 256;\n\t\tk2 -= min256;\n\t\tanswer += Math.min( k3, k2 ) * 32;\n\t\tSystem.out.println( answer );\n\t}\n}\n", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class cod {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tint k2=in.nextInt();\n\t\tint k3=in.nextInt();\n\t\tint k5=in.nextInt();\n\t\tint k6=in.nextInt();\n\t\tint b;\n\t\tint out=0;\n\t\tif(k2<k5){\n\t\t\tif(k2<k6){\n\t\t\t\tb=k2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb=k6;\n\t\t\t}\t\t\n\t\t}\n\t\telse{\n\t\t\tif(k5<k6){\n\t\t\t\tb=k5;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb=k6;\n\t\t\t}\n\t\t}\n\t\tk2-=b;\n\t\tk5-=b;\n\t\tk6-=b;\n\t\tout+=b*256;\n\t\tif(k2<k3)\n\t\t\tb=k2;\n\t\telse\n\t\t\tb=k3;\n\t\tout+=b*32;\n\t\t\n\t\t\t\n\t\tPrintWriter o=new PrintWriter(System.out);\n\t\to.println(out);\n\t\to.close();\n\t\tin.close();\n\n\t}\n\n}\n", "label": 0}
{"src": "import java.util.Scanner;\npublic class B734 {\n\n\tpublic static void main(String[] args) {\n\t    Scanner sc = new Scanner(System.in);\n\t    int k2 = sc.nextInt();\n\t    int k3 = sc.nextInt();\n\t    int k5 = sc.nextInt();\n\t    int k6 = sc.nextInt();\n\t    int min = k2;\n\t    int i = 2;\n\t    int sum = 0;\n\t    if(k5<min) {\n\t    \tmin = k5;\n\t    \ti = 5;\n\t    }\n\t    if(k6<min) {\n\t    \tmin = k6;\n\t    \ti = 6;\n\t    }\n\t\tif((k2-min) > k3) sum = 256*min + 32*k3;\n\t    else sum = 256*min + 32*(k2-min);\n\t  \n\t    \n\t    System.out.println(sum);\n\t\t\n\t}\n}", "label": 0}
{"src": "import java.util.Scanner;\n\n/**\n * Created by Luis Ngo on 4/1/2017.\n */\npublic class PB {\n    public static void main (String args[]){\n        Scanner scanner =  new Scanner(System.in);\n        int k2 =  scanner.nextInt();\n        int k3 =  scanner.nextInt();\n        int k5 =  scanner.nextInt();\n        int k6 = scanner.nextInt();\n\n        int num256 =  Math.min(Math.min(k2,k5),k6);\n        int num32 = Math.min(k3,k2-num256);\n\n        System.out.println(num256*256 + num32*32);\n    }\n}\n", "label": 0}
{"src": "\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.text.DecimalFormat;\n\npublic class B {\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tlong k2 = scan.nextLong();\n\t\tlong k3 = scan.nextLong();\n\t\tlong k5 = scan.nextLong();\n\t\tlong k6 = scan.nextLong();\n\t\tlong k256 = Math.min(k2, Math.min(k5, k6));\n\t\tlong k32 = Math.min(k3,k2-k256);\n\t\tlong ans = (long)256*k256+32*k32;\n\t\tSystem.out.println(ans);\n\t}\n}\n", "label": 0}
{"src": "import java.util.*;\npublic class Test11\n{\n  public static void main(String[] args)\n  {\n    Scanner input = new Scanner(System.in);\n    int k2 = input.nextInt();\n    int k3 = input.nextInt();\n    int k5 = input.nextInt();\n    int k6 = input.nextInt();\n    int sum = 0;\n    while(k2 > 0 && k5 > 0 && k6 > 0)\n    {\n      sum += 256;\n      k2--;\n      k5--;\n      k6--;\n    }\n    while(k2 > 0 && k3 > 0)\n    {\n      sum += 32;\n      k2--;\n      k3--;\n    }\n    System.out.println(sum);\n  }\n}", "label": 0}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.util.stream.*;\nimport java.math.BigInteger;\npublic class Main{\n\tprivate static BufferedReader in;\n\tprivate static BufferedWriter out;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\topen();\n\n\t\tStringTokenizer st;\n\t\tStringBuilder sb;\n\t\n\t\tint[] k=readInts();\n\t\tint mayor=(Math.min(k[0], Math.min(k[2], k[3])));\n\t\tk[0]-=mayor;\n\t\tint menor=Math.min(k[0],k[1]);\n\t\tint ans=(256)*mayor;\n\t\tif(menor>0)\n\t\t\tans+=(32*menor);\n\t\tout.write(ans+\"\\n\");\n\t\t\n\t\tclose();\n\t}\n\t\n\tprivate static int[] readInts() throws IOException {\n\t\treturn Stream.of(in.readLine().split(\" \")).mapToInt(Integer::parseInt).toArray();\n\t}\n\tprivate static int readInt() throws IOException {\n\t\treturn Integer.parseInt(in.readLine());\n\t}\n\tprivate static long[] readLongs() throws IOException {\n\t\treturn Stream.of(in.readLine().split(\" \")).mapToLong(Long::parseLong).toArray();\n\t}\n\tprivate static long readLong() throws IOException {\n\t\treturn Long.parseLong(in.readLine());\n\t}\n\tprivate static double[] readDoubles() throws IOException {\n\t\treturn Stream.of(in.readLine().split(\" \")).mapToDouble(Double::parseDouble).toArray();\n\t}\n\tprivate static double readDouble() throws IOException {\n\t\treturn Double.parseDouble(in.readLine());\n\t}\n\tprivate static String readString() throws IOException {\n\t\treturn in.readLine();\n\t}\n\tprivate static int setBit(int S, int j) {\n\t\treturn S | (1 << j);\n\t}\n\tprivate static int isOn(int S, int j) {\n\t\treturn S & (1 << j);\n\t}\n\tprivate static int clearBit(int S, int j) {\n\t\treturn S & ~(1 << j);\n\t}\n\tprivate static int toggleBit(int S, int j) {\n\t\treturn S ^ (1 << j);\n\t}\n\tprivate static int lowBit(int S) {\n\t\treturn S & (-S);\n\t}\n\tprivate static int setAll(int n) {\n\t\treturn (1 << n) - 1;\n\t}\n\tprivate static int modulo(int S, int N) {\n\t\treturn ((S) & (N - 1));\n\t} // returns S % N, where N is a power of 2\n\tprivate static boolean isPowerOfTwo(int S) {\n\t\treturn (S & (S - 1)) == 0 ? true : false;\n\t}\n\tprivate static int nearestPowerOfTwo(int S) {\n\t\treturn ((int) Math.pow(2.0, (int) ((Math.log((double) S) / Math.log(2.0)) + 0.5)));\n\t}\n\tprivate static int turnOffLastBit(int S) {\n\t\treturn ((S) & (S - 1));\n\t}\n\tprivate static int turnOnLastZero(int S) {\n\t\treturn ((S) | (S + 1));\n\t}\n\tprivate static int turnOffLastConsecutiveBits(int S) {\n\t\treturn ((S) & (S + 1));\n\t}\n\tprivate static int turnOnLastConsecutiveZeroes(int S) {\n\t\treturn ((S) | (S - 1));\n\t}\n\tprivate static void open() {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new BufferedWriter(new OutputStreamWriter((System.out)));\n\t}\n\tprivate static void close() throws IOException {\n\t\tout.flush();\n\t\tout.close();\n\t\tin.close();\n\t}\n}", "label": 0}
{"src": "import java.util.*;\n\npublic class AntonAndDigits {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int[] nums = new int[7];\n        nums[2] = scanner.nextInt();\n        nums[3] = scanner.nextInt();\n        nums[5] = scanner.nextInt();\n        nums[6] = scanner.nextInt();\n\n        int sum = 0;\n        while (true)\n        {\n            if (nums[2] > 0 && nums[5] > 0 && nums[6] > 0)\n            {\n                sum += 256;\n                nums[2]--; nums[5]--; nums[6]--;\n                continue;\n            }\n            else if (nums[2] > 0 && nums[3] > 0)\n            {\n                sum += 32;\n                nums[3]--; nums[2]--; \n                continue;\n            }\n            break;\n            // if (nums[2] > 0)\n            // {\n            //     if (nums[5] > 0 && nums[6] > 0)\n            //     {\n            //         sum += 256;\n            //         nums[2]--; nums[5]--; nums[6]--;\n            //         continue;\n            //     } \n            //     else if (nums[3] > 0)\n            //     {\n            //         sum += 32;\n            //         nums[3]--; nums[2]--; \n            //         continue;\n            //     }\n            // }\n            // break;\n        }\n        System.out.println(sum);\n    }\n}", "label": 0}
{"src": "import java.io.*;\nimport java.util.*;\n\n//System.out.println();\npublic class B\n{\n    public static int[] arr;\n    public static int two, three, five, six;\n    public static String s;\n    public static void main(String[] args) throws IOException\n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] in = br.readLine().trim().split(\"\\\\s\");\n         two = Integer.parseInt(in[0]);\n         three = Integer.parseInt(in[1]);\n         five = Integer.parseInt(in[2]);\n         six = Integer.parseInt(in[3]);\n\n        //fn();\n        System.out.println(fn());\n    }\n    \n    public static int fn()\n    {\n        //System.out.println();\n        int ans = 0;\n        int x = Math.min(Math.min(two, five), six);\n        ans += 256 * x;\n        \n        two -= x;\n        int y = Math.min(two, three);\n        ans += 32 * y;\n        return ans;\n    }\n}", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class problem7 {\n    public static void main(String[] args) {\n        // System.out.println(\"Enter Numbers\");\n        Scanner sc = new Scanner(System.in);\n        long k2 = sc.nextLong();\n        long k3 = sc.nextLong();\n        long k5 = sc.nextLong();\n        long k6 = sc.nextLong();\n        long sum = 0;\n        long min = 0;\n        long min1 = 0;\n        if (k5 >= 1 && k6 >= 1 && k2 >= 1) {\n            min1=Math.min(k5, k6);\n            min=Math.min(k2, min1);\n\n            k2 = k2 - min;\n            sum = sum + 256 * min;\n        }\n        if (k3 >= 1 && k2 >= 1) {\n            min = Math.min(k2, k3);\n            sum = sum + 32 * min;\n        }\n\n        System.out.println(sum);\n        // }\n\n    }\n\n}", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class Abhi {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner s = new Scanner(System.in);\n\t    \n\t\tint n2 = s.nextInt();\n\t\tint n3 = s.nextInt();\n\t\tint n5 = s.nextInt();\n\t\tint n6 = s.nextInt();\n\t\t\n\t\tint min1 = Math.min(n2,Math.min(n5,n6));\n\t\tn2 = n2 - min1;\n\t\tint min = Math.min(n2,n3);\n\t\t\n\t\tSystem.out.println(min1*256 + min*32);\n\t}\t\n} \n", "label": 0}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\n\npublic class tt {\n\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner r = new Scanner(System.in);\n\t\t\n\t\tint k2,k3,k5,k6;\n\t\t\n\t\tk2= r.nextInt();\n\t\tk3= r.nextInt();\n\t\tk5= r.nextInt();\n\t\tk6= r.nextInt();\n\t\t\n\t\tint sum = 0;\n\t\tsum += 256* Math.min(k2,Math.min(k5,k6));\n\t\tk2 -= Math.min(k2,Math.min(k5,k6));\n\t\tsum += 32* Math.min(k2, k3);\n\t\tSystem.out.print(sum);\n\n\t\n\t}\n\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\n/**\n * \n */\n\n/**\n * @author Bibek Regmi - bbkregmi\n * @versionDec 15, 2016\n */\npublic class AntonAndDanik\n{\n    public static void main(String[] args)\n    {\n        Scanner in = new Scanner(System.in);\n        System.out.println();\n        int numTwo = in.nextInt();\n        int numThree = in.nextInt();\n        int numFive = in.nextInt();\n        int numSix = in.nextInt();\n        int sum = 0;\n        \n        while (numTwo != 0 && numFive != 0 && numSix != 0)\n        {\n            sum += 256;\n            numTwo--;\n            numFive--;\n            numSix--;\n        }\n        \n        while(numTwo !=0 && numThree != 0)\n        {\n            sum += 32;\n            numTwo--;\n            numThree--;\n        }\n        \n        System.out.println(sum);\n        \n    }\n}\n", "label": 0}
{"src": "import java.util.*;\n\npublic class Main{\n\npublic static void main(String[] args) {\n\n Scanner scn=new Scanner(System.in);\n int k2=scn.nextInt();\n int k3=scn.nextInt();\n int k4=scn.nextInt();\n int k5=scn.nextInt();\n int sum=0;\n while(k2>0  && k4>0 && k5>0){\n     sum+=256;\n     k2--;\n     k4--;\n     k5--;\n }\n while(k2>0 && k3>0){\n     sum+=32;\n     k2--;\n     k3--;\n }\n System.out.println(sum);\n\n }\n}", "label": 0}
{"src": "import java.util.*;\n\npublic class helloWorld \n{\n\tpublic static void main(String[] args) \n\t{\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tint[] ar = new int[4];\n\t\tint ans = 0;\n\t\t\n\t\tfor(int i = 0; i < 4; i++)\n\t\t\tar[i] = in.nextInt();\n\t\t\n\t\tint a = Math.min(ar[0], Math.min(ar[2], ar[3]));\n\t\tans = a*256;\n\t\tar[0] -= a;\n\t\ta  = Math.min(ar[0], ar[1]);\n\t\tans += a*32;\n\t\t\n\t\tSystem.out.print(ans);\n\t\t\n\t\tin.close();\n\t}\n}\n", "label": 0}
{"src": "import java.awt.CardLayout;\nimport java.awt.Color;\nimport java.awt.Component;\nimport java.awt.Container;\nimport java.awt.Dimension;\nimport java.awt.FileDialog;\nimport java.awt.LayoutManager;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.awt.font.NumericShaper;\nimport java.awt.image.BufferedImage;\nimport java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.text.DecimalFormat;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.Stack;\nimport java.util.TreeSet;\nimport javax.imageio.ImageIO;\nimport javax.swing.ImageIcon;\nimport javax.swing.JButton;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\n\nimport org.omg.Messaging.SyncScopeHelper;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.FilenameFilter;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport java.io.InputStream;\nimport java.lang.reflect.Array;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\npublic class palin {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tTaskC solver = new TaskC();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskC {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\tint a = in.nextInt(), b = in.nextInt(), c = in.nextInt(), d = in.nextInt(), min = Math.min(Math.min(a, c), d),\n\t\t\t\tsum = min * 256;\n\t\ta -= min;\n\t\tsum += Math.min(a, b) * 32;\n\t\tSystem.out.println(sum);\n\t}\n}\n\nclass InputReader {\n\tBufferedReader br;\n\tStringTokenizer st;\n\n\tpublic InputReader(InputStream in) {\n\t\tbr = new BufferedReader(new InputStreamReader(in));\n\t\tst = null;\n\t}\n\n\tpublic String next() {\n\t\twhile (st == null || !st.hasMoreTokens()) {\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic float nextFloat() {\n\t\treturn Float.parseFloat(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}", "label": 0}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.PrintWriter;\nimport java.util.Scanner;\n\npublic class B {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\t\t\n\t\tint twos = in.nextInt();\n\t\tint threes = in.nextInt();\n\t\tint fives = in.nextInt();\n\t\tint sixes = in.nextInt();\n\t\tboolean bool = true;\n\t\tlong sum = 0;\n\t\t\n\t\tin.close();\n\t\twhile(bool){\n\t\t\tif(twos>0 && fives>0 && sixes>0){\n\t\t\t\tsum+=256;\n\t\t\t\ttwos--; fives--; sixes--;\n\t\t\t}\n\t\t\telse if(twos>0 && threes>0){\n\t\t\t\tsum+=32;\n\t\t\t\ttwos--; threes--;\n\t\t\t}\n\t\t\telse bool=false;\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\n}\n", "label": 0}
{"src": "import java.util.*;\n\npublic class B734 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner scan = new Scanner(System.in);\n\t\t\n\t\tint k2 = scan.nextInt();\n\t\tint k3 = scan.nextInt();\n\t\tint k5 = scan.nextInt();\n\t\tint k6 = scan.nextInt();\n\t\t\n\t\tint min = k2;\n\t\tif (k5 < min) {\n\t\t\tmin = k5;\n\t\t}\n\t\tif (k6 < min) {\n\t\t\tmin = k6;\n\t\t}\n\t\t\n\t\tint min1 = k2 - min;\n\t\tif(k3 < min1) {\n\t\t\tmin1 = k3;\n\t\t}\n\t\t\n\t\tSystem.out.println(256 * min + 32 * min1);\n\t}\n\n}\n", "label": 0}
{"src": "import java.util.*;\n\npublic class Solution {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int k2 = scan.nextInt();\n        int k3 = scan.nextInt();\n        int k5 = scan.nextInt();\n        int k6 = scan.nextInt();\n        int num256 = Math.min(Math.min(k5, k6), k2);\n        int num32 = Math.min(k3, k2 - num256);\n        int result = (256*num256) + (32*num32);\n        System.out.println(result);\n    }\n}", "label": 0}
{"src": "\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class CO_734B\n{\n\tstatic int imax=Integer.MAX_VALUE,imin=Integer.MIN_VALUE;\n\tstatic long lmax=Long.MAX_VALUE,lmin=Long.MIN_VALUE;\n\tstatic long mod=(long)1e9+7;\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\n\t//\tScanner scan=new Scanner(System.in);\n\t\tInputReader in =new InputReader(System.in);\n\t\tPrintWriter out=new PrintWriter(System.out);\n//\t\tint t=in.nextInt();\n \t\tint t=1;\n\t\twhile(t-->0){\n\t\t\tint i=0,j=0;\t\n\t\t\tint a=in.nextInt();\n\t\t\tint b=in.nextInt();\n\t\t\tint c=in.nextInt();\n\t\t\tint d=in.nextInt();\n\t\t\tint min=Math.min(Math.min(c,d),a);\n\t\t\tlong ans=256*min;\n\t\t\ta=a-min;\n\t\t\tif(b>=a){\n\t\t\t\tans+=a*32;\n\t\t\t}else{\n\t\t\t\tans+=b*32;\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\tout.close();\n\t}\n\t\n\tstatic void print(int arr[],int len){\n\t\tfor(int i=0;i<len;i++)\n\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\tstatic class InputReader\n\t{\n\t \n\t    private InputStream stream;\n\t    private byte[] buf = new byte[1024];\n\t    private int curChar;\n\t    private int numChars;\n\t \n\t    public InputReader(InputStream stream) {\n\t        this.stream = stream;\n\t    }\n\t \n\t    public int read() {\n\t        if (numChars == -1)\n\t            throw new InputMismatchException();\n\t        if (curChar >= numChars) {\n\t            curChar = 0;\n\t            try {\n\t                numChars = stream.read(buf);\n\t            } catch (IOException e) {\n\t                throw new InputMismatchException();\n\t            }\n\t            if (numChars <= 0)\n\t                return -1;\n\t        }\n\t        return buf[curChar++];\n\t    }\n\t \n\t    public int nextInt() {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t            c = read();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = read();\n\t        }\n\t        int res = 0;\n\t        do {\n\t            if (c < '0' || c > '9')\n\t                throw new InputMismatchException();\n\t            res *= 10;\n\t            res += c & 15;\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\t \n\t    public long nextLong() {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t            c = read();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = read();\n\t        }\n\t        long res = 0;\n\t        do {\n\t            if (c < '0' || c > '9')\n\t                throw new InputMismatchException();\n\t            res *= 10;\n\t            res += c & 15;\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\t \n\t    public String next() {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t            c = read();\n\t        StringBuilder res = new StringBuilder();\n\t        do {\n\t            res.appendCodePoint(c);\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res.toString();\n\t    }\n\t \n\t    public String nextLine() {\n\t        int c = read();\n\t        //while (c != '\\n' && c != '\\r' && c != '\\t' && c != -1)\n\t        //c = read();\n\t        StringBuilder res = new StringBuilder();\n\t        do {\n\t            res.appendCodePoint(c);\n\t            c = read();\n\t        } while (c != '\\n' && c != '\\r' && c != '\\t' && c != -1);\n\t        return res.toString();\n\t    }\n\t \n\t    public static boolean isSpaceChar(int c) {\n\t        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t    }\n\t \n\t}   \n\n}\n", "label": 0}
{"src": "import java.util.*;\npublic class Digit{\npublic static void main(String args[]) {\nScanner sc=new Scanner (System.in);\nint k2=sc.nextInt();\nint k3=sc.nextInt();\nint k5=sc.nextInt();\nint k6=sc.nextInt();\nint s1=0,s2=0;\nwhile((k2>=1) && (k5>=1) && (k6>=1)) {\ns1=s1+256;\nk2--;\nk5--;\nk6--;\n}\nwhile((k2>=1) && (k3>=1)) {\ns2=s2+32;\nk2--;\nk3--;\n}\nSystem.out.print(s1+s2);\n}\n}", "label": 0}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.util.Arrays;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class bekaar\n{\n    public static void main (String[] args) throws java.lang.Exception\n    { \n        try {\n        \n    \n        Scanner ob =new Scanner(System.in);\n        \n            int a=ob.nextInt();\n            int b=ob.nextInt();\n            int c=ob.nextInt();\n            int d=ob.nextInt();\n        \n        int m=Math.min(a,c);\n        int min1=Math.min(m,d);\n        a=a-min1;\n        int min2=Math.min(a,b);\n        System.out.println(min1*256+(min2*32));\n    } catch(Exception e) {\n    } finally {\n    }\n        \n        // your code goes here\n    }\n}\n", "label": 0}
{"src": "\nimport java.io.IOException;\nimport java.util.Scanner;\n\n\npublic class Main{\n\n    public static void main (String args[]) throws IOException {\n        Scanner scan = new Scanner(System.in);\n\n        int k2 = scan.nextInt(), k3 = scan.nextInt() , k5 = scan.nextInt(), k6 = scan.nextInt();\n        int cnt = 0, a = Math.min(Math.min(k2, k5), k6);\n        for (int i = 0; i < a; i++) {\n            cnt+=256;\n        }\n        for (int i = 0; i < Math.min(k2-a, k3); i++) {\n            cnt+=32;\n        }\n        System.out.println(cnt);\n    }\n}\n", "label": 0}
{"src": "import java.util.*;\nimport java.lang.Math;\n \n \n //so first of all,  we want to make as many 256's as possible \n //we an achieve this\npublic class Main{\n   public static void main(String[] args) {\n      Scanner sc = new Scanner(System.in); \n      int k2, k3, k5, k6;\n      k2 = sc.nextInt();\n      k3 = sc.nextInt();\n      k5 = sc.nextInt();\n      k6 = sc.nextInt();\n      \n      int num256 = Math.min(k6, Math.min(k2, k5));\n      k2 -= num256;\n      k5 -= num256;\n      k6 -= num256;\n      \n      int num32 = Math.min(k3, k2);\n      System.out.println(num32*32 + num256*256);\n      \n      /*\n      int n      = sc.nextInt();        // read input as integer\n      long k     = sc.nextLong();       // read input as long\n      double d   = sc.nextDouble();     // read input as double\n      String str = sc.next();           // read input as String\n      String s   = sc.nextLine();       // read whole line as String\n      */\n    }\n}", "label": 0}
{"src": "    import java.util.*;\n    import java.io.*;\n     \n    public class Main {\n\tstatic InputReader scn = new InputReader(System.in);\n\tstatic OutputWriter out = new OutputWriter(System.out);\n\tpublic static void main(String[] HastaLaVistaLa) {\n\t\t// Running Number Of TestCases (t)\n\t\tint t = 1;\n\t\twhile(t-- > 0)\n\t\t\tsolve();\n\t\tout.close();\n\t}\n\n\tpublic static void dummy(){\n\t\tint n = scn.nextInt();\n\t\tout.println(n);\n\t}\n\n\tstatic long[] dp;\n\tstatic long mod = 1000000007L;\n\tpublic static void solve() {\n\t\t// Main Solution (AC)\t\n\t\tint k2 = scn.nextInt();\n\t\tint k3 = scn.nextInt();\n\t\tint k5 = scn.nextInt();\n\t\tint k6 = scn.nextInt();\n\t\tint min = Math.min(Math.min(k2, k6), k5);\n\t\tlong ans = min * 256;\n\t\tk2-=min;\n\t\tk5-=min;\n\t\tk6-=min;\n\t\tmin = Math.min(k2, k3);\n\t\tans += min * 32;\n\t\tout.println(ans);\n\t\t\n\t\t\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}\n\n\tpublic static long factorial(long number) {\n\t\tnumber %= mod;\n\t        long result = 1;\n\t        for (long factor = 2; factor <= number; factor++) {\n\t            result *= factor % mod;\n\t            result %= mod;\n\t        }\n\t        result %= mod;\n\n        \treturn result;\n    }\n\n\t// Number of Divisor for Range [l, r]\n\tpublic static int[] NumberOFDivisors(int l, int r) {\n\t\tint[] arr = new int[l - r + 1];\n\t\tfor(int i = l; i <= r; i++) {\n\t\t\tfor(int j = i; j <= r; j += i)\n\t\t\t\tarr[j]++;\n\t\t}\n\t\treturn arr;\n\t}\n\n\tpublic static int LowerBound(long a[], long x) { // x is the target value or key\n\n\t\t  int l = -1,r = a.length;\n\t\t  while(l + 1 < r) {\n\n\t\t    int m = (l + r) >>> 1;\n\t\t    if(a[m] >= x) r = m;\n\t\t    else l = m;\n\n\t\t  }\n\t\t  return r;\n\t}\n\n\tstatic boolean[] prime;\n\tpublic static void sieveOfEratosthenes(int n) {\n        \tprime = new boolean[n+1];\n\t        for(int i=0;i<n;i++)\n\t            prime[i] = true;\n\t          \n\t        for(int p = 2; p*p <=n; p++) {\n\n\t            if(prime[p] == true) {\n\n\t                for(int i = p*p; i <= n; i += p)\n\t                    prime[i] = false;\n\t            }\n\t        }\n    \t}\n\n\tpublic static long binpow(long n, long m, long mod) {\n\t        long res = 1;\n\t        while (m > 0) {\n\t            if (m % 2 == 1) {\n\t                res *= n;\n\t                res %= mod;\n\t                m--;\n\t            }\n\t            n *= n;\n\t            n %= mod;\n\t            m /= 2;\n\t        }\n\t        return res;\n    \t}\n\n\tpublic static int UpperBound(long a[], long x) {// x is the key or target value\n\n\t\t    int l = -1,r = a.length;\n\n\t\t    while(l + 1 < r) {\n\n\t\t       int m = (l + r) >>> 1;\n\t\t       if(a[m] <= x) l = m;\n\t\t       else r = m;\n\n\t\t    }\n\t\t    return l + 1;\n\t}\n\n    \tpublic static long lcm(long a, long b) {\n\t\treturn (a * b) / gcd(a, b);\n\t}\n     \n\tpublic static HashMap<Integer, Integer> CountFrequencies(int[] arr) {\n     \n\t\tHashMap<Integer, Integer> map = new HashMap<>();\n\t\tfor (int i : arr) {\n\t\t\tif (map.containsKey(i)) map.put(i, map.get(i) + 1);\n\t\t\telse map.put(i, 1);\n\t\t}\n\t\treturn map;\n\t}\n\n\tpublic static void sort(int[] arr) {\n\t\tRandom rand = new Random();\n\t\tint n = arr.length;\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tswap(arr, i, rand.nextInt(n));\n\t\t}\n\t\tArrays.sort(arr);\n\t}\n\n\tpublic static void swap(int[] arr, int i, int j) {\n\t\tif(i!=j) {\n\t\t\tarr[i] ^= arr[j];\n\t\t\tarr[j] ^= arr[i];\n\t\t\tarr[i] ^= arr[j];\n\t\t}\n\t}\n     \n\tpublic static void sortbyColumn(int[][] arr, int col) {\n\t\tArrays.sort(arr, new Comparator<int[]>() {\n\t\t\tpublic int compare(final int[] entry1, final int[] entry2) {\n\t\t\t\tif (entry1[col] > entry2[col])\n\t\t\t\t\treturn 1;\n\t\t\t\telse\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic static void ArraySort2D(int[][] arr, int xy) {\n\t\t// xy == 0, for sorting wrt X-Axis\n\t\t// xy == 1, for sorting wrt Y-Axis\n\t\tArrays.sort(arr, Comparator.comparingDouble(o -> o[xy]));\n\t}\n\t\n\tpublic static int binarySearch(int arr[], int l, int r, int x) {\n\t\tif (r >= l) {\n\t\t\tint mid = l + (r - l) / 2;\n\t\t\tif (arr[mid] == x)\n\t\t\t\treturn mid;\n\t\t\tif (arr[mid] > x)\n\t\t\t\treturn binarySearch(arr, l, mid - 1, x);\n\t\t\treturn binarySearch(arr, mid + 1, r, x);\n\t\t}\n\t\treturn -1;\n\t}\n     \n\tstatic class InputReader {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\tprivate SpaceCharFilter filter;\n     \n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n     \n\t\tpublic int[] readIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = scn.nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n     \t\t\t\n     \t\tpublic long[] readLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = scn.nextLong();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n     \n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n     \n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n     \n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n     \n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n     \n\t\tpublic String next() {\n\t\t\treturn nextLine();\n\t\t}\n     \n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n     \n\tstatic class OutputWriter {\n\t\tprivate final PrintWriter writer;\n     \n\t\tpublic OutputWriter(OutputStream outputStream) {\n\t\t\twriter = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n\t\t}\n     \n\t\tpublic OutputWriter(Writer writer) {\n\t\t\tthis.writer = new PrintWriter(writer);\n\t\t}\n     \n\t\tpublic void print(Object... objects) {\n\t\t\tfor (int i = 0; i < objects.length; i++) {\n\t\t\t\tif (i != 0) {\n\t\t\t\t\twriter.print(' ');\n    //                    writer.print(1);\n\t\t\t\t}\n\t\t\t\twriter.print(objects[i]);\n\t\t\t}\n\t\t}\n     \n\t\tpublic void println(Object... objects) {\n\t\t\tprint(objects);\n\t\t\twriter.println();\n\t\t}\n     \n\t\tpublic void close() {\n\t\t\twriter.close();\n\t\t}\n\t}\n}", "label": 0}
{"src": "\nimport java.util.Scanner;\n\n\npublic class AntonAndDigits {\n    \n    public static void main(String[] args) {\n        \n        Scanner input = new Scanner (System.in);\n        \n        int k2 = input.nextInt();\n        int k3 = input.nextInt();\n        int k5 = input.nextInt();\n        int k6 = input.nextInt();\n        \n        int min1 = Math.min(k2 , Math.min(k5 , k6));\n        \n        int ans = min1 * 256;\n        \n        k2 -= min1;\n        k5 -= min1;\n        k6 -= min1;\n        \n        int min2 = Math.min(k2 , k3);\n        \n        ans += (min2 * 32);\n        \n        System.out.println(ans);\n    }\n    \n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\n//https://codeforces.com/problemset/problem/734/B\npublic class probB734 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tlong sum=0;\n\t\tlong k2=sc.nextLong();\n\t\tlong k3=sc.nextLong();\n\t\tlong k5=sc.nextLong();\n\t\tlong k6=sc.nextLong();\n\t\t\n\t\tif(k2<=k5 && k2<=k6)\n\t\t{\n\t\t\tsum=256*k2;\n\t\t\tk5-=k2;\n\t\t\tk6-=k2;\n\t\t\tk2-=k2;\n\t\t\t//System.out.println(sum+\"  \"+k2);\n\t\t}\n\t\telse if(k5<=k2 && k5<=k6)\n\t\t{\n\t\t\tsum=256*k5;\n\t\t\tk2=k2-k5;\n\t\t\tk6-=k5;\n\t\t\tk5-=k5;\n\t\t\t//System.out.println(sum+\"  k2:\"+k2 + \"k5:\" +k5);\n\t\t}\n\t\telse if(k6<=k5 && k6<=k2)\n\t\t{\n\t\t\tsum=256*k6;\n\t\t\tk5-=k6;\n\t\t\tk2-=k6;\n\t\t\tk6-=k6;\n\t\t\t//System.out.println(sum+\"  \"+k2);\n\t\t}\n\t\t\n\t\tif(k2<=k3)\n\t\t\tsum=sum+32*k2;\n\t\telse\n\t\t\tsum=sum+32*k3;\n\t\t\n\t\tSystem.out.println(sum);\n\n\t}\n\n}\n", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\n\npublic class Main{\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tString[] input_string = new String[4];\n\t\tint[] input_nums = new int[4];\n\t\t\n\t\tinput_string = br.readLine().split(\" \");\n\t\tfor(int i = 0; i < 4; i++)\n\t\t{\n\t\t\tinput_nums[i] = Integer.parseInt(input_string[i]);\n\t\t}\n\t\t\n\t\tint min = Math.min(input_nums[0], Math.min(input_nums[2], input_nums[3])), result = 0;\n\t\t\n\t\tresult += min * 256;\n\t\t\n\t\tinput_nums[0] -= min;\n\t\t\n\t\tif(input_nums[0] != 0)\n\t\t{\n\t\t\tmin = Math.min(input_nums[0], input_nums[1]);\n\t\t\tresult += min * 32;\n\t\t}\n\t\t\n\t\tbw.write(result + \"\\n\");\n\t\tbw.flush();\n\t}\n\n}\n", "label": 0}
{"src": "import static java.lang.System.exit;\nimport java.io.*;\nimport java.util.*;\n\npublic class B {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    static void solve() throws Exception {\n        int k2 = nextInt();\n        int k3 = nextInt();\n        int k5 = nextInt();\n        int k6 = nextInt();\n\n        int sum = 0;\n        int k = Math.min(k2, Math.min(k5, k6));\n        sum += k * 256;\n\n        sum += 32 * Math.min(k2-k, k3);\n\n        System.out.println(sum);\n    }\n\n\n    // some Garbage here //\n    static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    static char nextChar() throws IOException {\n        return (char)in.read();\n    }\n\n    static String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    public static void main(String[] args) {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n            solve();\n            in.close();\n            out.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n\n\n}", "label": 0}
{"src": "import java.util.*;\n\n\npublic class practice {\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner input = new Scanner (System.in);\n\t\tint k2 = input.nextInt();\n\t\tint k3 = input.nextInt();\n\t\tint k5 = input.nextInt();\n\t\tint k6 = input.nextInt();\n\t\t\n\t\tint sum256 = Math.min(k2, Math.min(k5, k6));\n\t\tint sum = sum256 * 256;\n\t\tk2 -= sum256;\n\t\tif (k2 > 0)\n\t\t{\n\t\t\tsum += Math.min(k2, k3) * 32;\n\t\t}\n\t\tSystem.out.println(sum);\n\t}\n\t\n}\n\n", "label": 0}
{"src": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport static java.util.Collections.list;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\n\n/**\n *\n * @author george\n */\npublic class main {\npublic static boolean isPrime(Long number) {\n    BigInteger bigInt = BigInteger.valueOf(number);\n    return bigInt.isProbablePrime(100);\n}\n\nstatic public class Princess{\n public int rate;public int beauty;public int intellect;public int richness;\n public Princess(int sum,int a,int b,int c){\n  this.rate=sum;\n  this.beauty=a;\n  this.intellect=b;\n  this.richness=c;\n  }\n\n        @Override\n        public String toString() {\n            return \"Princess{\" + \"rate=\" + rate + \", beauty=\" + beauty + \", intellect=\" + intellect + \", richness=\" + richness + '}';\n        }\n \n }\npublic static boolean contains(final int[] arr, final int key) {\n    return Arrays.stream(arr).anyMatch(i -> i == key);\n}\n static boolean isSubSequence(String str1, String str2, int m, int n)\n    {\n       \n        if (m == 0) \n            return true;\n        if (n == 0) \n            return false;\n             \n        \n        if (str1.charAt(m-1) == str2.charAt(n-1))\n            return isSubSequence(str1, str2, m-1, n-1);\n \n        \n        return isSubSequence(str1, str2, m, n-1);\n    }\n\n    static int gcdThing(int a, int b) {\n    BigInteger b1 = BigInteger.valueOf(a);\n    BigInteger b2 = BigInteger.valueOf(b);\n    BigInteger gcd = b1.gcd(b2);\n    return gcd.intValue();\n}\n    public static boolean checkAnagram(String str1, String str2) {\n        int i=0;\n        for (char c : str1.toCharArray()) {\n        i = str2.indexOf(c, i) + 1;\n        if (i <= 0) { return false; }\n    }\n    return true;\n\n}\n    /* Amusing Joke \n    String a,b,c;\n     a=s.next();b=s.next();c=s.next();\n     if((a.length()+b.length())!=c.length()){System.out.print(\"here\");System.out.print(\"NO\");}\n     else{\n         boolean x= true;\n         String agex=\"\";\n         if(checkAnagram(a, c)==false){System.out.print(\"here1\");x=false;}\n         else{\n             char [] g=a.toCharArray();\n             Arrays.sort(g);String ge=new String(g);a=ge;\n             g=b.toCharArray();Arrays.sort(g);ge=new String(b);b=ge;\n             g=c.toCharArray();Arrays.sort(g);ge=new String(c);c=ge;\n            if(isSubSequence(a, c, a.length(), c.length())){\n                 StringBuilder sb = new StringBuilder(c);String temp=\"\";\n                for (int i = 0; i < a.length(); i++) {\n                    temp+=a.charAt(i);\n                 c.replaceFirst(temp, \"\");temp=\"\";\n                   \n                }\n            }\n            else{x=false;}\n            if(isSubSequence(a, c, a.length(), c.length())){\n              StringBuilder sb = new StringBuilder(c);\n                for (int i = 0; i < b.length(); i++) {\n                  String temp=\"\";\n                    temp+=b.charAt(i);\n                 c.replaceFirst(temp, \"\");temp=\"\";\n                   \n                }\n            }\n            else{x=false;}\n            if(c.length()!=0){x=false;}\n    }if(x==false){System.out.print(\"NO\");}\n    else{System.out.print(\"YES\");}\n    }\n    */\n   public static void main (String []  args) throws IOException \n    {\n      Scanner s=new Scanner(System.in);\n      long a,b,c,d;a=s.nextInt();b=s.nextInt();c=s.nextInt();d=s.nextInt();\n      long result=0;\n      long talkwith=0;\n      if(d>=c){talkwith=c;}\n      else{talkwith=d;}\n      long i256=0;long i32=0;\n      if(a>=talkwith){i256=talkwith;a-=talkwith;}\n      else{i256=a;a=0;}\n      if(a>=b){i32=b;}\n      else{i32=a;}\n      \n      result =(i32*32)+(i256*256);\n      System.out.print(result);\n    }\n}\n\n   \n\n", "label": 0}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class justanotherday {\npublic static void main(String[] args) {\n\tScanner s=new Scanner(System.in);\n\tString line=s.nextLine();\n\tString[] t=line.split(\"\\\\ \");\n\tint h2=Integer.parseInt(t[0]);\n\tint h3=Integer.parseInt(t[1]);\n\tint h5=Integer.parseInt(t[2]);\n\tint h6=Integer.parseInt(t[3]);\n\tint min256=Math.min(h2, h5);\n\t min256=Math.min(min256, h6);\n\t h2-=min256;\n\t int min32=Math.min(h3, h2);\n\t System.out.println(((min256*256)+(min32*32)));\n\t\n\t\n}}", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class AntonAndDigits {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\t// Problem http://codeforces.com/problemset/problem/734/B\n\t\t// For more solutions check https://github.com/jontiboss\n\t\tReader reader = new Reader();\n\t\tint two = reader.nextInt();\n\t\tint three = reader.nextInt();\n\t\tint five = reader.nextInt();\n\t\tint six = reader.nextInt();\n\t\t//line below is used many times, so this only needs to be computed once instead of three times.\n\t\tint fiveSixMin = Math.min(five, six);\n\t\t\n\t\t//Count the smallest value of two,five and six. thats how many 256 numbers you could make.\n\t\t// remove the amount of twos needed in the making of the number 256, if the rest is bigger than 2 create as many 32 numbers as possible.\n\t\t//<<8 is 2^8 = 256 , <<5 == 2^5=32\n\t\tint sum = (Math.min(two,fiveSixMin)<<8);\n\t\tif(two-fiveSixMin>=0){\n\t\t\tsum += (Math.min(two-fiveSixMin, three)<<5);\n\t\t}\n\t\tSystem.out.println(sum);\n\n\t}\n\tstatic class Reader \n\t{ \n\t\tBufferedReader br; \n\t\tStringTokenizer st; \n\n\t\tpublic Reader() \n\t\t{ \n\t\t\tbr = new BufferedReader(new\n\t\t\t\t\tInputStreamReader(System.in)); \n\t\t} \n\n\t\tString next() \n\t\t{ \n\t\t\twhile (st == null || !st.hasMoreElements()) \n\t\t\t{ \n\t\t\t\ttry\n\t\t\t\t{ \n\t\t\t\t\tst = new StringTokenizer(br.readLine()); \n\t\t\t\t} \n\t\t\t\tcatch (IOException e) \n\t\t\t\t{ \n\t\t\t\t\te.printStackTrace(); \n\t\t\t\t} \n\t\t\t} \n\t\t\treturn st.nextToken(); \n\t\t} \n\n\t\tint nextInt() \n\t\t{ \n\t\t\treturn Integer.parseInt(next()); \n\t\t} \n\t}\n}\n", "label": 0}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class CF725B{ \n  public static int index;\n  public static void main(String[] args)throws Exception {\n    InputReader in = new InputReader(System.in);\n    PrintWriter pw = new PrintWriter(new OutputStreamWriter(System.out));\n    \n    String s = in.nextLine();\n    \n    long n = Long.parseLong(s.substring(0, s.length()-1));\n    \n    char c = s.charAt( s.length()-1);\n    \n    long x = BS(n); //System.err.println(x);\n    if(x == -1) x = BS2(n); //System.err.println(x);\n    \n    \n    long y = 0;\n    \n    if(c == 'f') y++;\n    else if(c == 'e') y+= 2;\n    else if(c == 'd') y+= 3;\n    else if(c == 'a') y+= 4;\n    else if(c == 'b') y+= 5;\n    else if(c == 'c') y+= 6;\n    \n    \n    \n    long z = (long)4*(x/(long)2);\n    \n    x--;\n    if( x%(long)2 == 1) z -= (long)3;\n    \n    long ans = (long)6 * x + z + y;\n    \n    pw.println(ans);\n    \n    pw.close();\n  }\n  \n  static long BS(long num){\n    long lo  = 0, hi = (long)1e18 + (long)50, mid = (lo+hi)/2;\n    long temp = 0;\n    while(lo < hi){\n      mid = (hi+lo)/2;\n      temp = (long)1 + (mid -1)* (long)4;\n      if( temp >= num) hi = mid;\n      else lo = mid+1;\n    }\n    \n   // System.err.println(lo);\n    \n//    if((long)1 + (lo -1)* (long)4 == num) return lo*(long)2;\n//    \n//    if(((long)1 + (lo -1)* (long)4)+2 == num) return lo*(long)2;\n//    else return lo*(long)2+ (long)1;\n    \n    if((long)1 + (lo -1)* (long)4 == num) return lo + lo - (long)1;\n    if((long)1 + (lo -2)* (long)4 == num - (long)1) return lo + lo - (long)2;\n    else return -1;\n    \n  }\n  \n  \n  static long BS2(long num){\n    long lo  = 0, hi = (long)1e18 + (long)50, mid = (lo+hi)/2;\n    long temp = 0;\n    while(lo < hi){\n      mid = (hi+lo)/2;\n      temp = (long)3 + (mid -1)* (long)4;\n      if( temp >= num) hi = mid;\n      else lo = mid+1;\n    }\n    \n   // System.err.println(lo);\n    \n//    if((long)1 + (lo -1)* (long)4 == num) return lo*(long)2;\n//    \n//    if(((long)1 + (lo -1)* (long)4)+2 == num) return lo*(long)2;\n//    else return lo*(long)2+ (long)1;\n    //System.err.println(lo+\" \"+((long)3 + (lo -1)* (long)4)+\" \"+num);\n    if((long)3 + (lo -1)* (long)4 == num) return lo + lo - (long)1;\n    if((long)3 + (lo -2)* (long)4 == num - (long)1) return lo + lo - (long)2;\n    else return -1;\n    \n  }\n  \n  \n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n    \n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream));\n      tokenizer = null;\n    }\n    \n    public String next()throws Exception {\n      while (tokenizer == null || !tokenizer.hasMoreTokens())\n        tokenizer = new StringTokenizer(reader.readLine());\n      return tokenizer.nextToken();\n    }\n    \n    public String nextLine()throws Exception {\n      String line = null;\n      tokenizer = null;\n      line =  reader.readLine();\n      return line;\n    }\n    \n    public int nextInt()throws Exception {\n      return Integer.parseInt(next());\n    }\n    \n    public double nextDouble() throws Exception{\n      return Double.parseDouble(next());\n    }\n    \n    public long nextLong()throws Exception {\n      return Long.parseLong(next());\n    }\n    \n  }\n}", "label": 0}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\n\n    void solve() throws IOException {\n        String place = next();\n        char c = place.charAt(place.length() - 1);\n        long n = Long.parseLong(place.substring(0, place.length() - 1));\n        int[] t = new int[]{4, 5, 6, 3, 2, 1};\n        n--;\n        long res = t[c - 'a'];\n        res += n / 4 * (2 * 7 + 2);\n        n %= 4;\n        if (n == 1 || n == 3) res += 7;\n\n        out.print(res);\n    }\n\n    BufferedReader br;\n    StringTokenizer st;\n    PrintWriter out;\n\n    public void run() {\n        try {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n\n            solve();\n            br.close();\n            out.flush();\n            out.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(123);\n        }\n    }\n\n    String next() throws IOException {\n        while (st == null || !st.hasMoreTokens()) {\n            String s = br.readLine();\n            if (s == null)\n                return null;\n            st = new StringTokenizer(s);\n        }\n        return st.nextToken();\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public static void main(String[] args) {\n        new Thread(new Main()).start();\n    }\n}", "label": 0}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author lebegio\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        MyReader in = new MyReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, MyReader in, PrintWriter out) {\n            String str = in.next();\n            long n = Long.parseLong(str.substring(0, str.length() - 1));\n            char ch = str.charAt(str.length() - 1);\n            int poz = getPoz(ch);\n            BigInteger time = BigInteger.ZERO;\n            if (n % 4 != 0) time = BigInteger.valueOf(n / 4).multiply(BigInteger.valueOf(16));\n            else time = BigInteger.valueOf((n - 1) / 4).multiply(BigInteger.valueOf(16));\n\n            if (n % 4 == 0) {\n                time = time.add(BigInteger.valueOf(poz + 7));\n            } else if (n % 4 == 1) {\n                time = time.add(BigInteger.valueOf(poz));\n            } else if (n % 4 == 2) {\n                time = time.add(BigInteger.valueOf(poz + 7));\n            } else if (n % 4 == 3) {\n                time = time.add(BigInteger.valueOf(poz));\n            }\n            out.println(time);\n        }\n\n        int getPoz(char ch) {\n            switch (ch) {\n                case 'a':\n                    return 4;\n                case 'b':\n                    return 5;\n                case 'c':\n                    return 6;\n                case 'd':\n                    return 3;\n                case 'e':\n                    return 2;\n                case 'f':\n                    return 1;\n            }\n            return -1;\n        }\n\n    }\n\n    static class MyReader {\n        private BufferedReader buffReader;\n        private StringTokenizer strTokenizer;\n        private static final int SIZE = 32768;\n\n        public MyReader(InputStream inputStream) {\n            buffReader = new BufferedReader(new InputStreamReader(inputStream), SIZE);\n        }\n\n        public String next() {\n            if (strTokenizer == null || !strTokenizer.hasMoreTokens()) {\n                try {\n                    strTokenizer = new StringTokenizer(buffReader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return strTokenizer.nextToken();\n        }\n\n    }\n}\n\n", "label": 0}
{"src": "import java.io.*;\n\npublic class Task725B {\n\n    public static void main(String... args) throws NumberFormatException,\n            IOException {\n        Solution.main(System.in, System.out);\n    }\n\n    static class Scanner {\n\n        private final BufferedReader br;\n        private String[] cache;\n        private int cacheIndex;\n\n        Scanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n            cache = new String[0];\n            cacheIndex = 0;\n        }\n\n        int nextInt() throws IOException {\n            if (cacheIndex >= cache.length) {\n                cache = br.readLine().split(\" \");\n                cacheIndex = 0;\n            }\n            return Integer.parseInt(cache[cacheIndex++]);\n        }\n\n        long nextLong() throws IOException {\n            if (cacheIndex >= cache.length) {\n                cache = br.readLine().split(\" \");\n                cacheIndex = 0;\n            }\n            return Long.parseLong(cache[cacheIndex++]);\n        }\n\n        String next() throws IOException {\n            if (cacheIndex >= cache.length) {\n                cache = br.readLine().split(\" \");\n                cacheIndex = 0;\n            }\n            return cache[cacheIndex++];\n        }\n\n        void close() throws IOException {\n            br.close();\n        }\n\n    }\n\n    static class Solution {\n\n        public static void main(InputStream is, OutputStream os)\n                throws NumberFormatException, IOException {\n            PrintWriter pw = new PrintWriter(os);\n            Scanner sc = new Scanner(is);\n\n            String s = sc.next();\n\n            long row = Long.parseLong(s.substring(0, s.length() - 1));\n\n            char seat = s.substring(s.length() - 1, s.length()).charAt(0);\n\n            pw.println(((row - 1) / 4) * 16 + ((row % 2 == 0) ? 7 : 0) + ((seat > 'c') ? ('g' - seat) : (seat - 'a' + 4)));\n\n            pw.flush();\n            sc.close();\n        }\n    }\n\n}", "label": 0}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport static java.lang.Double.parseDouble;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\npublic class CF725B {\n\t// false to System.in\n\tstatic final boolean FROM_FILE = false;\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tstatic void solve() throws Exception {\n\t\tString str = next();\n\t\tPattern pat = Pattern.compile(\"(\\\\d+)([a-z]*)\");\n\t\tMatcher mat = pat.matcher(str);\n\t\tmat.matches();\n\t\tlong n = Long.parseLong(mat.group(1)) - 1;\n\t\tchar s = mat.group(2).charAt(0);\n\n\t\tlong totalTime = 0;\n\t\t// Which attendant\n\t\t//n % 4 = [0, 1] [2, 3]\n\t\tint mod = (int) (n % 4);\n\t\t// Last group\n\t\ttotalTime += (n - mod) / 2 * 6;\n\n\t\t// 1, 3\n\t\tif (mod % 2 == 1) {\n\t\t\ttotalTime += 6;\n\t\t}\n\n\t\t// Order fdeabc\n\t\ttotalTime += \"fedabc\".indexOf(s) + 1;\n\n\t\t// Movement\n\t\ttotalTime += (n - (mod >= 2 ? 2 : 0));\n\n\t\tout.println(totalTime);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(FROM_FILE ?\n\t\t\t\t\tnew FileReader(new File(\"input\")) :\n\t\t\t\t\tnew InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n\n\tstatic int nextInt() throws IOException {\n\t\treturn parseInt(next());\n\t}\n\n\tstatic long nextLong() throws IOException {\n\t\treturn parseLong(next());\n\t}\n\n\tstatic double nextDouble() throws IOException {\n\t\treturn parseDouble(next());\n\t}\n\n\tstatic String next() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n}", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.SyncFailedException;\n\n/**\n * Created by spec on 22.10.2016.\n */\npublic class B_FoodInPlane {\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n        String place = in.readLine();\n        int col = place.charAt(place.length() - 1) - 'a';\n        long time = 0;\n        if (col < 3) time = col + 4;\n        else if (col == 3) time = 3;\n        else if (col == 4) time = 2;\n        else if (col == 5) time = 1;\n\n        long row = Long.parseLong(place.substring(0, place.length() - 1)) - 1;\n        time += (row / 4) * 16 + (row % 2) * 7;\n        System.out.println(time);\n    }\n}\n", "label": 0}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        String seatServe = \"fedabc\";\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            String s = in.readString();\n            char seat = s.charAt(s.length() - 1);\n            long row = Long.parseLong(s.substring(0, s.length() - 1));\n\n            long m = row % 4;\n            long iteration = (row - 1) / 4;\n            long iterationTime = iteration > 0 ? (4 * iteration + iteration * 12) : 0L;\n            if (m == 0 || m == 3) {\n                if (m == 0) {\n                    iterationTime += 7;\n                }\n            } else {\n                if (m == 2) {\n                    iterationTime += 7;\n                }\n            }\n\n            iterationTime += seatServe.indexOf(seat) + 1;\n            out.printLine(iterationTime);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void printLine(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "label": 0}
{"src": "import java.util.Scanner;\n\n/**\n * Created by igarus on 27.10.2016.\n */\npublic class CF_Canada2016_B {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String line = scanner.nextLine();\n        long n = Long.parseLong(line.substring(0, line.length() - 1));\n        char s = line.charAt(line.length() - 1);\n        int r = 0;\n        switch (s) {\n            case 'f':\n                r = 0;\n                break;\n            case 'e':\n                r = 1;\n                break;\n            case 'd':\n                r = 2;\n                break;\n            case 'a':\n                r = 3;\n                break;\n            case 'b':\n                r = 4;\n                break;\n            case 'c':\n                r = 5;\n                break;\n        }\n        int a = n % 4 == 1 || n % 4 == 3 ? 1 : 8;\n        long x = a + ((n - 1) / 4) * 16 + r;\n        System.out.print(x);\n    }\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class ProbB {\n\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    String line = scanner.nextLine().trim();\n    long row = Long.parseLong(line.substring(0, line.length() - 1));\n    char seat = line.charAt(line.length() - 1);\n\n    long total = (row - 1) / 4 * 16;\n\n    row %= 2;\n    if (row == 0) {\n      total += 7;\n    }\n\n    if (seat == 'f') {\n      total++;\n    } else if (seat == 'e') {\n      total += 2;\n    } else if (seat == 'd') {\n\n      total += 3;\n    } else if (seat == 'a') {\n\n      total += 4;\n    } else if (seat == 'b') {\n\n      total += 5;\n    } else if (seat == 'c') {\n\n      total += 6;\n    }\n\n    System.out.println(total);\n\n  }\n}\n\t \t  \t   \t\t\t \t \t\t \t  \t\t \t\t\t  \t", "label": 0}
{"src": "\nimport java.io.*;\nimport java.util.*;\n\npublic class B {\n\tInputStream is;\n\n\tint __t__ = 1;\n\tint __f__ = 0;\n\tint __FILE_DEBUG_FLAG__ = __f__;\n\tString __DEBUG_FILE_NAME__ = \"src/T\";\n\n\tFastScanner in;\n\tPrintWriter out;\n\n\tString order = \"fedabc\";\n\tpublic void solve() {\n\t\tString s = in.next();\n\t\tlong n = Long.valueOf(s.substring(0, s.length() - 1)) - 1;\n\t\tchar c = s.charAt(s.length() - 1);\n\t\t\n\t\tlong res = 0;\n\t\tres += (n / 4) * 16;\n\t\t\n\t\tlong row = (n % 4) % 2;\n\t\tif (row == 1) res += 7;\n\t\t\n\t\tres += order.indexOf(c) + 1;\n\t\tSystem.out.println(res);\n\t}\n\n\tpublic void run() {\n\t\tif (__FILE_DEBUG_FLAG__ == __t__) {\n\t\t\ttry {\n\t\t\t\tis = new FileInputStream(__DEBUG_FILE_NAME__);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\t// TODO \u81ea\u52d5\u751f\u6210\u3055\u308c\u305f catch \u30d6\u30ed\u30c3\u30af\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tSystem.out.println(\"FILE_INPUT!\");\n\t\t} else {\n\t\t\tis = System.in;\n\t\t}\n\t\tin = new FastScanner(is);\n\t\tout = new PrintWriter(System.out);\n\n\t\tsolve();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew B().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\treturn nextIntArray(n, 0);\n\t\t}\n\n\t\tint[] nextIntArray(int n, int margin) {\n\t\t\tint[] array = new int[n + margin];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i + margin] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\treturn nextLongArray(n, 0);\n\t\t}\n\n\t\tlong[] nextLongArray(int n, int margin) {\n\t\t\tlong[] array = new long[n + margin];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i + margin] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\treturn nextDoubleArray(n, 0);\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n, int margin) {\n\t\t\tdouble[] array = new double[n + margin];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i + margin] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}\n\n", "label": 0}
{"src": "import java.io.*;    //PrintWriter\nimport java.math.*;  //BigInteger, BigDecimal\nimport java.util.*;  //StringTokenizer, ArrayList\n\n\npublic class Canada_Cup_2016_B\n{\t\n\tFastReader in;\n\tPrintWriter out;\n\t\n\tpublic static void main(String[] args)  {\n\t\tnew Canada_Cup_2016_B().run();\n\t}\n\t\n\tvoid run()\n\t{\t\t\n\t\tin = new FastReader(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.close();\n\t}\n\t\n\tvoid solve()\n\t{\n\t\tString s = in.next();\n\t\tint n = s.length();\n\t\tchar seat = s.charAt(n-1);\n\t\tlong row = Long.parseLong(s.substring(0,n-1)); \n\t\t\n\t\tlong sec = (row - 1) / 4 * (6 + 1 + 6 + 3);\n\t\trow = (row - 1) % 2;\n\t\tsec += row * (6 + 1);\n\t\tsec += \"fedabc\".indexOf(seat) + 1;\n\t\t\t\t\n\t\tout.println(sec);\t\t\n\t}\n\n\t//-----------------------------------------------------\n\tvoid runWithFiles() {\n\t\tin = new FastReader(new File(\"input.txt\"));\n\t\ttry {\n\t\t\tout = new PrintWriter(new File(\"output.txt\"));\n\t\t} \n\t\tcatch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tsolve();\n\t\tout.close();\n\t}\n\t\n\tclass FastReader\n\t{\n\t    BufferedReader br;\n\t    StringTokenizer tokenizer;\n\t    \n\t    public FastReader(InputStream stream)\n\t    {\n\t        br = new BufferedReader(new InputStreamReader(stream));\n\t        tokenizer = null;\n\t    }\n\t\tpublic FastReader(File f) {\n\t\t\ttry {\n\t\t\t\tbr = new BufferedReader(new FileReader(f));\n\t\t\t\ttokenizer = null;\n\t\t\t}\n\t\t\tcatch (FileNotFoundException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t    \n\t    private String next() {\n\t        while (tokenizer == null || !tokenizer.hasMoreTokens())\n\t            try {\n\t            \ttokenizer = new StringTokenizer(br.readLine());\n\t            }\n\t            catch (IOException e) {\n\t                throw new RuntimeException(e);\n\t            }\n\t        return tokenizer.nextToken();\n\t    }\n\t\tpublic String nextLine() {\n\t\t\ttry\t{\n\t\t\t\treturn br.readLine();\n\t\t\t}\n\t\t\tcatch(Exception e) {\n\t\t\t\tthrow(new RuntimeException());\n\t\t\t}\n\t\t}\n\n\t    int nextInt() {\n\t        return Integer.parseInt(next());\n\t    }\n\t    long nextLong() {\n\t        return Long.parseLong(next());\n\t    }\n\t    double nextDouble() {\n\t        return Double.parseDouble(next());\n\t    }\t    \n\t    BigInteger nextBigInteger() {\n\t        return new BigInteger(next());\n\t    }\n\t    BigDecimal nextBigDecimal() {\n\t        return new BigDecimal(next());\n\t    }\n\t}\n}\n", "label": 0}
{"src": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Food {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        long n = Long.valueOf(line.substring(0, line.length() - 1));\n        char s = line.charAt(line.length() - 1);\n        int a;\n        switch (s) {\n            case 'a': a = 3; break;\n            case 'b': a = 4; break;\n            case 'c': a = 5; break;\n            case 'd': a = 2; break;\n            case 'e': a = 1; break;\n            case 'f': a = 0; break;\n            default: throw new IllegalArgumentException(\"CLASH OF CLAN\");\n        }\n        BigInteger pr = BigInteger.valueOf(((n - 1) / 4) * 4).multiply(BigInteger.valueOf(6 / 2));\n        long mt;\n        if ((n - 1) % 4 >= 2 ) {\n            mt = n - 2;\n        } else {\n            mt = n;\n        }\n        System.out.println(pr.add(BigInteger.valueOf(((n - 1) % 2) * 6)).add(BigInteger.valueOf(a))\n                .add(BigInteger.valueOf(mt)));\n    }\n}", "label": 0}
{"src": "\n\nimport java.util.Scanner;\n\npublic class FoodOnPlane {\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\t\tString s = sc.nextLine();\n\t\tlong n = Long.parseLong(s.substring(0, s.length()-1));\n\t\tlong patch = (n-1)/4;\n\t\tlong time = 0;\n\t\ttime+=patch*16;\n//\t\tSystem.out.println(time);\n\t\tif (n%2==0)\n\t\t\ttime+=7;\n\t\tchar c = s.charAt(s.length()-1);\n\t\tif (c=='f')\n\t\t\ttime+=1;\n\t\telse if (c=='e')\n\t\t\ttime+=2;\n\t\telse if (c=='d')\n\t\t\ttime+=3;\n\t\telse if (c=='a')\n\t\t\ttime+=4;\n\t\telse if (c=='b')\n\t\t\ttime+=5;\n\t\telse\n\t\t\ttime+=6;\n\t\tSystem.out.println(time);\n\t}\n}\n", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class FoodPlane {\n\tpublic static void main(String args[]) throws Exception{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString s= br.readLine();\n\t\tchar c = s.charAt(s.length()-1);\n\t\tlong r = Long.parseLong(s.substring(0,s.length()-1)) - 1;\n\t\t\n\t\tlong time= (r/4)*16;\n\t\tif((r%4)%2 != 0 ){\n\t\t\ttime++;\n\t\t\ttime+=6;\n\t\t}\n\t\tif(c=='f')time+=1;\n\t\telse if(c=='e')time+=2;\n\t\telse if(c=='d')time+=3;\n\t\telse if(c=='a')time+=4;\n\t\telse if(c=='b')time+=5;\n\t\telse if(c=='c')time+=6;\n\t\t\n\t\tSystem.out.println(time);\n\t}\n}\n", "label": 0}
{"src": "import java.util.*;\npublic class FoodPlane {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tString s = in.next();\n\t\tlong x = Long.parseLong(s.substring(0, s.length()-1));\n\t\tchar c = s.charAt(s.length()-1);\n\t\tlong count = ((x-1)/4)*16;\n\t\tx=((x-1)%4)+1;\n\t\tif(x==2||x==4){\n\t\t\tcount+=7;\n\t\t}\n\t\tif(c=='f') {\n\t\t\tcount+=1;\n\t\t}\n\t\tif(c=='e') {\n\t\t\tcount+=2;\n\t\t}\n\t\tif(c=='d') {\n\t\t\tcount+=3;\n\t\t}\n\t\tif(c=='a') {\n\t\t\tcount+=4;\n\t\t}\n\t\tif(c=='b') {\n\t\t\tcount+=5;\n\t\t}\n\t\tif(c=='c') {\n\t\t\tcount+=6;\n\t\t}\n\t\tSystem.out.println(count);\n\t}\n}\n", "label": 0}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Main {\n\n    private BufferedReader in;\n    private PrintWriter out;\n\n    public Main() {\n        try {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(new FileWriter(\"output.txt\"), true);\n        } catch (Exception e) {\n            //e.printStackTrace();\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out, true);\n        }\n        try {\n            solve();\n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (in != null)\n                try {\n                    in.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            if (out != null)\n                out.close();\n        }\n    }\n\n    private StringTokenizer tokenizer;\n\n    public String next() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreElements())\n            tokenizer = new StringTokenizer(in.readLine());\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.valueOf(next());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.valueOf(next());\n    }\n\n    public static void main(String[] args) {\n        new Main();\n    }\n\n    private void solve() throws Exception {\n        int[] add = new int[] {4,5,6,3,2,1};\n        String s = next();\n        boolean isOdd = false;\n        long place = Long.valueOf(s.substring(0, s.length()-1));\n        long obs = (place+3)/4 - 1;\n        if (place % 2 > 0) isOdd = true;\n        long start = obs*14+2*obs;\n        if (!isOdd)\n            start += 7;\n        out.print(start+add[s.charAt(s.length()-1)-'a']);\n    }\n\n}\n", "label": 0}
{"src": "import java.io.IOException;\nimport java.io.PrintStream;\nimport java.util.Scanner;\n\n\npublic class B {\n\n\tprivate static Scanner in = new Scanner(System.in);\n\tprivate static PrintStream out = System.out;\n\t//private static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t//private static PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\t\n\tprivate static int map(char seat) {\n\t\tint[] ORDER = {3, 4, 5, 2, 1, 0};\n\t\treturn ORDER[seat - 'a'] + 1;\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tString s = in.next();\n\t\tlong row = Long.parseLong(s.substring(0, s.length() - 1)) - 1;\n\t\tchar seat = s.charAt(s.length() - 1);\n\t\tlong ans = 16*(row/4);\n\t\tif (row%2 == 1) {\n\t\t\tans += 7;\n\t\t}\n\t\tans += map(seat);\n\t\tout.println(ans);\n\t}\n\n}\n", "label": 0}
{"src": "import java.util.*;\npublic class X{\npublic static void main(String... x){\nScanner sc = new Scanner(System.in);\nString line = sc.nextLine();\nlong r = Long.valueOf(line.substring(0,line.length()-1));\nchar ch = line.charAt(line.length()-1);\nlong rr = ((r-1)/4) * 12;  \nlong rrr = ((r-1)%4%2) *6;\nlong d = (r-1);\nif (((r-1)%4)>=2) d-=2;\nlong rrrr = 0;\nswitch (ch){\n  case 'a': rrrr = 4; break;\n  case 'b': rrrr = 5; break;\n  case 'c': rrrr = 6; break;\n  case 'd': rrrr = 3; break;\n  case 'e': rrrr = 2; break;\n  case 'f': rrrr = 1; break;\n}\nSystem.out.println(rr+rrr+rrrr+d);\n\n}}  //5e 18", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\n\npublic class B {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader r = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter w = new PrintWriter(System.out);\n\n\t\tString temp = r.readLine();\n\t\tchar last = temp.charAt(temp.length() - 1);\n\t\tint seat = -1;\n\t\t\n\t\tif (last == 'f') {\n\t\t\tseat = 0;\n\t\t} else if (last == 'e') {\n\t\t\tseat = 1;\n\t\t} else if (last == 'd') {\n\t\t\tseat = 2;\n\t\t} else if (last == 'a') {\n\t\t\tseat = 3;\n\t\t} else if (last == 'b') {\n\t\t\tseat = 4;\n\t\t} else if (last == 'c') {\n\t\t\tseat = 5;\n\t\t}\n\t\t\n\t\tseat++;\n\t\tlong n = Long.parseLong(temp.substring(0, temp.length() - 1));\n\t\t\n\t\tlong groups = (n - 1) / 4;\n\t\tlong remainder = (n - 1) % 2;\n\t\t\n\t\tlong answer = groups * 16 + (remainder == 1 ? 7 : 0) + seat;\n\t\t\n\t\tw.println(answer);\n\t\tw.flush();\n\t\t\n\t\t\n\t}\n\n}\n", "label": 0}
{"src": "import java.io.*;\nimport java.math.BigDecimal;\nimport java.util.*;\n\n@SuppressWarnings(\"WeakerAccess\")\npublic class Main {\n\n    final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    public static void main(String[] args) {\n        new Main().run();\n        // Sworn to fight and die\n    }\n\n    void init() throws FileNotFoundException {\n        if (ONLINE_JUDGE) {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        } else {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    public void run() {\n        try {\n            long t1 = System.currentTimeMillis();\n            init();\n            solve();\n            out.close();\n            long t2 = System.currentTimeMillis();\n            System.err.println(\"Time = \" + (t2 - t1));\n        } catch (Exception e) {\n            e.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n    class Point {\n        double [] a;\n\n        public Point(int n) {\n            this.a = new double[n];\n        }\n\n        double scalar(Point b) {\n            double result = 0;\n            for (int i = 0; i < a.length; i++) {\n                result += a[i] * b.a[i];\n            }\n\n            return result;\n        }\n\n        double len() {\n            double res = 0;\n\n            for (int i = 0; i < a.length; i++) {\n                res += (a[i] * a[i]);\n            }\n\n            return Math.sqrt(res);\n        }\n\n        double dist(Point b) {\n            double res = 0;\n\n            for (int i = 0; i < a.length; i++) {\n                res += ((a[i] - b.a[i]) * (a[i] - b.a[i]));\n            }\n\n            return Math.sqrt(res);\n        }\n\n        void alphaScalar(double alpha) {\n            for (int i = 0; i < a.length; i++) {\n                a[i] *= alpha;\n            }\n        }\n\n    }\n\n\n    public void solve() throws IOException {\n\n        String input = readString();\n        int len = input.length();\n\n        char letter = input.charAt(len - 1);\n\n        long n = Long.parseLong(input.substring(0, len - 1));\n\n        long quarter = n / 4;\n\n        if (n % 4 == 0) {\n            quarter -= 1;\n        }\n\n        long ans = 16 * quarter;\n\n        long mod = n % 4;\n\n        if (mod == 0) {\n            mod = 4;\n        }\n\n        if (mod == 2) {\n            ans += 6;\n            ans += 1;\n        }\n\n        if (mod == 4) {\n            ans += 6;\n            ans += 1;\n        }\n\n        if (letter == 'f') {\n            ans += 1;\n        }\n        if (letter == 'e') {\n            ans += 2;\n        }\n\n        if (letter == 'd') {\n            ans += 3;\n        }\n\n        if (letter == 'a') {\n            ans += 4;\n        }\n        if (letter == 'b') {\n            ans += 5;\n        }\n\n        if (letter == 'c') {\n            ans += 6;\n        }\n\n        out.print(ans);\n\n\n\n\n    }\n\n}", "label": 0}
{"src": "/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n//package javaapplication1;\n\nimport java.util.Scanner;\n\n/**\n *\n * @author TaMeEm\n */\npublic class JavaApplication1 {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        long n;\n        int len;\n        char ch;\n        String s;\n        Scanner in=new Scanner(System.in);\n        s=in.next();\n        len=s.length();\n        ch=s.charAt(len-1);\n        //System.out.println(ch);\n        s=s.substring(0, len-1);\n        n=Long.parseLong(s);\n        //System.out.println(n);\n        long res=(n-1)/4;\n        res*=16;\n        long rem=n%4;\n        if(rem%2==0)\n            res+=7;\n        switch(ch)\n        {\n            case 'f':\n                res+=1;\n                break;\n            case 'e':\n                res+=2;\n                break;\n            case 'd':\n                res+=3;\n                break;\n            case 'a':\n                res+=4;\n                break;\n            case 'b':\n                res+=5;\n                break;\n            case 'c':\n                res+=6;\n                break;\n        }\n        System.out.println(res);\n    }\n}\n", "label": 0}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\t//Scanner sc = new Scanner(new File(\"src/input.txt\"));\n\t\t\n\t\tString str = sc.next();\n\t\tlong n = Long.parseLong(str.substring(0, str.length()-1));\n\t\tchar c = str.charAt(str.length()-1);\n\t\t\n\t\tlong[] seatVal = new long[6];\n\t\tseatVal[0] = 4;\n\t\tseatVal[1] = 5;\n\t\tseatVal[2] = 6;\n\t\tseatVal[3] = 3;\n\t\tseatVal[4] = 2;\n\t\tseatVal[5] = 1;\n\t\t\n\t\tlong temp = ((n-1)/4)*2;\n\t\tlong time = ((temp + ((n-1)%2)) * 7) + temp;\n\t\ttime += seatVal[c-'a'];\n\t\t\n\t\tSystem.out.println(time);\n\t}\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class CanadaCap2016FoodOnThePlane {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String s = sc.next();\n        long n = Long.parseLong(s.substring(0, s.length() - 1));\n        int seat = s.charAt(s.length() - 1);\n        long cycleTime = 6 + 6 + (2 - 1) + (5 - 2);\n        long cycleRows = 4;\n        long cycles = n / cycleRows;\n        long row = n % cycleRows;\n        if (row == 0) {\n            row = cycleRows;\n            cycles--;\n        }\n        long result = cycles * cycleTime;\n\n        int time = -1;\n        switch (seat) {\n        case 'a':\n            time = 4;\n            break;\n        case 'b':\n            time = 5;\n            break;\n        case 'c':\n            time = 6;\n            break;\n        case 'd':\n            time = 3;\n            break;\n        case 'e':\n            time = 2;\n            break;\n        case 'f':\n            time = 1;\n            break;\n        }\n        result += time;\n        if (row == 2 || row == 4) {\n            result += 6 + (2 - 1);\n        }\n        System.out.println(result);\n    }\n}\n", "label": 0}
{"src": "import java.io.*;\nimport java.util.*;\npublic class B {\n  public static void main (String[] args) throws Exception {\n    Scanner in = new Scanner(System.in);\n    String take = in.next();\n    long n = Long.parseLong(take.substring(0, take.length() - 1)) - 1;\n    char c = take.charAt(take.length() - 1);\n    long time = 16 * (n / 4);\n    long rem = (n % 4);\n    if (rem == 1 || rem == 3) time+= 7;\n    String t = \"456321\";\n    time += (int)(t.charAt((int)(c - 'a')) - '1') + 1;\n    System.out.println(time);\n  }\n}", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class Task2 {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String str = sc.next();\n        char col = str.charAt(str.length() - 1);\n        long row = Long.parseLong(str.substring(0, str.length() - 1)) - 1;\n\n        long pos = row % 4;\n        long rows = row - pos;\n\n        long sec = (rows / 2) * 6 + rows;\n\n        if (pos == 1 || pos == 3) {\n            sec += 7;\n        }\n        sec += offset(col);\n\n        System.out.println(sec);\n    }\n\n    private static int offset(char ch) {\n        switch (ch) {\n            case 'f':\n                return 1;\n            case 'e':\n                return 2;\n            case 'd':\n                return 3;\n            case 'a':\n                return 4;\n            case 'b':\n                return 5;\n            case 'c':\n                return 6;\n        }\n        return 0;\n    }\n}\n", "label": 0}
{"src": "import java.util.*;\nimport java.io.*;\n//Captain on duty!\n\n\n\npublic class Main {\n\n    static void compare(Main.pair a[] , int n) {\n\n        Arrays.sort(a, new Comparator<Main.pair>() {\n            @Override\n            public int compare(Main.pair p1, Main.pair p2) {\n                return p1.f - p2.f;\n            }\n        });\n    }\n    public static boolean checkPalindrome(String s)\n    {\n        // reverse the given String\n        String reverse = new StringBuffer(s).reverse().toString();\n\n        // check whether the string is palindrome or not\n        if (s.equals(reverse))\n            return true;\n\n        else\n            return false;\n    }\n\n    static class pair implements Comparable\n    {\n        int f;\n        int s;\n        pair(int fi, int se)\n        {\n            f=fi;\n            s=se;\n        }\n        public int compareTo(Object o)//desc order\n        {\n            pair pr=(pair)o;\n            if(s>pr.s)\n                return -1;\n            if(s==pr.s)\n            {\n                if(f>pr.f)\n                    return 1;\n                else\n                    return -1;\n            }\n            else\n                return 1;\n        }\n        public boolean equals(Object o)\n        {\n            pair ob=(pair)o;\n            if(o!=null)\n            {\n                if((ob.f==this.f)&&(ob.s==this.s))\n                    return true;\n            }\n            return false;\n        }\n        public int hashCode()\n        {\n            return (this.f+\" \"+this.s).hashCode();\n        }\n\n\n    }\n\n    public static boolean palin(int l, int r, char[] c) {\n        while (l <= r) {\n            if (c[l] != c[r]) return false;\n            l++;\n            r--;\n        }\n        return true;\n    }\n\n\n    public static long gcd(long a, long b)\n    {\n        if(b==0)\n            return a;\n\n        return gcd(b, a%b);\n    }\n\n    public static long hcf(long a, long b)\n    {\n        long t;\n        while(b != 0)\n        {\n            t = b;\n            b = a%b;\n            a = t;\n        }\n        return a;\n    }\n\n    public static boolean isPrime(int n)\n    {\n        if (n <= 1)\n            return false;\n\n        // Check from 2 to n-1\n        for (int i = 2; i < n; i++)\n            if (n % i == 0)\n                return false;\n\n        return true;\n    }\n\n    public static String reverse(String str)\n    {\n        String str1=\"\";\n        for(int i=0;i<str.length();i++)\n        {\n            str1 = str1 + str.charAt(str.length()-i-1);\n        }\n        return str1;\n    }\n\n\n\n    public static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n\n    }\n\n\n    public static void main(String[] args) {\n        FastReader s = new FastReader();\n\n       String str=s.next();\n       int l=str.length();\n       long n = Long.parseLong(str.substring(0,l-1));\n       char f = str.charAt(l-1);\n       long ans=0;\n       if(n>4)\n       {\n           long temp=n/4;\n           if(n%4==0)\n               temp-=1;\n           if(n%2==0)\n               ans+=7;\n           ans+=(temp*16);\n           //System.out.println(ans);\n\n       }\n       else\n       {\n           if(n%2==0)\n               ans+=7;\n       }\n       if(f=='f')\n           ans+=1;\n       else if(f=='e')\n           ans+=2;\n       else if(f=='d')\n           ans+=3;\n       else if(f=='a')\n           ans+=4;\n       else if(f=='b')\n           ans+=5;\n       else if(f=='c')\n           ans+=6;\n       System.out.println(ans);\n\n\n\n    }\n}\n\n\n\n\n\n\n\n\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class R725B {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String s=in.next();\n        Character c=s.charAt(s.length()-1);\n        String nn=s.substring(0, s.length()-1);\n        long n=Long.parseLong(nn), ans=0;\n        ans=((n-1)/4)*(6+1+6+3);\n        n=(n-1)%4+1;\n        if (n%2==0) ans+=7;\n        if (c>'c')\n            ans+='f'-c+1;\n        else\n            ans+=c-'a'+4;\n        System.out.println(ans);\n    }\n}\n", "label": 0}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class p2\n{\n  public static void main (String[]args)throws IOException\n  {\n    Scanner s=new Scanner (System.in);\n    String input=s.next();\n    char seat = input.charAt(input.length()-1);\n    Long row = Long.parseLong(input.substring(0,input.length()-1));\n    Long time = 0L;\n    Long rowType = row%4;\n    Long previousRows=row/4;\n    if (rowType == 0)\n      previousRows--;\n    time += previousRows*16;\n    Long typeTime=0L;\n    if (seat == 'f')\n      typeTime=1L;\n    else if (seat == 'e')\n      typeTime=2L;\n    else if (seat == 'd')\n      typeTime=3L;\n    else if (seat == 'a')\n      typeTime=4L;\n    else if (seat == 'b')\n      typeTime=5L;\n    else\n      typeTime=6L;\n    int f=1,e=2,d=3,a=4,b=5,c=6;\n    if (rowType == 1 || rowType == 3)\n      time += typeTime;\n    else \n      time += (typeTime+7);\n    System.out.println(time);\n   }\n\n}\n  ", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\n\npublic class FoodOnThePlane {\n    static BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter out = new PrintWriter(System.out);\n    public static void main(String[] args) throws IOException {\n        String str = in.readLine();\n        String s =str.substring(0, str.length()-1);\n        long row = Long.parseLong(s);\n      \n        long ans = 0;\n        if(row%4 == 3 || row%4 == 0){\n//            long x = row-3;\n            ans += row/2;\n            ans--;\n            ans *= 6;\n//            ans -= x;\n            ans += row -3;\n        }\n        else{\n            ans += row/2;\n            \n            ans *= 6;\n//            ans -= x;\n            ans += row -1;\n        }\n       int x = \"fedabc\".indexOf(str.charAt(str.length()-1))+1;\n        ans += x;\n        out.println(ans);\n        out.flush();\n    }\n}\n", "label": 0}
{"src": "\nimport java.io.*;\nimport java.math.BigInteger;\n\n/**\n *\n * @author mohanad\n */\npublic class CandaCup2016_B {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) throws IOException {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\n       String in = bf.readLine();\n       \n        BigInteger nn= new BigInteger(in.substring(0 , in.length()-1 ));\n        char a=in.charAt(in.length()-1);\n        \n        BigInteger an = new BigInteger(\"0\");\n        BigInteger div=an.subtract(BigInteger.ONE).divideAndRemainder(new BigInteger(\"4\"))[1];\n        if (nn.subtract(BigInteger.ONE).divideAndRemainder(new BigInteger(\"4\"))[1]==BigInteger.ZERO)\n        an= nn.subtract(new BigInteger(\"1\")).multiply(new BigInteger(\"3\")).add(nn).subtract(BigInteger.ONE);\n        else if (nn.subtract(BigInteger.ONE).divideAndRemainder(new BigInteger(\"4\"))[1].compareTo(new BigInteger(\"2\"))==0)\n            an= nn.subtract(new BigInteger(\"3\")).multiply(new BigInteger(\"3\")).add(nn).subtract(new BigInteger(\"3\"));\n        \n        else if (nn.subtract(BigInteger.ONE).divideAndRemainder(new BigInteger(\"4\"))[1].compareTo(new BigInteger(\"3\"))==0)\n         an= nn.subtract(new BigInteger(\"4\")).multiply(new BigInteger(\"3\")).add(nn).subtract(new BigInteger(\"3\")).add(new BigInteger(\"6\"));\n        \n        else \n            an= nn.subtract(new BigInteger(\"2\")).multiply(new BigInteger(\"3\")).add(nn).subtract(BigInteger.ONE).add(new BigInteger(\"6\"));\n        \n        if (a=='f')\n        System.out.println(an.add(new BigInteger(\"1\")));\n        else if (a=='e')\n            System.out.println(an.add(new BigInteger(\"2\")));\n        else if (a=='d')\n            System.out.println(an.add(new BigInteger(\"3\")));\n        else if (a=='c')\n            System.out.println(an.add(new BigInteger(\"6\")));\n        else if (a=='b')\n            System.out.println(an.add(new BigInteger(\"5\")));\n        else System.out.println(an.add(new BigInteger(\"4\")));\n        \n    }\n\n}\n", "label": 0}
{"src": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class B {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        String line = sc.nextLine();\n        long n = Long.valueOf(line.substring(0, line.length() - 1));\n        char s = line.charAt(line.length() - 1);\n        int a;\n        switch (s) {\n            case 'a':\n                a = 3;\n                break;\n            case 'b':\n                a = 4;\n                break;\n            case 'c':\n                a = 5;\n                break;\n            case 'd':\n                a = 2;\n                break;\n            case 'e':\n                a = 1;\n                break;\n            case 'f':\n                a = 0;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Illegal Argument\");\n        }\n        // Count of processed rows\n        BigInteger pr = BigInteger.valueOf(((n - 1) / 4) * 4).multiply(BigInteger.valueOf(6 / 2));\n        // Additional moving time\n        long mt;\n        if ((n - 1) % 4 >= 2 ) {\n            mt = n - 2;\n        } else {\n            mt = n;\n        }\n        System.out.println(pr.add(BigInteger.valueOf(((n - 1) % 2) * 6)).add(BigInteger.valueOf(a))\n                .add(BigInteger.valueOf(mt)));\n    }\n}\n", "label": 0}
{"src": "import java.util.StringTokenizer;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\npublic class B {\n    public static void main(String args[]) {\n        Sc sc = new Sc(System.in);\n        String s = sc.n();\n        long n = Long.parseLong(s.substring(0,s.length()-1));\n        int sec = Math.abs(s.charAt(s.length()-1) - 'f');\n        if(sec == 3) sec = 5;\n        else if(sec == 5) sec = 3;\n        long alls = ((n-1)/4)*12 + sec + 1;\n        if((n+1)/2%2 == 1) {\n            alls += n-1;\n        } else alls += n-3;\n\n        if(n%2 == 0) alls += 6;\n\n        System.out.println(alls);\n    }\n}\nclass Sc {\n    public Sc(InputStream i) {\n        r = new BufferedReader(new InputStreamReader(i));\n    }\n\n    public boolean hasM() {\n        return peekToken() != null;\n    }\n\n    public int nI() {\n        return Integer.parseInt(nextToken());\n    }\n\n    public double nD() { \n        return Double.parseDouble(nextToken());\n    }\n\n    public long nL() {\n        return Long.parseLong(nextToken());\n    }\n\n    public String n() {\n        return nextToken();\n    }\n\n    private BufferedReader r;\n    private String line;\n    private StringTokenizer st;\n    private String token;\n\n    private String peekToken() {\n        if (token == null) \n            try {\n                while (st == null || !st.hasMoreTokens()) {\n                    line = r.readLine();\n                    if (line == null) return null;\n                    st = new StringTokenizer(line);\n                }\n                token = st.nextToken();\n            } catch (IOException e) { }\n        return token;\n    }\n\n    private String nextToken() {\n        String ans = peekToken();\n        token = null;\n        return ans;\n    }\n}", "label": 0}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\n/**\n * Created by vikas.k on 18/03/17.\n */\npublic class Plane {\n    public static PrintWriter out;\n    public static FastScanner in;\n\n    private void solve() {\n        String num = in.nextLine();\n\n        int l = num.length();\n\n        long n = 0L;\n        for(int i=0;i<l-1;i++){\n            if(n>0) n*=10;\n            n+=(long)(num.charAt(i)-'0');\n        }\n        n--;\n        char c = num.charAt(l-1);\n        long d = n/4;\n        long r = n%4;\n        long time = 16*d;\n        //out.println(time+\" \"+d+\" \"+r);\n        if(r == 1 || r == 3){\n            time+=7;\n        }\n        if(c >= 'd'){\n            time+=('f'-c)+1;\n        }else{\n            time+=3+(c-'a')+1;\n        }\n        out.print(time);\n\n    }\n\n    private void runIO() {\n        in = new FastScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        solve();\n        out.close();\n    }\n\n    private static class FastScanner {\n        BufferedReader bufferedReader;\n        StringTokenizer stringTokenizer;\n\n        private FastScanner() {\n            bufferedReader = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        private String next() {\n            if (stringTokenizer == null || !stringTokenizer.hasMoreElements()) {\n                try {\n                    stringTokenizer = new StringTokenizer(bufferedReader.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return stringTokenizer.nextToken();\n        }\n\n        private int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        private long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        private String nextLine() {\n            String ret = \"\";\n            try {\n                ret = bufferedReader.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return ret;\n        }\n    }\n\n    public static void main(String[] args) {\n        new Plane().runIO();\n    }\n}\n", "label": 0}
{"src": "import java.math.BigInteger;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String [] args) {\n        Scanner cin = new Scanner(System.in);\n\n        String str = cin.nextLine();\n\n        char mesto = str.charAt(str.length() - 1);\n        BigInteger ryad = new BigInteger(str.substring(0, str.length() -1));\n\n        BigInteger past = ryad.subtract(BigInteger.ONE).divide(new BigInteger(\"4\"));\n        BigInteger now = ryad.subtract(BigInteger.ONE).mod(new BigInteger(\"4\"));\n\n       // System.out.println(past + \" \" + now);\n\n        BigInteger result = past.multiply(new BigInteger(\"13\"));\n\n        if(!past.equals(BigInteger.ZERO)) {\n            result  = result.add(past.multiply(new BigInteger(\"3\")));\n        }\n\n        int dob = 0;\n        if(now.equals(BigInteger.ONE) || now.equals(new BigInteger(\"3\"))) {\n            dob += 7;\n        }\n        switch (mesto) {\n            case 'f':{\n                dob+=1;\n                break;\n            }\n            case 'e':{\n                dob+=2;\n                break;\n            }\n            case 'd':{\n                dob+=3;\n                break;\n            }\n            case 'a':{\n                dob+=4;\n                break;\n            }\n            case 'b':{\n                dob+=5;\n                break;\n            }\n            case 'c':{\n                dob+=6;\n                break;\n            }\n        }\n\n        result = result.add(new BigInteger(Integer.toString(dob)));\n        System.out.println(result);\n    }\n}", "label": 0}
{"src": "\nimport java.io.BufferedReader;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\n\n\nimport java.util.*;\n\npublic class random_num {\npublic static int mod= (int) (Math.pow(10,9)+7);\n\tpublic static void main(String args[]){\n\t\tInputReader s= new InputReader(System.in);\n\t\tOutputStream outputStream= System.out;\n\t\tPrintWriter out= new PrintWriter(outputStream);\n\t\tString str=s.nextLine();\n\t\tString str1=\"\";\n\t\tfor(int i=0;i<str.length()-1;i++){\n\t\t\tstr1+=str.charAt(i);\n\t\t}\n\t\tlong n=Long.parseLong(str1);\n\t\t//System.out.println(n);\n\t\tlong modi=n%4;\n\t\tlong divi=n/4;\n\t\tif(modi==0){\n\t\t\tmodi=2;\n\t\t\tdivi-=1;\n\t\t}\n\t\telse if(modi==3)\n\t\t\tmodi-=2;\n\t\tlong ans=16*divi+7*(modi-1);\n\t\tif(str.charAt(str.length()-1)=='a') ans+=4;\n\t\telse if(str.charAt(str.length()-1)=='b') ans+=5;\n\t\telse if(str.charAt(str.length()-1)=='c') ans+=6;\n\t\telse if(str.charAt(str.length()-1)=='d') ans+=3; \n\t\telse if(str.charAt(str.length()-1)=='e') ans+=2;\n\t\telse if(str.charAt(str.length()-1)=='f') ans++;\n\t\tSystem.out.println(ans);\n\t\tout.close();\n\t\t\n\t}\n\tstatic class InputReader {\n\t\t\n\t    public BufferedReader reader;\n\t    public StringTokenizer tokenizer;\n \n\t    public InputReader(InputStream inputstream) {\n\t      reader = new BufferedReader(new InputStreamReader(inputstream));\n\t      tokenizer = null;\n\t    }\n\t    \n\t    public String nextLine(){\n\t    \tString fullLine=null;\n\t    \twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t            try {\n\t              fullLine=reader.readLine();\n\t            } catch (IOException e) {\n\t              throw new RuntimeException(e);\n\t            }\n\t            return fullLine;\n\t          }\n\t          return fullLine;\n\t    }\n\t\tpublic String next() {\n\t      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t        try {\n\t          tokenizer = new StringTokenizer(reader.readLine());\n\t        } catch (IOException e) {\n\t          throw new RuntimeException(e);\n\t        }\n\t      }\n\t      return tokenizer.nextToken();\n\t    }\n\t\tpublic long nextLong() {\n\t\t      return Long.parseLong(next());\n\t\t    }\n\t    public int nextInt() {\n\t      return Integer.parseInt(next());\n\t    }\n\t  }\n\t\n\tpublic static HashMap<Integer,Long> getcatalan(int n){\n\t\tHashMap<Integer,Long> a=new HashMap<Integer,Long>();\n\t\ta.put(0,(long)1);\n\t\tfor(int i=1;i<=n+1;i++){\n\t\t\tlong m=2*(2*i-1);\n\t\t\tlong m1=m*a.get(i-1);\n\t\t\tlong m3=m1/(i+1);\n\t\t\t//out.println(m+\" \"+m1+\" \"+m2+\" \"+m3);\n\t\t\t\n\t\t\ta.put(i,m3%1000000007);\n\t\t}\n\t\treturn a;\n\t}\n\t\n\tpublic static int getGdc(int[] x) {\n\t    // get the smallest of all number no need to check for higher values\n\t    int smallest = getSmallest(x);\n\n\t    for(int i = smallest; i >= 1; i--) {\n\t       int j;\n\t       for(j = 0; j < x.length; ++j) {\n\t           if(x[j] % i != 0)\n\t               break;\n\t       }\n\t       // if we pass through the array with all % == 0 return the value\n\t       if(j == x.length)\n\t           return i;\n\t    }\n\t    // so the only possible is 1\n\t    return 1;\n\t}\n\n\t// return smallest number of an array of int\n\tpublic static int getSmallest(int[] x) {\n\t    int smallest = x[0];\n\t    for(int i = 1; i < x.length; ++i) {\n\t        if(x[i] < smallest)\n\t            smallest = x[i];\n\t    }\n\t    return smallest;\n\t}\n\tpublic static long gcd(long number1, long number2) {  \n\t\tif(number2 == 0){\n\t\t\treturn number1;\n\t\t} \n\t\treturn gcd(number2, number1%number2); \n\t}\n\t\n\tpublic static int combinations(int n,int r){\n\t\tif(n==r) return 1;\n\t\tif(r==1) return n;\n\t\tif(r==0) return 1;\n\t\treturn combinations(n-1,r)+ combinations(n-1,r-1);\n\t}\n\tpublic static long binomialCoeff(int n, int k)\n\t{\n\t    long C[][]= new long[n+1][k+1];\n\t    int i, j;\n\t \n\t    // Caculate value of Binomial Coefficient in bottom up manner\n\t    for (i = 0; i <= n; i++)\n\t    {\n\t        for (j = 0; j <= Math.min(i, k); j++)\n\t        {\n\t            // Base Cases\n\t            if (j == 0 || j == i)\n\t                C[i][j] = 1;\n\t \n\t            // Calculate value using previosly stored values\n\t            else\n\t                C[i][j] = C[i-1][j-1] + C[i-1][j];\n\t        }\n\t    }\n\t \n\t    return C[n][k];\n\t}\n\tpublic static long expo(long a, long b){\n\t    if (b==1)\n\t        return a;\n\t    if (b==2)\n\t        return a*a;\n\n\t    if (b%2==0){\n\t            return expo(expo(a,b/2),2);\n\t    }\n\t    else{\n\t        return a*(expo(expo(a,(b-1)/2),2));\n\t    }\n\t}\n\t\n\tpublic static int[] sieve(int N){\n\t\tint arr[]= new int[N+1];\n\t\tint b[]=new int[N+1];\n\t\tfor(int i=2;i<Math.sqrt(N);i++){\n\t\t\tif(arr[i]==0){\n\t\t\t\t\n\t\t\t\tfor(int j= i*i;j<= N;j= j+i){\n\t\t\t\t\tarr[j]=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn arr;\n\t\t// All the i for which arr[i]==0 are prime numbers.\n\t}\n\tstatic class Pair implements Comparable<Pair>\n    {\n        int f,s;\n        Pair(int ii, int cc)\n        {\n            f=ii;\n            s=cc;\n        }\n        \n        public int compareTo(Pair o) \n        {\n            return Integer.compare(this.f, o.f);\n        }\n        \n    }\n\tpublic static class company{\n\t\tpublic int t;\n\t\tpublic int d;\n\t\tpublic company(int m,int f){\n\t\t\tthis.t=m;\n\t\t\tthis.d=f;\n\t\t}\n\t\tpublic int get_t(){\n\t\t\treturn this.t;\n\t\t}\n\t\tpublic int get_d(){\n\t\t\treturn this.d;\n\t\t}\n\t}\n\tpublic static class pair_comparator implements Comparator<company>{\n\n\t\t@Override\n\t\tpublic int compare(company arg0, company arg1) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn arg0.t-arg1.t;\n\t\t}\n\t\t\n\t}\n\n}", "label": 0}
{"src": "import java.io.*;\n\npublic class Main {\n    public static String pos = \"fedabc\";\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String s = br.readLine();\n        long r = Long.parseLong(s.substring(0,s.length()-1));\n        r--;\n        char c = s.charAt(s.length()-1);\n        long ans = pos.indexOf(c);\n        ans += (r/4)*(12+4);\n        if (r%4 == 3 || r%4 == 1) ans += 7;\n        System.out.println(ans+1);\n    }\n}", "label": 0}
{"src": "\nimport java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\n/**\n *\n * @author umang\n */\n\npublic class B725{\n    \n    public static int mod = 1000000007;\n\n    public static void main(String[] args) {\n \n        InputReader in = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        \n        String s=in.readString();\n        int l=s.length();\n        BigInteger n = new  BigInteger(s.substring(0, l-1));\n        BigInteger count = new BigInteger(\"0\");\n        BigInteger zero = new BigInteger(\"0\");\n        BigInteger one = new BigInteger(\"1\");\n        BigInteger two = new BigInteger(\"2\");\n        BigInteger three = new BigInteger(\"3\");\n        BigInteger four = new BigInteger(\"4\");\n        BigInteger five = new BigInteger(\"5\");\n        BigInteger six = new BigInteger(\"6\");        \n        BigInteger seven = new BigInteger(\"7\");        \n        BigInteger stn = new BigInteger(\"16\");\n        int c=s.charAt(l-1);\n        if(n.mod(four).equals(zero)) count = n.subtract(one).divide(four);\n        else count=n.divide(four);\n        count=count.multiply(stn);\n\n        if(n.mod(two).equals(zero))count=count.add(seven);\n        if(c=='f')count=count.add(one);\n        else if(c=='e')count=count.add(two);\n        else if(c=='d')count=count.add(three);\n        else if(c=='a')count=count.add(four);\n        else if(c=='b')count=count.add(five);\n        else if(c=='c')count=count.add(six);\n        \n        w.println(count);\n        w.close();\n    }\n    \n    public static long gcd(long x,long y){\n\tif(x%y==0)\n\t\treturn y;\n\telse\n\t\treturn gcd(y,x%y);\n    }\n    \n    public static int gcd(int x,int y){\n\tif(x%y==0)\n\t\treturn y;\n\telse \n\t\treturn gcd(y,x%y);\n    }\n    \n    public static int abs(int a,int b){\n\treturn (int)Math.abs(a-b);\n    }\n\n    public static long abs(long a,long b){\n\treturn (long)Math.abs(a-b);\n    }\n    \n    public static int max(int a,int b){\n\tif(a>b)\n\t\treturn a;\n\telse\n\t\treturn b;\n    }\n\n    public static int min(int a,int b){\n\tif(a>b)\n\t\treturn b;\n\telse \n\t\treturn a;\n    }\n    \n    public static long max(long a,long b){\n\tif(a>b)\n\t\treturn a;\n\telse\n\t\treturn b;\n    }\n\n    public static long min(long a,long b){\n\tif(a>b)\n\t\treturn b;\n\telse \n\t\treturn a;\n    }\n\n    public static long pow(long n,long p,long m){\n\t long  result = 1;\n\t  if(p==0)\n\t    return 1;\n\tif (p==1)\n\t    return n;\n\twhile(p!=0)\n\t{\n\t    if(p%2==1)\n\t        result *= n;\n\t    if(result>=m)\n\t    result%=m;\n\t    p >>=1;\n\t    n*=n;\n\t    if(n>=m)\n\t    n%=m;\n\t}\n\treturn result;\n    }\n    \n    public static long pow(long n,long p){\n\tlong  result = 1;\n\t  if(p==0)\n\t    return 1;\n\tif (p==1)\n\t    return n;\n\twhile(p!=0)\n\t{\n\t    if(p%2==1)\n\t        result *= n;\t    \n\t    p >>=1;\n\t    n*=n;\t    \n\t}\n\treturn result;\n    }\n    \n    static class Pair{\n\t\tint x;\n\t\tint y;\n\t\tPair(int x,int y){\n\t\t\tthis.x=x;\n\t\t\tthis.y=y;\n\t\t}\n\t}\n    \n    public static class CompareTable implements Comparator{\n        public int compare(Object o1,Object o2){\n            Pair p1 = (Pair) o1;\n            Pair p2 = (Pair) o2;\n            \n            if(p1.x>p2.x)\n                return -1;\n            else if(p1.x<p2.x)\n                return 1;\n            else{\n                if(p1.y<p2.y)\n                    return -1;\n                else if(p1.y>p2.y)\n                    return 1;\n                else\n                    return 0;\n            }\n        }\n    }\n\tstatic class InputReader {\n\n\t\tprivate final InputStream stream;\n\t\tprivate final byte[] buf = new byte[8192];\n\t\tprivate int curChar, snumChars;\n\t\tprivate SpaceCharFilter filter;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t}\n\n\t\tpublic int snext() {\n\t\t\tif (snumChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= snumChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tsnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (snumChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint a[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\ta[i] = nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\n\t\tpublic String readString() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c)) {\n\t\t\t\tc = snext();\n\t\t\t}\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tint c = snext();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = snext();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = snext();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\tif (filter != null)\n\t\t\t\treturn filter.isSpaceChar(c);\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tprivate boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tpublic interface SpaceCharFilter {\n\t\t\tpublic boolean isSpaceChar(int ch);\n\t\t}\n\t}\n}    \n\n", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n/**\n * Created by Everest on 22.10.2016.\n */\npublic class B3 {\n\n    public static void main(String[] args) throws IOException {\n\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        String tmp = br.readLine();\n        char c = tmp.charAt(tmp.length()-1);\n\n        int c1 = 0;\n\n        if (c == 'a'){\n            c1 = 4;\n        }else if(c == 'b'){\n            c1 = 5;\n        }else if(c == 'c'){\n            c1 = 6;\n        }else if(c == 'd'){\n            c1 = 3;\n        }else if(c == 'e'){\n            c1 = 2;\n        }else if(c == 'f'){\n            c1 = 1;\n        }\n\n        long n = Long.parseLong(tmp.substring(0, tmp.length()-1));\n        long ans = 0;\n\n        if(n % 4 == 0){\n            ans = 12*(n/4 - 1) + 6 + n-3 + c1;\n        }else if( (n % 4 != 0) && (n % 2 == 0) ){\n            ans = 12*(n/4 + 1) - 6 + c1 + n-1;\n        }else{\n            ans = 12*(n/4) + c1 + (((n+1) % 4 == 0) ? (n-3) : (n-1));\n        }\n\n        System.out.println(ans);\n\n    }\n\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\n/**\n *\n * @author aboragab\n */\npublic class B_FoodOnThePlane {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String s = in.nextLine();\n        long n = Long.parseLong(s.substring(0, s.length()-1));\n        char c = s.charAt(s.length()-1);\n        long sec = 0;\n        long line = 0 , moves = 0;\n        if(n%4 == 0){\n            line = n/2;\n            moves = n-3;\n        }else if((n+1)%4 == 0){\n            line = ((n+1)/2)-1;\n            moves = n-3;\n        }else if((n+2)%4 == 0){\n            line = ((n+2)/2);\n            moves = n-1;\n        }else if((n+3)%4 == 0){\n            line = ((n+3)/2)-1;\n            moves = n-1;\n        }\n        sec += (--line) * 6;\n        sec += moves;\n        switch(c){\n                case 'f': sec+=1; break;\n                case 'e': sec+=2; break;\n                case 'd': sec+=3; break;\n                case 'a': sec+=4; break;\n                case 'b': sec+=5; break;\n                case 'c': sec+=6; break;\n        }\n        System.out.println(sec);\n    }\n}", "label": 0}
{"src": "\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.text.DecimalFormat;\n\npublic class B {\n\tstatic long tt(char c){\n\t\tif(c=='f') return 1;\n\t\tif(c=='e') return 2;\n\t\tif(c=='d') return 3;\n\t\tif(c=='a') return 4;\n\t\tif(c=='b') return 5;\n\t\treturn 6;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tString s = scan.next();\n\t\tint l = s.length();\n\t\tlong n = Long.parseLong(s.substring(0, l-1));\n\t\tchar c = s.charAt(l-1);\n\t\tlong ans = 0;\n\t\tif(n%4==1||n%4==3){\n\t\t\tlong k = n/4;\n\t\t\tans+=k*(long)16;\n\t\t\tans+=tt(c);\n\t\t}else{\n\t\t\tlong k = (n-1)/4;\n\t\t\tans+=k*(long)16+7;\n\t\t\tans+=tt(c);\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}", "label": 0}
{"src": "import java.util.Scanner;\n\n\npublic class Foodintheplane {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\n\t\tScanner input = new Scanner(System.in);\n\t\tString s = input.next();\n\t\t long n = Long.parseLong(s.substring(0,s.length()-1));\n\t\t n--;\n\t\t long total=0;\n\t\t long z = n%4;\n\t\t long k = n/4;\n\t\t total+=12*k + k*4;\n\t\t if(z%2!=0){\n\t\t\t total+=7;\n\t\t }\n\t\t if(s.charAt(s.length()-1) == 'f')total++;\n\t\t if(s.charAt(s.length()-1) == 'e')total+=2;\n\t\t if(s.charAt(s.length()-1)=='d')total+=3;\n\t\t if(s.charAt(s.length()-1) == 'a')total+=4;\n\t\t if(s.charAt(s.length()-1)=='b')total+=5;\n\t\t if(s.charAt(s.length()-1)=='c')total+=6;\n\t\t\t\t System.out.println(total);\n\t}\n\n}\n", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class B {\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tString in = sc.next();\n\t\t\n\t\tlong n = Long.parseLong(in.substring(0, in.length() - 1));\n\t\tchar s = in.charAt(in.length() - 1); \n\t\t\n\t\tlong res = 0;\n\t\t\n\t\tlong row;\n\n\t\tif(n % 4 == 1 || n % 4 == 2) {\n\t\t\trow = n / 2 + 1;\n\t\t}\n\t\telse {\n\t\t\trow = n / 2;\n\t\t}\n\t\t\n\t\tres = (row - 1) * 6;\n\t\tres += (row - 1)/ 2 * 4;\n\t\t\n\t\tif(row % 2 == 0)\n\t\t\tres++;\n\t\t\n\t\t\n\t\tif(s == 'f')\n\t\t\tres++;\n\t\telse if(s == 'e')\n\t\t\tres += 2;\n\t\telse if(s == 'd')\n\t\t\tres += 3;\n\t\telse if(s == 'a')\n\t\t\tres += 4;\n\t\telse if(s == 'b')\n\t\t\tres += 5;\n\t\telse if(s == 'c')\n\t\t\tres += 6;\n\t\t\n\t\tout.println(res);\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\t}\n\t\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile(st == null || !st.hasMoreTokens()) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t}\n\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws NumberFormatException, IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n}\n", "label": 0}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class foodonplane {\n  private static InputReader in;\n  private static PrintWriter out;\n  public static int[] time = {3,4,5,2,1,0};\n\n  public static void main(String[] args) throws IOException {\n    in = new InputReader(System.in);\n    out = new PrintWriter(System.out, true);\n\n    String s = in.next();\n    int off = s.charAt(s.length()-1) - 'a';\n    s = s.substring(0, s.length()-1);\n    long n = Long.parseLong(s);\n    n--;\n    long ans = (n/4) * 16L + time[off];\n    if (n % 4 == 1 || n % 4 == 3) {\n      ans += 6+1;\n    } \n    out.println(ans+1);\n    out.close();\n    System.exit(0);\n  }\n\n  static class InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n      reader = new BufferedReader(new InputStreamReader(stream), 32768);\n      tokenizer = null;\n    }\n\n    public String next() {\n      while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n        try {\n          tokenizer = new StringTokenizer(reader.readLine());\n        } catch (IOException e) {\n          throw new RuntimeException(e);\n        }\n      }\n      return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n      return Integer.parseInt(next());\n    }\n  }\n\n\n}\n", "label": 0}
{"src": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\npublic class Main {\n\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n\n        // Start writing your solution here. -------------------------------------\n        String s = sc.next();\n        String s2 = s.substring(0, s.length() - 1);\n        char c = s.charAt(s.length() - 1);\n        long l = Long.parseLong(s2) - 1;\n        final long pass = l / 4 * (2 * 6);\n        final long rows = l / 4 * 4;\n        long sum  = pass + rows;\n        long n = l % 4;\n        if ( n == 0) {\n        } else if (n == 1)  {\n            sum += 7;\n        } else if (n == 2)  {\n        } else if (n == 3)  {\n            sum += 7;\n        }\n        if (c =='a') {\n           sum += 4;\n        } else if (c == 'b') {\n            sum += 5;\n        } else if (c == 'c') {\n            sum += 6;\n        } else if (c == 'd') {\n            sum += 3;\n        } else if (c == 'e') {\n            sum += 2;\n        } else if (c == 'f') {\n            sum += 1;\n        }\n        out.println(sum);\n\n\n\n\n\n        /*\n        int n      = sc.nextInt();        // read input as integer\n        long k     = sc.nextLong();       // read input as long\n        double d   = sc.nextDouble();     // read input as double\n        String str = sc.next();           // read input as String\n        String s   = sc.nextLine();       // read whole line as String\n\n        int result = 3*n;\n        out.println(result);                    // print via PrintWriter\n        */\n\n        // Stop writing your solution here. -------------------------------------\n        out.close();\n    }\n\n\n\n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n    //--------------------------------------------------------\n}", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class CF_CanadaCup2016_B {\n\n    public static void main(String[] args) throws IOException {\n        br = new BufferedReader(new InputStreamReader(System.in));\n        st = new StringTokenizer(\"\");\n        sb = new StringBuilder();\n\n        String in = nxtTok();\n\n        long line = Long.parseLong(in.substring(0, in.length() - 1));\n        String seat = in.substring(in.length() - 1);\n        long time = 0;\n        time += ((line-1) / 4) * 16;\n        line %= 4;\n\n        if (line == 2)\n            time += 7;\n\n//        if (line == 3)\n//            time += 2;\n\n        if (line == 0)\n            time += 7;\n\n        if (seat.equalsIgnoreCase(\"f\"))\n            time += 1;\n        if (seat.equalsIgnoreCase(\"e\"))\n            time += 2;\n        if (seat.equalsIgnoreCase(\"d\"))\n            time += 3;\n        if (seat.equalsIgnoreCase(\"a\"))\n            time += 4;\n        if (seat.equalsIgnoreCase(\"b\"))\n            time += 5;\n        if (seat.equalsIgnoreCase(\"c\"))\n            time += 6;\n\n        System.out.println(time);\n    }\n\n    static BufferedReader br;\n    static StringTokenizer st;\n    static StringBuilder sb;\n    static FileReader fr;\n\n    static String nxtTok() throws IOException {\n        while (! st.hasMoreTokens()) {\n            String s = br.readLine();\n            if (s == null)\n                return null;\n            st = new StringTokenizer(s.trim());\n        }\n        return st.nextToken();\n    }\n\n    static int nxtInt() throws IOException {\n        return Integer.parseInt(nxtTok());\n    }\n\n    static long nxtLng() throws IOException {\n        return Long.parseLong(nxtTok());\n    }\n\n    static double nxtDbl() throws IOException {\n        return Double.parseDouble(nxtTok());\n    }\n\n    static int[] nxtIntArr(int n) throws IOException {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nxtInt();\n        return a;\n    }\n\n    static long[] nxtLngArr(int n) throws IOException {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++)\n            a[i] = nxtLng();\n        return a;\n    }\n\n    static char[] nxtCharArr() throws IOException {\n        return nxtTok().toCharArray();\n    }\n}", "label": 0}
{"src": "import java.io.*;\nimport java.util.StringTokenizer;\n\npublic class B {\n\n    FastScanner scanner;\n    PrintWriter writer;\n\n    private static final String ORDER = \"fedabc\";\n\n    void solve() throws IOException {\n        scanner = new FastScanner(System.in);\n        writer = new PrintWriter(System.out);\n        String line = scanner.nextLine().trim();\n        long n = Long.parseLong(line.substring(0, line.length() - 1)) - 1;\n        char s = line.charAt(line.length() - 1);\n        long time = (n / 4) * 16;\n        n = n % 4;\n        if (n == 1 || n == 3) {\n            time += 7;\n        }\n        time += ORDER.indexOf(s) + 1;\n        writer.println(time);\n        writer.close();\n    }\n\n    public static void main(String... args) throws IOException {\n        new B().solve();\n    }\n\n    static class FastScanner {\n\n        BufferedReader br;\n        StringTokenizer tokenizer;\n\n        FastScanner(String fileName) throws FileNotFoundException {\n            this(new FileInputStream(new File(fileName)));\n        }\n\n        FastScanner(InputStream is) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n\n        String nextLine() throws IOException {\n            tokenizer = null;\n            return br.readLine();\n        }\n\n        String next() throws IOException {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                String line = br.readLine();\n                if (line == null) {\n                    return null;\n                }\n                tokenizer = new StringTokenizer(line);\n            }\n            return tokenizer.nextToken();\n        }\n    }\n}\n", "label": 0}
{"src": "import static java.lang.Double.parseDouble;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Long.parseLong;\nimport static java.lang.System.exit;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class B {\n\n\tstatic BufferedReader in;\n\tstatic PrintWriter out;\n\tstatic StringTokenizer tok;\n\n\tstatic void solve() throws Exception {\n\t\tString s = next();\n\t\tlong n = parseLong(s.substring(0, s.length() - 1)) - 1;\n\t\tint x = \"fedabc\".indexOf(s.charAt(s.length() - 1));\n\t\tlong ans = 16 * (n / 4);\n\t\tif (n % 2 != 0) {\n\t\t\tans += 7;\n\t\t}\n\t\tans += x + 1;\n\t\tout.print(ans);\n\t}\n\n\tstatic int nextInt() throws IOException {\n\t\treturn parseInt(next());\n\t}\n\n\tstatic long nextLong() throws IOException {\n\t\treturn parseLong(next());\n\t}\n\n\tstatic double nextDouble() throws IOException {\n\t\treturn parseDouble(next());\n\t}\n\n\tstatic String next() throws IOException {\n\t\twhile (tok == null || !tok.hasMoreTokens()) {\n\t\t\ttok = new StringTokenizer(in.readLine());\n\t\t}\n\t\treturn tok.nextToken();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintWriter(new OutputStreamWriter(System.out));\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\te.printStackTrace();\n\t\t\texit(1);\n\t\t}\n\t}\n}", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\npublic class B {\n\tstatic class N {\n\t\tint from, to;\n\n\t\tN(int f, int t) {\n\t\t\tfrom = f;\n\t\t\tto = t;\n\t\t}\n\n\t\tpublic String toString() {\n\t\t\treturn from + \" \" + to;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n\t\tchar[] x = bf.readLine().toCharArray();\n\t\tStringBuffer sb = new StringBuffer();\n\t\tfor (int i = 0; i < x.length - 1; i++) {\n\t\t\tsb.append(x[i]);\n\t\t}\n\t\tlong n = Long.parseLong(sb.toString());\n\t\tint s = x[x.length - 1] - 'a';\n\t\tlong ans = (n - 1) / 4;\n\t\tans *= 16L;\n\t\tif (s >= 0 && s <= 2) {\n\t\t\tans += s;\n\t\t\tans += 4;\n\t\t} else {\n\t\t\tans += 6 - s;\n\t\t}\n\t\tif (((n - 1) % 4) % 2 == 1) {\n\t\t\tans += 7;\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t}\n\n}", "label": 0}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Hieu Le\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        private final char[] seats = {'f', 'e', 'd', 'a', 'b', 'c'};\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            String line = in.next();\n            long row = Long.parseLong(line.substring(0, line.length() - 1));\n            char seat = line.charAt(line.length() - 1);\n\n            long rank = -1;\n            long advances = -1;\n            long k = row / 4;\n            if (row % 4 == 0) {\n                rank = 2 * k;\n                advances = row - 3;\n            } else if (row % 4 == 1) {\n                rank = 2 * k + 1;\n                advances = row - 1;\n            } else if (row % 4 == 2) {\n                rank = 2 * k + 2;\n                advances = row - 1;\n            } else if (row % 4 == 3) {\n                rank = 2 * k + 1;\n                advances = row - 3;\n            }\n\n            long res = (rank - 1) * seats.length + (indexOf(seats, seat) + 1) + advances;\n            out.println(res);\n        }\n\n        private static int indexOf(char[] values, char target) {\n            for (int i = 0; i < values.length; ++i) {\n                if (target == values[i])\n                    return i;\n            }\n            return -1;\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n        private static final int BUFFER_SIZE = 32768;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), BUFFER_SIZE);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n    }\n}\n\n", "label": 0}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Arthur Gazizov - Kazan FU #4.3 [2oo7]\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            String data = in.next();\n            char position = data.charAt(data.length() - 1);\n            long n = Long.parseLong(data.substring(0, data.length() - 1));\n            long m = n / 4L;\n            long r = n % 4L;\n            if (r == 0) {\n                m -= 1L;\n                r += 4L;\n            }\n            long ans = m * 16L;\n            String s = \"fedabc\";\n            for (int i = 0; i < s.length(); i++) {\n                ans++;\n                if (s.charAt(i) == position) {\n                    break;\n                }\n            }\n            if (r % 2 == 0) {\n                ans += 7;\n            }\n            out.print(ans);\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void print(long i) {\n            writer.print(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (Character.isValidCodePoint(c)) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        try (Scanner in = new Scanner(System.in)) {\n            String input = in.next();\n            char c = input.charAt(input.length() - 1);\n            long rowIndex = Long.valueOf(input.substring(0, input.length() - 1)) - 1;\n\n            if (rowIndex % 4 != 0 && (rowIndex - 1) % 4 != 0) {\n                rowIndex -= 2;\n            }\n            long seconds = ((rowIndex / 4) * 4 + (rowIndex % 4)) + ((rowIndex / 4) * 2 + (rowIndex % 4)) * 6;\n            long customersBefore = 0;\n            switch (c) {\n                case 'a':\n                    customersBefore = 3;\n                    break;\n                case 'b':\n                    customersBefore = 4;\n                    break;\n                case 'c':\n                    customersBefore = 5;\n                    break;\n                case 'd':\n                    customersBefore = 2;\n                    break;\n                case 'e':\n                    customersBefore = 1;\n                    break;\n                case 'f':\n                    customersBefore = 0;\n                    break;\n            }\n            System.out.println(seconds + (customersBefore + 1));\n        }\n    }\n}\n", "label": 0}
{"src": "import java.io.*;\nimport java.util.*;\npublic class TestClass {\n\t\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\t\n\tpublic static void main(String[] args) throws Exception{\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tString s = in.readLine();\n\t\tlong x = Long.parseLong(s.substring(0,s.length()-1));\n\t\tint y = s.charAt(s.length()-1)-'a';\n\t\t//System.out.println(x%4+\" \"+y);\n\t\tlong z[][] = {{11,12,13,10,9,8},{4,5,6,3,2,1},{11,12,13,10,9,8},{4,5,6,3,2,1}};\n\t\tlong k =x%4;\n\t\tint k1 = (int)k;\n\t\t//System.out.println(k1+\" \"+y);\n\t\tlong ans = z[k1][y];\n\t\tans += ((x-1)/4)*16;\n\t\tout.println(ans);\n\t\tout.close();\n\t}\n\n}\n\n    \n    \n    \n    \n    \n    \n    \n    \n\n", "label": 0}
{"src": "//package codeforces;\n\nimport java.util.Scanner;\n\n/**\n * Created by nitin.s on 22/10/16.\n */\npublic class FoodOnThePlane {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        String s = in.nextLine();\n        char seat = s.charAt(s.length() - 1);\n        Long seatNo = Long.valueOf(s.substring(0, s.length() - 1));\n        Long blocks = (seatNo - 1) / 4;\n        Long rows = 4 * blocks;\n        Long answer = (((rows / 2) * 6) + blocks) + 3 * blocks;\n        answer += calc(seat);\n        if(seatNo % 4 == 2 || seatNo % 4 == 0) {\n            answer += 7;\n        }\n\n        System.out.println(answer);\n    }\n\n    private static Long calc(char seat) {\n        long tmp = 0;\n        if(seat == 'f') tmp += 1;\n        else if(seat == 'e') tmp += 2;\n        else if(seat == 'd') tmp += 3;\n        else if(seat == 'a') tmp += 4;\n        else if(seat == 'b') tmp += 5;\n        else tmp += 6;\n        return tmp;\n    }\n}\n", "label": 0}
{"src": "/* package whatever; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Ideone\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tScanner in = new Scanner(System.in);\n\t\tString s = in.nextLine();\n\t\tint[] idx = {4,5,6,3,2,1};\n\t\tlong l = Long.parseLong(s.substring(0, s.length() - 1));\n\t\tint x = s.charAt(s.length() - 1) - 'a';\n\t\tif(l % 4 == 1 || l % 4 == 2) {\n\t\t\tlong ans = ((l - l%4)/4) * 12 + (l - 1) + idx[x];\n\t\t\tif(l % 4 == 2)\n\t\t\t\tans += 6;\n\t\t\tSystem.out.print(ans);\n\t\t} else {\n\t\t\tlong ans = ((l - 1)/4)  * 12 + (l-3) + idx[x];\n\t\t\tif(l % 4 == 0)\n\t\t\t\tans += 6;\n\t\t\tSystem.out.print(ans);\n\t\t}\n\t\t\n\t}\n}", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Hashtable;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tlong result = 0;\n\t\t\n\t\tString s = sc.nextLine();\n\t\tchar c = s.charAt(s.length()-1);\n\t\tString sNumber = s.substring(0, s.length()-1);\n\t\t\n\t\tlong n = Long.parseLong(sNumber) - 1;\n\t\t\n\t\tlong group4 = n / 4;\n\t\t\n\t\tif(group4 != 0)\n\t\t\tresult += group4 * 16;\n\t\telse result += group4 * 14;\n\t\t\n\t\tlong remainder = n % 4;\n\t\tif(remainder == 1 || remainder == 3)\n\t\t\tresult += 7;\n\n\t\t\n\t\tif(c >= 'd')\n\t\t\tresult += Math.abs(c - 'f') + 1;\n\t\telse result += Math.abs(c - 'a') + 4;\n\t\t\n\t\tout.println(result);\n\t\t\n\t\tout.flush();\n\t\tout.close();\n\t}\n\t\n\tclass Pair{\n\t\tint y;\n\t\tint position;\n\t\t\n\t\tpublic Pair(int y, int position){\n\t\t\tthis.y = y;\n\t\t\tthis.position = position;\n\t\t}\n\t}\n\t\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\n\t\tpublic Scanner(InputStream s){\tbr = new BufferedReader(new InputStreamReader(s));}\n\n\t\tpublic Scanner(FileReader r){\tbr = new BufferedReader(r);}\n\n\t\tpublic String next() throws IOException \n\t\t{\n\t\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() throws IOException {return Integer.parseInt(next());}\n\n\t\tpublic long nextLong() throws IOException {return Long.parseLong(next());}\n\n\t\tpublic String nextLine() throws IOException {return br.readLine();}\n\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(next()); }\n\n\t\tpublic boolean ready() throws IOException {return br.ready();}\n\n\t}\n\t\n}\n", "label": 0}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        InputStream inputStream = System.in;\n//        InputStream inputStream = new FileInputStream(\"sum.in\");\n        OutputStream outputStream = System.out;\n//        OutputStream outputStream = new FileOutputStream(\"sum.out\");\n\n\n//        Path path = Paths.get(URI.create(\"file:///foo/bar/Main.java\"));\n//        System.out.print(path.getName(200));\n\n//        Path p = Paths.get(\"/foo/bar/Main.java\");\n//        for (Path e : p) {\n//            System.out.println(e);\n//        }\n\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Answer solver = new Answer();\n        solver.solve(in, out);\n        out.close();\n    }\n}\n\nclass Answer {\n    private final int INF = (int) (1e9 + 7);\n\n    public void solve(InputReader in, PrintWriter out) throws IOException {\n        String s = in.next();\n        long n = Long.parseLong(s.substring(0, s.length() - 1));\n        char c = s.charAt(s.length() - 1);\n\n        Map<Character, Integer> count = new HashMap<>();\n        count.put('f', 1);\n        count.put('e', 2);\n        count.put('d', 3);\n        count.put('a', 4);\n        count.put('b', 5);\n        count.put('c', 6);\n\n        long t = n % 4;\n        long x = 16 * (n / 4);\n\n//        out.println(\"t: \" + t + \", x: \" + x);\n        long ans = x - (6 - count.get(c));\n        if (t == 2) {\n            ans += 13;\n        } else if (t == 1 || t == 3) {\n            ans += 6;\n        } else {\n            ans -= 3;\n        }\n        out.print(ans);\n    }\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n\n    InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class Solution {\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tString x = in.next();\n\t\tlong count = 0;\n\t\tlong row = Long.parseLong(x.substring(0, x.length()-1));\n\t\tswitch(x.charAt(x.length()-1)){\n\t\tcase 'a': count+=4;break;\n\t\tcase 'b': count+=5;break;\n\t\tcase 'c': count+=6;break;\n\t\tcase 'd': count+=3;break;\n\t\tcase 'e': count+=2;break;\n\t\tcase 'f': count+=1;break;\n\t\t}\n\t\tif(row%4==1 ||row%4 == 2){\n\t\t\tcount+=row-1;\n\t\t\tcount += (row/2) * 6;\n\t\t} else {\n\t\t\tcount+=row-3;\n\t\t\tcount += ((row-2)/2) * 6;\n\t\t}\n\t\tSystem.out.println(count);\n\t\tin.close();\n\t}\n\t\n}\n", "label": 0}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\npublic class A\n{\n    String line;\n    StringTokenizer inputParser;\n    BufferedReader is;\n    FileInputStream fstream;\n    DataInputStream in;\n    String FInput=\"\";\n    \n    void openInput(String file)\n    {\n        if(file==null)is = new BufferedReader(new InputStreamReader(System.in));//stdin\n        else\n        {\n                try{\n        \n                        \n                fstream = new FileInputStream(file);\n                in = new DataInputStream(fstream);\n                is = new BufferedReader(new InputStreamReader(in));\n                }catch(Exception e)\n                {\n                        System.err.println(e);\n                }\n        }\n    }\n    \n    void readNextLine()\n\t{\n\t\ttry {\n\t\t\tline = is.readLine();\n\t\t\tinputParser = new StringTokenizer(line, \" ,\\t\");\n\t\t\t//System.err.println(\"Input: \" + line);\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(\"Unexpected IO ERROR: \" + e);\n\t\t}\t\n\t\tcatch (NullPointerException e)\n\t\t{\n\t\t\tline=null;\n\t\t\t\n\t\t}\n\t\t\n\t}\n    \n    long NextLong()\n    {\n            String n = inputParser.nextToken();\n            \n            long val = Long.parseLong(n);\n            \n             return val;\n    }\n    \n    int NextInt()\n    {\n            String n = inputParser.nextToken();\n            int val = Integer.parseInt(n);\n            \n            //System.out.println(\"I read this number: \" + val);\n            return val;\n    }\n    \n    double NextDouble()\n    {\n            String n = inputParser.nextToken();\n            double val = Double.parseDouble(n);\n            \n            //System.out.println(\"I read this number: \" + val);\n            return val;\n    }\n    \n    String NextString()\n    {\n            String n = inputParser.nextToken();\n            return n;\n    }\n    \n    void closeInput()\n    {\n            try {\n                    is.close();\n            } catch (IOException e) {\n                    System.err.println(\"Unexpected IO ERROR: \" + e);\n            }\n                    \n    }\n    \n    \n    public static void main(String [] argv)\n    {\n            //String filePath=\"circles.in\";\n            String filePath=null;\n            if(argv.length>0)filePath=argv[0];\n            new A(filePath);\n            \n    }\n    \n    public A(String inputFile)\n    {\n    \topenInput(inputFile);\n\t\t//readNextLine();\n\t\tint T=1;//NextInt();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor(int t=1; t<=T; t++)\n\t\t{\n\t\t\treadNextLine();\n\t\t\tchar c = line.charAt(line.length()-1);\n\t\t\tline = line.substring(0, line.length()-1);\n\t\t\tlong N=Long.parseLong(line);\n\t\t\t\n\t\t\tif((N-1)%4>1)N-=2;\n\t\t\tlong ret = (N-1)/4*12+1;\n\t\t\tif(N%2==0)ret+=6;\n\t\t\tString seats=\"fedabc\";\n\t\t\tret+=seats.indexOf(c);\n\t\t\tret+=N-1;\n\t\t\t\n\t\t\tsb.append(ret);\n\t\t}\n\t\tSystem.out.print(sb);\n\t\t\n\t\tcloseInput();\t\t\n\t}\n\n}", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class B {\n\tprivate void work() {\n\t\tString s = \"fedabc\";\n\t\tScanner sc = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n\t\tString a = sc.next();\n\t\tsc.close();\n\n\t\tlong r = Long.parseLong(a.substring(0, a.length() - 1));\n\t\tint k = s.indexOf(a.charAt(a.length() - 1));\n\n\t\tint rr = (int) (r & 3);\n\t\tlong res = 16 * (r >> 2) + k + 1;\n\t\tif (rr == 0) {\n\t\t\trr = 4;\n\t\t\tres -= 16;\n\t\t}\n\n\t\tif ((rr & 1) == 0) {\n\t\t\tres += 7;\n\t\t}\n\n\t\tSystem.out.println(res);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew B().work();\n\t}\n\n}\n", "label": 0}
{"src": "\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Checker\n{\n\tstatic int imax=Integer.MAX_VALUE,imin=Integer.MIN_VALUE;\n\tstatic long lmax=Long.MAX_VALUE,lmin=Long.MIN_VALUE;\n\tstatic long mod=(long)1e9+7;\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tInputReader in =new InputReader(System.in);\n\t\tPrintWriter out=new PrintWriter(System.out);\n//\t\tint test=in.nextInt();\n \t\tint test=1;\n \t\tint i=0,j=0;\t\n\t\twhile(test-->0){\n\t\t\tString str=in.ns();\n\t\t\tlong n=Long.parseLong(str.substring(0,str.length()-1));\n\t\t\tchar c=str.charAt(str.length()-1);\n\t\t\tlong tmp=n/4;\n\t\t\tif(n%4==0){\n\t\t\t\ttmp--;\n\t\t\t}\n\t\t\tlong m=n%4;\n\t\t\tlong ans=0;\n\t\t\tif(m==0||m==2){\n\t\t\t\tswitch(c){\n\t\t\t\tcase 'a':\n\t\t\t\t\tans=4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tans=5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\tans=6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tans=3;\n\t\t\t\t\tbreak;\t\t\n\t\t\t\tcase 'e':\n\t\t\t\t\tans=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tans=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tans+=7;\n\t\t\t}else{\n\t\t\t\tswitch(c){\n\t\t\t\tcase 'a':\n\t\t\t\t\tans=4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'b':\n\t\t\t\t\tans=5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'c':\n\t\t\t\t\tans=6;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'd':\n\t\t\t\t\tans=3;\n\t\t\t\t\tbreak;\t\t\n\t\t\t\tcase 'e':\n\t\t\t\t\tans=2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'f':\n\t\t\t\t\tans=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tout.println(tmp*16+ans);\n\t\t}\n\tout.close();\n\t}\n\t\n\tstatic class Pair{\n\t\t\n\t}\n\tstatic void print(int arr[],int len){\n\t\tfor(int i=0;i<len;i++)\n\t\tSystem.out.print(arr[i]+\" \");\n\t\tSystem.out.println();\n\t}\n\t\n\tstatic class InputReader\n\t{\n\t \n\t    private InputStream stream;\n\t    private byte[] buf = new byte[1024];\n\t    private int curChar;\n\t    private int numChars;\n\t \n\t    public InputReader(InputStream stream) {\n\t        this.stream = stream;\n\t    }\n\t \n\t    public int read() {\n\t        if (numChars == -1)\n\t            throw new InputMismatchException();\n\t        if (curChar >= numChars) {\n\t            curChar = 0;\n\t            try {\n\t                numChars = stream.read(buf);\n\t            } catch (IOException e) {\n\t                throw new InputMismatchException();\n\t            }\n\t            if (numChars <= 0)\n\t                return -1;\n\t        }\n\t        return buf[curChar++];\n\t    }\n\t \n\t    public int ni() {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t            c = read();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = read();\n\t        }\n\t        int res = 0;\n\t        do {\n\t            if (c < '0' || c > '9')\n\t                throw new InputMismatchException();\n\t            res *= 10;\n\t            res += c & 15;\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\t \n\t    public long nl() {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t            c = read();\n\t        int sgn = 1;\n\t        if (c == '-') {\n\t            sgn = -1;\n\t            c = read();\n\t        }\n\t        long res = 0;\n\t        do {\n\t            if (c < '0' || c > '9')\n\t                throw new InputMismatchException();\n\t            res *= 10;\n\t            res += c & 15;\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res * sgn;\n\t    }\n\t \n\t    public String ns() {\n\t        int c = read();\n\t        while (isSpaceChar(c))\n\t            c = read();\n\t        StringBuilder res = new StringBuilder();\n\t        do {\n\t            res.appendCodePoint(c);\n\t            c = read();\n\t        } while (!isSpaceChar(c));\n\t        return res.toString();\n\t    }\n\t \n\t    public String nLine() {\n\t        int c = read();\n\t        //while (c != '\\n' && c != '\\r' && c != '\\t' && c != -1)\n\t        //c = read();\n\t        StringBuilder res = new StringBuilder();\n\t        do {\n\t            res.appendCodePoint(c);\n\t            c = read();\n\t        } while (c != '\\n' && c != '\\r' && c != '\\t' && c != -1);\n\t        return res.toString();\n\t    }\n\t \n\t    public static boolean isSpaceChar(int c) {\n\t        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t    }\n\t \n\t}   \n\n}\n", "label": 0}
{"src": "import java.util.*;\n\n\npublic class main {\n    public static int getValue(char c)\n    {\n        if (c == 'f')\n            return 1;\n        else if (c == 'e')\n            return 2;\n        else if (c == 'd')\n            return 3;\n        else if (c == 'a')\n            return 4;\n        else if (c == 'b')\n            return 5;\n        else\n            return 6;\n    }\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        String str = input.nextLine();\n\n        char c = str.charAt(str.length() - 1);\n        long n = Long.parseLong(str.substring(0, str.length() - 1));\n\n        long res;\n\n        if (n % 4 == 1)\n        {\n            res = (n - 1)/4;\n            System.out.println(res * 16 + getValue(c));\n        }\n        else if (n % 4 == 2)\n        {\n            res = (n - 2)/4;\n            System.out.println(res * 16 + 7 + getValue(c));\n        }\n        else if (n % 4 == 3)\n        {\n            res = (n - 3)/4;\n            System.out.println(res * 16 + getValue(c));\n         }\n        else\n        {\n            res = (n - 4)/4;\n            System.out.println(res * 16 + 7 + getValue(c));\n        }\n    }\n}\n\n", "label": 0}
{"src": "import java.io.*;\nimport java.util.*;\n\n\npublic class Solution {\n    private BufferedReader in;\n    private StringTokenizer line;\n    private PrintWriter out;\n    private boolean isDebug;\n\n    public Solution(boolean isDebug) {\n        this.isDebug = isDebug;\n    }\n\n    private static final long mm = 1000000007;\n\n    private long mult(long a, long b) {\n        return a * b % mm;\n    }\n\n    private long pow(long a, long n) {\n        if (n == 0) {\n            return 1;\n        }\n        long t = pow(a, n / 2);\n        t = mult(t, t);\n        if (n % 2 != 0) {\n            t = mult(t, a);\n        }\n        return t;\n    }\n\n    private void solve() throws IOException {\n        String s = nextToken();\n        char ch = s.charAt(s.length() - 1);\n        s = s.substring(0, s.length() - 1);\n        long num = new Long(s) - 1;\n        long res = num / 4 * 16;\n        num %= 4;\n        if (num % 2 != 0) {\n            res += 7;\n        }\n        switch (ch) {\n            case 'f':\n                res += 1;\n                break;\n            case 'e':\n                res += 2;\n                break;\n            case 'd':\n                res += 3;\n                break;\n            case 'a':\n                res += 4;\n                break;\n            case 'b':\n                res += 5;\n                break;\n            case 'c':\n                res += 6;\n                break;\n        }\n        out.println(res);\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Solution(args.length > 0 && \"DEBUG_MODE\".equals(args[0])).run(args);\n    }\n\n    public void run(String[] args) throws IOException {\n        if (isDebug) {\n            in = new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));\n        } else {\n            in = new BufferedReader(new InputStreamReader(System.in));\n        }\n        out = new PrintWriter(System.out);\n//        out = new PrintWriter(\"output.txt\");\n\n//        long start_time = System.nanoTime();\n\n//        int t = nextInt();\n        int t = 1;\n//        int t = isDebug ? nextInt() : 1;\n        for (int i = 0; i < t; i++) {\n//            out.print(\"Case #\" + (i + 1) + \": \");\n            solve();\n        }\n//\n//        long end_time = System.nanoTime();\n//        if (isDebug) {\n//            out.println(String.format(\"<<<<< %.6f >>>>>\", (end_time - start_time) / 1e9));\n//        }\n\n        in.close();\n        out.flush();\n        out.close();\n    }\n\n    private int[] nextIntArray(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nextInt();\n        }\n        return res;\n    }\n\n    private long[] nextLongArray(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nextLong();\n        }\n        return res;\n    }\n\n    private int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    private long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    private double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    private String nextToken() throws IOException {\n        while (line == null || !line.hasMoreTokens()) {\n            line = new StringTokenizer(in.readLine());\n        }\n        return line.nextToken();\n    }\n\n    private static class Pll {\n        private long key;\n        private long value;\n\n        public Pll(long key, long value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Pll pll = (Pll) o;\n\n            if (key != pll.key) return false;\n            return value == pll.value;\n\n        }\n\n        @Override\n        public int hashCode() {\n            int result = (int) (key ^ (key >>> 32));\n            result = 31 * result + (int) (value ^ (value >>> 32));\n            return result;\n        }\n    }\n\n    private static class Pii {\n        private int key;\n        private int value;\n\n        public Pii(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Pii pii = (Pii) o;\n\n            if (key != pii.key) return false;\n            return value == pii.value;\n\n        }\n\n        @Override\n        public int hashCode() {\n            int result = key;\n            result = 31 * result + value;\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"Pii{\" +\n                    \"key=\" + key +\n                    \", value=\" + value +\n                    '}';\n        }\n    }\n\n    private static class Pair<K, V> {\n        private K key;\n        private V value;\n\n        public Pair(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        public K getKey() {\n            return key;\n        }\n\n        public V getValue() {\n            return value;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n\n            Pair<?, ?> pair = (Pair<?, ?>) o;\n\n            if (key != null ? !key.equals(pair.key) : pair.key != null) return false;\n            return !(value != null ? !value.equals(pair.value) : pair.value != null);\n\n        }\n\n        @Override\n        public int hashCode() {\n            int result = key != null ? key.hashCode() : 0;\n            result = 31 * result + (value != null ? value.hashCode() : 0);\n            return result;\n        }\n\n        @Override\n        public String toString() {\n            return \"Pair{\" +\n                    \"key=\" + key +\n                    \", value=\" + value +\n                    '}';\n        }\n    }\n}", "label": 0}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n    MyScanner in;\n    PrintWriter out;\n\n    public static void main(String[] args) throws Exception {\n        new B().run();\n    }\n\n    public void run() throws Exception {\n        in = new MyScanner();\n        out = new PrintWriter(System.out);\n\n        solve();\n\n        out.close();\n    }\n\n    public void solve() throws Exception {\n        String seat = in.next();\n        char c = seat.charAt(seat.length() - 1);\n        long r = Long.valueOf(seat.substring(0, seat.length() - 1));\n\n        long ans = 16 * ((r - 1) / 4);\n        long p = r % 4;\n        ans += (p == 0 || p == 2) ? 7 : 0;\n        ans += \"fedabc\".indexOf(c) + 1;\n\n        out.println(ans);\n    }\n\n    class MyScanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() throws Exception {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() throws Exception {\n            while ((st == null) || (!st.hasMoreTokens())) {\n                String t = br.readLine();\n                if (t == null) {\n                    return null;\n                }\n                st = new StringTokenizer(t);\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() throws Exception {\n            return Integer.parseInt(next());\n        }\n\n        double nextDouble() throws Exception {\n            return Double.parseDouble(next());\n        }\n\n        boolean nextBoolean() throws Exception {\n            return Boolean.parseBoolean(next());\n        }\n\n        long nextLong() throws Exception {\n            return Long.parseLong(next());\n        }\n    }\n}\n", "label": 0}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Van Hanh Pham <skyvn97> <vanhanh.pham@gmail.com>\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskB {\n        private static final String ORDER = \"fedabc\";\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            String input = in.nextString();\n            long row = Long.parseLong(input.substring(0, input.length() - 1)) - 1;\n            int col = findOrder(input.charAt(input.length() - 1));\n            long numTurn = 2 * (row / 4);\n            if (row % 2 != 0) numTurn++;\n            long res = 6 * numTurn + col + 1;\n            if (row % 4 >= 2) res += row - 2;\n            else res += row;\n            out.println(res);\n        }\n\n        private static int findOrder(char c) {\n            for (int i = 0; i < 6; i++)\n                if (ORDER.charAt(i) == c) return i;\n            throw new RuntimeException();\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String nextString() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n    }\n}\n\n", "label": 0}
{"src": "/**\n * Created by stem on 01.05.2016.\n */\n\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String args[]) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        char[] a = sc.nextLine().toCharArray();\n        long n = 0;\n        for (int i = 0; i < a.length - 1; i++) {\n            n = 10 * n + ((int) a[i]) - ((int) '0');\n        }\n        long res = (n - 1) / 4 * 16 + ((n - 1) % 2) * 7;\n        switch (a[a.length - 1]) {\n            case 'a':\n                res += 4;\n                break;\n            case 'b':\n                res += 5;\n                break;\n            case 'c':\n                res += 6;\n                break;\n            case 'd':\n                res += 3;\n                break;\n            case 'e':\n                res += 2;\n                break;\n            case 'f':\n                res += 1;\n                break;\n        }\n        System.out.print(res);\n    }\n}\n", "label": 0}
{"src": "import java.io.*;\nimport java.util.*;\npublic class B {\n\tpublic static void main(String[]args)throws Throwable{\n\t\tPrintWriter pw=new PrintWriter(System.out);\n\t\tMyScanner sc=new MyScanner();\n\t\t\n\t\t\n\t\tint [] v={4,5,6,3,2,1};\n\t\tString s=sc.next();\n\t\tlong x=Long.parseLong(s.substring(0, s.length()-1));\n\t\tchar c=s.charAt(s.length()-1);\n\t\t\n\t\tlong time=0;\n\t\t\n\t\tlong pre=(x-1)/4;\n\t\t\n\t\tif(x%4==3 || x%4==0)\n\t\t\tx-=2;\n\t\t\n\t\ttime+=pre>0? (pre)*12 : 0;\n\t\t\n\t\tif(x%4==2)\n\t\t\ttime+=6;\n\t\t\n\t\ttime+=v[c-'a'];\n\t\t\n\t\ttime+=(x-1);\n\t\t\n\t\tpw.println(time);\n\t\t\n\t\tpw.flush();\n\t\tpw.close();\n\t}\n\t\n\tstatic class MyScanner {\n\t      BufferedReader br;\n\t      StringTokenizer st;\n\t \n\t      public MyScanner() {\n\t         br = new BufferedReader(new InputStreamReader(System.in));\n\t      }\n\t \n\t      String next() {\n\t          while (st == null || !st.hasMoreElements()) {\n\t              try {\n\t                  st = new StringTokenizer(br.readLine());\n\t              } catch (IOException e) {\n\t                  e.printStackTrace();\n\t              }\n\t          }\n\t          return st.nextToken();\n\t      }\n\t \n\t      int nextInt() {\n\t          return Integer.parseInt(next());\n\t      }\n\t \n\t      long nextLong() {\n\t          return Long.parseLong(next());\n\t      }\n\t \n\t      double nextDouble() {\n\t          return Double.parseDouble(next());\n\t      }\n\t \n\t      String nextLine(){\n\t          String str = \"\";\n\t\t  try {\n\t\t     str = br.readLine();\n\t\t  } catch (IOException e) {\n\t\t     e.printStackTrace();\n\t\t  }\n\t\t  return str;\n\t      }\n\n\t   }\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\n\npublic class Pro_725 {\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner in = new Scanner(System.in);\n\t\tchar[] number = in.next().toCharArray();\n\t\tlong num = 0,mul=1,x=0;\n\t\tfor (int i = number.length - 2; i >= 0; i--) {\n\t\t\tx = number[i] - 48;\n\t\t\tnum += mul * x;\n\t\t\tmul *= 10;\n\t\t}\n\t\tnum -=1;\n\t\tlong rowCostSec = (num/4) * 16 + (num%2) * 7; \n\t\t//////////\n\t\tint position = number[number.length - 1] - 'a' + 1;\n\t\tposition *= -1;\n\t\tposition += 7;\n\t\tif(position == 4)\n\t\t\tposition = 6;\n\t\telse if(position == 6)\n\t\t\tposition = 4;\n\t\t/////////////\n\t\t//num += position;\n\t\tSystem.out.println(rowCostSec + position);\n\t}\n}\t\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class Solution {\n\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tString x = input.nextLine();\n\t\tlong n = Long.valueOf(x.substring(0, x.length() - 1));\n\t\tlong c;\n\t\tchar e = x.charAt(x.length() - 1);\n\t\tif (e == 'f')\n\t\t\tc = 1;\n\t\telse if (e == 'e')\n\t\t\tc = 2;\n\t\telse if (e == 'd')\n\t\t\tc = 3;\n\t\telse if (e == 'a')\n\t\t\tc = 4;\n\t\telse if (e == 'b')\n\t\t\tc = 5;\n\t\telse\n\t\t\tc = 6;\n\n\t\tlong r = 0;\n\t\tr = n / 4 >= 1 ? ((n / 4)) * 16 : r;\n\t\tr = n % 4 == 0 ? r - 16 : r;\n\t\tr = n % 2 == 0 ? r + 7 : r;\n\n\t\tSystem.out.println(r + c);\n\n\t\tinput.close();\n\t}\n\n}", "label": 0}
{"src": "import java.util.*;\nimport java.io.*;\npublic class ClassB {\n\n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String line = br.readLine();\n        long n = Long.parseLong(line.substring(0, line.length()-1)) - 1;\n        String code = \"_fedabc\";\n        char s = line.charAt(line.length()-1);\n        long res;\n        if(n%4==0 || n%4==2) res = 16*(n/4) + code.indexOf(s);\n        else res = 16*(n/4) + 7 + code.indexOf(s);\n        System.out.println(res);\n    }\n\n}\n", "label": 0}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.awt.Point;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\nimport static java.lang.Math.*;\n\n\npublic class __Canada_B implements Runnable{\n\t\n\tfinal static Random rnd = new Random();\n\t\n\t// SOLUTION!!! \n\t// HACK ME PLEASE IF YOU CAN!!!\n\t// PLEASE!!!\n\t// PLEASE!!!\n\t// PLEASE!!!\n\t\n\tstatic final String ORDER = \"fedabc\";\n\t\n\tvoid solve() {\n\t\tString place = readString();\n\t\t\n\t\tlong row = Long.parseLong(place.substring(0, place.length() - 1));\n\t\tint index = ORDER.indexOf(place.charAt(place.length() - 1));\n\t\t\n\t\tlong quadro = (row - 1) / 4;\n\t\t\n\t\tlong time = quadro * ORDER.length() * 2;\n\t\ttime += quadro * 4;\n\t\t\n\t\tif (row % 2 == 0) {\n\t\t\ttime += ORDER.length();\n\t\t\ttime++;\n\t\t}\n\t\t\n\t\ttime += index;\n\t\t\n\t\tlong answer = time + 1;\n\t\tout.println(answer);\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tfinal boolean FIRST_INPUT_STRING = true;\n\tfinal boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\n\tfinal static int MAX_STACK_SIZE = 128;\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tpublic void run(){\n\t\ttry{\n\t\t\ttimeBegin = System.currentTimeMillis();\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\t\n\t\t\tinit();\n\t\t\t\n\t\t\tif (ONLINE_JUDGE) {\n\t\t\t\tsolve();\n\t\t\t} else {\n\t\t\t\twhile (true) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tsolve();\n\t\t\t\t\t\tout.println();\n\t\t\t\t\t} catch (NumberFormatException e) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} catch (NullPointerException e) {\n\t\t\t\t\t\tif (FIRST_INPUT_STRING) break;\n\t\t\t\t\t\telse throw e;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tout.close();\n\t\t\ttime();\n\t\t}catch (Exception e){\n\t\t\te.printStackTrace(System.err);\n\t\t\tSystem.exit(-1);\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tBufferedReader in;\n\tOutputWriter out;\n\tStringTokenizer tok = new StringTokenizer(\"\");\n\t\n\tpublic static void main(String[] args){\n\t\tnew Thread(null, new __Canada_B(), \"\", MAX_STACK_SIZE * (1L << 20)).start();\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tvoid init() throws FileNotFoundException{\n\t\tLocale.setDefault(Locale.US);\n\t\t\n\t\tif (ONLINE_JUDGE){\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new OutputWriter(System.out);\n\t\t}else{\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new OutputWriter(\"output.txt\");\n\t\t}\n\t}\n\t\n\t////////////////////////////////////////////////////////////////\n\t\n\tlong timeBegin, timeEnd;\n\n\tvoid time(){\n\t\ttimeEnd = System.currentTimeMillis();\n\t\tSystem.err.println(\"Time = \" + (timeEnd - timeBegin));\n\t}\n\t\n\tvoid debug(Object... objects){\n\t\tif (ONLINE_JUDGE){\n\t\t\tfor (Object o: objects){\n\t\t\t\tSystem.err.println(o.toString());\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tString delim = \" \";\n\t\n\tString readLine() {\n\t\ttry {\n\t\t\treturn in.readLine();\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeIOException(e);\n\t\t}\n\t}\n\t\n\tString readString() {\n\t\ttry {\n\t\t\twhile(!tok.hasMoreTokens()){\n\t\t\t\ttok = new StringTokenizer(readLine());\n\t\t\t}\n\t\t\t\n\t\t\treturn tok.nextToken(delim);\n\t\t} catch (NullPointerException e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////\n\t\n\tfinal char NOT_A_SYMBOL = '\\0';\n\t\n\tchar readChar() {\n\t\ttry {\n\t\t\tint intValue = in.read();\n\t\t\t\n\t\t\tif (intValue == -1){\n\t\t\t\treturn NOT_A_SYMBOL;\n\t\t\t}\n\t\t\t\n\t\t\treturn (char) intValue;\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeIOException(e);\n\t\t}\n\t}\n\t\n\tchar[] readCharArray() {\n\t\treturn readLine().toCharArray();\n\t}\n\t\n\tchar[][] readCharField(int rowsCount) {\n\t\tchar[][] field = new char[rowsCount][];\n\t\tfor (int row = 0; row < rowsCount; ++row) {\n\t\t\tfield[row] = readCharArray();\n\t\t}\n\t\t\n\t\treturn field;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////\n\t\n\tint readInt() {\n\t\treturn Integer.parseInt(readString());\n\t}\n\t\n\tint[] readIntArray(int size) {\n\t\tint[] array = new int[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readInt();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\tint[] readSortedIntArray(int size) {\n\t\tInteger[] array = new Integer[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tarray[index] = readInt();\n\t\t}\n\t\tArrays.sort(array);\n\t\t\n\t\tint[] sortedArray = new int[size];\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tsortedArray[index] = array[index];\n\t\t}\n\t\t\n\t\treturn sortedArray;\n\t}\n\t\n\tint[] readIntArrayWithDecrease(int size) {\n\t\tint[] array = readIntArray(size);\n\t\t\n\t\tfor (int i = 0; i < size; ++i) {\n\t\t\tarray[i]--;\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////\n\t\n\tint[][] readIntMatrix(int rowsCount, int columnsCount) {\n\t\tint[][] matrix = new int[rowsCount][];\n\t\t\n\t\tfor (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n\t\t\tmatrix[rowIndex] = readIntArray(columnsCount);\n\t\t}\n\t\t\n\t\treturn matrix;\n\t}\n\t\n\tint[][] readIntMatrixWithDecrease(int rowsCount, int columnsCount) {\n\t\tint[][] matrix = new int[rowsCount][];\n\t\t\n\t\tfor (int rowIndex = 0; rowIndex < rowsCount; ++rowIndex) {\n\t\t\tmatrix[rowIndex] = readIntArrayWithDecrease(columnsCount);\n\t\t}\n\t\t\n\t\treturn matrix;\n\t}\n\t\n\t///////////////////////////////////////////////////////////////////\n\t\n\tlong readLong() {\n\t\treturn Long.parseLong(readString());\n\t}\n\t\n\tlong[] readLongArray(int size) {\n\t\tlong[] array = new long[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readLong();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////\n\t\n\tdouble readDouble() {\n\t\treturn Double.parseDouble(readString());\n\t}\n\t\n\tdouble[] readDoubleArray(int size) {\n\t\tdouble[] array = new double[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readDouble();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t////////////////////////////////////////////////////////////////////\n\t\t\n\tBigInteger readBigInteger() {\n\t\treturn new BigInteger(readString());\n\t}\n\t\n\tBigDecimal readBigDecimal() {\n\t\treturn new BigDecimal(readString());\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tPoint readPoint() {\n\t\tint x = readInt();\n\t\tint y = readInt();\n\t\treturn new Point(x, y);\n\t}\n\t\n\tPoint[] readPointArray(int size) {\n\t\tPoint[] array = new Point[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index){\n\t\t\tarray[index] = readPoint();\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tList<Integer>[] readGraph(int vertexNumber, int edgeNumber) {\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tList<Integer>[] graph = new List[vertexNumber];\n\t\t\n\t\tfor (int index = 0; index < vertexNumber; ++index){\n\t\t\tgraph[index] = new ArrayList<Integer>();\n\t\t}\n\t\t\n\t\twhile (edgeNumber-- > 0){\n\t\t\tint from = readInt() - 1;\n\t\t\tint to = readInt() - 1;\n\t\t\t\n\t\t\tgraph[from].add(to);\n\t\t\tgraph[to].add(from);\n\t\t}\n\t\t\n\t\treturn graph;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic class IntIndexPair {\n\t\t\n\t\tstatic Comparator<IntIndexPair> increaseComparator = new Comparator<IntIndexPair>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compare(IntIndexPair indexPair1, IntIndexPair indexPair2) {\n\t\t\t\tint value1 = indexPair1.value;\n\t\t\t\tint value2 = indexPair2.value;\n\t\t\t\t\n\t\t\t\tif (value1 != value2) return value1 - value2;\n\t\t\t\t\n\t\t\t\tint index1 = indexPair1.index;\n\t\t\t\tint index2 = indexPair2.index;\n\t\t\t\t\n\t\t\t\treturn index1 - index2;\n\t\t\t}\n\t\t};\n\t\t\n\t\tstatic Comparator<IntIndexPair> decreaseComparator = new Comparator<IntIndexPair>() {\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compare(IntIndexPair indexPair1, IntIndexPair indexPair2) {\n\t\t\t\tint value1 = indexPair1.value;\n\t\t\t\tint value2 = indexPair2.value;\n\t\t\t\t\n\t\t\t\tif (value1 != value2) return -(value1 - value2);\n\t\t\t\t\n\t\t\t\tint index1 = indexPair1.index;\n\t\t\t\tint index2 = indexPair2.index;\n\t\t\t\t\n\t\t\t\treturn index1 - index2;\n\t\t\t}\n\t\t};\n\t\t\n\t\tint value, index;\n\n\t\tpublic IntIndexPair(int value, int index) {\n\t\t\tsuper();\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\t\t\n\t\t\n\t\tpublic int getRealIndex() {\n\t\t\treturn index + 1;\n\t\t}\n\t}\n\t\n\tIntIndexPair[] readIntIndexArray(int size) {\n\t\tIntIndexPair[] array = new IntIndexPair[size];\n\t\t\n\t\tfor (int index = 0; index < size; ++index) {\n\t\t\tarray[index] = new IntIndexPair(readInt(), index);\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic class OutputWriter extends PrintWriter {\n\n\t\tfinal int DEFAULT_PRECISION = 12;\n\t\t\n\t\tprotected int precision;\n\t\tprotected String format, formatWithSpace;\n\t\t\n\t\t{\n\t\t\tprecision = DEFAULT_PRECISION;\n\t\t\t\n\t\t\tformat = createFormat(precision);\n\t\t\tformatWithSpace = format + \" \";\n\t\t}\n\t\t\n\t\tpublic OutputWriter(OutputStream out) {\n\t\t\tsuper(out);\n\t\t}\n\n\t\tpublic OutputWriter(String fileName) throws FileNotFoundException {\n\t\t\tsuper(fileName);\n\t\t}\n\t\t\n\t\tpublic int getPrecision() {\n\t\t\treturn precision;\n\t\t}\n\n\t\tpublic void setPrecision(int precision) {\n\t\t\tprecision = max(0, precision);\n\t\t\tthis.precision = precision;\n\t\t\t\n\t\t\tformat = createFormat(precision);\n\t\t\tformatWithSpace = format + \" \";\n\t\t}\n\t\t\n\t\tprivate String createFormat(int precision){\n\t\t\treturn \"%.\" + precision + \"f\";\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void print(double d){\n\t\t\tprintf(format, d);\n\t\t}\n\t\t\n\t\tpublic void printWithSpace(double d){\n\t\t\tprintf(formatWithSpace, d);\n\t\t}\n\n\t\tpublic void printAll(double...d){\n\t\t\tfor (int i = 0; i < d.length - 1; ++i){\n\t\t\t\tprintWithSpace(d[i]);\n\t\t\t}\n\t\t\t\n\t\t\tprint(d[d.length - 1]);\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic void println(double d){\n\t\t\tprintlnAll(d);\n\t\t}\n\t\t\n\t\tpublic void printlnAll(double... d){\n\t\t\tprintAll(d);\n\t\t\tprintln();\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic class RuntimeIOException extends RuntimeException {\n\n\t\t/**\n\t\t * \n\t\t */\n\t\tprivate static final long serialVersionUID = -6463830523020118289L;\n\n\t\tpublic RuntimeIOException(Throwable cause) {\n\t\t\tsuper(cause);\n\t\t}\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t//////////////// Some useful constants and functions ////////////////\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic final int[][] steps = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; \n\tstatic final int[][] steps8 = {\n\t\t\t{-1, 0}, {1, 0}, {0, -1}, {0, 1},\n\t\t\t{-1, -1}, {1, 1}, {1, -1}, {-1, 1}\n\t};\n\t\n\tstatic final boolean checkCell(int row, int rowsCount, int column, int columnsCount) {\n\t\treturn checkIndex(row, rowsCount) && checkIndex(column, columnsCount);\n\t}\n\t\n\tstatic final boolean checkIndex(int index, int lim){\n\t\treturn (0 <= index && index < lim);\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic final boolean checkBit(int mask, int bit){\n\t\treturn (mask & (1 << bit)) != 0;\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic final long getSum(int[] array) {\n\t\tlong sum = 0;\n\t\tfor (int value: array) {\n\t\t\tsum += value;\n\t\t}\n\t\t\n\t\treturn sum;\n\t}\n\t\n\tstatic final Point getMinMax(int[] array) {\n\t\tint min = array[0];\n\t\tint max = array[0];\n\t\t\n\t\tfor (int index = 0, size = array.length; index < size; ++index, ++index) {\n\t\t\tint value = array[index];\n\t\t\t\n\t\t\tif (index == size - 1) {\n\t\t\t\tmin = min(min, value);\n\t\t\t\tmax = max(max, value);\n\t\t\t} else {\n\t\t\t\tint otherValue = array[index + 1];\n\t\t\t\t\n\t\t\t\tif (value <= otherValue) {\n\t\t\t\t\tmin = min(min, value);\n\t\t\t\t\tmax = max(max, otherValue);\n\t\t\t\t} else {\n\t\t\t\t\tmin = min(min, otherValue);\n\t\t\t\t\tmax = max(max, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn new Point(min, max);\n\t}\n\t\n\t/////////////////////////////////////////////////////////////////////\n\t\n\tstatic class IdMap<KeyType> extends HashMap<KeyType, Integer> {\n\n\t\t/**\n\t\t * \n\t\t */\n\t\tprivate static final long serialVersionUID = -3793737771950984481L;\n\n\t\tpublic IdMap() {\n\t\t\tsuper();\n\t\t}\n\t\t\n\t\tint getId(KeyType key) {\n\t\t\tInteger id = super.get(key);\n\t\t\tif (id == null) {\n\t\t\t\tsuper.put(key, id = size());\n\t\t\t}\n\t\t\t\n\t\t\treturn id;\n\t\t}\n\t}\n}\n\n", "label": 0}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.stream.Collector;\nimport java.util.stream.Collectors;\nimport java.util.stream.IntStream;\n\npublic class Main {\n    public static void main(String[] args) {\n\n        File file = new File(\"in.txt\");\n        InputStream inputStream = null;\n//        try {inputStream= new FileInputStream(file);} catch (FileNotFoundException ex){return;};\n        inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskB solver = new TaskB();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\n\n\n\n\nclass TaskB {\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n\n        String position = in.next();\n\n        Long row = Long.parseLong(position.substring(0,position.length()-1));\n        Character seat = position.charAt(position.length()-1);\n\n        Long time = 0L;\n\n        time += ((row-1)/4) * (12+4);\n        row = (row-1) % 4 ;\n        if(row == 1 || row == 3){\n            time+=7;\n        }\n\n        switch (seat){\n            case 'f' : time+=1; break;\n            case 'e' : time+=2; break;\n            case 'd' : time+=3; break;\n            case 'c' : time+=6; break;\n            case 'b' : time+=5; break;\n            case 'a' : time+=4; break;\n        }\n\n        out.println(time);\n\n\n    }\n\n\n\n\n\n\n}\n\n\n\n\nclass InputReader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public String nextLine(){\n        try {\n            return reader.readLine();\n        } catch (IOException e){\n            throw new RuntimeException(e);\n        }\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n    public long nextLong() { return Long.parseLong(next()); }\n\n}\n\n\n\nclass Pair<F, S> {\n    public final F first;\n    public final S second;\n\n\n\n\n    public Pair(F first, S second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (!(o instanceof Pair)) {\n            return false;\n        }\n        Pair<?, ?> p = (Pair<?, ?>) o;\n        return Objects.equals(p.first, first) && Objects.equals(p.second, second);\n    }\n\n    @Override\n    public int hashCode() {\n        return (first == null ? 0 : first.hashCode()) ^ (second == null ? 0 : second.hashCode());\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + first + \", \" + second + ')';\n    }\n}", "label": 0}
{"src": "\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n\nimport java.util.Scanner;\n\n/**\n *\n * @author Raed\n */\npublic class FoodOnPlane {\n    \n    /**\n     * @param args the command line arguments\n     */\n    \n    public static final int NUM=6;\n    public static void main(String[] args) {\n        // TODO code application logic here\n        Scanner input = new Scanner(System.in);\n        String data= input.next();\n        int len = data.length();\n        String row = data.substring(0, len-1);\n        String seat = data.substring(len-1,len);\n        \n        System.out.println(getTime(Long.parseLong(row),seat));\n    }\n    \n    \n    public static long getTime(long row, String seat){\n        row--;\n        long mod =row%2;//either 0 or 1\n        long  rowT=row/4;\n        long rowTime = (rowT*2) + mod;\n        long actualRowTime = rowT + rowT*3 +mod; \n        long seatCount= rowTime*NUM;\n        \n        long seatTime=0;\n        \n        switch(seat){\n            \n            case \"f\":\n                seatTime =1;\n                break;\n            case \"e\":\n                seatTime =2;\n                break;\n            case \"d\":\n                seatTime =3;\n                break;\n            case \"a\":\n                seatTime =4;\n                break;\n            case \"b\":\n                seatTime =5;\n                break;\n            case \"c\":\n                seatTime =6;\n                break;\n                \n                \n                \n        }\n        \n        return actualRowTime+seatCount+seatTime;\n    }\n}\n", "label": 0}
{"src": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class CodeForces {\n    private final BufferedReader reader;\n    private final PrintWriter writer;\n    private StringTokenizer tokenizer;\n\n    private void solve() {\n        String input = next();\n        long n = Long.parseLong(input.substring(0, input.length() - 1));\n        int seat = input.charAt(input.length() - 1) - 'a';\n        int dec[] = new int[] {2, 1, 0, 3, 4, 5};\n        int seatDec = dec[seat];\n        boolean isEven = n % 2 == 0;\n        n >>>= 1;\n        boolean isNext;\n        long res;\n        if (isEven) {\n            isNext = (n + 1) % 2 == 0;\n            n = (n - 1) >>> 1;\n            res = n * 12 + 12 - seatDec;\n            res += (1 + 4 * n);\n        } else {\n            isNext = n % 2 == 0;\n            n >>>= 1;\n            res = n * 12 + 6 - seatDec;\n            res += (4 * n);\n        }\n        writer.print(res);\n    }\n\n    public static void main(String[] args) {\n        new CodeForces(System.in, System.out);\n    }\n\n    private CodeForces(InputStream inputStream, OutputStream outputStream) {\n        this.reader = new BufferedReader(new InputStreamReader(inputStream));\n        this.writer = new PrintWriter(outputStream);\n        solve();\n        writer.close();\n    }\n\n    private String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    private String readLine() {\n        String line;\n        try {\n            line = reader.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return line;\n    }\n\n    private int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    private long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    private double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public boolean hasNext() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            String line = readLine();\n            if (line == null) {\n                return false;\n            }\n            tokenizer = new StringTokenizer(line);\n        }\n        return true;\n    }\n\n    public BigInteger nextBigInteger() {\n        return new BigInteger(next());\n    }\n\n    public static int upperBinarySearch (int[] array, int start, int finish, int key) {\n        int low = 0;\n        int high = array.length- 1;\n        if (high < 0) return -1;\n        while (low < high) {\n            int mid = (low + high + 1) >>> 1;\n            if (array[mid] <= key) low = mid;\n            else high = mid - 1;\n        }\n        if (array[low] != key) {\n            if (array[low] < key) low++;\n            low = -(low + 1);\n        }\n        return low;\n    }\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\n/**\n * Created by arsen on 22.10.16.\n */\npublic class Solver2 {\n    public static void main(String ... args){\n        Scanner sc = new Scanner(System.in);\n        String s = sc.nextLine();\n        long n = Long.parseLong(s.substring(0, s.length()-1));\n        char c = s.charAt(s.length()-1);\n        long num = (n-1) /4 ;\n        long sum = 13*num;\n        long numinR = n-num*4;\n        if(numinR == 2 || numinR == 4)\n            sum+= 7;\n        sum+=num*3;\n        if(c=='f')\n            sum+=1;\n        else if(c=='e')\n            sum+=2;\n        else if(c=='d')\n            sum+=3;\n        else if(c=='a')\n            sum+=4;\n        else if(c=='b')\n            sum+=5;\n        else if(c=='c')\n            sum+=6;\n        System.out.println(sum);\n    }\n}\n", "label": 0}
{"src": "import java.util.*;\n\npublic class Cheker{\n\tpublic static void main(String []args){\n\t\tScanner sc=new Scanner(System.in);\n\t\tint[] val={4,5,6,3,2,1};\n\t\t//int[] rowVal={1,2,1,2};\n\t\tString str=sc.next();\n\t\tlong row=Long.valueOf(str.substring(0, str.length()-1));\n\t\tchar c=str.charAt(str.length()-1);\n\t\tlong div=row/4;\n\t\tlong sub=row-(4*div);\n\t\tlong res=0;\n\t\tif(row<=4){\n\t\t\tif(row<=2){\n\t\t\t\tres+=(row-1);\n\t\t\t\tres+=val[c-97];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres+=(row-3);\n\t\t\t\tres+=val[c-97];\n\t\t\t}\n\t\t\tif(row==2 || row==4){\n\t\t\t\tres+=6;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(sub>2 || sub==0){\n\t\t\t\tres+=(row-3);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tres+=row-1;\n\t\t\t}\n\t\t\tres+=(div*12);\n\t\t\tres+=val[c-97];\n\t\t\tif(sub==2 || sub==0){\n\t\t\t\tres+=6;\n\t\t\t}\n\t\t\tif(sub==0){\n\t\t\t\tres-=12;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t\tsc.close();\n\t}\n}", "label": 0}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\n\npublic class CC_A {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString s = br.readLine();\n\t\tlong n = Long.parseLong(s.substring(0, s.length() - 1));\n\t\t\n\t\t\n\t\t\n\t\tHashMap<String, Integer> map = new HashMap<String, Integer>();\n\t\tmap.put(\"a\", 4);\n\t\tmap.put(\"b\", 5);map.put(\"c\", 6);map.put(\"d\", 3);map.put(\"e\", 2);map.put(\"f\", 1);\n\t\t\n\t\tlong row = (n - 1) / 4 * 3;\n\t\tlong cols = ((n-1) % 2 + ((n-1)/4) * 2) * 7;\n\t\tlong let = map.get(s.charAt(s.length() - 1) + \"\");\n\t\t\n\t\tSystem.out.println(row + cols + let - (n-1)/4);\n\t\t\n\t\t\n\t}\n}\n", "label": 0}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\npublic class FoodOnThePlane {\n\tpublic static void main(String args[]) throws Exception {\n\t\tBufferedReader s = new BufferedReader(new InputStreamReader(System.in));\n\t\t//BufferedReader s = new BufferedReader(new FileReader(\"*.in\"));\n\t\t//PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\"*.out\")));\n\t\t//StringTokenizer st = new StringTokenizer(s.readLine());\n\t\tString y = s.readLine();\n\t\tlong row = Long.parseLong(y.substring(0, y.length()-1));\n\t\tint col = y.charAt(y.length()-1) - 'a';\n\t\tlong secs = 0;\n\t\tif(row == 1)secs = 0;\n\t\telse if (row == 2)secs = 7;\n\t\telse {\n\t\t\tlong remainder = row % 4;\n\t\t\tif(remainder == 1){\n\t\t\t\tsecs = ((row - 1) / 4) * 16;\n\t\t\t} else if (remainder == 3){\n\t\t\t\tsecs = ((row - 3)/4) * 16;\n\t\t\t} else if (remainder == 2){\n\t\t\t\tsecs = ((((row + 2) / 4)-1) * 16)+7;\n\t\t\t} else {\n\t\t\t\tsecs = (((row / 4)-1) * 16)+7;\n\t\t\t}\n\t\t}\n\t\tif(col == 0){\n\t\t\tsecs += 4;\n\t\t} else if(col == 1){\n\t\t\tsecs += 5;\n\t\t} else if(col == 2){\n\t\t\tsecs += 6;\n\t\t} else if(col == 3){\n\t\t\tsecs += 3;\n\t\t} else if(col == 4){\n\t\t\tsecs += 2;\n\t\t} else {\n\t\t\tsecs+=1;\n\t\t}\n\t\tSystem.out.println(secs);\n\t}\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\npublic class B725 {\n\n    public static void main(String[] args) {\n        int fullRoundTime = 16;\n        int halfRoundTime = 7;\n        Scanner in = new Scanner(System.in);\n        String seat = in.next();\n        long row = Long.parseLong(seat.substring(0, seat.length()-1))-1;\n        char posInRow = seat.charAt(seat.length()-1);\n        long fullRounds = row/4;\n        boolean halfRound = ((row%2) == 1);\n        int timeInRow = \"fedabc\".indexOf(posInRow) + 1;\n        long answer = fullRoundTime*fullRounds + (halfRound ? halfRoundTime : 0) + timeInRow;\n        System.out.println(answer);\n    }\n\n}\n", "label": 0}
{"src": "import java.util.Scanner;\n\n/**\n * Created by Volodymyr Kovalenko\n */\npublic class Sol1 {\n    public static void main(String [] spt) {\n        Scanner sc = new Scanner(System.in);\n\n        String s = sc.nextLine();\n        long  row  = Long.parseLong(s.substring(0, s.length() - 1));\n        char p = s.charAt(s.length() - 1);\n        row--;\n\n        long rest = row % 4;\n\n        if (rest  >=  2) {\n            row -= 2;\n        }\n        long result = row;\n\n\n        long tt = row / 4;\n\n        result += 6 * tt * 2;\n\n        if (row % 4 == 1) {\n            result += 6;\n        }\n        if (p == 'f'){\n            result += 1;\n        }\n        if (p == 'e'){\n            result += 2;\n        }\n        if (p == 'd'){\n            result += 3;\n        }\n        if (p == 'a'){\n            result += 4;\n        }\n        if (p == 'b'){\n            result += 5;\n        }\n        if (p == 'c'){\n            result += 6;\n        }\n\n\n        System.out.println(result);\n    }\n}\n", "label": 0}
{"src": "import java.util.Scanner;\npublic class Problem {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static int choose (char c) {\n\t\tif (c == 'f')\n\t\t\treturn 1;\n\t\telse if (c == 'e')\n\t\t\treturn 2;\n\t\telse if (c == 'd')\n\t\t\treturn 3;\n\t\telse if (c == 'a')\n\t\t\treturn 4;\n\t\telse if (c == 'b')\n\t\t\treturn 5;\n\t\telse \n\t\t\treturn 6;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tlong sec = 0;\n\t\tString seat = \"\";\n\t\tseat = in.nextLine();\n\t\tchar rowChar = seat.charAt(seat.length()-1);\n\t\tlong ind = 0;\n\t\tind = Long.parseLong(seat.substring(0,seat.length()-1).trim());\n\t\tlong completedRows = ind - (ind%4);\n\t\tcompletedRows /= 4;\n\t\tsec += (completedRows*13) + ((completedRows-1)*3);\n\t\tif (ind%4 == 0) {\n\t\t\tsec -= 6;\n\t\t\tsec += choose(rowChar);\n\t\t\tSystem.out.println(sec);\n\t\t} else if (ind%4 == 1 || ind%4 == 3) {\n\t\t\tsec += 3;\n\t\t\tsec += choose(rowChar);\n\t\t\tSystem.out.println(sec);\n\t\t} else {\n\t\t\tsec += 3+7;\n\t\t\tsec += choose(rowChar);\n\t\t\tSystem.out.println(sec);\n\t\t}\n\t\tin.close();\n\t}\n}", "label": 0}
{"src": "import java.util.List;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tFastPrinter out = new FastPrinter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskE {\n    public void solve(int testNumber, FastScanner in, FastPrinter out) {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int p = in.nextInt();\n        int[] a = in.readIntArray(n);\n        int[] b = in.readIntArray(m);\n        for (int i = 0; i < n; i++) {\n            a[i] %= p;\n        }\n        for (int j = 0; j < m; j++) {\n            b[j] %= p;\n        }\n        int k = 90;\n        int[] dp = new int[1];\n        dp[0] = (a[0] + b[0]) % p;\n        List<int[]> dynamics = new ArrayList<int[]>();\n        dynamics.add(dp);\n        List<Integer> step = new ArrayList<Integer>();\n        step.add(0);\n        int[] size = new int[n + m - 1];\n        size[0] = 1;\n        for (int steps = 1; steps < n + m - 1; steps++) {\n            dp = nextDP(n, m, p, a, b, dp, steps);\n            if (steps != n + m - 2 && steps % k == 0) {\n                dynamics.add(dp);\n                step.add(steps);\n            }\n        }\n        out.println(dp[0]);\n        StringBuilder answer = new StringBuilder();\n        for (int curStep = n + m - 2, curIndex = 0; curStep > 0; ) {\n            int lastStep = step.remove(step.size() - 1);\n            int[][] dps = new int[curStep - lastStep + 1][];\n            dps[0] = dynamics.remove(dynamics.size() - 1);\n            for (int i = 1; i < curStep - lastStep; i++) {\n                dps[i] = nextDP(n, m, p, a, b, dps[i - 1], lastStep + i);\n            }\n            dps[curStep - lastStep] = dp;\n            for (int i = curStep - lastStep; i > 0; i--) {\n                int steps = i + lastStep;\n                int shift2 = steps < n ? 1 : 0;\n                int x = Math.min(steps, n - 1) - curIndex;\n                int y = steps - x;\n                if (x == 0 || y > 0 && dps[i - 1][curIndex - shift2 + 1] < dps[i - 1][curIndex - shift2]) {\n                    answer.append('S');\n                    curIndex -= shift2;\n                } else {\n                    answer.append('C');\n                    curIndex -= shift2;\n                    ++curIndex;\n                }\n            }\n            dp = dps[0];\n            curStep = lastStep;\n        }\n        out.println(answer.reverse());\n    }\n\n    private int[] nextDP(int n, int m, int p, int[] a, int[] b, int[] dp, int steps) {\n        int shift1 = steps < m ? 0 : -1;\n        int shift2 = steps < n ? 1 : 0;\n        int newSize = dp.length + shift1 + shift2;\n        int[] next = new int[newSize];\n        int x = Math.min(steps, n - 1);\n        int y = steps - x;\n        int cur2 = -shift2;\n        int cur3 = -shift2 + 1;\n        for (int cur = 0; cur < newSize; cur++, cur2++, cur3++) {\n            int pay = a[x] + b[y];\n            if (pay >= p) {\n                pay -= p;\n            }\n            int best = 0;\n            if (x > 0 && best < dp[cur3]) {\n                best = dp[cur3];\n            }\n            if (y > 0 && best < dp[cur2]) {\n                best = dp[cur2];\n            }\n            next[cur] = best + pay;\n            x--;\n            y++;\n        }\n        return next;\n    }\n}\n\nclass FastScanner extends BufferedReader {\n\n    boolean isEOF;\n\n    public FastScanner(InputStream is) {\n        super(new InputStreamReader(is));\n    }\n\n    public int read() {\n        try {\n            int ret = super.read();\n            if (isEOF && ret < 0) {\n                throw new InputMismatchException();\n            }\n            isEOF = ret == -1;\n            return ret;\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    static boolean isWhiteSpace(int c) {\n        return c >= -1 && c <= 32;\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isWhiteSpace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int ret = 0;\n        while (!isWhiteSpace(c)) {\n            if (c < '0' || c > '9') {\n                throw new NumberFormatException(\"digit expected \" + (char) c\n                        + \" found\");\n            }\n            ret = ret * 10 + c - '0';\n            c = read();\n        }\n        return ret * sgn;\n    }\n\n    public int[] readIntArray(int n) {\n        int[] ret = new int[n];\n        for (int i = 0; i < n; i++) {\n            ret[i] = nextInt();\n        }\n        return ret;\n    }\n\n    }\n\nclass FastPrinter extends PrintWriter {\n\n    public FastPrinter(OutputStream out) {\n        super(out);\n    }\n\n    public FastPrinter(Writer out) {\n        super(out);\n    }\n\n\n}\n\n", "label": 3}
{"src": "import java.io.*;\n\nimport static java.util.Arrays.fill;\nimport static java.util.Arrays.binarySearch;\nimport static java.util.Arrays.sort;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n\n    void run() throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        solve();\n    }\n    \n    /*************************************************************** \n     * Solution\n     **************************************************************/\n    static final int MAXSZ = 20000;\n    static final int STEP = 300;\n    static final int PRECALC = (MAXSZ + STEP - 1) / STEP;\n    \n    static final byte UNDEF = 0;\n    static final byte CANDY = 'C';\n    static final byte STONE = 'S';\n\n    int[] rowA = new int [MAXSZ];\n    int[] rowB = new int [MAXSZ];\n    \n    int[] cdp = rowA;\n    int[] ndp = rowB;\n    \n    int[][] pc = new int [PRECALC][MAXSZ];\n    byte[][] pr = new byte [STEP + 2][MAXSZ];\n    \n    Queue tmpPath = new Queue();\n    Queue ansPath = new Queue();\n    \n    int MOD;\n    int rowNum;\n    int colNum;\n    \n    int[] rowVal;\n    int[] colVal;\n    \n    int blockNum = 0;\n    \n    void solve() throws IOException  {\n        rowNum = nextInt();\n        colNum = nextInt();\n        MOD = nextInt();\n        rowVal = nextIntArray(rowNum); for (int i = 0; i < rowNum; i++) rowVal[i] %= MOD;\n        colVal = nextIntArray(colNum); for (int i = 0; i < colNum; i++) colVal[i] %= MOD;\n        in.close();\n        if (rowNum <= STEP) turtleDP(rowNum, colNum); else advancedDP();\n        PrintWriter out = new PrintWriter(System.out);\n        out.println(cost(ansPath));\n        for (int it = ansPath.head; it != ansPath.tail; it = (it + 1) % Queue.QSIZE)\n            out.print((char) ansPath.data[it]);\n        out.close();\n    }\n\n    int cost(Queue path) {\n        int ret = cost(0, 0);\n        int row = 0, col = 0;\n        for (int it = path.head; it != path.tail; it = (it + 1) % Queue.QSIZE) {\n            if (path.data[it] == CANDY) row++; else col++;\n            ret += cost(row, col);\n        }\n        return ret;\n    }\n\n    int cost(int row, int col) {\n        int ret = rowVal[row] + colVal[col];\n        return ret < MOD ? ret : ret - MOD;\n    }\n    \n    void turtleDP(int rowNum, int colNum) {\n        dpClearUp(rowNum, colNum);\n        cdp[0] = cost(0, 0);\n        for (int row = 0; row < rowNum; row++) {\n            int nrow = row + 1;\n            if (nrow < rowNum) {\n                for (int col = 0, ncol = 1; ncol < colNum; ++col, ++ncol) {\n                    int cval = cdp[col];\n                    int nvalDN = cval + cost(nrow, col);\n                    if (ndp[col] < nvalDN) {\n                        ndp[col] = nvalDN;\n                        pr[nrow][col] = CANDY;\n                    }\n                    int nvalRT = cval + cost(row, ncol);\n                    if (cdp[ncol] < nvalRT) {\n                        cdp[ncol] = nvalRT;\n                        pr[row][ncol] = STONE;\n                    }\n                }\n                ndp[colNum - 1] = cdp[colNum - 1] + cost(nrow, colNum - 1);\n                pr[nrow][colNum - 1] = CANDY;\n            } else {\n                for (int col = 0, ncol = 1; ncol < colNum; ++col, ++ncol) {\n                    int nval = cdp[col] + cost(row, ncol);\n                    if (cdp[ncol] < nval) {\n                        cdp[ncol] = nval;\n                        pr[row][ncol] = STONE;\n                    }\n                }\n            }\n            dpSwapRows(colNum);\n        }\n        for (int row = rowNum - 1, col = colNum - 1; pr[row][col] != UNDEF; ) {\n            ansPath.pushFront(pr[row][col]);\n            if (pr[row][col] == CANDY) row--; else col--;\n        }\n    }\n    \n    void advancedDP() {\n        precalc();\n        int row = rowNum - 1;\n        int col = colNum - 1;\n        for (int block = blockNum - 1; block > 0; block--) {\n            solveBlock(block, row, col);\n            while (!tmpPath.isEmpty()) {\n                byte x = tmpPath.popBack();\n                ansPath.pushFront(x);\n                if (x == CANDY) row--; else col--;\n            }\n        }\n        turtleDP(row + 1, col + 1);\n    }\n    \n    void solveBlock(int block, int endRow, int endCol) {\n        int startRow = STEP * block;\n        dpClearUp(endRow - startRow + 1, endCol + 1);\n        System.arraycopy(pc[block], 0, cdp, 0, endCol + 1);\n        for (int row = startRow; row <= endRow; row++) {\n            int nrow = row + 1;\n            int prRow = row - startRow;\n            int prNRow = nrow - startRow;\n            if (nrow <= endRow) {\n                for (int col = 0, ncol = 1; ncol <= endCol; ++col, ++ncol) {\n                    int cval = cdp[col];\n                    int nvalDN = cval + cost(nrow, col);\n                    if (ndp[col] < nvalDN) {\n                        ndp[col] = nvalDN;\n                        pr[prNRow][col] = CANDY;\n                    }\n                    int nvalRT = cval + cost(row, ncol);\n                    if (cdp[ncol] < nvalRT) {\n                        cdp[ncol] = nvalRT;\n                        pr[prRow][ncol] = STONE;\n                    }\n                }\n                ndp[endCol] = cdp[endCol] + cost(nrow, endCol);\n                pr[prNRow][endCol] = CANDY;\n            } else {\n                for (int col = 0, ncol = 1; ncol <= endCol; ++col, ++ncol) {\n                    int nval = cdp[col] + cost(row, ncol);\n                    if (cdp[ncol] < nval) {\n                        cdp[ncol] = nval;\n                        pr[prRow][ncol] = STONE;\n                    }\n                }\n            }\n            dpSwapRows(colNum);\n        }\n        for (int row = endRow - startRow, col = endCol; pr[row][col] != UNDEF; ) {\n            tmpPath.pushFront(pr[row][col]);\n            if (pr[row][col] == CANDY) row--; else col--;\n        }\n    }\n\n    void precalc() {\n        dpClearUp(0, colNum);\n        cdp[0] = cost(0, 0);\n        for (int row = 0, add = 0; row < rowNum; row++) {\n            if (row == add) {\n                System.arraycopy(cdp, 0, pc[blockNum++], 0, colNum);\n                add += STEP;\n            }\n            int nrow = row + 1;\n            if (nrow < rowNum) {\n                for (int col = 0, ncol = 1; ncol < colNum; ++col, ++ncol) {\n                    int cval = cdp[col];\n                    int nvalDN = cval + cost(nrow, col);\n                    if (ndp[col] < nvalDN) ndp[col] = nvalDN;\n                    int nvalRT = cval + cost(row, ncol);\n                    if (cdp[ncol] < nvalRT) cdp[ncol] = nvalRT;\n                }\n                ndp[colNum - 1] = cdp[colNum - 1] + cost(nrow, colNum - 1);\n            } else {\n                for (int col = 0, ncol = 1; ncol < colNum; ++col, ++ncol) {\n                    int nval = cdp[col] + cost(row, ncol);\n                    if (cdp[ncol] < nval) cdp[ncol] = nval;\n                }\n            }\n            dpSwapRows(colNum);\n        }\n    }\n\n    void dpClearUp(int rowNum, int colNum) {\n        fill(cdp, 0, colNum, -1);\n        fill(ndp, 0, colNum, -1);\n        for (int row = 0; row < rowNum; row++)\n            fill(pr[row], 0, colNum, UNDEF);\n    }\n    \n    void dpSwapRows(int colNum) {\n        if (cdp == rowA) {\n            cdp = rowB;\n            ndp = rowA;\n        } else {\n            cdp = rowA;\n            ndp = rowB;\n        }\n        fill(ndp, 0, colNum, -1);\n    }\n    \n    class Queue {\n        static final int QSIZE = MAXSZ + MAXSZ + 10;\n\n        int head;\n        int tail;\n        byte[] data = new byte [QSIZE];\n\n        Queue() {\n            this.clear();\n        }\n\n        void clear() {\n            head = tail = 0;\n        }\n\n        boolean isEmpty() {\n            return head == tail;\n        }\n\n        void pushBack(byte x) {\n            data[tail] = x;\n            if (++tail == QSIZE)\n                tail = 0;\n        }\n\n        void pushFront(byte x) {\n            if (--head < 0)\n                head = QSIZE - 1;\n            data[head] = x;\n        }\n\n        byte popBack() {\n            if (--tail < 0)\n                tail = QSIZE - 1;\n            return data[tail];\n        }\n\n        byte popFront() {\n            byte ret = data[head];\n            if (++head == QSIZE)\n                head = 0;\n            return ret;\n        }\n    }\n    \n    /*************************************************************** \n     * Input \n     **************************************************************/\n    BufferedReader in;\n    \n    int nextInt() throws IOException {\n        int n, c;\n        for (c = in.read(); c < '0' || c > '9'; c = in.read());\n        for (n = 0; '0' <= c && c <= '9'; c = in.read())\n            n = n * 10 + c - '0';\n        return n;\n    }\n    \n    int[] nextIntArray(int size) throws IOException {\n        int[] ret = new int [size];\n        for (int i = 0; i < size; i++)\n            ret[i] = nextInt();\n        return ret;\n    }\n    \n    /*************************************************************** \n     * Utility\n     **************************************************************/\n    static String memoryStatus() {\n        return (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory() >> 20) + \"/\" + (Runtime.getRuntime().totalMemory() >> 20) + \" MB\";\n    }\n}\n", "label": 3}
{"src": "import java.util.List;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tFastPrinter out = new FastPrinter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskE {\n    public void solve(int testNumber, FastScanner in, FastPrinter out) {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int p = in.nextInt();\n        int[] a = in.readIntArray(n);\n        int[] b = in.readIntArray(m);\n        for (int i = 0; i < n; i++) {\n            a[i] %= p;\n        }\n        for (int j = 0; j < m; j++) {\n            b[j] %= p;\n        }\n        int k = 130;\n        int[] dp = new int[1];\n        dp[0] = (a[0] + b[0]) % p;\n        List<int[]> dynamics = new ArrayList<int[]>();\n        dynamics.add(dp);\n        List<Integer> step = new ArrayList<Integer>();\n        step.add(0);\n        int[] size = new int[n + m - 1];\n        size[0] = 1;\n        for (int steps = 1; steps < n + m - 1; steps++) {\n            dp = nextDP(n, m, p, a, b, dp, steps);\n            if (steps != n + m - 2 && steps % k == 0) {\n                dynamics.add(dp);\n                step.add(steps);\n            }\n        }\n        out.println(dp[0]);\n        StringBuilder answer = new StringBuilder();\n        for (int curStep = n + m - 2, curIndex = 0; curStep > 0; ) {\n            int lastStep = step.remove(step.size() - 1);\n            int[][] dps = new int[curStep - lastStep + 1][];\n            dps[0] = dynamics.remove(dynamics.size() - 1);\n            for (int i = 1; i < curStep - lastStep; i++) {\n                dps[i] = nextDP(n, m, p, a, b, dps[i - 1], lastStep + i);\n            }\n            dps[curStep - lastStep] = dp;\n            for (int i = curStep - lastStep; i > 0; i--) {\n                int steps = i + lastStep;\n                int shift2 = steps < n ? 1 : 0;\n                int x = Math.min(steps, n - 1) - curIndex;\n                int y = steps - x;\n                if (x == 0 || y > 0 && dps[i - 1][curIndex - shift2 + 1] < dps[i - 1][curIndex - shift2]) {\n                    answer.append('S');\n                    curIndex -= shift2;\n                } else {\n                    answer.append('C');\n                    curIndex -= shift2;\n                    ++curIndex;\n                }\n            }\n            dp = dps[0];\n            curStep = lastStep;\n        }\n        out.println(answer.reverse());\n    }\n\n    private int[] nextDP(int n, int m, int p, int[] a, int[] b, int[] dp, int steps) {\n        int shift1 = steps < m ? 0 : -1;\n        int shift2 = steps < n ? 1 : 0;\n        int newSize = dp.length + shift1 + shift2;\n        int[] next = new int[newSize];\n        int x = Math.min(steps, n - 1);\n        int y = steps - x;\n        int cur2 = -shift2;\n        int cur3 = -shift2 + 1;\n        for (int cur = 0; cur < newSize; cur++, cur2++, cur3++) {\n            int pay = a[x] + b[y];\n            if (pay >= p) {\n                pay -= p;\n            }\n            int best = 0;\n            if (x > 0 && best < dp[cur3]) {\n                best = dp[cur3];\n            }\n            if (y > 0 && best < dp[cur2]) {\n                best = dp[cur2];\n            }\n            next[cur] = best + pay;\n            x--;\n            y++;\n        }\n        return next;\n    }\n}\n\nclass FastScanner extends BufferedReader {\n\n    boolean isEOF;\n\n    public FastScanner(InputStream is) {\n        super(new InputStreamReader(is));\n    }\n\n    public int read() {\n        try {\n            int ret = super.read();\n            if (isEOF && ret < 0) {\n                throw new InputMismatchException();\n            }\n            isEOF = ret == -1;\n            return ret;\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    static boolean isWhiteSpace(int c) {\n        return c >= -1 && c <= 32;\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isWhiteSpace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int ret = 0;\n        while (!isWhiteSpace(c)) {\n            if (c < '0' || c > '9') {\n                throw new NumberFormatException(\"digit expected \" + (char) c\n                        + \" found\");\n            }\n            ret = ret * 10 + c - '0';\n            c = read();\n        }\n        return ret * sgn;\n    }\n\n    public int[] readIntArray(int n) {\n        int[] ret = new int[n];\n        for (int i = 0; i < n; i++) {\n            ret[i] = nextInt();\n        }\n        return ret;\n    }\n\n    }\n\nclass FastPrinter extends PrintWriter {\n\n    public FastPrinter(OutputStream out) {\n        super(out);\n    }\n\n    public FastPrinter(Writer out) {\n        super(out);\n    }\n\n\n}\n\n", "label": 3}
{"src": "import java.util.List;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tFastPrinter out = new FastPrinter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskE {\n    public void solve(int testNumber, FastScanner in, FastPrinter out) {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int p = in.nextInt();\n        int[] a = in.readIntArray(n);\n        int[] b = in.readIntArray(m);\n        for (int i = 0; i < n; i++) {\n            a[i] %= p;\n        }\n        for (int j = 0; j < m; j++) {\n            b[j] %= p;\n        }\n        int k = 150;\n        int[] dp = new int[Math.max(n, m)];\n        dp[0] = (a[0] + b[0]) % p;\n        List<int[]> dynamics = new ArrayList<int[]>();\n        dynamics.add(dp);\n        List<Integer> step = new ArrayList<Integer>();\n        step.add(0);\n        int[] next = new int[Math.max(n, m)];\n        int[] size = new int[n + m - 1];\n        size[0] = 1;\n        for (int steps = 1; steps < n + m - 1; steps++) {\n            size[steps] = nextDP(n, m, p, a, b, dp, next, size[steps - 1], steps);\n            int[] t = dp;\n            dp = next;\n            next = t;\n            if (steps != n + m - 2 && steps % k == 0) {\n                dynamics.add(Arrays.copyOf(dp, size[steps]));\n                step.add(steps);\n            }\n        }\n        out.println(dp[0]);\n        next = null;\n        System.gc();\n        int[][] dps = new int[k + 2][Math.max(n, m)];\n        StringBuilder answer = new StringBuilder();\n        for (int curStep = n + m - 2, curIndex = 0; curStep > 0; ) {\n            System.gc();\n            int lastStep = step.remove(step.size() - 1);\n            System.arraycopy(dynamics.remove(dynamics.size() - 1), 0, dps[0], 0, size[lastStep]);\n            for (int i = 1; i < curStep - lastStep; i++) {\n                nextDP(n, m, p, a, b, dps[i - 1], dps[i], size[lastStep + i - 1], lastStep + i);\n            }\n            System.arraycopy(dp, 0, dps[0], 0, size[curStep]);\n            for (int i = curStep - lastStep; i > 0; i--) {\n                int steps = i + lastStep;\n                int shift2 = steps < n ? 1 : 0;\n                int x = Math.min(steps, n - 1) - curIndex;\n                int y = steps - x;\n                if (x == 0 || y > 0 && dps[i - 1][curIndex - shift2 + 1] < dps[i - 1][curIndex - shift2]) {\n                    answer.append('S');\n                    curIndex -= shift2;\n                } else {\n                    answer.append('C');\n                    curIndex -= shift2;\n                    ++curIndex;\n                }\n            }\n            dp = dps[0];\n            curStep = lastStep;\n        }\n        out.println(answer.reverse());\n    }\n\n    private int nextDP(int n, int m, int p, int[] a, int[] b, int[] dp, int[] next, int size, int steps) {\n        int shift1 = steps < m ? 0 : -1;\n        int shift2 = steps < n ? 1 : 0;\n        int newSize = size + shift1 + shift2;\n        int x = Math.min(steps, n - 1);\n        int y = steps - x;\n        int cur2 = -shift2;\n        int cur3 = -shift2 + 1;\n        for (int cur = 0; cur < newSize; cur++, cur2++, cur3++) {\n            int pay = a[x] + b[y];\n            if (pay >= p) {\n                pay -= p;\n            }\n            int best = 0;\n            if (x > 0 && best < dp[cur3]) {\n                best = dp[cur3];\n            }\n            if (y > 0 && best < dp[cur2]) {\n                best = dp[cur2];\n            }\n            next[cur] = best + pay;\n            x--;\n            y++;\n        }\n        return newSize;\n    }\n}\n\nclass FastScanner extends BufferedReader {\n\n    boolean isEOF;\n\n    public FastScanner(InputStream is) {\n        super(new InputStreamReader(is));\n    }\n\n    public int read() {\n        try {\n            int ret = super.read();\n            if (isEOF && ret < 0) {\n                throw new InputMismatchException();\n            }\n            isEOF = ret == -1;\n            return ret;\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    static boolean isWhiteSpace(int c) {\n        return c >= -1 && c <= 32;\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isWhiteSpace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int ret = 0;\n        while (!isWhiteSpace(c)) {\n            if (c < '0' || c > '9') {\n                throw new NumberFormatException(\"digit expected \" + (char) c\n                        + \" found\");\n            }\n            ret = ret * 10 + c - '0';\n            c = read();\n        }\n        return ret * sgn;\n    }\n\n    public int[] readIntArray(int n) {\n        int[] ret = new int[n];\n        for (int i = 0; i < n; i++) {\n            ret[i] = nextInt();\n        }\n        return ret;\n    }\n\n    }\n\nclass FastPrinter extends PrintWriter {\n\n    public FastPrinter(OutputStream out) {\n        super(out);\n    }\n\n    public FastPrinter(Writer out) {\n        super(out);\n    }\n\n\n}\n\n", "label": 3}
{"src": "import java.util.List;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tFastPrinter out = new FastPrinter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskE {\n    public void solve(int testNumber, FastScanner in, FastPrinter out) {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int p = in.nextInt();\n        int[] a = in.readIntArray(n);\n        int[] b = in.readIntArray(m);\n        for (int i = 0; i < n; i++) {\n            a[i] %= p;\n        }\n        for (int j = 0; j < m; j++) {\n            b[j] %= p;\n        }\n        int k = 150;\n        int[] dp = new int[Math.max(n, m)];\n        dp[0] = (a[0] + b[0]) % p;\n        List<int[]> dynamics = new ArrayList<int[]>();\n        dynamics.add(dp);\n        List<Integer> step = new ArrayList<Integer>();\n        step.add(0);\n        int[] next = new int[Math.max(n, m)];\n        int[] size = new int[n + m - 1];\n        size[0] = 1;\n        for (int steps = 1; steps < n + m - 1; steps++) {\n            size[steps] = nextDP(n, m, p, a, b, dp, next, size[steps - 1], steps);\n            int[] t = dp;\n            dp = next;\n            next = t;\n            if (steps != n + m - 2 && steps % k == 0) {\n                dynamics.add(Arrays.copyOf(dp, size[steps]));\n                step.add(steps);\n            }\n        }\n        out.println(dp[0]);\n        next = null;\n        int[][] dps = new int[k + 2][Math.max(n, m)];\n        StringBuilder answer = new StringBuilder();\n        for (int curStep = n + m - 2, curIndex = 0; curStep > 0; ) {\n            int lastStep = step.remove(step.size() - 1);\n            System.arraycopy(dynamics.remove(dynamics.size() - 1), 0, dps[0], 0, size[lastStep]);\n            for (int i = 1; i < curStep - lastStep; i++) {\n                nextDP(n, m, p, a, b, dps[i - 1], dps[i], size[lastStep + i - 1], lastStep + i);\n            }\n            System.arraycopy(dp, 0, dps[0], 0, size[curStep]);\n            for (int i = curStep - lastStep; i > 0; i--) {\n                int steps = i + lastStep;\n                int shift2 = steps < n ? 1 : 0;\n                int x = Math.min(steps, n - 1) - curIndex;\n                int y = steps - x;\n                if (x == 0 || y > 0 && dps[i - 1][curIndex - shift2 + 1] < dps[i - 1][curIndex - shift2]) {\n                    answer.append('S');\n                    curIndex -= shift2;\n                } else {\n                    answer.append('C');\n                    curIndex -= shift2;\n                    ++curIndex;\n                }\n            }\n            dp = dps[0];\n            curStep = lastStep;\n        }\n        out.println(answer.reverse());\n    }\n\n    private int nextDP(int n, int m, int p, int[] a, int[] b, int[] dp, int[] next, int size, int steps) {\n        int shift1 = steps < m ? 0 : -1;\n        int shift2 = steps < n ? 1 : 0;\n        int newSize = size + shift1 + shift2;\n        int x = Math.min(steps, n - 1);\n        int y = steps - x;\n        int cur2 = -shift2;\n        int cur3 = -shift2 + 1;\n        for (int cur = 0; cur < newSize; cur++, cur2++, cur3++) {\n            int pay = a[x] + b[y];\n            if (pay >= p) {\n                pay -= p;\n            }\n            int best = 0;\n            if (x > 0 && best < dp[cur3]) {\n                best = dp[cur3];\n            }\n            if (y > 0 && best < dp[cur2]) {\n                best = dp[cur2];\n            }\n            next[cur] = best + pay;\n            x--;\n            y++;\n        }\n        return newSize;\n    }\n}\n\nclass FastScanner extends BufferedReader {\n\n    boolean isEOF;\n\n    public FastScanner(InputStream is) {\n        super(new InputStreamReader(is));\n    }\n\n    public int read() {\n        try {\n            int ret = super.read();\n            if (isEOF && ret < 0) {\n                throw new InputMismatchException();\n            }\n            isEOF = ret == -1;\n            return ret;\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    static boolean isWhiteSpace(int c) {\n        return c >= -1 && c <= 32;\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isWhiteSpace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int ret = 0;\n        while (!isWhiteSpace(c)) {\n            if (c < '0' || c > '9') {\n                throw new NumberFormatException(\"digit expected \" + (char) c\n                        + \" found\");\n            }\n            ret = ret * 10 + c - '0';\n            c = read();\n        }\n        return ret * sgn;\n    }\n\n    public int[] readIntArray(int n) {\n        int[] ret = new int[n];\n        for (int i = 0; i < n; i++) {\n            ret[i] = nextInt();\n        }\n        return ret;\n    }\n\n    }\n\nclass FastPrinter extends PrintWriter {\n\n    public FastPrinter(OutputStream out) {\n        super(out);\n    }\n\n    public FastPrinter(Writer out) {\n        super(out);\n    }\n\n\n}\n\n", "label": 3}
{"src": "import java.util.List;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.ArrayList;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tFastPrinter out = new FastPrinter(outputStream);\n\t\tTaskE solver = new TaskE();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskE {\n    public void solve(int testNumber, FastScanner in, FastPrinter out) {\n        int n = in.nextInt();\n        int m = in.nextInt();\n        int p = in.nextInt();\n        int[] a = in.readIntArray(n);\n        int[] b = in.readIntArray(m);\n        for (int i = 0; i < n; i++) {\n            a[i] %= p;\n        }\n        for (int j = 0; j < m; j++) {\n            b[j] %= p;\n        }\n        int k = 100;\n        int[] dp = new int[Math.max(n, m)];\n        dp[0] = (a[0] + b[0]) % p;\n        List<int[]> dynamics = new ArrayList<int[]>();\n        dynamics.add(dp);\n        List<Integer> step = new ArrayList<Integer>();\n        step.add(0);\n        int[] next = new int[Math.max(n, m)];\n        int[] size = new int[n + m - 1];\n        size[0] = 1;\n        for (int steps = 1; steps < n + m - 1; steps++) {\n            size[steps] = nextDP(n, m, p, a, b, dp, next, size[steps - 1], steps);\n            int[] t = dp;\n            dp = next;\n            next = t;\n            if (steps != n + m - 2 && steps % k == 0) {\n                dynamics.add(Arrays.copyOf(dp, size[steps]));\n                step.add(steps);\n            }\n        }\n        out.println(dp[0]);\n        next = null;\n        int[][] dps = new int[k + 2][Math.max(n, m)];\n        StringBuilder answer = new StringBuilder();\n        for (int curStep = n + m - 2, curIndex = 0; curStep > 0; ) {\n            int lastStep = step.remove(step.size() - 1);\n            System.arraycopy(dynamics.remove(dynamics.size() - 1), 0, dps[0], 0, size[lastStep]);\n            for (int i = 1; i < curStep - lastStep; i++) {\n                nextDP(n, m, p, a, b, dps[i - 1], dps[i], size[lastStep + i - 1], lastStep + i);\n            }\n            System.arraycopy(dp, 0, dps[0], 0, size[curStep]);\n            for (int i = curStep - lastStep; i > 0; i--) {\n                int steps = i + lastStep;\n                int shift2 = steps < n ? 1 : 0;\n                int x = Math.min(steps, n - 1) - curIndex;\n                int y = steps - x;\n                if (x == 0 || y > 0 && dps[i - 1][curIndex - shift2 + 1] < dps[i - 1][curIndex - shift2]) {\n                    answer.append('S');\n                    curIndex -= shift2;\n                } else {\n                    answer.append('C');\n                    curIndex -= shift2;\n                    ++curIndex;\n                }\n            }\n            dp = dps[0];\n            curStep = lastStep;\n        }\n        out.println(answer.reverse());\n    }\n\n    private int nextDP(int n, int m, int p, int[] a, int[] b, int[] dp, int[] next, int size, int steps) {\n        int shift1 = steps < m ? 0 : -1;\n        int shift2 = steps < n ? 1 : 0;\n        int newSize = size + shift1 + shift2;\n        int x = Math.min(steps, n - 1);\n        int y = steps - x;\n        int cur2 = -shift2;\n        int cur3 = -shift2 + 1;\n        for (int cur = 0; cur < newSize; cur++, cur2++, cur3++) {\n            int pay = a[x] + b[y];\n            if (pay >= p) {\n                pay -= p;\n            }\n            int best = 0;\n            if (x > 0 && best < dp[cur3]) {\n                best = dp[cur3];\n            }\n            if (y > 0 && best < dp[cur2]) {\n                best = dp[cur2];\n            }\n            next[cur] = best + pay;\n            x--;\n            y++;\n        }\n        return newSize;\n    }\n}\n\nclass FastScanner extends BufferedReader {\n\n    boolean isEOF;\n\n    public FastScanner(InputStream is) {\n        super(new InputStreamReader(is));\n    }\n\n    public int read() {\n        try {\n            int ret = super.read();\n            if (isEOF && ret < 0) {\n                throw new InputMismatchException();\n            }\n            isEOF = ret == -1;\n            return ret;\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    static boolean isWhiteSpace(int c) {\n        return c >= -1 && c <= 32;\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isWhiteSpace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int ret = 0;\n        while (!isWhiteSpace(c)) {\n            if (c < '0' || c > '9') {\n                throw new NumberFormatException(\"digit expected \" + (char) c\n                        + \" found\");\n            }\n            ret = ret * 10 + c - '0';\n            c = read();\n        }\n        return ret * sgn;\n    }\n\n    public int[] readIntArray(int n) {\n        int[] ret = new int[n];\n        for (int i = 0; i < n; i++) {\n            ret[i] = nextInt();\n        }\n        return ret;\n    }\n\n    }\n\nclass FastPrinter extends PrintWriter {\n\n    public FastPrinter(OutputStream out) {\n        super(out);\n    }\n\n    public FastPrinter(Writer out) {\n        super(out);\n    }\n\n\n}\n\n", "label": 3}
{"src": "//package prac;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class D79 {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[] from = new int[n-1];\n\t\tint[] to = new int[n-1];\n\t\tint[] w = new int[n-1];\n\t\tfor(int i = 0;i < n-1;i++){\n\t\t\tfrom[i] = ni()-1;\n\t\t\tto[i] = ni()-1;\n\t\t\tw[i] = ni();\n\t\t}\n\t\tint[][][] g = packWU(n, from, to, w);\n\t\tint[][] pars = parents(g, 0);\n\t\tint[] par = pars[0], ord = pars[1];\n\t\t\n\t\tlong[] min = new long[n];\n\t\tlong[] num = new long[n];\n\t\tlong[] r = new long[n];\n\t\tlong[][] rn = new long[n][];\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tint cur = ord[i];\n\t\t\tnum[cur] = 1;\n\t\t\tint p = 0;\n\t\t\tfor(int[] e : g[cur]){\n\t\t\t\tif(par[cur] != e[0]){\n\t\t\t\t\tr[cur] += r[e[0]] + e[1]*2;\n\t\t\t\t\tnum[cur] += num[e[0]];\n\t\t\t\t\tmin[cur] += min[e[0]] + e[1] * num[e[0]];\n\t\t\t\t\trn[p++] = new long[]{r[e[0]] + e[1]*2, num[e[0]]};\n\t\t\t\t}\n\t\t\t}\n//\t\t\ttr(cur, num[cur], min[cur], rn);\n\t\t\tArrays.sort(rn, 0, p, new Comparator<long[]>() {\n\t\t\t\tpublic int compare(long[] a, long[] b) {\n\t\t\t\t\treturn Long.signum(a[0]*b[1]-b[0]*a[1]);\n\t\t\t\t}\n\t\t\t});\n\t\t\tlong rsum = 0;\n\t\t\tfor(int j = 0;j < p;j++){\n\t\t\t\tmin[cur] += rsum * rn[j][1];\n\t\t\t\trsum += rn[j][0];\n\t\t\t}\n\t\t}\n\t\tout.printf(\"%.15f\\n\", (double)min[0] / (n-1));\n\t}\n\t\n\tpublic static int[][][] packWU(int n, int[] from, int[] to, int[] w) {\n\t\tint[][][] g = new int[n][][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]][2];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\t--p[from[i]];\n\t\t\tg[from[i]][p[from[i]]][0] = to[i];\n\t\t\tg[from[i]][p[from[i]]][1] = w[i];\n\t\t\t--p[to[i]];\n\t\t\tg[to[i]][p[to[i]]][0] = from[i];\n\t\t\tg[to[i]][p[to[i]]][1] = w[i];\n\t\t}\n\t\treturn g;\n\t}\n\tpublic static int[][] parents(int[][][] g, int root)\n\t{\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\t\t\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor(int p = 0, r = 1;p < r;p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor(int[] nex : g[cur]){\n\t\t\t\tif(par[cur] != nex[0]){\n\t\t\t\t\tq[r++] = nex[0];\n\t\t\t\t\tpar[nex[0]] = cur;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] {par, q};\n\t}\n\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new D79().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "label": 4}
{"src": "import java.awt.Point;\nimport java.awt.geom.Line2D;\nimport java.awt.geom.Point2D;\nimport java.io.*;\nimport java.math.BigInteger;\nimport static java.math.BigInteger.*;\nimport java.util.*;\npublic class D{\n    int n;\n    ArrayList<Integer>[]g;\n    ArrayList<Long>[]c;\n\n    void solve()throws Exception\n    {\n        n=nextInt();\n        g=new ArrayList[n];\n        c=new ArrayList[n];\n        for(int i=0;i<n;i++)\n        {\n            g[i]=new ArrayList<Integer>();\n            c[i]=new ArrayList<Long>();\n        }\n\n        for(int i=0;i<n-1;i++)\n        {\n            int a=nextInt()-1;\n            int b=nextInt()-1;\n            int w=nextInt();\n            g[a].add(b);\n            c[a].add((long)w);\n            g[b].add(a);\n            c[b].add((long)w);\n        }\n        long[] res=rec(0,-1);\n        System.out.println(res[2]/(n-1.0));\n\n\n\n    }\n\n    private long[] rec(int at, int par) {\n\n        int cnt=0;\n        for(int i=0;i<g[at].size();i++)\n        {\n            int x=g[at].get(i);\n            if(x==par)\n                continue;\n            cnt++;\n        }\n        long[][]p=new long[cnt][];\n        cnt=0;\n        long[]res=new long[3];\n        for(int i=0;i<g[at].size();i++)\n        {\n            int x=g[at].get(i);\n            long w=c[at].get(i);\n            if(x==par)\n                continue;\n            p[cnt]=rec(x,at);\n            p[cnt][0]++;\n            p[cnt][1]+=2*w;\n            p[cnt][2]+=(p[cnt][0])*w;\n            cnt++;\n        }\n        Arrays.sort(p,new Comparator<long[]>() {\n            public int compare(long[] o1, long[] o2) {\n                long b=o1[1]*o2[0]-o2[1]*o1[0];\n                return b>0?1:(b<0?-1:0);\n            }\n        });\n        long t=0;\n        for(long[]x :p)\n        {\n            res[0]+=x[0];\n            res[1]+=x[1];\n            res[2]+=x[2]+x[0]*t;\n            t+=x[1];\n        }\n        return res;\n    }\n\n    ////////////\n    BufferedReader reader;\n    PrintWriter writer;\n    StringTokenizer stk;\n    void run()throws Exception\n    {\n        reader=new BufferedReader(new InputStreamReader(System.in));\n        stk=null;\n        writer=new PrintWriter(System.out);\n        solve();\n        reader.close();\n        writer.close();\n    }\n    int nextInt()throws Exception\n    {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong()throws Exception\n    {\n        return Long.parseLong(nextToken());\n\n    }\n    double nextDouble()throws Exception\n    {\n        return Double.parseDouble(nextToken());\n\n\n    }\n\n    String nextString()throws Exception\n    {\n        return nextToken();\n    }\n    String nextLine()throws Exception\n    {\n        return reader.readLine();\n    }\n    String nextToken()throws Exception\n    {\n        if(stk==null || !stk.hasMoreTokens())\n        {\n            stk=new StringTokenizer(nextLine());\n            return nextToken();\n\n        }\n        return stk.nextToken();\n    }\n\n    public static void main(String[]args) throws Exception\n    {\n        new D().run();\n    }\n\n\n\n}", "label": 4}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class ProblemD {\n\t\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\tint n = Integer.valueOf(in.readLine());\n\t\tgraph = new List[n];\n\t\tfor (int i = 0 ; i < n ; i++) {\n\t\t\tgraph[i] = new ArrayList<Edge>();\n\t\t}\n\t\tfor (int i = 0 ; i < n-1 ; i++) {\n\t\t\tString[] abt = in.readLine().split(\" \");\n\t\t\tint a = Integer.valueOf(abt[0])-1;\n\t\t\tint b = Integer.valueOf(abt[1])-1;\n\t\t\tint t = Integer.valueOf(abt[2]);\n\t\t\tgraph[a].add(new Edge(b, t));\n\t\t\tgraph[b].add(new Edge(a, t));\n\t\t}\n\t\tmemo = new int[n];\n\t\tArrays.fill(memo, -1);\n\t\t\n\t\tout.println(dfs(0, -1).time);\n\t\tout.flush();\n\t}\n\n\tstatic class Edge {\n\t\tint to;\n\t\tint cost;\n\t\tEdge(int _, int __) {\n\t\t\tto = _;\n\t\t\tcost = __;\n\t\t}\n\t}\n\t\n\tstatic int[] memo;\n\tstatic List<Edge>[] graph; \n\t\n\tstatic class Result implements Comparable<Result> {\n\t\tint num;\n\t\tdouble time;\n\t\tdouble backtime;\n\t\tEdge edge;\n\t\tResult(int _, double __) {\n\t\t\tnum = _;\n\t\t\ttime = __;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Result arg0) {\n\t\t\treturn Double.compare((backtime + edge.cost) * arg0.num, (arg0.backtime + arg0.edge.cost) * num);\n\t\t}\n\t}\n\n\tstatic int tdfs(int now, int parent) {\n\t\tif (memo[now] >= 0) {\n\t\t\treturn memo[now];\n\t\t}\n\t\tint result = 0;\n\t\tfor (Edge edge : graph[now]) {\n\t\t\tif (parent == edge.to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tresult += tdfs(edge.to, now) + edge.cost;\n\t\t}\n\t\tmemo[now] = result;\n\t\treturn result;\n\t}\n\t\n\tstatic Result dfs(int now, int parent) {\n\t\tint cn = (parent == -1) ? graph[now].size() : graph[now].size()-1;\n\t\tResult[] r = new Result[cn];\n\t\tint cidx = 0;\n\t\tint vcnt = (parent == -1) ? 0 : 1;\n\t\tfor (Edge edge : graph[now]) {\n\t\t\tif (parent == edge.to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr[cidx] = dfs(edge.to, now);\n\t\t\tr[cidx].edge = edge;\n\t\t\tr[cidx].time += edge.cost;\n\t\t\tvcnt += r[cidx].num;\n\t\t\tcidx++;\n\t\t}\n\t\tArrays.sort(r);\n\t\t\n\t\tResult my = new Result(vcnt, 0);\n\t\tmy.backtime = tdfs(now, parent);\n\t\tdouble time = 0;\n\t\tfor (int i = 0 ; i < cidx ; i++) {\n\t\t\ttime += r[i].time;\n\t\t\tmy.time += time * r[i].num / vcnt;\n\t\t\ttime -= r[i].time;\n\t\t\ttime += tdfs(r[i].edge.to, now) * 2 + r[i].edge.cost * 2;\n\t\t}\n\t\treturn my;\n\t}\n\t\n\tpublic static void debug(Object... o) {\n\t\tSystem.err.println(Arrays.deepToString(o));\n\t}\n}\n", "label": 4}
{"src": "//package round79;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class D {\n\tScanner in;\n\tPrintWriter out;\n//\tString INPUT = \"6 1 2 4 2 3 2 1 4 4 4 5 2 5 6 1\";\n\tString INPUT = \"5\\r\\n\" +\n\t\"1 2 1\\r\\n\" +\n\t\"1 3 1\\r\\n\" +\n\t\"1 4 1\\r\\n\" +\n\t\"1 5 1\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[] from = new int[n-1];\n\t\tint[] to = new int[n-1];\n\t\tint[] len = new int[n-1];\n\t\tfor(int i = 0;i < n-1;i++){\n\t\t\tfrom[i] = ni() - 1;\n\t\t\tto[i] = ni() - 1;\n\t\t\tlen[i] = ni();\n\t\t}\n\t\t\n\t\tint[][] g = packWU(n, from, to, len);\n\t\tint[][] gu = packU(n, from, to);\n\t\tint[] par = parents(gu, 0);\n\t\tint[][] chs = parentToChildren(par);\n\t\tint[] ord = sortByDepth(chs, 0);\n\t\tfinal long[] c = new long[n];\n\t\tfinal long[] a = new long[n];\n\t\tfinal long[] b = new long[n];\n\t\t\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tfor(int j = 0;j < g[ord[i]].length;j+=2){\n\t\t\t\tif(par[ord[i]] != g[ord[i]][j]){\n\t\t\t\t\tc[ord[i]] += c[g[ord[i]][j]] + g[ord[i]][j+1]*2;\n\t\t\t\t\ta[ord[i]] += a[g[ord[i]][j]];\n\t\t\t\t}\n\t\t\t}\n\t\t\ta[ord[i]]++;\n\t\t}\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tint z = gu[ord[i]].length;\n\t\t\tint[][] ya = new int[z][2];\n\t\t\tfor(int j = 0;j < z;j++){\n\t\t\t\tya[j][0] = gu[ord[i]][j];\n\t\t\t\tya[j][1] = g[ord[i]][2*j+1];\n\t\t\t}\n\t\t\tArrays.sort(ya, new Comparator<int[]>(){\n\t\t\t\tpublic int compare(int[] x, int[] y)\n\t\t\t\t{\n\t\t\t\t\treturn -Long.signum(a[x[0]]*(c[y[0]]+2*y[1])-a[y[0]]*(c[x[0]]+2*x[1]));\n\t\t\t\t}\n\t\t\t});\n\t\t\tlong t = 0;\n\t\t\tfor(int j = 0;j < z;j++){\n\t\t\t\tint k = ya[j][0];\n\t\t\t\tif(par[ord[i]] != k){\n\t\t\t\t\tt += ya[j][1];\n\t\t\t\t\tb[ord[i]] += t * a[k] + b[k];\n\t\t\t\t\tt += c[k] + ya[j][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.printf(\"%.9f\\n\", (double)b[0] / (n-1));\n\t}\n\t\n\tstatic int[][] packU(int n, int[] from, int[] to)\n\t{\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor(int f : from)p[f]++;\n\t\tfor(int t : to)p[t]++;\n\t\tfor(int i = 0;i < n;i++)g[i] = new int[p[i]];\n\t\tfor(int i = 0;i < from.length;i++){\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tpublic static int[][] parentToChildren(int[] parent)\n\t{\n\t\tint n = parent.length;\n\t\tint[] ct = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(parent[i] >= 0){\n\t\t\t\tct[parent[i]]++;\n\t\t\t}\n\t\t}\n\t\tint[][] ret = new int[n][];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tret[i] = new int[ct[i]];\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(parent[i] >= 0){\n\t\t\t\tret[parent[i]][--ct[parent[i]]] = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret;\n\t}\n\t\n\tstatic int[][] packWU(int n, int[] from, int[] to, int[] w)\n\t{\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor(int f : from)p[f]+=2;\n\t\tfor(int t : to)p[t]+=2;\n\t\tfor(int i = 0;i < n;i++)g[i] = new int[p[i]];\n\t\tfor(int i = 0;i < from.length;i++){\n\t\t\tg[from[i]][--p[from[i]]] = w[i];\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = w[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tpublic static int[] parents(int[][] g, int root)\n\t{\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\t\t\n\t\tQueue<Integer> q = new ArrayDeque<Integer>();\n\t\tq.add(root);\n\t\twhile(q.size() > 0){\n\t\t\tint cur = q.poll();\n\t\t\tfor(int nex : g[cur]){\n\t\t\t\tif(par[cur] != nex){\n\t\t\t\t\tq.add(nex);\n\t\t\t\t\tpar[nex] = cur;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn par;\n\t}\n\t\n\tpublic static int[] sortByDepth(int[][] children, int root)\n\t{\n\t\tint n = children.length;\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tint r = 1;\n\t\tfor(int p = 0;p < n;p++) {\n\t\t\tfor(int c : children[q[p]]) {\n\t\t\t\tq[r++] = c;\n\t\t\t}\n\t\t}\n\t\treturn q;\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tin = oj ? new Scanner(System.in) : new Scanner(INPUT);\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tnew D().run();\n\t}\n\t\n\tint ni() { return Integer.parseInt(in.next()); }\n\tlong nl() { return Long.parseLong(in.next()); }\n\tdouble nd() { return Double.parseDouble(in.next()); }\n\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tvoid tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "label": 4}
{"src": "import java.io.*;\nimport java.lang.Math;\nimport java.util.*;\n\npublic class D\n{\n\tpublic static Scanner in;\n\tpublic static PrintStream out;\n\t\n\tprivate static class Vertex implements Comparable\n\t{\n\t\tpublic int number;\n\t\tpublic int child_count;\t\t\n\t\tpublic Vertex[] childs;\n\t\tpublic int[] childs_length;\n\t\t\n\t\t\n\t\tpublic Vertex(int n)\n\t\t{\n\t\t\tnumber = n;\n\t\t\tchild_count = 0;\n\t\t\t\n\t\t\tp = 0;\n\t\t\tt = 1;\n\t\t}\n\t\t\n\t\tpublic void add_child(Vertex v, int length)\n\t\t{\n\t\t\tchilds[child_count] = v;\n\t\t\tchilds_length[child_count] = length;\n\t\t\tchild_count++;\n\t\t}\n\t\t\n\t\tlong t;\n\t\tlong p;\n\t\tdouble s;\n\t\t\n\t\tpublic int compareTo(Object o)\n\t\t{\n\t\t\tVertex v = (Vertex)o;\n\t\t\tlong d = t*v.p - v.t*p;\n\t\t\t\n\t\t\tif (d==0)\n\t\t\t{\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\t\n\t\t\treturn d < 0 ? -1 : 1;\n\t\t}\n\t\t\n\t\tpublic void dfs(int from)\n\t\t{\n\t\t\tint i;\n\t\t\t\n\t\t\tp = (number==0) ? 0 : 1;\n\t\t\tt = 0;\n\t\t\t\n\t\t\tfor (i=0; i<child_count; i++)\n\t\t\t{\n\t\t\t\tif (childs[i].number!=from)\n\t\t\t\t{\n\t\t\t\t\tchilds[i].dfs(number);\n\t\t\t\t\n\t\t\t\t\tchilds[i].t += (long) (2*childs_length[i]);\n\t\t\t\t\tchilds[i].s += (double) childs_length[i];\n\t\t\t\t\t\n\t\t\t\t\tp+= childs[i].p;\n\t\t\t\t\tt+= childs[i].t;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(childs);\n\t\t\t\n\t\t\ts = 0;\n\t\t\tdouble ts = 0;\n\t\t\t\n\t\t\tfor (i=0; i<child_count; i++)\n\t\t\t{\n\t\t\t\tif (childs[i].number!=from)\n\t\t\t\t{\n\t\t\t\t\ts += (ts + childs[i].s) * ((double)childs[i].p) / (double)p;\n\t\t\t\t\tts += (double)childs[i].t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static Vertex[] v;\n\tpublic static int n;\n\t\n\tpublic static void read()\n\t{\n\t\tn = in.nextInt();\n\t\t\n\t\tv = new Vertex[n];\n\t\tint i;\n\t\tfor (i=0; i<n; i++)\n\t\t{\n\t\t\tv[i] = new Vertex(i);\n\t\t}\n\t\t\n\t\tint[] a = new int[n-1];\n\t\tint[] b = new int[n-1];\n\t\tint[] t = new int[n-1];\n\t\t\n\t\tfor (i=0; i<n-1; i++)\n\t\t{\n\t\t\ta[i] = in.nextInt()-1;\n\t\t\tb[i] = in.nextInt()-1;\n\t\t\tt[i] = in.nextInt();\n\t\t\t\n\t\t\tv[a[i]].child_count++;\n\t\t\tv[b[i]].child_count++;\n\t\t}\n\t\t\n\t\tfor (i=0; i<n; i++)\n\t\t{\n\t\t\tv[i].childs = new Vertex[v[i].child_count];\n\t\t\tv[i].childs_length = new int[v[i].child_count];\n\t\t\tv[i].child_count = 0;\n\t\t}\n\t\t\n\t\tfor (i=0; i<n-1; i++)\n\t\t{\n\t\t\tv[a[i]].add_child(v[b[i]], t[i]);\n\t\t\tv[b[i]].add_child(v[a[i]], t[i]);\n\t\t}\n\t}\n\t\n\tpublic static void test()\n\t{\n\t\tread();\n\t\tv[0].dfs(-1);\n\t\tout.println(v[0].s);\n\t}\n       \n\tpublic static void main(String args[])\n\t{\n\t\ttry\n\t\t{\n\t\t\t//in = new Scanner(new File(\"in.txt\"));\n\t\t\t//out = new PrintStream(new File(\"out.txt\"));\n\t\t\tin = new Scanner(System.in);\n\t\t\tout = System.out;\n\t\t}\n\t\tcatch (Exception e)\n\t\t{\n\t\t\treturn;\n\t\t}\n\t   \n\t\t//int t = in.nextInt();\n\t\t//for (int i=0; i<t; i++)\n\t\t{\n\t\t\ttest();\n\t\t}\n\t}\n}\n\n", "label": 4}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\n\npublic class CodeB \n{\n\tstatic class Scanner\n\t{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\t\n\t\tpublic String nextLine()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn br.readLine();\n\t\t\t}\n\t\t\tcatch(Exception e)\n\t\t\t{\n\t\t\t\tthrow(new RuntimeException());\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic String next()\n\t\t{\n\t\t\twhile(!st.hasMoreTokens())\n\t\t\t{\n\t\t\t\tString l = nextLine();\n\t\t\t\tif(l == null)\n\t\t\t\t\treturn null;\n\t\t\t\tst = new StringTokenizer(l);\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\t\n\t\tpublic double nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\t\n\t\tpublic int[] nextIntArray(int n)\n\t\t{\n\t\t\tint[] res = new int[n];\n\t\t\tfor(int i = 0; i < res.length; i++)\n\t\t\t\tres[i] = nextInt();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tpublic long[] nextLongArray(int n)\n\t\t{\n\t\t\tlong[] res = new long[n];\n\t\t\tfor(int i = 0; i < res.length; i++)\n\t\t\t\tres[i] = nextLong();\n\t\t\treturn res;\n\t\t}\n\t\t\n\t\tpublic double[] nextDoubleArray(int n)\n\t\t{\n\t\t\tdouble[] res = new double[n];\n\t\t\tfor(int i = 0; i < res.length; i++)\n\t\t\t\tres[i] = nextLong();\n\t\t\treturn res;\n\t\t}\n\t\tpublic void sortIntArray(int[] array)\n\t\t{\n\t\t\tInteger[] vals = new Integer[array.length];\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tvals[i] = array[i];\n\t\t\tArrays.sort(vals);\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tarray[i] = vals[i];\n\t\t}\n\t\t\n\t\tpublic void sortLongArray(long[] array)\n\t\t{\n\t\t\tLong[] vals = new Long[array.length];\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tvals[i] = array[i];\n\t\t\tArrays.sort(vals);\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tarray[i] = vals[i];\n\t\t}\n\t\t\n\t\tpublic void sortDoubleArray(double[] array)\n\t\t{\n\t\t\tDouble[] vals = new Double[array.length];\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tvals[i] = array[i];\n\t\t\tArrays.sort(vals);\n\t\t\tfor(int i = 0; i < array.length; i++)\n\t\t\t\tarray[i] = vals[i];\n\t\t}\n\n\t\tpublic String[] nextStringArray(int n) \n\t\t{\t\n\t\t\tString[] vals = new String[n];\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t\tvals[i] = next();\n\t\t\treturn vals;\n\t\t}\n\t}\n\t\n\tstatic long tiempoActual = 0;\n\t\n\tstatic class Nodo\n\t{\n\t\tlong n;\n\t\tlong o;\n\t\tboolean visitado;\n\t\tArrayList <Arista> aristas = new ArrayList <Arista> ();\n\t\t\n\t\tvoid calcular(Nodo padre)\n\t\t{\n\t\t\tn = 1;\n\t\t\to = 0;\n\t\t\tfor(Arista a : aristas)\n\t\t\t{\n\t\t\t\tif(a.otro == padre)\n\t\t\t\t\tcontinue;\n\t\t\t\ta.otro.calcular(this);\n\t\t\t\tlong nEsta = a.otro.n;\n\t\t\t\tlong oEsta = a.otro.o;\n\t\t\t\toEsta += (a.peso << 1);\n\t\t\t\tn += nEsta;\n\t\t\t\to += oEsta;\n\t\t\t\ta.n = nEsta;\n\t\t\t\ta.o = oEsta;\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong simular(Nodo padre)\n\t\t{\n\t\t\tlong resultado = 0;\n\t\t\tif(!visitado)\n\t\t\t{\n\t\t\t\tvisitado = true;\n\t\t\t\tresultado += tiempoActual;\n\t\t\t}\n\t\t\tArista alPadre = null;\n\t\t\tfor(Arista a : aristas)\n\t\t\t{\n\t\t\t\tif(a.otro == padre)\n\t\t\t\t{\n\t\t\t\t\talPadre = a;\n\t\t\t\t\taristas.remove(a);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tCollections.sort(aristas);\n\t\t\tfor(Arista a : aristas)\n\t\t\t{\n\t\t\t\tif(a.otro == padre)\n\t\t\t\t\tcontinue;\n\t\t\t\ttiempoActual += a.peso;\n\t\t\t\tresultado += a.otro.simular(this);\n\t\t\t}\n\t\t\tif(alPadre != null)\n\t\t\t\ttiempoActual += alPadre.peso;\n\t\t\treturn resultado;\n\t\t}\n\t}\n\t\n\tstatic class Arista implements Comparable <Arista>\n\t{\n\t\tlong n;\n\t\tlong o;\n\t\tlong peso;\n\t\tNodo otro;\n\t\t\n\t\tArista(Nodo o, long p)\n\t\t{\n\t\t\totro = o;\n\t\t\tpeso = p;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Arista otro) \n\t\t{\n\t\t\tlong a = n * otro.o;\n\t\t\tlong b = otro.n * o;\n\t\t\treturn Long.valueOf(b).compareTo(a);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args)\n\t{\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt();\n\t\tNodo[] nodos = new Nodo[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tnodos[i] = new Nodo();\n\t\tfor(int i = 0; i < (n - 1); i++)\n\t\t{\n\t\t\tint a = sc.nextInt() - 1;\n\t\t\tint b = sc.nextInt() - 1;\n\t\t\tint c = sc.nextInt();\n\t\t\tnodos[a].aristas.add(new Arista(nodos[b], c));\n\t\t\tnodos[b].aristas.add(new Arista(nodos[a], c));\n\t\t}\n\t\tnodos[0].calcular(null);\n\t\tSystem.out.println(nodos[0].simular(null) / ((double) (n - 1)));\n\t}\n}", "label": 4}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\npublic class taskD {\n    public static void main(String[] args) throws IOException {\n        new taskD().run();\n    }\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer;\n\n    void run() throws IOException {\n        try {\n            reader = new BufferedReader(new InputStreamReader(System.in));\n            writer = new PrintWriter(new OutputStreamWriter(System.out));\n            tokenizer = null;\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int to[];\n    int nxt[];\n    int head[];\n    int cost[];\n    long time[];\n    long value[];\n    int count[];\n    int edge[];\n    int e ;\n\n    void init(int V, int E) {\n        to = new int[E];\n        nxt = new int[E];\n        cost = new int[E];\n        time = new long[V];\n        value = new long[V];\n        count = new int[V];\n        head = new int[V];\n        edge = new int[V];\n        e = 0;\n        Arrays.fill(head, -1);\n    }\n    void ae(int u, int v, int w) {\n        to[e] = v;\n        cost[e] = w;\n        nxt[e] = head[u];\n        head[u] = e ++;\n    }\n    void addEdge(int u, int v, int w) {\n        ae(u, v, w);\n        ae(v, u, w);\n    }\n\n\n    void solve() throws IOException {\n        int n = nextInt();\n        init(n, n - 1 + n - 1);\n        for (int i = 0; i < n - 1; ++i) {\n            int x = nextInt()  - 1;\n            int y = nextInt()  - 1;\n            int w = nextInt()  ;\n            addEdge(x, y, w);\n        }\n\n        dfs(0, 0, 0);\n\n        long ans = value[0];\n        long t = n - 1;\n        long g = gcd(ans, t);\n        ans /= g;\n        t /= g;\n\n        double res = ans * 1.0 / t;\n\n        writer.printf(Locale.US, \"%.10f\", res);\n\n\n    }\n\n    private long gcd(long a, long b) {\n        while (a > 0 && b > 0) {\n            if (a >= b)\n                a %= b;\n            else b %= a;\n        }\n        return a + b;\n    }\n\n\n    private void dfs(int cur, int par, int lastW) {\n        int cnt = 0;\n        long val = 0;\n        long tm = lastW * 2;\n        int totalCnt = 1;\n        for (int e = head[cur]; e >= 0; e = nxt[e]) {\n            if (to[e] != par) {\n                dfs(to[e], cur, cost[e]);\n                edge[to[e]] = cost[e];\n                tm += time[to[e]];\n                val += value[to[e]];\n                totalCnt += count[to[e]];\n                ++ cnt;\n            }\n        }\n        Integer[] a = new Integer[cnt];\n        int ptr = 0;\n        for (int e = head[cur]; e >= 0; e = nxt[e]) {\n            if (to[e] != par)\n                a[ptr ++] = to[e];\n        }\n        Arrays.sort(a, new Comparator<Integer>() {\n            public int compare(Integer integer, Integer integer1) {\n                int i = integer;\n                int j = integer1;\n                long value = -(time[j] * count[i] - time[i] * count[j]) ;\n                if (value == 0)\n                    return 0;\n                if (value < 0)\n                    return -1;\n                return 1;\n            }\n        });\n\n        long cc = 0;\n        for (int i = 0; i < a.length; ++i) {\n            val += count[a[i]] * (cc + edge[a[i]]);\n            cc += time[a[i]];\n        }\n        value[cur] = val;\n        count[cur] = totalCnt;\n        time[cur] = tm;\n\n    }\n\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    BigInteger nextBigInteger() throws IOException {\n        return new BigInteger(nextToken());\n    }\n}", "label": 4}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class D {\n\n    BufferedReader br;\n    PrintWriter out;\n    StringTokenizer st;\n    boolean eof;\n\n    class Edge {\n        int to, cost;\n\n        public Edge(int to, int cost) {\n            super();\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n\n    ArrayList<Edge>[] g;\n    long[] ans;\n    int[] size;\n    int[] traverse;\n\n    class SubTree implements Comparable<SubTree> {\n        int cost, size;\n\n        public SubTree(int cost, int size) {\n            super();\n            this.cost = cost;\n            this.size = size;\n        }\n\n        @Override\n        public int compareTo(SubTree o) {\n            long val1 = (long) cost * o.size;\n            long val2 = (long) o.cost * size;\n            if (val1 == val2)\n                return 0;\n            return val1 < val2 ? -1 : 1;\n        }\n    }\n\n    void dfs(int v, int pr) {\n        size[v] = 1;\n        ans[v] = 0;\n        traverse[v] = 0;\n        int cnt = 0;\n        for (Edge e : g[v])\n            if (e.to != pr) {\n                dfs(e.to, v);\n                cnt++;\n                size[v] += size[e.to];\n                ans[v] += ans[e.to] + (long) e.cost * size[e.to];\n                traverse[v] += traverse[e.to] + 2 * e.cost;\n            }\n\n        SubTree[] arr = new SubTree[cnt];\n        for (Edge e : g[v])\n            if (e.to != pr) {\n                arr[--cnt] = new SubTree(2 * e.cost + traverse[e.to],\n                        size[e.to]);\n            }\n\n        Arrays.sort(arr);\n\n        if (arr.length > 1) {\n\n            long totCost = arr[0].cost;\n            for (int i = 1; i < arr.length; i++) {\n                ans[v] += totCost * arr[i].size;\n                totCost += arr[i].cost;\n            }\n        }\n\n    }\n\n    void solve() throws IOException {\n        int n = nextInt();\n        g = new ArrayList[n];\n        for (int i = 0; i < n; i++)\n            g[i] = new ArrayList<Edge>();\n        for (int i = 0; i < n - 1; i++) {\n            int v1 = nextInt() - 1;\n            int v2 = nextInt() - 1;\n            int cost = nextInt();\n            g[v1].add(new Edge(v2, cost));\n            g[v2].add(new Edge(v1, cost));\n        }\n\n        ans = new long[n];\n        traverse = new int[n];\n        size = new int[n];\n        dfs(0, -1);\n\n        out.printf(\"%.9f\\n\", 1.0 * ans[0] / (n - 1));\n    }\n\n    void inp() throws IOException {\n        Locale.setDefault(Locale.US);\n        br = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        solve();\n        out.close();\n    }\n\n    public static void main(String[] args) throws IOException {\n        new D().inp();\n    }\n\n    String nextToken() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return \"0\";\n            }\n        }\n        return st.nextToken();\n    }\n\n    String nextString() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                st = new StringTokenizer(br.readLine());\n            } catch (Exception e) {\n                eof = true;\n                return \"0\";\n            }\n        }\n        return st.nextToken(\"\\n\");\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n}\n", "label": 4}
{"src": "import java.io.*;\n\nimport java.awt.geom.Point2D;\nimport java.text.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\n\tfinal String filename = \"\";\n\n\tpublic void solve() throws Exception {\n\t\tint n = iread();\n\t\tfirst = new Edge[n];\n\t\tfor (int i = 0; i + 1 < n; i++) {\n\t\t\tint a = iread(), b = iread(), w = iread();\n\t\t\ta--;\n\t\t\tb--;\n\t\t\tnew Edge(a, b, w);\n\t\t\tnew Edge(b, a, w);\n\t\t}\n\t\tv1 = new long[n];\n\t\tv2 = new long[n];\n\t\tv3 = new long[n];\n\t\ta = new Pair[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = new Pair();\n\t\t}\n\t\tdfs(0, -1);\n\t\tdouble ans = v2[0] * 1.0 / (n - 1);\n\t\tout.write(ans + \"\\n\");\n\t}\n\n\tPair[] a;\n\n\tvoid dfs(int x, int par) {\n\t\tv3[x] = 1;\n\n\t\tfor (Edge e = first[x]; e != null; e = e.next)\n\t\t\tif (e.to != par) {\n\t\t\t\tdfs(e.to, x);\n\t\t\t}\n\t\tint c = 0;\n\t\tfor (Edge e = first[x]; e != null; e = e.next)\n\t\t\tif (e.to != par) {\n\t\t\t\tint y = e.to;\n\t\t\t\tv3[x] += v3[y];\n\t\t\t\tv1[x] = v1[x] + e.len * 2 + v1[y];\n\t\t\t\tv2[x] += v2[y] + e.len * v3[y];\n\t\t\t\ta[c].n = v1[y] + e.len * 2;;\n\t\t\t\ta[c++].d = v3[y];\n\t\t\t}\n\t\tlong s = 0;\n\t\tArrays.sort(a, 0, c);\n\t\tfor (int i = 0; i < c; i++) {\n\t\t\tv2[x] += s * a[i].d;\n\t\t\ts += a[i].n;\n\t\t}\n\t}\n\n\tEdge[] first;\n\tlong[] v1, v2, v3;\n\n\tclass Edge {\n\t\tint from, to, len;\n\t\tEdge next;\n\n\t\tpublic Edge(int from, int to, int len) {\n\t\t\tsuper();\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.len = len;\n\n\t\t\tnext = first[from];\n\t\t\tfirst[from] = this;\n\t\t}\n\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tlong n, d;\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tlong x = n * o.d - o.n * d;\n\t\t\tif (x < 0)\n\t\t\t\treturn -1;\n\t\t\tif (x > 0)\n\t\t\t\treturn 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t\t// in = new BufferedReader(new FileReader(filename+\".in\"));\n\t\t\t// out = new BufferedWriter(new FileWriter(filename+\".out\"));\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(1);\n\t\t}\n\t}\n\n\tpublic int iread() throws Exception {\n\t\treturn Integer.parseInt(readword());\n\t}\n\n\tpublic double dread() throws Exception {\n\t\treturn Double.parseDouble(readword());\n\t}\n\n\tpublic long lread() throws Exception {\n\t\treturn Long.parseLong(readword());\n\t}\n\n\tBufferedReader in;\n\n\tBufferedWriter out;\n\n\tpublic String readword() throws IOException {\n\t\tStringBuilder b = new StringBuilder();\n\t\tint c;\n\t\tc = in.read();\n\t\twhile (c >= 0 && c <= ' ')\n\t\t\tc = in.read();\n\t\tif (c < 0)\n\t\t\treturn \"\";\n\t\twhile (c > ' ') {\n\t\t\tb.append((char) c);\n\t\t\tc = in.read();\n\t\t}\n\t\treturn b.toString();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tLocale.setDefault(Locale.US);\n\t\t} catch (Exception e) {\n\n\t\t}\n\t\t// new Thread(new Main()).start();\n\t\tnew Thread(null, new Main(), \"1\", 1 << 25).start();\n\t}\n}", "label": 4}
{"src": "import static java.lang.Math.*;\nimport static java.lang.System.currentTimeMillis;\nimport static java.lang.System.exit;\nimport static java.lang.System.arraycopy;\nimport static java.util.Arrays.sort;\nimport static java.util.Arrays.binarySearch;\nimport static java.util.Arrays.fill;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry {\n\t\t\tif (new File(\"input.txt\").exists())\n\t\t\t\tSystem.setIn(new FileInputStream(\"input.txt\"));\n\t\t} catch (SecurityException e) {\n\t\t}\n\t\tnew Thread(null, new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tnew Main().run();\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\texit(999);\n\t\t\t\t}\n\t\t\t}\n\t\t}, \"1\", 1 << 25).start();\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st = new StringTokenizer(\"\");\n\n\t\n\t\n\tArrayList<Pair> g[];\n\tint n;\n\t\n\tint subcount[];\n\tdouble sum[];\n\tboolean used[];\n\t\n\tdouble dfs(int v){\n\n//\t\tSystem.err.println(\"------------\");\n\t\tdouble ans = 0;\n\t\tif(used[v])\n\t\t\treturn 0;\n\t\tused[v] = true;\n\t\tsubcount[v] = 1;\n\t\tPP m[] = new PP[g[v].size()];\n\t\tfor(int k = 0; k < g[v].size(); k++){\n\t\t\tPair e = g[v].get(k);\n\t\t\tif(used[e.b])\n\t\t\t\tm[k] = new PP(1,0);\n\t\t\telse{\n\t\t\t\tdouble res = dfs(e.b);\n\t\t\t\tsubcount[v] += subcount[e.b];\n\t\t\t\tans += (res + e.t) * subcount[e.b];\n\t\t\t\tsum[v] += sum[e.b]+ 2 * e.t; \n//\t\t\t\tSystem.err.println(\"kek \" + sum[v\t]);\n\t\t\t\tm[k] = new PP(sum[e.b] + 2 * e.t, subcount[e.b]);\n\t\t\t}\n\t\t}\n\t\tsort(m);\n\t\tint count = subcount[v];\n\n//\t\tSystem.err.println(\"ans \" + ans);\n\t\tif(count > 1 ) System.err.println(Arrays.toString(m));\n//\t\tSystem.err.println(v + \" sum \" + sum[v] + \" sc \" + subcount[v]);\n\t\tfor(int i = 0; i < g[v].size(); i++){\n\t\t\tcount -=  m[i].cc;\n\t\t\tans += m[i].ext * (count > 0 ? count - 1 : 0); \n//\t\t\tSystem.err.println(ans);\n\t\t}\n\t\t\n\n//\t\tSystem.err.println(v + \" \" + ans + \" \" + subcount[v]);\n\t\tif(v == 0)\n\t\t\tif(subcount[v] == 0)\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\tsubcount[v]--;\n//\t\tSystem.err.println(\"------------\");\n\t\treturn ans / subcount[v];\t\n\t\t\n\t}\n\tclass PP implements Comparable<PP>{\n\t\tdouble ext;\n\t\tint cc;\n\t\tPP(double ex, int c){\n\t\t\tcc = c;\n\t\t\text = ex;\n\t\t}\n\t\tpublic int compareTo(PP e){\n\t\t\treturn ext/cc > e.ext / e.cc ? 1 : -1;\n\t\t}\n\t\tpublic String toString(){\n\t\t\treturn (ext / cc) +  \" \"; //\"\\'\" + ext + \" \" + cc + \"\\'\";\n\t\t}\n\t\t\n\t}\n\tprivate void run() throws IOException {\n\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\tout = new PrintWriter(System.out);\n\n\t\tn = nextInt();\n\t\tg = new ArrayList[n];\n\t\tsum = new double[n];\n\t\tused = new boolean[n];\n\t\tsubcount = new int[n];\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tg[i] = new ArrayList();\n\t\tfor(int i = 0; ++i < n;){\n\t\t\tint a = nextInt() - 1;\n\t\t\tint b = nextInt() - 1;\n\t\t\tint t = nextInt();\n\t\t\tg[a].add(new Pair(b, t));\n\t\t\tg[b].add(new Pair(a, t));\n\t\t}\n\t\t\n\t\tout.println(dfs(0));\n\t\t\t\n\t\t\n\t\tin.close();\n\t\tout.close();\n\t}\n\t\n\tclass Pair{\n\t\tint b;\n\t\tint t;\t\n\t\tPair(int x, int y){\n\t\t\tb = x; t = y;\n\t\t}\n\t}\n\tString nextToken() throws IOException {\n\t\twhile (!st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\tString nextLine() throws IOException {\n\t\tst = new StringTokenizer(\"\");\n\t\treturn in.readLine();\n\t}\n\tboolean EOF() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString s = in.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn true;\n\t\t\tst = new StringTokenizer(s);\n\t\t}\n\t\treturn false;\n\t}\n}\n", "label": 4}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Comparator;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Reader;\nimport java.io.Writer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Niyaz Nigmatullin\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner(inputStream);\n\t\tFastPrinter out = new FastPrinter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n\n    static int[] from, to, w;\n    static int[][] edges;\n    static int[] sum;\n    static int[] count;\n    static long answer;\n\n    static final Comparator<Integer> comp = new Comparator<Integer>() {\n        public int compare(Integer o1, Integer o2) {\n            return Long.signum((long) sum[o1] * count[o2] - (long) sum[o2] * count[o1]);\n        }\n    };\n\n    static void dfs(int v, int p) {\n        sum[v] = 0;\n        count[v] = 1;\n        Integer[] ver = new Integer[edges[v].length - (p < 0 ? 0 : 1)];\n        int cur = 0;\n        for (int i : edges[v]) {\n            int go = from[i] ^ v ^ to[i];\n            if (go == p) {\n                continue;\n            }\n            ver[cur++] = go;\n            dfs(go, v);\n            sum[go] += 2 * w[i];\n            answer += (long) count[go] * w[i];\n            sum[v] += sum[go];\n            count[v] += count[go];\n        }\n        Arrays.sort(ver, comp);\n        int curCount = count[v] - 1;\n        for (int i : ver) {\n            curCount -= count[i];\n            answer += (long) curCount * sum[i];\n        }\n    }\n\n    public void solve(int testNumber, FastScanner in, FastPrinter out) {\n        int n = in.nextInt();\n        from = new int[n - 1];\n        to = new int[n - 1];\n        w = new int[n - 1];\n        for (int i = 0; i + 1 < n; i++) {\n            from[i] = in.nextInt() - 1;\n            to[i] = in.nextInt() - 1;\n            w[i] = in.nextInt();\n        }\n        edges = GraphUtils.getEdgesUndirectedWeighted(n, from, to);\n        count = new int[n];\n        sum = new int[n];\n        answer = 0;\n        dfs(0, -1);\n        out.println((double) answer / (n - 1));\n    }\n}\n\nclass FastScanner extends BufferedReader {\n\n    boolean isEOF;\n\n    public FastScanner(InputStream is) {\n        super(new InputStreamReader(is));\n    }\n\n    public int read() {\n        try {\n            int ret = super.read();\n            if (isEOF && ret < 0) {\n                throw new InputMismatchException();\n            }\n            isEOF = ret == -1;\n            return ret;\n        } catch (IOException e) {\n            throw new InputMismatchException();\n        }\n    }\n\n    static boolean isWhiteSpace(int c) {\n        return c >= -1 && c <= 32;\n    }\n\n    public int nextInt() {\n        int c = read();\n        while (isWhiteSpace(c)) {\n            c = read();\n        }\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int ret = 0;\n        while (!isWhiteSpace(c)) {\n            if (c < '0' || c > '9') {\n                throw new NumberFormatException(\"digit expected \" + (char) c\n                        + \" found\");\n            }\n            ret = ret * 10 + c - '0';\n            c = read();\n        }\n        return ret * sgn;\n    }\n\n    }\n\nclass FastPrinter extends PrintWriter {\n\n    public FastPrinter(OutputStream out) {\n        super(out);\n    }\n\n    public FastPrinter(Writer out) {\n        super(out);\n    }\n\n\n}\n\nclass GraphUtils {\n\n    public static int[][] getEdgesUndirectedWeighted(int n, int[] v, int[] u) {\n        int[][] edges = new int[n][];\n        int[] deg = getDegreeUndirected(n, v, u);\n        for (int i = 0; i < n; i++) {\n            edges[i] = new int[deg[i]];\n        }\n        int m = v.length;\n        Arrays.fill(deg, 0);\n        for (int i = 0; i < m; i++) {\n            edges[v[i]][deg[v[i]]++] = i;\n            edges[u[i]][deg[u[i]]++] = i;\n        }\n        return edges;\n    }\n\n    public static int[] getDegreeUndirected(int n, int[] v, int[] u) {\n        int[] deg = new int[n];\n        for (int i : v) {\n            deg[i]++;\n        }\n        for (int i : u) {\n            deg[i]++;\n        }\n        return deg;\n    }\n\n\n    }\n\n", "label": 4}
{"src": "//package prac;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class D79 {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint[] from = new int[n-1];\n\t\tint[] to = new int[n-1];\n\t\tint[] w = new int[n-1];\n\t\tfor(int i = 0;i < n-1;i++){\n\t\t\tfrom[i] = ni()-1;\n\t\t\tto[i] = ni()-1;\n\t\t\tw[i] = ni();\n\t\t}\n\t\tint[][][] g = packWU(n, from, to, w);\n\t\tint[][] pars = parents(g, 0);\n\t\tint[] par = pars[0], ord = pars[1], pw = pars[4];\n\t\t\n\t\tlong[] min = new long[n];\n\t\tlong[] num = new long[n];\n\t\tlong[] r = new long[n];\n\t\tfor(int i = n-1;i >= 0;i--){\n\t\t\tint cur = ord[i];\n\t\t\tnum[cur] = 1;\n\t\t\tlong[][] rn = new long[g[cur].length][];\n\t\t\tint p = 0;\n\t\t\tfor(int[] e : g[cur]){\n\t\t\t\tif(par[cur] != e[0]){\n\t\t\t\t\tr[cur] += r[e[0]] + e[1]*2;\n\t\t\t\t\tnum[cur] += num[e[0]];\n\t\t\t\t\tmin[cur] += min[e[0]] + e[1] * num[e[0]];\n\t\t\t\t\trn[p++] = new long[]{r[e[0]] + e[1]*2, num[e[0]]};\n\t\t\t\t}\n\t\t\t}\n//\t\t\ttr(cur, num[cur], min[cur], rn);\n\t\t\tArrays.sort(rn, 0, p, new Comparator<long[]>() {\n\t\t\t\tpublic int compare(long[] a, long[] b) {\n\t\t\t\t\treturn Long.signum(a[0]*b[1]-b[0]*a[1]);\n\t\t\t\t}\n\t\t\t});\n\t\t\tlong rsum = 0;\n\t\t\tfor(int j = 0;j < p;j++){\n\t\t\t\tmin[cur] += rsum * rn[j][1];\n\t\t\t\trsum += rn[j][0];\n\t\t\t}\n\t\t}\n\t\tout.printf(\"%.15f\\n\", (double)min[0] / (n-1));\n\t}\n\t\n\tpublic static int[][][] packWU(int n, int[] from, int[] to, int[] w) {\n\t\tint[][][] g = new int[n][][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]][2];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\t--p[from[i]];\n\t\t\tg[from[i]][p[from[i]]][0] = to[i];\n\t\t\tg[from[i]][p[from[i]]][1] = w[i];\n\t\t\t--p[to[i]];\n\t\t\tg[to[i]][p[to[i]]][0] = from[i];\n\t\t\tg[to[i]][p[to[i]]][1] = w[i];\n\t\t}\n\t\treturn g;\n\t}\n\tpublic static int[][] parents(int[][][] g, int root)\n\t{\n\t\tint n = g.length;\n\t\tint[] par = new int[n];\n\t\tArrays.fill(par, -1);\n\t\tint[] dw = new int[n];\n\t\tint[] pw = new int[n];\n\t\tint[] dep = new int[n];\n\t\t\n\t\tint[] q = new int[n];\n\t\tq[0] = root;\n\t\tfor(int p = 0, r = 1;p < r;p++) {\n\t\t\tint cur = q[p];\n\t\t\tfor(int[] nex : g[cur]){\n\t\t\t\tif(par[cur] != nex[0]){\n\t\t\t\t\tq[r++] = nex[0];\n\t\t\t\t\tpar[nex[0]] = cur;\n\t\t\t\t\tdep[nex[0]] = dep[cur] + 1;\n\t\t\t\t\tdw[nex[0]] = dw[cur] + nex[1];\n\t\t\t\t\tpw[nex[0]] = nex[1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[][] {par, q, dep, dw, pw};\n\t}\n\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new D79().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tprivate void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "label": 4}
{"src": "import java.util.List;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Comparator;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.util.Collections;\nimport java.util.Collection;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author AlexFetisov\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskD solver = new TaskD();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskD {\n\n    private Graph tree;\n\n    public void solve(int testNumber, InputReader in, PrintWriter out) {\n        int n = in.nextInt();\n        tree = new Graph();\n        tree.initGraphWithCost(n, n - 1);\n        for (int i = 0; i < n-1; ++i) {\n            int a = in.nextInt()-1;\n            int b = in.nextInt()-1;\n            int cost = in.nextInt();\n            tree.addEdgeWithCost(a, b, cost);\n        }\n        fullSum = new long[n];\n        count = new int[n];\n        f = new long[n];\n        out.println((double) rec(0, -1) / (n - 1));\n    }\n\n    long[] fullSum;\n    int[] count;\n    long[] f;\n\n    private long rec(int v, int p) {\n        int c = 0;\n        for (int i = tree.first[v]; i != -1; i = tree.next[i]) {\n            if (tree.to[i] != p) {\n                ++c;\n                rec(tree.to[i], v);\n            }\n        }\n        Integer[] edges = new Integer[c];\n        int car = 0;\n        fullSum[v] = 0;\n        count[v] = 1;\n        for (int i = tree.first[v]; i != -1; i = tree.next[i]) {\n            if (tree.to[i] != p) {\n                edges[car++] = i;\n                fullSum[v] += fullSum[tree.to[i]] + 2 * tree.cost[i];\n                count[v] += count[tree.to[i]];\n            }\n        }\n        Arrays.sort(edges, new Comparator<Integer>() {\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return Long.signum(count[tree.to[o2]] * (fullSum[tree.to[o1]] + tree.cost[o1] * 2) - count[tree.to[o1]] * (fullSum[tree.to[o2]]+ tree.cost[o2] * 2));\n            }\n        });\n        f[v] = 0;\n        long prev = 0;\n        for (Integer e : edges) {\n            f[v] += f[tree.to[e]] + count[tree.to[e]] * (prev + tree.cost[e]);\n            prev += fullSum[tree.to[e]] + tree.cost[e] * 2;\n        }\n        return f[v];\n    }\n}\n\nclass Graph {\n    public int[] from;\n    public int[] to;\n    public int[] first;\n    public int[] next;\n    public int[] cost;\n    public int nVertex;\n    public int nEdges;\n    public int curEdge;\n\n    public Graph() {}\n\n    public void initGraphWithCost(int n, int m) {\n        curEdge = 0;\n        nVertex = n;\n        nEdges = m;\n        from = new int[m * 2];\n        to = new int[m * 2];\n        first = new int[n];\n        next = new int[m * 2];\n        cost = new int[m * 2];\n        Arrays.fill(first, -1);\n    }\n\n    public void addEdgeWithCost(int a, int b, int c) {\n        next[curEdge] = first[a];\n        first[a] = curEdge;\n        to[curEdge] = b;\n        from[curEdge] = a;\n        cost[curEdge] = c;\n        ++curEdge;\n\n        next[curEdge] = first[b];\n        first[b] = curEdge;\n        to[curEdge] = a;\n        from[curEdge] = b;\n        cost[curEdge] = c;\n        ++curEdge;\n    }\n\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer stt;\n\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n    }\n\n    public String nextLine() {\n        try {\n            return reader.readLine().trim();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    public String nextString() {\n        while (stt == null || !stt.hasMoreTokens()) {\n            stt = new StringTokenizer(nextLine());\n        }\n        return stt.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(nextString());\n    }\n\n}\n\n", "label": 4}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Spiders {\n\t\n\tstatic byte[][] m = new byte[101][101];\n\tstatic boolean[] nNew = new boolean[101];\n\tstatic byte[] path = new byte[101];\n\tstatic byte ni;\n\t\n\tpublic static void search(byte v) {\n\t\tnNew[v] = true;\n\t\tfor (byte i = 1; i <= ni; i++) {\n\t\t\tif (m[v][i] > 0 && ! nNew[i]) {\n\t\t\t\tpath[i] = (byte)(path[v] + 1);\n\t\t\t\tsearch(i);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) \n\t\tthrows FileNotFoundException {\n\t\tScanner sc = new Scanner(new File(\"Input.txt\"));\n\t\tbyte n = sc.nextByte();\n\t\tbyte x, y;\n\t\tbyte[] count;\n\t\tbyte max;\n\t\tint s = 0;\n\t\t\n\t\tfor (byte i = 1; i <= n; i++) {\n\t\t\tni = sc.nextByte();\n\t\t\t//cleaning\n\t\t\tm = new byte[101][101];\n\t\t\tcount = new byte[101];\n\t\t\t//cleaning\n\t\t\t\n\t\t\tfor (byte j = 1; j <= ni - 1; j++) {\n\t\t\t\tx = sc.nextByte();\n\t\t\t\ty = sc.nextByte();\n\t\t\t\tm[x][y] = 1;\n\t\t\t\tm[y][x] = 1;\n\t\t\t\tcount[x]++;\n\t\t\t\tcount[y]++;\n\t\t\t}\n\t\t\t\n\t\t\tmax = -1;\n\t\t\tfor (byte j = 1; j <= ni; j++) {\n\t\t\t\tif (count[j] == 1) {\n\t\t\t\t\tnNew = new boolean[101];\n\t\t\t\t\tpath = new byte[101];\n\t\t\t\t\tsearch(j);\n\t\t\t\t\tfor (byte p = 1; p <= ni; p++) {\n\t\t\t\t\t\tif (path[p] > max) {\n\t\t\t\t\t\t\tmax = path[p];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\ts+=max;\n\t\t}\n\t\t\n\t\tPrintWriter pr = new PrintWriter(new File(\"Output.txt\"));\n\t\tpr.print(s);\n\t\tpr.close();\n\t}\n\n}\n", "label": 3}
{"src": "import java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\n\npublic class f {\n    public static void main(String[] args) throws IOException\n    {\n        Scanner in = new Scanner(new File(\"input.txt\"));\n        PrintWriter out = new PrintWriter(new File(\"output.txt\"));\n        \n        int ans = 0;\n        \n        int spiders = in.nextInt();\n        ArrayList<Integer>[] g;\n        for(int i = 0; i < spiders; i++)\n        {\n            int n = in.nextInt();\n            g = new ArrayList[n];\n            for(int j = 0; j < n; j++)\n                g[j] = new ArrayList<Integer>();\n            \n            for(int j = 0; j < n-1; j++)\n            {\n                int a = in.nextInt()-1;\n                int b = in.nextInt()-1;\n                g[a].add(b);\n                g[b].add(a);\n            }\n            \n            int bestHeight = 0;\n            for(int j = 0; j < n; j++)\n            {\n                int ht = height(g, j);\n                if(ht > bestHeight)\n                    bestHeight = ht;\n            }\n            ans+=bestHeight;\n        }\n        \n        out.println(ans);\n        \n        out.close();\n    }\n    \n    public static int height(ArrayList<Integer>[] g, int start)\n    {\n        LinkedList<Integer> queue = new LinkedList<Integer>();\n        LinkedList<Integer> deep = new LinkedList<Integer>();\n        boolean[] visited = new boolean[g.length];\n        visited[start]=true;\n        int depth = 0;\n        queue.add(start);\n        deep.add(depth);\n        int largest = 0;\n        while(!queue.isEmpty())\n        {\n            int at = queue.pop();\n            int curDep = deep.pop();\n            if(curDep>largest)\n                largest=curDep;\n            \n            for(int i = 0; i < g[at].size(); i++)\n            {\n                if(!visited[g[at].get(i)])\n                {\n                    visited[g[at].get(i)]=true;\n                    queue.add(g[at].get(i));\n                    deep.add(curDep+1);\n                }\n            }\n        }\n        return largest;\n    }\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Spiders {\n\t\n\tstatic int spiders;\n\tstatic int[][] g;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t//BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedReader in = new BufferedReader(new FileReader(\"input.txt\"));\n\t\tPrintWriter out = new PrintWriter(new FileWriter(\"output.txt\"), true);\n\t\tspiders = Integer.parseInt(in.readLine());\n\t\tint res = 0;\n\t\tfor (int spider = 0; spider < spiders; spider++) {\n\t\t\tStringTokenizer st = new StringTokenizer(in.readLine());\n\t\t\tint n = Integer.parseInt(st.nextToken());\n\t\t\tg = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(g[i], 1000000);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\tint a = Integer.parseInt(st.nextToken()) - 1;\n\t\t\t\tint b = Integer.parseInt(st.nextToken()) - 1;\n\t\t\t\tg[a][b] = g[b][a] = 1;\n\t\t\t}\n\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tg[i][j] = Math.min(g[i][j], g[i][k] + g[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint best = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t//out.println(Arrays.toString(g[i]));\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (i == j) continue;\n\t\t\t\t\tbest = Math.max(best, g[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tres += best;\n\t\t}\n\t\tout.println(res);\n\t}\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class CF0120F_Spiders {\n\n\tstatic class Node {\n\t\tint id;\n\t\tArrayList<Integer> connections;\n\t\tint val;\n\n\t\tpublic Node(int i) {\n\t\t\tid = i;\n\t\t\tconnections = new ArrayList<Integer>();\n\t\t\tval = -1;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader reader = new BufferedReader(new FileReader(\"input.txt\"));\n\t\tPrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n\t\tStringTokenizer finder = new StringTokenizer(reader.readLine());\n\t\tint spiders = Integer.parseInt(finder.nextToken());\n\t\tint count = 0;\n\t\tfor (int s = 0; s < spiders; s++) {\n\t\t\tfinder = new StringTokenizer(reader.readLine());\n\t\t\tint n = Integer.parseInt(finder.nextToken());\n\t\t\tNode[] nodes1 = new Node[n];\n\t\t\tNode[] nodes2 = new Node[n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tnodes1[i] = new Node(i);\n\t\t\t\tnodes2[i] = new Node(i);\n\n\t\t\t}\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint n1 = Integer.parseInt(finder.nextToken()) - 1;\n\t\t\t\tint n2 = Integer.parseInt(finder.nextToken()) - 1;\n\t\t\t\tnodes1[n1].connections.add(n2);\n\t\t\t\tnodes1[n2].connections.add(n1);\n\t\t\t\tnodes2[n1].connections.add(n2);\n\t\t\t\tnodes2[n2].connections.add(n1);\n\t\t\t}\n\n\t\t\tQueue<Node> q = new LinkedList<Node>();\n\t\t\tnodes1[0].val = 0;\n\t\t\tq.add(nodes1[0]);\n\t\t\tint firstNode = -1;\n\t\t\tint firstVal = 0;\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode node = q.poll();\n\n\t\t\t\tfor (int i = 0; i < node.connections.size(); i++) {\n\t\t\t\t\tif (nodes1[node.connections.get(i)].val == -1) {\n\t\t\t\t\t\tnodes1[node.connections.get(i)].val = node.val + 1;\n\t\t\t\t\t\tq.add(nodes1[node.connections.get(i)]);\n\t\t\t\t\t\tif (firstVal < node.val + 1) {\n\t\t\t\t\t\t\tfirstVal = node.val + 1;\n\t\t\t\t\t\t\tfirstNode = node.connections.get(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tnodes2[firstNode].val = 0;\n\t\t\tq.add(nodes2[firstNode]);\n\t\t\tint secondVal = 0;\n\t\t\twhile (!q.isEmpty()) {\n\t\t\t\tNode node = q.poll();\n\n\t\t\t\tfor (int i = 0; i < node.connections.size(); i++) {\n\t\t\t\t\tif (nodes2[node.connections.get(i)].val == -1) {\n\t\t\t\t\t\tnodes2[node.connections.get(i)].val = node.val + 1;\n\t\t\t\t\t\tq.add(nodes2[node.connections.get(i)]);\n\t\t\t\t\t\tif (secondVal < node.val + 1) {\n\t\t\t\t\t\t\tsecondVal = node.val + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcount += secondVal;\n\t\t}\n\t\twriter.println(count);\n\t\twriter.close();\n\t\treader.close();\n\t}\n\n}\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\n\npublic class CodeA \n{\n\tstatic boolean DEBUG = false;\n\tstatic class Scanner\n\t{\n\t\t\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tBufferedWriter bw;\n\n\t\tpublic Scanner()\n\t\t{ \n\t\t\tif(DEBUG)\n\t\t\t{\n\t\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t\tbw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t\t}\n\t\t\telse\n\t\t\t\ttry \n\t\t\t\t{\n\t\t\t\t\tbr = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\t\t\tbw = new BufferedWriter(new FileWriter(\"output.txt\"));\n\t\t\t\t} \n\t\t\t\tcatch (Exception e) \n\t\t\t\t{\n\t\t\t\t}\n\t\t}\n\n\t\tpublic String next()\n\t\t{\n\n\t\t\twhile(st == null || !st.hasMoreTokens())\n\t\t\t{\n\t\t\t\ttry { st = new StringTokenizer(br.readLine()); }\n\t\t\t\tcatch(Exception e) { throw new RuntimeException(); }\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tpublic int nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tpublic double nextDouble()\n\t\t{\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tpublic String nextLine()\n\t\t{\n\t\t\tst = null;\n\t\t\ttry { return br.readLine(); }\n\t\t\tcatch(Exception e) { throw new RuntimeException(); }\n\t\t}\n\n\t\tpublic boolean endLine()\n\t\t{\n\t\t\ttry \n\t\t\t{\n\t\t\t\tString next = br.readLine();\n\t\t\t\twhile(next != null && next.trim().isEmpty())\n\t\t\t\t\tnext = br.readLine();\n\t\t\t\tif(next == null)\n\t\t\t\t\treturn true;\n\t\t\t\tst = new StringTokenizer(next);\n\t\t\t\treturn st.hasMoreTokens();\n\t\t\t}\n\t\t\tcatch(Exception e) { throw new RuntimeException(); }\n\t\t}\n\t\t\n\t\tpublic void print(String s)\n\t\t{\n\t\t\ttry \n\t\t\t{\n\t\t\t\tbw.write(s);\n\t\t\t} \n\t\t\tcatch (IOException e) \n\t\t\t{\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic void println(String s)\n\t\t{\n\t\t\tprint(s);\n\t\t\tprint(\"\\n\");\n\t\t}\n\t}\n\t\n\tstatic class Nodo\n\t{\n\t\tArrayList <Nodo> aristas = new ArrayList <Nodo> ();\n\t\t\n\t\tint dfs(Nodo anterior)\n\t\t{\n\t\t\tint max = 0;\n\t\t\tfor(Nodo n : aristas)\n\t\t\t\tif(n != anterior)\n\t\t\t\t\tmax = Math.max(max, n.dfs(this) + 1);\n\t\t\treturn max;\n\t\t}\n\t}\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt();\n\t\tint ans = 0;\n\t\tfor(int sp = 0; sp < n; sp++)\n\t\t{\n\t\t\tint nAct = sc.nextInt();\n\t\t\tNodo[] este = new Nodo[nAct];\n\t\t\tfor(int i = 0; i < nAct; i++)\n\t\t\t\teste[i] = new Nodo();\n\t\t\tfor(int i = 0; i < nAct - 1; i++)\n\t\t\t{\n\t\t\t\tint a = sc.nextInt() - 1, b = sc.nextInt() - 1;\n\t\t\t\teste[a].aristas.add(este[b]);\n\t\t\t\teste[b].aristas.add(este[a]);\n\t\t\t}\n\t\t\tint max = 0;\n\t\t\tfor(int i = 0; i < nAct; i++)\n\t\t\t\tmax = Math.max(max, este[i].dfs(null));\n\t\t\tans += max;\n\t\t}\n\t\tsc.println(ans + \"\");\n\t\tsc.bw.flush();\n\t\tsc.bw.close();\n\t}\n\n}\n", "label": 3}
{"src": "import java.util.List;\nimport java.util.Scanner;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.io.OutputStream;\nimport java.io.FileOutputStream;\nimport java.io.PrintWriter;\nimport java.io.FileInputStream;\nimport java.util.Queue;\nimport java.util.LinkedList;\nimport java.util.Collection;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author \"Johan Sannemo\"\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream;\n        try {\n            inputStream = new FileInputStream(\"input.txt\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        OutputStream outputStream;\n        try {\n            outputStream = new FileOutputStream(\"output.txt\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskF {\n\n    static int[] bfsLongest(List<List<Integer>> tree, int source){\n        int[] dist = new int[tree.size()];\n        Queue<Integer> q = new LinkedList<Integer>();\n        Arrays.fill(dist, 10000);\n        dist[source] = 0;\n        q.add(source);\n        while(!q.isEmpty()){\n            int cur = q.poll();\n            int sof = dist[cur]+1;\n            for(Integer i : tree.get(cur)){\n                if(dist[i] == 10000){\n                    q.add(i);\n                }\n                dist[i] = Math.min(dist[i], sof);\n            }\n        }\n        int bestNode = source, bestDist = 0;\n        for(int i = 0; i<tree.size(); i++){\n            if(dist[i] > bestDist) {\n                bestDist = dist[i];\n                bestNode = i;\n            }\n        }\n        return new int[]{bestNode, bestDist};\n    }\n\n    static int diam(List<List<Integer>> tree){\n        int ni = bfsLongest(tree, 0)[0];\n        return bfsLongest(tree, ni)[1];\n    }\n\n    public void solve(int testNumber, Scanner in, PrintWriter out) {\n        int n = in.nextInt();\n        int ans = 0;\n        for(int i = 0; i<n; i++){\n            int nodes = in.nextInt();\n            List<List<Integer>> tree = new ArrayList<List<Integer>>();\n            for(int j = 0; j<nodes; j++) tree.add(new LinkedList<Integer>());\n            for(int j = 1; j < nodes; j++){\n                int t = in.nextInt(),  f = in.nextInt();\n                t--;\n                f--;\n                tree.get(t).add(f);\n                tree.get(f).add(t);\n            }\n            ans += diam(tree);\n        }\n        out.println(ans);\n    }\n}\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\n\npublic class F {\n    private void solve() throws IOException {\n        int T = nextInt();\n        int res = 0;\n        while(T-->0) {\n            int n = nextInt();\n            int[][] a = new int[n][n];\n            for (int i = 0; i < a.length; i++) {\n                for (int j = 0; j < a.length; j++) {\n                    a[i][j] = 1<<29;\n                }\n                a[i][i] = 0;\n            }\n            for (int i = 0; i < n - 1; i++) {\n                int f = nextInt() - 1;\n                int s = nextInt() - 1;\n                if (f != s)\n                    a[f][s] = a[s][f] = 1;\n            }\n            \n            for (int k = 0; k < n; k++) {\n                for (int i = 0; i < n; i++) {\n                    for (int j = 0; j < n; j++) {\n                        a[i][j] = Math.min(a[i][j], a[i][k] + a[k][j]);\n                    }\n                }\n            }\n            \n            int max = 0;\n            for (int i = 0; i < a.length; i++) {\n                for (int j = 0; j < a.length; j++) {\n                    max = Math.max(max, a[i][j]);\n                }\n            }\n            res += max;\n            \n        }\n        writer.println(res);\n    }\n\n    public static void main(String[] args) {\n        new F().run();\n    }\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer;\n\n    public void run() {\n        try {\n            reader = new BufferedReader(new FileReader(\"input.txt\"));\n            tokenizer = null;\n            writer = new PrintWriter(\"output.txt\");\n            solve();\n            reader.close();\n            writer.close();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    BigInteger nextBigInteger() throws IOException {\n        return new BigInteger(nextToken());\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Spiders {\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner in = new Scanner(new File(\"input.txt\"));\n\t\tPrintWriter out = new PrintWriter(new File(\"output.txt\"));\n//\t\tPrintWriter out = new PrintWriter(System.out);\n//\t\tin.init(System.in);\n\t\tint n = in.nextInt();\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < n; i ++)\n\t\t{\n\t\t\tint m = in.nextInt();\n\t\t\tArrayList<Integer>[] adj = new ArrayList[m];\n\t\t\tfor(int j = 0; j < m; j ++)\n\t\t\t\tadj[j] = new ArrayList<Integer>();\n\t\t\tfor(int j = 0; j < m-1; j ++)\n\t\t\t{\n\t\t\t\tint a = in.nextInt() - 1;\n\t\t\t\tint b = in.nextInt() - 1;\n\t\t\t\tadj[a].add(b);\n\t\t\t\tadj[b].add(a);\n\t\t\t}\n\t\t\tans += getDiameter(adj);\n\t\t}\n\t\n\t\tout.println(ans);\n\t\tout.close();\n\t}\n\t\n\tstatic int getDiameter(ArrayList<Integer>[] adj)\n\t{\n\t\tint[] vis = BFS(adj, 0);\n\t\tint n = vis.length;\n\t\tint max = -1;\n\t\tint maxi = -1;\n\t\tfor(int i = 0; i < n; i ++)\n\t\t{\n\t\t\tif(vis[i] > max)\n\t\t\t{\n\t\t\t\tmax = vis[i];\n\t\t\t\tmaxi = i;\n\t\t\t}\n\t\t}\n\t\tvis = BFS(adj, maxi);\n\t\tmax = -1;\n\t\tfor(int i = 0; i < n; i ++)\n\t\t\tmax = Math.max(vis[i],  max);\n\t\treturn max;\n\t}\n\n\tstatic int[] BFS(ArrayList<Integer>[] adj, int start)\n\t{\n\t\tint n = adj.length;\n\t\tArrayDeque<Integer> q = new ArrayDeque<Integer>();\n\t\tint[] dist = new int[n];\n\t\tint[] parent = new int[n];\n\t\tparent[start] = -1;\n\t\tdist[start] = 0;\n\t\tq.add(start);\n\t\twhile(!q.isEmpty())\n\t\t{\n\t\t\tint at = q.poll();\n\t\t\tfor(int e: adj[at])\n\t\t\t{\n\t\t\t\tif(e == parent[at])\n\t\t\t\t\tcontinue;\n\t\t\t\tdist[e] = dist[at] + 1;\n\t\t\t\tparent[e] = at;\n\t\t\t\tq.add(e);\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t}\n\t\n\tpublic static class in {\n\t    static BufferedReader reader;\n\t    static StringTokenizer tokenizer;\n\n\t    static void init(InputStream in) {\n\t        reader = new BufferedReader(\n\t                     new InputStreamReader(in) );\n\t        tokenizer = new StringTokenizer(\"\");\n\t    }\n\n\t    static String next() throws IOException {\n\t        while ( ! tokenizer.hasMoreTokens() ) {\n\t            tokenizer = new StringTokenizer(\n\t                   reader.readLine() );\n\t        }\n\t        return tokenizer.nextToken();\n\t    }\n\n\t    static int nextInt() throws IOException {\n\t        return Integer.parseInt( next() );\n\t    }\n\t\t\n\t    static double nextDouble() throws IOException {\n\t        return Double.parseDouble( next() );\n\t    }\n\t    static long nextLong() throws IOException {\n\t        return Long.parseLong( next() );\n\t    }\n\t}\n}\n", "label": 3}
{"src": "import java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class F {\n    static ArrayList<ArrayList<Integer>> grid;\n    static int l;\n    static boolean vis[];\n    public static int dfs(int node) {\n        if(vis[node]) return 0;\n        vis[node]=true;\n        int max=0;\n        for(int i=0;i<grid.get(node).size();i++) {\n            max=Math.max(max, dfs(grid.get(node).get(i)));\n        }\n        return max+1;\n    }\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(new FileReader(\"input.txt\"));\n        //Scanner sc=new Scanner(System.in);\n        FileWriter fw = new FileWriter(\"output.txt\");\n        int trees=sc.nextInt();\n        int res=0;\n        for(int i=0;i<trees;i++) {\n            grid=new ArrayList<ArrayList<Integer>>();\n            l=sc.nextInt();\n            for(int j=0;j<l;j++) grid.add(new ArrayList<Integer>());\n            \n            for(int j=1;j<l;j++) {\n                int st=sc.nextInt();\n                int e=sc.nextInt();\n                grid.get(st-1).add(e-1);\n                grid.get(e-1).add(st-1);\n            }\n            \n            int max=0;\n            for(int j=0;j<l;j++) {\n                vis=new boolean[l];\n                max=Math.max(max,dfs(j));\n            }\n            res+=(max-1);\n        }\n        fw.write(res+\"\\n\");\n        fw.flush();\n        System.out.println(res);\n    }\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\npublic final class code\n// public class Main\n// class code\n// public class Solution\n{\n    static int k;\n    static ArrayList<ArrayList<Integer>> list;\n    static void solve()throws IOException\n    {\n        int n=nextInt();\n        int ans=0;\n        for(int i=1;i<=n;i++)\n        {\n            k=nextInt();\n            list=new ArrayList<>();\n            for(int j=0;j<=k;j++)\n                list.add(new ArrayList<Integer>());\n            for(int j=1;j<k;j++)\n            {\n                int u=nextInt();\n                int v=nextInt();\n                list.get(u).add(v);\n                list.get(v).add(u);\n            }\n            int diameter=farthest(farthest(1).first).second;\n            ans+=diameter;\n        } \n        out.println(ans);\n    }\n    static Pair farthest(int v)\n    {\n        Queue<Pair> queue=new LinkedList<>();\n        boolean visited[]=new boolean[k+1];\n        queue.add(new Pair(v,0));\n        visited[v]=true;\n        Pair max=new Pair(v,0);\n        while(queue.isEmpty()==false)\n        {\n            Pair p=queue.remove();\n            if(p.second>max.second)\n                max=p;\n            for(int i:list.get(p.first))\n            {\n                if(visited[i]==false)\n                {\n                    queue.add(new Pair(i,p.second+1));\n                    visited[i]=true;\n                }\n            }\n        }\n        return max;\n    }\n    static class Pair\n    {\n        int first,second;\n        Pair(int a,int b)\n        {\n            first=a;\n            second=b;\n        }\n        public boolean equals(Object o)\n        {\n            if(o==null)\n                return false;\n            Pair p=(Pair)o;\n            return first==p.first?second==p.second:false;\n        }\n        public int hashCode()\n        {\n            return (int)((1l*first*inf+second)%mod);\n        }\n        public String toString()\n        {\n            return first+\" \"+second;\n        }\n    }\n\n     \n    ///////////////////////////////////////////////////////////\n\n    static final long mod=(long)(1e9+7);\n    static final int inf=(int)(1e9+1);\n    static final int maxn=(int)(1e6);\n    static final long lim=(long)(1e18);\n\n    public static void main(String args[])throws IOException\n    {\n        br=new BufferedReader(new InputStreamReader(new FileInputStream(\"input.txt\")));\n        out=new PrintWriter(new FileOutputStream(\"output.txt\"));\n        \n        solve();\n         \n        // int t=nextInt();\n        // for(int i=1;i<=t;i++)\n        // {\n        //    // out.print(\"Case #\"+i+\": \");\n        //     solve();\n        // }\n         \n        out.close();\n    }\n    \n    static int max(int ... a)\n    {\n    int ret=a[0];\n    for(int i=1;i<a.length;i++)\n    ret=Math.max(ret,a[i]);\n    return ret;\n    }\n    static int min(int ... a)\n    {\n    int ret=a[0];\n    for(int i=1;i<a.length;i++)\n    ret=Math.min(ret,a[i]);\n    return ret;\n    }\n    static void debug(Object ... a)\n    {\n    System.out.print(\"> \");\n    for(int i=0;i<a.length;i++)\n    System.out.print(a[i]+\" \");\n    System.out.println();\n    }\n    static void debug(int a[]){debuga(Arrays.stream(a).boxed().toArray());}\n    static void debug(long a[]){debuga(Arrays.stream(a).boxed().toArray());}\n    static void debuga(Object a[])\n    {\n    System.out.print(\"> \");\n    for(int i=0;i<a.length;i++)\n    System.out.print(a[i]+\" \");\n    System.out.println();\n    }\n    static Random random;\n    static BufferedReader br;\n    static StringTokenizer st;\n    static PrintWriter out;\n    static String nextToken()throws IOException\n    {\n    while(st==null || !st.hasMoreTokens())\n    st=new StringTokenizer(br.readLine());\n    return st.nextToken();\n    }\n    static String nextLine()throws IOException\n    {\n    return br.readLine();\n    }\n    static int nextInt()throws IOException\n    {\n    return Integer.parseInt(nextToken());\n    }\n    static long nextLong()throws IOException\n    {\n    return Long.parseLong(nextToken());\n    }\n    static double nextDouble()throws IOException\n    {\n    return Double.parseDouble(nextToken());\n    }\n}", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main { \n    \n    static boolean FROM_FILE = true;\n    \n    static class FastReader { \n        BufferedReader br; \n        StringTokenizer st; \n        public FastReader() { \n            if (FROM_FILE) {\n                try {\n                    br = new BufferedReader(new FileReader(\"input.txt\")); \n                } catch (IOException error) {\n                }   \n            } else {\n                br = new BufferedReader(new InputStreamReader(System.in));    \n            }\n        }\n        String next() { \n            while (st == null || !st.hasMoreElements()) { \n                try { \n                    st = new StringTokenizer(br.readLine()); \n                } catch (IOException  e) { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        }\n        int nextInt() { \n            return Integer.parseInt(next()); \n        }\n        long nextLong() { \n            return Long.parseLong(next()); \n        }\n  \n        double nextDouble() { \n            return Double.parseDouble(next()); \n        } \n        String nextLine() { \n            String str = \"\"; \n            try { \n                str = br.readLine(); \n            } catch (IOException e) { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n    \n    public static void main(String[] args) { \n        FastReader fr = new FastReader(); \n        PrintWriter out = null;\n        if (FROM_FILE) {\n            try {\n                out = new PrintWriter(new FileWriter(\"output.txt\"));\n            } catch (IOException error) {\n                \n            }\n        } else {\n            out = new PrintWriter(new OutputStreamWriter(System.out));\n        }\n        int t = fr.nextInt();\n        int total = 0;\n        while (t-- > 0) {\n            int n = fr.nextInt();\n            ArrayList<Integer>[] adj = new ArrayList[n + 1];\n            for (int i = 1; i <= n; i += 1) adj[i] = new ArrayList<Integer>();\n            int[] degree = new int[n + 1];\n            for (int i = 0; i < n - 1; i += 1) {\n                int a = fr.nextInt(), b = fr.nextInt();\n                adj[a].add(b); adj[b].add(a);\n                degree[a] += 1; degree[b] += 1;\n            }\n            ArrayList<Integer> cur = new ArrayList<Integer>();\n            for (int i = 1; i <= n; i += 1) cur.add(i);\n            int step = 0, re = 0;\n            while (true) {\n                ArrayList<Integer> leaves = new ArrayList<Integer>(cur); leaves.removeIf((e) -> degree[e] != 1);\n                // out.print(\"leaves: \"); out.println(leaves);\n                cur.removeIf((e) -> degree[e] == 1);\n                if (leaves.size() <= 1) {\n                    if (leaves.size() == 1) re = 0;\n                    else re = cur.size() - 1;\n                    break;\n                }\n                for (Integer u : leaves) {\n                    for (Integer v : adj[u]) {\n                        if (degree[v] > 1) degree[v] -= 1;\n                    }\n                }\n                step += 1;\n            }\n            // out.println(\"step: \" + step + \" \" + re);\n            // out.println(\"added: \" + (step * 2 + re));\n            total += step * 2 + re;\n        }\n        out.println(total);\n        \n        out.flush();\n    } \n} ", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\npublic class test {\n    static boolean[][] adj;\n    public static void main(String[] args) throws Exception{\n        Scanner sc = new Scanner(new File(\"input.txt\"));\n        PrintWriter out = new PrintWriter(new File(\"output.txt\"));\n        int spiders =Integer.parseInt(sc.nextLine());\n        int total=0;\n        for(int s=0;s<spiders;s++){\n            String in = sc.nextLine();\n            Scanner SB = new Scanner(in);\n            \n            int nodes = SB.nextInt();\n            adj = new boolean[nodes][nodes];\n            while(SB.hasNextInt()){\n                int f = SB.nextInt()-1;\n                int g = SB.nextInt()-1;\n                adj[f][g]=adj[g][f]=true;\n            }\n            int max = 0;\n            for(int a=0;a<nodes;a++){\n                max=Math.max(max, DFS(a, new boolean[nodes],0));\n            }\n            total+=max;\n        }\n        \n        out.println(total);\n        out.close();\n        \n\n    }\n\n    private static int DFS(int b, boolean[] bs,int l ) {\n        int max = l;\n        bs[b]=true;\n        for(int a=0;a<bs.length;a++){\n            if(!bs[a]&&adj[b][a])\n                max = Math.max(DFS(a,bs,l+1),max);\n        }\n        return max;\n    }\n\n}\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author unknown\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream;\n        try {\n            inputStream = new FileInputStream(\"input.txt\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        OutputStream outputStream;\n        try {\n            outputStream = new FileOutputStream(\"output.txt\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        FSpidersByFindingDiaWith2DFSes solver = new FSpidersByFindingDiaWith2DFSes();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FSpidersByFindingDiaWith2DFSes {\n        int largestDia = 0;\n        int farthestNode = 0;\n        ArrayList<Integer>[] graph;\n        int[] depth;\n        int maxDepth = 0;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int tlength = 0;\n            for (int k = 0; k < n; k++) {\n                int m = in.nextInt();\n                largestDia = 0;\n                farthestNode = 0;\n                graph = new ArrayList[m + 1];\n                depth = new int[m + 1];\n                maxDepth = 0;\n                for (int i = 0; i < m + 1; i++) {\n                    graph[i] = new ArrayList<>();\n                }\n                for (int i = 0; i < (m - 1); i++) {\n                    int u = in.nextInt();\n                    int v = in.nextInt();\n                    graph[u].add(v);\n                    graph[v].add(u);\n                }\n                tlength += getDiameter(graph);\n            }\n            out.println(tlength);\n        }\n\n        int getDiameter(ArrayList<Integer>[] graph) {\n            dfs(1, 0);\n            Arrays.fill(depth, 0);\n            maxDepth = 0;\n            dfs(farthestNode, 0);\n            return maxDepth - 1;\n        }\n\n        void dfs(int to, int from) {\n            depth[to] = depth[from] + 1;\n            if (depth[to] > maxDepth) {\n                maxDepth = depth[to];\n                farthestNode = to;\n            }\n            for (var node : graph[to]) {\n                if (node != from) {\n                    dfs(node, to);\n                }\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class F120 {\n\tPrintWriter out;\n\tBufferedReader bf;\n\tStringTokenizer st ;\n\tboolean u[];\n\tArrayList<Integer> g[];\n\tint INF = Integer.MAX_VALUE / 2;\n\n\tprivate void solution() throws IOException {\n\n\t\tint k = nextInt();\n\t\tint Res = 0;\n\t\twhile (k > 0) {\n\t\t\tint n = nextInt(), lol = 0;\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tg[i] = new ArrayList<Integer>();\n\t\t\t}\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tint a = nextInt() - 1;\n\t\t\t\tint b = nextInt() - 1;\n\t\t\t\tg[a].add(b);\n\t\t\t\tg[b].add(a);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tu = new boolean[n];\n\t\t\t\tlol = Math.max(dfs(i), lol);\n\t\t\t}\n\t\t\tRes = Res + lol;\n\t\t\tk--;\n\t\t}\n\t\t out.println(Res);\n\t}\n\t public void File() throws IOException {\n         bf = new BufferedReader(new FileReader(new File(\"input.txt\")));\n         out = new PrintWriter(new File(\"output.txt\"));\n         st = null;\n         solution();\n         bf.close();\n         out.close(); \n }\n\t// ---------------------------------------------------------------------------\n\tprivate int dfs(int v) {\n\t\tu[v] = true;\n\t\tint res = 0;\n\t\tfor (int i : g[v])\n\t\t\tif (!u[i])\n\t\t\t\tres = Math.max(res, dfs(i) + 1);\n\t\treturn res;\n\t}\n\n\t// ---------------------------------------------------------------------------\n\tString nextToken() throws IOException {\n        if (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(bf.readLine());\n        }\n        return st.nextToken();\n    }\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew F120().File();\n\t}\n}", "label": 3}
{"src": "import java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n\npublic class F {\n\n    static ArrayList<Integer>[]ages;\n    static int[]d;\n    \n    public static void main(String[] args) throws IOException{\n        Scanner sc = new Scanner(new File(\"input.txt\"));\n        PrintWriter pw = new PrintWriter(new File(\"output.txt\"));\n        int m = sc.nextInt();\n        int ans = 0;\n        for (int i = 1; i <= m; i++) {\n            int n = sc.nextInt();\n            ages = new ArrayList[n+1];\n            for (int j = 1; j <= n; j++) {\n                ages[j] = new ArrayList<Integer>();\n            }\n            for (int j = 1; j < n; j++) {\n                int v1 = sc.nextInt();\n                int v2 = sc.nextInt();\n                ages[v1].add(v2);\n                ages[v2].add(v1);\n            }\n            d = new int[n+1];\n            int max = 0;\n            for (int j = 1; j <= n; j++) {\n                d[j] = 0;\n                dfs(j, 0);\n                for (int j2 = 1; j2 <= n; j2++) {\n                    if (d[j2] > max)\n                        max = d[j2];\n                }\n            }\n            ans += max;\n        }\n        pw.println(ans);\n        pw.close();\n    }\n\n    private static void dfs(int v, int p) {\n        for (int to : ages[v]) {\n            if (to != p) {\n                d[to] = d[v]+1;\n                dfs(to, v);\n            }\n        }\n    }\n\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class cf_120f {\n\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tScanner in = new Scanner(new File(\"input.txt\"));\n\t\tPrintWriter out = new PrintWriter(new File(\"output.txt\"));\n\t\tint s = in.nextInt();\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < s; i++) {\n\t\t\tint n = in.nextInt();\n\t\t\tArrayList<Integer>[] list = new ArrayList[100];\n\t\t\tfor (int j = 0; j < list.length; j++) {\n\t\t\t\tlist[j] = new ArrayList<Integer>();\n\t\t\t}\n\t\t\tfor (int j = 1; j < n; j++) {\n\t\t\t\tint a = in.nextInt(), b = in.nextInt();\n\t\t\t\tlist[a-1].add(b-1);\n\t\t\t\tlist[b-1].add(a-1);\n\t\t\t}\n\t\t\tint maxLength = 0;\n\t\t\tfor (int j = 0; j < list.length; j++) {\n\t\t\t\tArrayDeque<Integer> stk = new ArrayDeque<Integer>();\n\t\t\t\tint[] been = new int[100];\n\t\t\t\tArrays.fill(been, -1);\n\t\t\t\tbeen[j] = 0;\n\t\t\t\tstk.push(j);\n\t\t\t\twhile(!stk.isEmpty()){\n\t\t\t\t\tint cur = stk.pop();\n\t\t\t\t\tfor(Integer k : list[cur]) {\n\t\t\t\t\t\tif(been[k]==-1){\n\t\t\t\t\t\t\tbeen[k] = been[cur]+1;\n\t\t\t\t\t\t\tmaxLength = maxLength>been[k]?maxLength:been[k];\n\t\t\t\t\t\t\tstk.push(k);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=maxLength;\n\t\t}\n\t\tout.println(ans);\n\t\tout.close();\n\t}\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Main implements Runnable {\n\tprivate BufferedReader in;\n\tprivate PrintWriter out;\n\tprivate StringTokenizer st;\n\tprivate Random rnd;\n\t\n\tboolean[] used = new boolean[100];\n\tboolean[][] g = new boolean[100][100];\n\tint n;\n\t\n\tprivate int dfs(int u) {\n\t\tused[u] = true;\n\t\t\n\t\tint add = 0;\n\t\t\n\t\tfor(int v = 0; v < n; v++) {\n\t\t\tif(!g[u][v]) continue;\n\t\t\tif(used[v]) continue;\n\t\t\tadd = Math.max(add, 1 + dfs(v));\n\t\t}\n\t\t\n\t\treturn add;\n\t}\n\t\n\tpublic void solve() throws IOException {\n\t\tint k = nextInt();\n\t\tint ans = 0;\n\t\t\n\t\tfor(int t = 0; t < k; t++) {\n\t\t\tn = nextInt();\n\t\t\t\n\t\t\tfor(int i = 0; i < 100; i++) Arrays.fill(g[i], false);\n\t\t\t\n\t\t\tfor(int i = 0; i < n - 1; i++) {\n\t\t\t\tint u = nextInt() - 1;\n\t\t\t\tint v = nextInt() - 1;\n\t\t\t\tg[u][v] = true;\n\t\t\t\tg[v][u] = true;\n\t\t\t}\n\t\t\t\n\t\t\tint cur_max = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(used, false);\n\t\t\t\t\n\t\t\t\tcur_max = Math.max(cur_max, dfs(i));\n\t\t\t}\n\t\t\t\n\t\t\tans += cur_max;\n\t\t}\n\t\t\n\t\tout.println(ans);\n\t}\n\t\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t} \n\t\n\tpublic void run() {\n\t\ttry {\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\t\t\n\t\t\t//in = new BufferedReader(new InputStreamReader((System.in)));\n\t\t\t//out = new PrintWriter(System.out);\n\t\t\t\n\t\t\tst = null;\n\t\t\trnd = new Random();\n\t\t\t\n\t\t\tsolve();\n\t\t\t\n\t\t\tout.close();\n\t\t} catch(IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tprivate String nextToken() throws IOException, NullPointerException {\n\t\twhile(st == null || !st.hasMoreTokens()) {\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\t}\n\t\t\n\t\treturn st.nextToken();\n\t}\n\t\n\tprivate int nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\t\n\tprivate long nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\t\n\tprivate double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n}", "label": 3}
{"src": "import java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Scanner;\n\npublic class CF6 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = null;\n\t\ttry {\n\t\t\tscanner = new Scanner(new FileInputStream(new File(\"input.txt\")));\n\t\t} catch (FileNotFoundException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\tint n = scanner.nextInt();\n\t\tint ret = 0;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint ni = scanner.nextInt();\n\t\t\tint[][] mat = new int[ni][ni];\n\t\t\tfor (int j = 0; j < ni - 1; j++) {\n\t\t\t\tint p1 = scanner.nextInt();\n\t\t\t\tint p2 = scanner.nextInt();\n\t\t\t\tmat[p1 - 1][p2 - 1] = 1;\n\t\t\t\tmat[p2 - 1][p1 - 1] = 1;\n\t\t\t}\n\t\t\tmaxd = 0;\n\t\t\tdfs(mat, ni);\n\t\t\tret += maxd;\n\t\t}\n\n\t\ttry {\n\t\t\tBufferedWriter out = new BufferedWriter(\n\t\t\t\t\tnew FileWriter(\"output.txt\"));\n\n\t\t\tout.write(String.valueOf(ret));\n\t\t\tout.close();\n\t\t} catch (FileNotFoundException e1) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te1.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tstatic int maxd;\n\n\tpublic static void dfs(int[][] mat, int n) {\n\t\tmaxd = 0;\n\n\t\tint state[] = new int[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tstate[j] = 0;\n\t\t\t}\n\t\t\trunDFS(mat, i, state, n, 0);\n\t\t}\n\n\t}\n\n\tstatic void runDFS(int[][] mat, int u, int[] state, int n, int depth) {\n\t\tif (maxd < depth)\n\t\t\tmaxd = depth;\n\t\tstate[u] = 1;\n\n\t\tfor (int v = 0; v < n; v++)\n\n\t\t\tif (mat[u][v] == 1 && state[v] == 0)\n\t\t\t\trunDFS(mat, v, state, n, depth + 1);\n\n\t\tstate[u] = 2;\n\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.util.*;\npublic class icpc\n{\n    public static void main(String[] args) throws IOException\n    {\n        //BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\n        Scanner in = new Scanner(new File(\"input.txt\"));\n        PrintWriter out = new PrintWriter(new File(\"output.txt\"));\n        int n = in.nextInt();\n        int ans = 0;\n        for (int i=0;i<n;i++)\n        {\n            int m = in.nextInt();\n            ArrayList<Integer>[] adj = (ArrayList<Integer>[])new ArrayList[m];\n            for (int j=0;j<m;j++)\n                adj[j] = new ArrayList<>();\n            for (int j=0;j<m - 1;j++)\n            {\n                int a = in.nextInt() - 1;\n                int b = in.nextInt() - 1;\n                adj[a].add(b);\n                adj[b].add(a);\n            }\n            ans += findDiameter(adj);\n        }\n        out.println(ans);\n        out.close();\n    }\n    public static int findDiameter(ArrayList<Integer>[] adj)\n    {\n        int node = DFS(adj, 0, 0);\n        return DFS(adj, 1, node);\n    }\n    public static int DFS(ArrayList<Integer>[] adj, int f, int u)\n    {\n        int n = adj.length;\n        boolean[] visited = new boolean[n];\n        int[] distance = new int[n];\n        explore(adj, visited, distance, u, 0);\n        int max = 0;\n        int node = -1;\n        for (int i=0;i<n;i++)\n        {\n            if (distance[i] > max)\n            {\n                max = distance[i];\n                node = i;\n            }\n        }\n        if (f == 0)\n            return node;\n        else\n            return max;\n    }\n    public static void explore(ArrayList<Integer>[] adj, boolean[] visited, int[] distance, int v, int count)\n    {\n        visited[v] = true;\n        distance[v] = count;\n        for (int i=0;i<adj[v].size();i++)\n        {\n            if (!visited[adj[v].get(i)])\n            {\n                explore(adj, visited, distance, adj[v].get(i), count + 1);\n            }\n        }\n    }\n}\nclass DSU\n{\n    int[] parent;\n    int[] size;\n    //Pass number of total nodes as parameter to the constructor\n    DSU(int n)\n    {\n        this.parent = new int[n];\n        this.size = new int[n];\n        Arrays.fill(parent, -1);\n    }\n\n    public void makeSet(int v)\n    {\n        parent[v] = v;\n        size[v] = 1;\n    }\n\n    public int findSet(int v)\n    {\n        if (v == parent[v]) return v;\n        return parent[v] = findSet(parent[v]);\n    }\n\n    public void unionSets(int a, int b)\n    {\n        a = findSet(a);\n        b = findSet(b);\n        if (a != b)\n        {\n            if (size[a] < size[b])\n            {\n                int temp = a;\n                a = b;\n                b = temp;\n            }\n            parent[b] = a;\n            size[a] += size[b];\n        }\n    }\n}\nclass FastFourierTransform\n{\n    private void fft(double[] a, double[] b, boolean invert)\n    {\n        int count = a.length;\n        for (int i = 1, j = 0; i < count; i++)\n        {\n            int bit = count >> 1;\n            for (; j >= bit; bit >>= 1)\n                j -= bit;\n            j += bit;\n            if (i < j)\n            {\n                double temp = a[i];\n                a[i] = a[j];\n                a[j] = temp;\n                temp = b[i];\n                b[i] = b[j];\n                b[j] = temp;\n            }\n        }\n        for (int len = 2; len <= count; len <<= 1)\n        {\n            int halfLen = len >> 1;\n            double angle = 2 * Math.PI / len;\n            if (invert)\n                angle = -angle;\n            double wLenA = Math.cos(angle);\n            double wLenB = Math.sin(angle);\n            for (int i = 0; i < count; i += len)\n            {\n                double wA = 1;\n                double wB = 0;\n                for (int j = 0; j < halfLen; j++)\n                {\n                    double uA = a[i + j];\n                    double uB = b[i + j];\n                    double vA = a[i + j + halfLen] * wA - b[i + j + halfLen] * wB;\n                    double vB = a[i + j + halfLen] * wB + b[i + j + halfLen] * wA;\n                    a[i + j] = uA + vA;\n                    b[i + j] = uB + vB;\n                    a[i + j + halfLen] = uA - vA;\n                    b[i + j + halfLen] = uB - vB;\n                    double nextWA = wA * wLenA - wB * wLenB;\n                    wB = wA * wLenB + wB * wLenA;\n                    wA = nextWA;\n                }\n            }\n        }\n        if (invert)\n        {\n            for (int i = 0; i < count; i++)\n            {\n                a[i] /= count;\n                b[i] /= count;\n            }\n        }\n    }\n\n    public long[] multiply(long[] a, long[] b)\n    {\n        int resultSize = Integer.highestOneBit(Math.max(a.length, b.length) - 1) << 2;\n        resultSize = Math.max(resultSize, 1);\n        double[] aReal = new double[resultSize];\n        double[] aImaginary = new double[resultSize];\n        double[] bReal = new double[resultSize];\n        double[] bImaginary = new double[resultSize];\n        for (int i = 0; i < a.length; i++)\n            aReal[i] = a[i];\n        for (int i = 0; i < b.length; i++)\n            bReal[i] = b[i];\n        fft(aReal, aImaginary, false);\n        fft(bReal, bImaginary, false);\n        for (int i = 0; i < resultSize; i++)\n        {\n            double real = aReal[i] * bReal[i] - aImaginary[i] * bImaginary[i];\n            aImaginary[i] = aImaginary[i] * bReal[i] + bImaginary[i] * aReal[i];\n            aReal[i] = real;\n        }\n        fft(aReal, aImaginary, true);\n        long[] result = new long[resultSize];\n        for (int i = 0; i < resultSize; i++)\n            result[i] = Math.round(aReal[i]);\n        return result;\n    }\n}\nclass NumberTheory\n{\n    public boolean isPrime(long n)\n    {\n        if(n < 2)\n            return false;\n        for(long x = 2;x * x <= n;x++)\n        {\n            if(n % x == 0)\n                return false;\n        }\n        return true;\n    }\n    public ArrayList<Long> primeFactorisation(long n)\n    {\n        ArrayList<Long> f = new ArrayList<>();\n        for(long x=2;x * x <= n;x++)\n        {\n            while(n % x == 0)\n            {\n                f.add(x);\n                n /= x;\n            }\n        }\n        if(n > 1)\n            f.add(n);\n        return f;\n    }\n    public int[] sieveOfEratosthenes(int n)\n    {\n        //Returns an array with the smallest prime factor for each number and primes marked as 0\n        int[] sieve = new int[n + 1];\n        for(int x=2;x * x <= n;x++)\n        {\n            if(sieve[x] != 0)\n                continue;\n            for(int u=x*x;u<=n;u+=x)\n            {\n                if(sieve[u] == 0)\n                {\n                    sieve[u] = x;\n                }\n            }\n        }\n        return sieve;\n    }\n    public long gcd(long a, long b)\n    {\n        if(b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n    public long phi(long n)\n    {\n        double result = n;\n\n        for(long p=2;p*p<=n;p++)\n        {\n            if(n % p == 0)\n            {\n                while (n % p == 0)\n                    n /= p;\n                result *= (1.0 - (1.0 / (double)p));\n            }\n        }\n        if(n > 1)\n            result *= (1.0 - (1.0 / (double)n));\n        return (long)result;\n    }\n    public Name extendedEuclid(long a, long b)\n    {\n        if(b == 0)\n            return new Name(a, 1, 0);\n        Name n1 = extendedEuclid(b, a % b);\n        Name n2 = new Name(n1.d, n1.y, n1.x - (long)Math.floor((double)a / b) * n1.y);\n        return n2;\n    }\n    public long modularExponentiation(long a, long b, long n)\n    {\n        long d = 1L;\n        String bString = Long.toBinaryString(b);\n        for(int i=0;i<bString.length();i++)\n        {\n            d = (d * d) % n;\n            if(bString.charAt(i) == '1')\n                d = (d * a) % n;\n        }\n        return d;\n    }\n}\nclass Name\n{\n    long d;\n    long x;\n    long y;\n\n    public Name(long d, long x, long y)\n    {\n        this.d = d;\n        this.x = x;\n        this.y = y;\n    }\n}\nclass SuffixArray\n{\n    int ALPHABET_SZ = 256, N;\n    int[] T, lcp, sa, sa2, rank, tmp, c;\n\n    public SuffixArray(String str)\n    {\n        this(toIntArray(str));\n    }\n\n    private static int[] toIntArray(String s)\n    {\n        int[] text = new int[s.length()];\n        for (int i = 0; i < s.length(); i++) text[i] = s.charAt(i);\n        return text;\n    }\n\n    public SuffixArray(int[] text)\n    {\n        T = text;\n        N = text.length;\n        sa = new int[N];\n        sa2 = new int[N];\n        rank = new int[N];\n        c = new int[Math.max(ALPHABET_SZ, N)];\n        construct();\n        kasai();\n    }\n\n    private void construct()\n    {\n        int i, p, r;\n        for (i = 0; i < N; ++i) c[rank[i] = T[i]]++;\n        for (i = 1; i < ALPHABET_SZ; ++i) c[i] += c[i - 1];\n        for (i = N - 1; i >= 0; --i) sa[--c[T[i]]] = i;\n        for (p = 1; p < N; p <<= 1)\n        {\n            for (r = 0, i = N - p; i < N; ++i) sa2[r++] = i;\n            for (i = 0; i < N; ++i) if (sa[i] >= p) sa2[r++] = sa[i] - p;\n            Arrays.fill(c, 0, ALPHABET_SZ, 0);\n            for (i = 0; i < N; ++i) c[rank[i]]++;\n            for (i = 1; i < ALPHABET_SZ; ++i) c[i] += c[i - 1];\n            for (i = N - 1; i >= 0; --i) sa[--c[rank[sa2[i]]]] = sa2[i];\n            for (sa2[sa[0]] = r = 0, i = 1; i < N; ++i)\n            {\n                if (!(rank[sa[i - 1]] == rank[sa[i]]\n                        && sa[i - 1] + p < N\n                        && sa[i] + p < N\n                        && rank[sa[i - 1] + p] == rank[sa[i] + p])) r++;\n                sa2[sa[i]] = r;\n            }\n            tmp = rank;\n            rank = sa2;\n            sa2 = tmp;\n            if (r == N - 1) break;\n            ALPHABET_SZ = r + 1;\n        }\n    }\n\n    private void kasai()\n    {\n        lcp = new int[N];\n        int[] inv = new int[N];\n        for (int i = 0; i < N; i++) inv[sa[i]] = i;\n        for (int i = 0, len = 0; i < N; i++)\n        {\n            if (inv[i] > 0)\n            {\n                int k = sa[inv[i] - 1];\n                while ((i + len < N) && (k + len < N) && T[i + len] == T[k + len]) len++;\n                lcp[inv[i] - 1] = len;\n                if (len > 0) len--;\n            }\n        }\n    }\n}\nclass ZAlgorithm\n{\n    public int[] calculateZ(char input[])\n    {\n        int Z[] = new int[input.length];\n        int left = 0;\n        int right = 0;\n        for(int k = 1; k < input.length; k++) {\n            if(k > right) {\n                left = right = k;\n                while(right < input.length && input[right] == input[right - left]) {\n                    right++;\n                }\n                Z[k] = right - left;\n                right--;\n            } else {\n                //we are operating inside box\n                int k1 = k - left;\n                //if value does not stretches till right bound then just copy it.\n                if(Z[k1] < right - k + 1) {\n                    Z[k] = Z[k1];\n                } else { //otherwise try to see if there are more matches.\n                    left = k;\n                    while(right < input.length && input[right] == input[right - left]) {\n                        right++;\n                    }\n                    Z[k] = right - left;\n                    right--;\n                }\n            }\n        }\n        return Z;\n    }\n    public ArrayList<Integer> matchPattern(char text[], char pattern[])\n    {\n        char newString[] = new char[text.length + pattern.length + 1];\n        int i = 0;\n        for(char ch : pattern) {\n            newString[i] = ch;\n            i++;\n        }\n        newString[i] = '$';\n        i++;\n        for(char ch : text) {\n            newString[i] = ch;\n            i++;\n        }\n        ArrayList<Integer> result = new ArrayList<>();\n        int Z[] = calculateZ(newString);\n\n        for(i = 0; i < Z.length ; i++) {\n            if(Z[i] == pattern.length) {\n                result.add(i - pattern.length - 1);\n            }\n        }\n        return result;\n    }\n}\nclass KMPAlgorithm\n{\n    public int[] computeTemporalArray(char[] pattern)\n    {\n        int[] lps = new int[pattern.length];\n\n        int index = 0;\n        for(int i=1;i<pattern.length;)\n        {\n            if(pattern[i] == pattern[index])\n            {\n                lps[i] = index + 1;\n                index++;\n                i++;\n            }\n            else\n            {\n                if(index != 0)\n                {\n                    index = lps[index - 1];\n                }\n                else\n                {\n                    lps[i] = 0;\n                    i++;\n                }\n            }\n        }\n        return lps;\n    }\n\n    public ArrayList<Integer> KMPMatcher(char[] text, char[] pattern)\n    {\n        int[] lps = computeTemporalArray(pattern);\n\n        int j = 0;\n        int i = 0;\n        int n = text.length;\n        int m = pattern.length;\n        ArrayList<Integer> indices = new ArrayList<>();\n        while(i < n)\n        {\n            if(pattern[j] == text[i])\n            {\n                i++;\n                j++;\n            }\n            if(j == m)\n            {\n                indices.add(i - j);\n                j = lps[j - 1];\n            }\n            else if(i < n && pattern[j] != text[i])\n            {\n                if(j != 0)\n                    j = lps[j - 1];\n                else\n                    i = i + 1;\n            }\n        }\n        return indices;\n    }\n}\nclass Hashing\n{\n    public long[] computePowers(long p, int n, long m)\n    {\n        long[] powers = new long[n];\n        powers[0] = 1;\n        for(int i=1;i<n;i++)\n        {\n            powers[i] = (powers[i - 1] * p) % m;\n        }\n        return powers;\n    }\n    public long computeHash(String s)\n    {\n        long p = 31;\n        long m = 1_000_000_009;\n        long hashValue = 0L;\n        long[] powers = computePowers(p, s.length(), m);\n        for(int i=0;i<s.length();i++)\n        {\n            char ch = s.charAt(i);\n            hashValue = (hashValue + (ch - 'a' + 1) * powers[i]) % m;\n        }\n        return hashValue;\n    }\n}\nclass BasicFunctions\n{\n    public long min(long[] A)\n    {\n        long min = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            min = Math.min(min, A[i]);\n        }\n        return min;\n    }\n    public long max(long[] A)\n    {\n        long max = Long.MAX_VALUE;\n        for(int i=0;i<A.length;i++)\n        {\n            max = Math.max(max, A[i]);\n        }\n        return max;\n    }\n}\nclass MergeSortInt\n{\n    // Merges two subarrays of arr[].\n    // First subarray is arr[l..m]\n    // Second subarray is arr[m+1..r]\n    void merge(int arr[], int l, int m, int r) {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        /* Create temp arrays */\n        int L[] = new int[n1];\n        int R[] = new int[n2];\n\n        /*Copy data to temp arrays*/\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        /* Merge the temp arrays */\n\n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n\n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        /* Copy remaining elements of L[] if any */\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        /* Copy remaining elements of R[] if any */\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    // Main function that sorts arr[l..r] using\n    // merge()\n    void sort(int arr[], int l, int r) {\n        if (l < r) {\n            // Find the middle point\n            int m = (l + r) / 2;\n\n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n\n}\nclass MergeSortLong\n{\n    // Merges two subarrays of arr[].\n    // First subarray is arr[l..m]\n    // Second subarray is arr[m+1..r]\n    void merge(long arr[], int l, int m, int r) {\n        // Find sizes of two subarrays to be merged\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        /* Create temp arrays */\n        long L[] = new long[n1];\n        long R[] = new long[n2];\n\n        /*Copy data to temp arrays*/\n        for (int i = 0; i < n1; ++i)\n            L[i] = arr[l + i];\n        for (int j = 0; j < n2; ++j)\n            R[j] = arr[m + 1 + j];\n\n\n        /* Merge the temp arrays */\n\n        // Initial indexes of first and second subarrays\n        int i = 0, j = 0;\n\n        // Initial index of merged subarry array\n        int k = l;\n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n                arr[k] = L[i];\n                i++;\n            } else {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n\n        /* Copy remaining elements of L[] if any */\n        while (i < n1) {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n\n        /* Copy remaining elements of R[] if any */\n        while (j < n2) {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n\n    // Main function that sorts arr[l..r] using\n    // merge()\n    void sort(long arr[], int l, int r) {\n        if (l < r) {\n            // Find the middle point\n            int m = (l + r) / 2;\n\n            // Sort first and second halves\n            sort(arr, l, m);\n            sort(arr, m + 1, r);\n\n            // Merge the sorted halves\n            merge(arr, l, m, r);\n        }\n    }\n}\nclass Node\n{\n\n    int x;\n    int y;\n\n    public Node(int x, int y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public boolean equals(Object ob)\n    {\n        if(ob == null)\n            return false;\n        if(!(ob instanceof Node))\n            return false;\n        if(ob == this)\n            return true;\n        Node obj = (Node)ob;\n        if(this.x == obj.x && this.y == obj.y)\n            return true;\n        return false;\n    }\n\n    @Override\n    public int hashCode()\n    {\n        return (int)this.x;\n    }\n}\nclass Reader\n{\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader()\n    {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException\n    {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String readLine() throws IOException\n    {\n        byte[] buf = new byte[64]; // line length\n        int cnt = 0, c;\n        while ((c = read()) != -1)\n        {\n            if (c == '\\n')\n                break;\n            buf[cnt++] = (byte) c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int nextInt() throws IOException\n    {\n        int ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do\n        {\n            ret = ret * 10 + c - '0';\n        }  while ((c = read()) >= '0' && c <= '9');\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public long nextLong() throws IOException\n    {\n        long ret = 0;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    public double nextDouble() throws IOException\n    {\n        double ret = 0, div = 1;\n        byte c = read();\n        while (c <= ' ')\n            c = read();\n        boolean neg = (c == '-');\n        if (neg)\n            c = read();\n\n        do {\n            ret = ret * 10 + c - '0';\n        }\n        while ((c = read()) >= '0' && c <= '9');\n\n        if (c == '.')\n        {\n            while ((c = read()) >= '0' && c <= '9')\n            {\n                ret += (c - '0') / (div *= 10);\n            }\n        }\n\n        if (neg)\n            return -ret;\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException\n    {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1)\n            buffer[0] = -1;\n    }\n\n    private byte read() throws IOException\n    {\n        if (bufferPointer == bytesRead)\n            fillBuffer();\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException\n    {\n        if (din == null)\n            return;\n        din.close();\n    }\n}\nclass FenwickTree\n{\n    public void update(long[] fenwickTree,long delta,int index)\n    {\n        index += 1;\n        while(index < fenwickTree.length)\n        {\n            fenwickTree[index] += delta;\n            index = index + (index & (-index));\n        }\n    }\n    public long prefixSum(long[] fenwickTree,int index)\n    {\n        long sum = 0L;\n        index += 1;\n        while(index > 0)\n        {\n            sum += fenwickTree[index];\n            index -= (index & (-index));\n        }\n        return sum;\n    }\n}\nclass SegmentTree\n{\n    public int nextPowerOfTwo(int num)\n    {\n        if(num == 0)\n            return 1;\n        if(num > 0 && (num & (num - 1)) == 0)\n            return num;\n        while((num &(num - 1)) > 0)\n        {\n            num = num & (num - 1);\n        }\n        return num << 1;\n    }\n    public int[] createSegmentTree(int[] input)\n    {\n        int np2 = nextPowerOfTwo(input.length);\n        int[] segmentTree = new int[np2 * 2 - 1];\n\n        for(int i=0;i<segmentTree.length;i++)\n            segmentTree[i] = Integer.MIN_VALUE;\n\n        constructSegmentTree(segmentTree,input,0,input.length-1,0);\n        return segmentTree;\n\n    }\n    private void constructSegmentTree(int[] segmentTree,int[] input,int low,int high,int pos)\n    {\n        if(low == high)\n        {\n            segmentTree[pos] = input[low];\n            return;\n        }\n        int mid = (low + high)/ 2;\n        constructSegmentTree(segmentTree,input,low,mid,2*pos + 1);\n        constructSegmentTree(segmentTree,input,mid+1,high,2*pos + 2);\n        segmentTree[pos] = Math.max(segmentTree[2*pos + 1],segmentTree[2*pos + 2]);\n    }\n    public int rangeMinimumQuery(int []segmentTree,int qlow,int qhigh,int len)\n    {\n        return rangeMinimumQuery(segmentTree,0,len-1,qlow,qhigh,0);\n    }\n    private int rangeMinimumQuery(int segmentTree[],int low,int high,int qlow,int qhigh,int pos)\n    {\n        if(qlow <= low && qhigh >= high){\n            return segmentTree[pos];\n        }\n        if(qlow > high || qhigh < low){\n            return Integer.MIN_VALUE;\n        }\n        int mid = (low+high)/2;\n        return Math.max(rangeMinimumQuery(segmentTree, low, mid, qlow, qhigh, 2 * pos + 1),\n                rangeMinimumQuery(segmentTree, mid + 1, high, qlow, qhigh, 2 * pos + 2));\n    }\n}\nclass Trie\n{\n\n    private class TrieNode\n    {\n        Map<Character, TrieNode> children;\n        boolean endOfWord;\n        public TrieNode()\n        {\n            children = new HashMap<>();\n            endOfWord = false;\n        }\n    }\n\n    private final TrieNode root;\n    public Trie()\n    {\n        root = new TrieNode();\n    }\n\n    public void insert(String word)\n    {\n        TrieNode current = root;\n        for (int i = 0; i < word.length(); i++)\n        {\n            char ch = word.charAt(i);\n            TrieNode node = current.children.get(ch);\n            if (node == null)\n            {\n                node = new TrieNode();\n                current.children.put(ch, node);\n            }\n            current = node;\n        }\n        current.endOfWord = true;\n    }\n\n    public boolean search(String word)\n    {\n        TrieNode current = root;\n        for (int i = 0; i < word.length(); i++)\n        {\n            char ch = word.charAt(i);\n            TrieNode node = current.children.get(ch);\n            if (node == null)\n            {\n                return false;\n            }\n            current = node;\n        }\n        return current.endOfWord;\n    }\n\n    public void delete(String word)\n    {\n        delete(root, word, 0);\n    }\n\n    private boolean delete(TrieNode current, String word, int index)\n    {\n        if (index == word.length())\n        {\n            if (!current.endOfWord)\n            {\n                return false;\n            }\n            current.endOfWord = false;\n            return current.children.size() == 0;\n        }\n        char ch = word.charAt(index);\n        TrieNode node = current.children.get(ch);\n        if (node == null)\n        {\n            return false;\n        }\n        boolean shouldDeleteCurrentNode = delete(node, word, index + 1);\n\n        if (shouldDeleteCurrentNode)\n        {\n            current.children.remove(ch);\n            return current.children.size() == 0;\n        }\n        return false;\n    }\n}\nclass SegmentTreeLazy\n{\n    public int nextPowerOfTwo(int num)\n    {\n        if(num == 0)\n            return 1;\n        if(num > 0 && (num & (num - 1)) == 0)\n            return num;\n        while((num &(num - 1)) > 0)\n        {\n            num = num & (num - 1);\n        }\n        return num << 1;\n    }\n\n    public int[] createSegmentTree(int input[])\n    {\n        int nextPowOfTwo = nextPowerOfTwo(input.length);\n        int segmentTree[] = new int[nextPowOfTwo*2 -1];\n\n        for(int i=0; i < segmentTree.length; i++){\n            segmentTree[i] = Integer.MAX_VALUE;\n        }\n        constructMinSegmentTree(segmentTree, input, 0, input.length - 1, 0);\n        return segmentTree;\n    }\n\n    private void constructMinSegmentTree(int segmentTree[], int input[], int low, int high,int pos)\n    {\n        if(low == high)\n        {\n            segmentTree[pos] = input[low];\n            return;\n        }\n        int mid = (low + high)/2;\n        constructMinSegmentTree(segmentTree, input, low, mid, 2 * pos + 1);\n        constructMinSegmentTree(segmentTree, input, mid + 1, high, 2 * pos + 2);\n        segmentTree[pos] = Math.min(segmentTree[2*pos+1], segmentTree[2*pos+2]);\n    }\n\n    public void updateSegmentTreeRangeLazy(int input[], int segmentTree[], int lazy[], int startRange, int endRange, int delta)\n    {\n        updateSegmentTreeRangeLazy(segmentTree, lazy, startRange, endRange, delta, 0, input.length - 1, 0);\n    }\n\n    private void updateSegmentTreeRangeLazy(int segmentTree[], int lazy[], int startRange, int endRange, int delta, int low, int high, int pos)\n    {\n        if(low > high)\n        {\n            return;\n        }\n        if (lazy[pos] != 0)\n        {\n            segmentTree[pos] += lazy[pos];\n            if (low != high)\n            {\n                lazy[2 * pos + 1] += lazy[pos];\n                lazy[2 * pos + 2] += lazy[pos];\n            }\n            lazy[pos] = 0;\n        }\n\n        if(startRange > high || endRange < low)\n        {\n            return;\n        }\n\n        if(startRange <= low && endRange >= high)\n        {\n            segmentTree[pos] += delta;\n            if(low != high) {\n                lazy[2*pos + 1] += delta;\n                lazy[2*pos + 2] += delta;\n            }\n            return;\n        }\n\n        int mid = (low + high)/2;\n        updateSegmentTreeRangeLazy(segmentTree, lazy, startRange, endRange, delta, low, mid, 2*pos+1);\n        updateSegmentTreeRangeLazy(segmentTree, lazy, startRange, endRange, delta, mid+1, high, 2*pos+2);\n        segmentTree[pos] = Math.min(segmentTree[2*pos + 1], segmentTree[2*pos + 2]);\n    }\n\n    public int rangeMinimumQueryLazy(int segmentTree[], int lazy[], int qlow, int qhigh, int len)\n    {\n        return rangeMinimumQueryLazy(segmentTree, lazy, qlow, qhigh, 0, len - 1, 0);\n    }\n\n    private int rangeMinimumQueryLazy(int segmentTree[], int lazy[], int qlow, int qhigh, int low, int high, int pos)\n    {\n        if(low > high)\n        {\n            return Integer.MAX_VALUE;\n        }\n        if (lazy[pos] != 0)\n        {\n            segmentTree[pos] += lazy[pos];\n            if (low != high)\n            {\n                lazy[2 * pos + 1] += lazy[pos];\n                lazy[2 * pos + 2] += lazy[pos];\n            }\n            lazy[pos] = 0;\n        }\n\n        if(qlow > high || qhigh < low)\n        {\n            return Integer.MAX_VALUE;\n        }\n\n        if(qlow <= low && qhigh >= high)\n        {\n            return segmentTree[pos];\n        }\n\n        int mid = (low+high)/2;\n        return Math.min(rangeMinimumQueryLazy(segmentTree, lazy, qlow, qhigh, low, mid, 2 * pos + 1), rangeMinimumQueryLazy(segmentTree, lazy,  qlow, qhigh, mid + 1, high, 2 * pos + 2));\n    }\n}\n", "label": 3}
{"src": "import java.util.InputMismatchException;\nimport java.math.BigInteger;\nimport java.util.Stack;\nimport java.util.*;\nimport java.util.Collection;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Comparator;\nimport java.io.*;\nimport java.util.Iterator;\nimport java.util.concurrent.atomic.AtomicBoolean;\nimport java.util.Arrays;\n\n/**\n * Generated by Contest helper plug-in\n * Actual solution is at the bottom\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputReader in;\n\t\tPrintWriter out;\n\t\ttry {\n\t\t\tin = new StreamInputReader(new FileInputStream(\"input.txt\"));\n\t\t\tout = new PrintWriter(new PrintStream(new FileOutputStream(\"output.txt\")));\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\trun(in, out);\n\t}\n\n\tpublic static void run(InputReader in, PrintWriter out) {\n\t\tSolver solver = new TaskF();\n\t\tsolver.solve(1, in, out);\n\t\tExit.exit(in, out);\n\t}\n}\n\nabstract class InputReader {\n\tprivate boolean finished = false;\n\n\tpublic abstract int read();\n\n\tpublic int readInt() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = read();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\n\tpublic String readString() {\n\t\tint c = read();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = read();\n\t\tStringBuffer res = new StringBuffer();\n\t\tdo {\n\t\t\tres.appendCodePoint(c);\n\t\t\tc = read();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t}\n\n\tpublic void setFinished(boolean finished) {\n\t\tthis.finished = finished;\n\t}\n\n\tpublic abstract void close();\n}\n\nclass StreamInputReader extends InputReader {\n\tprivate InputStream stream;\n\tprivate byte[] buf = new byte[1024];\n\tprivate int curChar, numChars;\n\n\tpublic StreamInputReader(InputStream stream) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic int read() {\n\t\tif (numChars == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (curChar >= numChars) {\n\t\t\tcurChar = 0;\n\t\t\ttry {\n\t\t\t\tnumChars = stream.read(buf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (numChars <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[curChar++];\n\t}\n\n\tpublic void close() {\n\t\ttry {\n\t\t\tstream.close();\n\t\t} catch (IOException ignored) {\n\t\t}\n\t}\n}\n\nclass Exit {\n\tprivate Exit() {\n\t}\n\n\tpublic static void exit(InputReader in, PrintWriter out) {\n\t\tin.setFinished(true);\n\t\tin.close();\n\t\tout.close();\n\t}\n}\n\ninterface Solver {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out);\n}\n\nclass GraphUtils {\n\tpublic static int[][] buildGraph(int vertexCount, int[] from, int[] to) {\n\t\tint edgeCount = from.length;\n\t\tint[] degree = new int[vertexCount];\n\t\tfor (int i = 0; i < edgeCount; i++) {\n\t\t\tdegree[from[i]]++;\n\t\t\tdegree[to[i]]++;\n\t\t}\n\t\tint[][] graph = new int[vertexCount][];\n\t\tfor (int i = 0; i < vertexCount; i++)\n\t\t\tgraph[i] = new int[degree[i]];\n\t\tfor (int i = 0; i < edgeCount; i++) {\n\t\t\tgraph[from[i]][--degree[from[i]]] = i;\n\t\t\tgraph[to[i]][--degree[to[i]]] = i;\n\t\t}\n\t\treturn graph;\n\t}\n\n\tpublic static int otherVertex(int vertex, int from, int to) {\n\t\treturn from + to - vertex;\n\t}\n\n\tpublic static int[][] buildSimpleGraph(int vertexCount, int[] from, int[] to) {\n\t\tint[][] graph = buildGraph(vertexCount, from, to);\n\t\tsimplifyGraph(from, to, graph);\n\t\treturn graph;\n\t}\n\n\tprivate static void simplifyGraph(int[] from, int[] to, int[][] graph) {\n\t\tfor (int i = 0; i < graph.length; i++) {\n\t\t\tfor (int j = 0; j < graph[i].length; j++) {\n\t\t\t\tgraph[i][j] = otherVertex(i, from[graph[i][j]], to[graph[i][j]]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nclass IOUtils {\n\n\tpublic static void readIntArrays(InputReader in, int[]... arrays) {\n\t\tfor (int i = 0; i < arrays[0].length; i++) {\n\t\t\tfor (int j = 0; j < arrays.length; j++)\n\t\t\t\tarrays[j][i] = in.readInt();\n\t\t}\n\t}\n\n\t}\n\nclass TaskF implements Solver {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\tint count = in.readInt();\n\t\tint answer = 0;\n\t\tfor (int i = 0; i < count; i++)\n\t\t\tanswer += processSpider(in);\n\t\tout.println(answer);\n\t}\n\n\tprivate int processSpider(InputReader in) {\n\t\tint size = in.readInt();\n\t\tint[] from = new int[size - 1];\n\t\tint[] to = new int[size - 1];\n\t\tIOUtils.readIntArrays(in, from, to);\n\t\tfor (int i = 0; i < size - 1; i++) {\n\t\t\tfrom[i]--;\n\t\t\tto[i]--;\n\t\t}\n\t\tint[][] graph = GraphUtils.buildSimpleGraph(size, from, to);\n\t\tint result = 0;\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tresult = Math.max(result, dfs(i, -1, graph));\n\t\treturn result;\n\t}\n\n\tprivate int dfs(int vertex, int last, int[][] graph) {\n\t\tint result = 0;\n\t\tfor (int next : graph[vertex]) {\n\t\t\tif (next != last)\n\t\t\t\tresult = Math.max(result, 1 + dfs(next, vertex, graph));\n\t\t}\n\t\treturn result;\n\t}\n}\n\n", "label": 3}
{"src": "//package saratov11;\nimport java.io.ByteArrayInputStream;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\n\npublic class F {\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\t\n\tvoid solve()\n\t{\n\t\tint n = ni();\n\t\tint ret = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tint m = ni();\n\t\t\tint[] from = new int[m-1];\n\t\t\tint[] to = new int[m-1];\n\t\t\tfor(int j = 0;j < m-1;j++){\n\t\t\t\tfrom[j] = ni()-1;\n\t\t\t\tto[j] = ni()-1;\n\t\t\t}\n\t\t\tint[][] g = packU(m, from, to);\n\t\t\tint[] x = farthest(g, 0);\n\t\t\tint[] y = farthest(g, x[0]);\n\t\t\tret += y[1];\n\t\t}\n\t\tout.println(ret);\n\t}\n\t\n\tint[] farthest(int[][] g, int x)\n\t{\n\t\tint n = g.length;\n\t\tint[] q = new int[n];\n\t\tint[] d = new int[n];\n\t\tArrays.fill(d, 1000000);\n\t\tint p = 0;\n\t\td[x] = 0;\n\t\tq[p++] = x;\n\t\tfor(int i = 0;i < p;i++){\n\t\t\tint cur = q[i];\n\t\t\tfor(int e : g[cur]){\n\t\t\t\tif(d[e] > d[cur] + 1){\n\t\t\t\t\td[e] = d[cur] + 1;\n\t\t\t\t\tq[p++] = e;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn new int[]{q[n-1], d[q[n-1]]};\n\t}\n\t\n\tstatic int[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor(int f : from)\n\t\t\tp[f]++;\n\t\tfor(int t : to)\n\t\t\tp[t]++;\n\t\tfor(int i = 0;i < n;i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor(int i = 0;i < from.length;i++){\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = oj ? new FileInputStream(\"input.txt\") : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = oj ? new PrintWriter(\"output.txt\") : new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolve();\n\t\tout.flush();\n\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tnew F().run();\n\t}\n\t\n\tpublic int ni()\n\t{\n\t\ttry {\n\t\t\tint num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic long nl()\n\t{\n\t\ttry {\n\t\t\tlong num = 0;\n\t\t\tboolean minus = false;\n\t\t\twhile((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n\t\t\tif(num == '-'){\n\t\t\t\tnum = 0;\n\t\t\t\tminus = true;\n\t\t\t}else{\n\t\t\t\tnum -= '0';\n\t\t\t}\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t}else{\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn -1;\n\t}\n\t\n\tpublic String ns()\n\t{\n\t\ttry{\n\t\t\tint b = 0;\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile((b = is.read()) != -1 && (b == '\\r' || b == '\\n' || b == ' '));\n\t\t\tif(b == -1)return \"\";\n\t\t\tsb.append((char)b);\n\t\t\twhile(true){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1)return sb.toString();\n\t\t\t\tif(b == '\\r' || b == '\\n' || b == ' ')return sb.toString();\n\t\t\t\tsb.append((char)b);\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn \"\";\n\t}\n\t\n\tpublic char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\ttry{\n\t\t\tint b = 0, p = 0;\n\t\t\twhile((b = is.read()) != -1 && (b == ' ' || b == '\\r' || b == '\\n'));\n\t\t\tif(b == -1)return null;\n\t\t\tbuf[p++] = (char)b;\n\t\t\twhile(p < n){\n\t\t\t\tb = is.read();\n\t\t\t\tif(b == -1 || b == ' ' || b == '\\r' || b == '\\n')break;\n\t\t\t\tbuf[p++] = (char)b;\n\t\t\t}\n\t\t\treturn Arrays.copyOf(buf, p);\n\t\t} catch (IOException e) {\n\t\t}\n\t\treturn null;\n\t}\n\t\n\t\n\tdouble nd() { return Double.parseDouble(ns()); }\n\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\tvoid tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "label": 3}
{"src": "\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author HavroninaTE\n */\npublic class Spiders {\n    static ArrayList<Integer> g[];\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(Paths.get(\"input.txt\"),\"UTF-8\");\n        int n = sc.nextInt();\n        int totalLength=0;\n        int max;\n        for(int i=0;i<n;i++)\n        {\n            int k = sc.nextInt();\n            g = new ArrayList[k];\n            for(int j=0;j<k;j++) //\u043e\u0431\u0445\u043e\u0434 \u043f\u043e \u043f\u0430\u0443\u043a\u0430\u043c\n                g[j]=new ArrayList();\n            for(int u,v,j=1;j<k;j++)\n            {\n               u=sc.nextInt()-1;\n               v=sc.nextInt()-1;\n               g[u].add(v);\n               g[v].add(u);\n            }\n            max=0;\n            for(int q=0;q<k;q++)\n                max = Math.max(max, dfs(q,-1)-1);\n            totalLength+=max;\n        }\n        PrintWriter out = new PrintWriter(\"output.txt\",\"UTF-8\");\n        out.println(totalLength);\n        out.close();\n    }\n    private static int dfs(int v,int p)\n    {\n        int max=0;\n        for(int u:g[v])\n            if(u!=p)\n                max=Math.max(max,dfs(u,v));\n        return max+1;\n    }\n}\n", "label": 3}
{"src": "import java.awt.*;\nimport java.awt.geom.*;\nimport java.io.*;\nimport java.math.*;\nimport java.text.*;\nimport java.util.*;\n\n/*\nbr = new BufferedReader(new FileReader(\"input.txt\"));\npw = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\nbr = new BufferedReader(new InputStreamReader(System.in));\npw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n */\n\npublic class Main {\n\tprivate static BufferedReader br;\n\tprivate static StringTokenizer st;\n\tprivate static PrintWriter pw;\n\n\tstatic boolean[] lose;\n\n\tstatic final long MOD = 1000000007;\n\n\tpublic static void main(String[] args) throws IOException\t{\n\t\tbr = new BufferedReader(new FileReader(\"input.txt\"));\n\t\tpw = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n\t\tint qq = readInt();\n\t\tint sum = 0;\n\t\twhile(qq-- > 0)\t{\n\t\t\tint ret = 0;\n\t\t\tint n = readInt();\n\t\t\tint[][] dist = new int[n][n];\n\t\t\tfor(int i = 0; i < n; i++)\t{\n\t\t\t\tArrays.fill(dist[i], 1 << 25);\n\t\t\t\tdist[i][i] = 0;\n\t\t\t}\n\t\t\tfor(int k = 1; k < n; k++)\t{\n\t\t\t\tint a = readInt();\n\t\t\t\tint b = readInt();\n\t\t\t\ta--;\n\t\t\t\tb--;\n\t\t\t\tdist[a][b] = dist[b][a] = 1;\n\t\t\t}\n\t\t\tfor(int k = 0; k < n; k++)\t{\n\t\t\t\tfor(int i = 0; i < n; i++)\t{\n\t\t\t\t\tfor(int j = 0; j < n; j++)\t{\n\t\t\t\t\t\tdist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0; i < n; i++)\t{\n\t\t\t\tfor(int j = 0; j < n; j++)\t{\n\t\t\t\t\tret = Math.max(ret, dist[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += ret;\n\t\t}\n\t\tpw.println(sum);\n\t\tpw.close(); \n\t}\n\n\t/* NOTEBOOK CODE */\n\n\tpublic static void loadArray(int[][] grid) throws IOException {\n\t\tfor(int[] a: grid)\n\t\t\tloadArray(a);\n\t}\n\n\tpublic static void loadArray(int[] in) throws IOException {\n\t\tfor(int i = 0; i < in.length; i++)\n\t\t\tin[i] = readInt();\n\t}\n\n\tpublic static void loadArray(long[] in) throws IOException {\n\t\tfor(int i = 0; i < in.length; i++)\n\t\t\tin[i] = readLong();\n\t}\n\n\n\tprivate static long readLong() throws IOException\t{\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tprivate static double readDouble() throws IOException\t{\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tprivate static int readInt() throws IOException\t{\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tprivate static String nextToken() throws IOException\t{\n\t\twhile(st == null || !st.hasMoreTokens())\t{\n\t\t\tif(!br.ready())\t{\n\t\t\t\tpw.close();\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\tst = new StringTokenizer(br.readLine().trim());\n\t\t}\n\t\treturn st.nextToken();\n\t}\n}", "label": 3}
{"src": "import static java.lang.Math.*;\nimport static java.lang.System.currentTimeMillis;\nimport static java.lang.System.exit;\nimport static java.lang.System.arraycopy;\nimport static java.util.Arrays.sort;\nimport static java.util.Arrays.binarySearch;\nimport static java.util.Arrays.fill;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\ttry {\n\t\t\tif (new File(\"input.txt\").exists())\n\t\t\t\tSystem.setIn(new FileInputStream(\"input.txt\"));\n\t\t} catch (SecurityException e) {\n\t\t}\n\t\tnew Thread(null, new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tnew Main().run();\n\t\t\t\t} catch (Throwable e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t\texit(999);\n\t\t\t\t}\n\t\t\t}\n\t\t}, \"1\", 1 << 23).start();\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st = new StringTokenizer(\"\");\n\n\tint n;\n\tint MAX = 101;\n\tArrayList<Integer> g[] = new ArrayList[MAX];\n\t\n\n\tprivate void run() throws IOException {\n\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\tout = new PrintWriter(\"output.txt\");\n\t\t\n\t\tint n = nextInt();\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < MAX; i++)\n\t\t\tg[i] = new ArrayList<Integer>();\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tans += solve();\n\t\t}\n//\t\tSystem.err.println(ans);\n\t\tout.println(ans);\n\t\tin.close();\n\t\tout.close();\n\t}\n\t\n\tint used[] = new int[MAX];\n\tint dist[] = new int[MAX];\n\tint tick = 1;\n\t\n\tint solve() throws IOException{\n\t\tfor(int i = 0; i < MAX; i++)\n\t\t\tg[i].clear();\n\t\tn = nextInt();\n\t\tfor(int i = 1; i < n; i++){\n\t\t\tint a = nextInt() - 1;\n\t\t\tint b = nextInt() - 1;\n\t\t\tg[a].add(b);\n\t\t\tg[b].add(a);\n\t\t}\n\t\ttick++;\n\t\tdfs(0, 0);\n\t\tint id = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tif(dist[id] < dist[i])\n\t\t\t\tid = i;\n\t\ttick++;\n\t\tdfs(id, 0);\n\t\tint max = 0;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tmax = max(dist[i], max);\n\t\treturn max;\n\t}\n\tvoid dfs(int v, int depth){\n\t\tused[v] = tick;\n\t\tdist[v] = depth;\n\t\tfor(int nv : g[v]){\n\t\t\tif(used[nv] == tick) continue;\n\t\t\tdfs(nv, depth + 1);\n\t\t}\n\t}\n\tString nextToken() throws IOException {\n\t\twhile (!st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\tString nextLine() throws IOException {\n\t\tst = new StringTokenizer(\"\");\n\t\treturn in.readLine();\n\t}\n\tboolean EOF() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString s = in.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn true;\n\t\t\tst = new StringTokenizer(s);\n\t\t}\n\t\treturn false;\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author El-Bishoy\n */\npublic class Main {\n    public static void main(String[] args) throws FileNotFoundException {\n        InputStream inputStream = new FileInputStream(\"input.txt\");\n        OutputStream outputStream = new FileOutputStream(\"output.txt\");\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        F120_Spiders solver = new F120_Spiders();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class F120_Spiders {\n        ArrayList<Integer>[] adj;\n        int max = 0;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            solve2(in, out);\n        }\n\n        private void solve2(InputReader in, OutputWriter out) {\n\n            int n = in.nextInt();\n\n\n            int ans = 0;\n            while (n-- > 0) {\n                int nn = in.nextInt();\n                adj = GraphUtils.buildAdjList(nn);\n\n                int e = nn - 1;\n                while (e-- > 0) {\n                    int u = in.nextInt() - 1, v = in.nextInt() - 1;\n                    adj[u].add(v);\n                    adj[v].add(u);\n\n                }\n\n                for (int i = 0; i < nn; i++) {\n                    boolean[] visited = new boolean[nn];\n                    int[] lengths = new int[nn];\n                    dfs(visited, lengths, i);\n                }\n\n\n                ans += max;\n                max = 0;\n\n            }\n\n            out.println(ans);\n        }\n\n        private void dfs(boolean[] visited, int[] lengths, int v) {\n            visited[v] = true;\n\n            for (int u : adj[v]) {\n                if (!visited[u]) {\n                    lengths[u] = lengths[v] + 1;\n                    max = Math.max(max, lengths[u]);\n                    dfs(visited, lengths, u);\n                }\n\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class GraphUtils {\n        public static ArrayList<Integer>[] buildAdjList(int n) {\n            ArrayList<Integer>[] adj = new ArrayList[n];\n\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n\n            return adj;\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.text.DecimalFormat;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.Stack;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.Queue;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\npublic class Main {\n    int n, m;\n    int[] dis = new int[N];\n    int bfs(int x){\n        for(int i = 0; i <= m; i++)dis[i] = -1;\n        dis[x] = 0;\n        int ans = x;\n        Queue<Integer> q = new LinkedList(); q.add(x);\n        while(!q.isEmpty()){\n            int u = q.poll();\n            for(int i = head[u]; i!=-1; i = edge[i].nex){\n                int v = edge[i].to;\n                if(dis[v] == -1){\n                    dis[v] = dis[u]+1;\n                    q.add(v);\n                    if(dis[ans]<dis[v])ans = v;\n                }\n            }\n        }\n        return ans;\n    }\n    int solve(){\n        int E = bfs(1);\n        E = bfs(E);     \n        return dis[E];\n    }\n    void work() throws Exception{\n        n = Int();\n        int ans = 0;\n        while(n-->0){\n            init_edge();\n            m = Int();\n            for(int i = 1, u, v; i < m; i++){\n                u = Int(); v = Int();\n                add(u, v); add(v, u);\n            }\n            ans += solve();\n        }\n        out.println(ans);\n    }\n\n    public static void main(String[] args) throws Exception{\n        Main wo = new Main();\n    //  in = new BufferedReader(new InputStreamReader(System.in));\n        in = new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"input.txt\"))));\n    //  out = new PrintWriter(System.out);\n        out = new PrintWriter(new File(\"output.txt\"));\n        wo.work();\n        out.close();\n    }\n\n    static int N = 1100;\n    static int M = N*N * 10;\n    DecimalFormat df=new DecimalFormat(\"0.0000\");\n    static long inf = 1000000000000L;\n    static long inf64 = (long) 1e18*2;\n    static double eps = 1e-8;\n    static double Pi = Math.PI;\n    static int mod = 1000000009 ;\n    \n    private String Next() throws Exception{\n        while (str == null || !str.hasMoreElements())\n            str = new StringTokenizer(in.readLine());\n        return str.nextToken();\n    }\n    private int Int() throws Exception{\n        return Integer.parseInt(Next());\n    }\n    private long Long() throws Exception{\n        return Long.parseLong(Next());\n    }\n    StringTokenizer str;\n    static BufferedReader in;\n    static PrintWriter out;\n\n    class Edge{\n        int from, to, nex;\n        Edge(){}\n        Edge(int from, int to, int nex){\n            this.from = from;\n            this.to = to;\n            this.nex = nex;\n        }\n    }\n    Edge[] edge = new Edge[M<<1];\n    int[] head = new int[N];\n    int edgenum;\n    void init_edge(){for(int i = 0; i < N; i++)head[i] = -1; edgenum = 0;}\n    void add(int u, int v){\n        edge[edgenum] = new Edge(u, v, head[u]);\n        head[u] = edgenum++;\n    }/*\n    int upper_bound(int[] A, int l, int r, int val) {// upper_bound(A+l,A+r,val)-A;\n        int pos = r;\n        r--;\n        while (l <= r) {\n            int mid = (l + r) >> 1;\n            if (A[mid] <= val) {\n                l = mid + 1;\n            } else {\n                pos = mid;\n                r = mid - 1;\n            }\n        }\n        return pos;\n    }/**/\n\n    int Pow(int x, int y) {\n        int ans = 1;\n        while (y > 0) {\n            if ((y & 1) > 0)\n                ans *= x;\n            y >>= 1;\n            x = x * x;\n        }\n        return ans;\n    }\n    double Pow(double x, int y) {\n        double ans = 1;\n        while (y > 0) {\n            if ((y & 1) > 0)\n                ans *= x;\n            y >>= 1;\n            x = x * x;\n        }\n        return ans;\n    }\n    int Pow_Mod(int x, int y, int mod) {\n        int ans = 1;\n        while (y > 0) {\n            if ((y & 1) > 0)\n                ans *= x;\n            ans %= mod;\n            y >>= 1;\n            x = x * x;\n            x %= mod;\n        }\n        return ans;\n    }\n    long Pow(long x, long y) {\n        long ans = 1;\n        while (y > 0) {\n            if ((y & 1) > 0)\n                ans *= x;\n            y >>= 1;\n            x = x * x;\n        }\n        return ans;\n    }\n    long Pow_Mod(long x, long y, long mod) {\n        long ans = 1;\n        while (y > 0) {\n            if ((y & 1) > 0)\n                ans *= x;\n            ans %= mod;\n            y >>= 1;\n            x = x * x;\n            x %= mod;\n        }\n        return ans;\n    }\n\n    int gcd(int x, int y){\n        if(x>y){int tmp = x; x = y; y = tmp;}\n        while(x>0){\n            y %= x;\n            int tmp = x; x = y; y = tmp;\n        }\n        return y;\n    }\n    int max(int x, int y) {\n        return x > y ? x : y;\n    }\n\n    int min(int x, int y) {\n        return x < y ? x : y;\n    }\n\n    double max(double x, double y) {\n        return x > y ? x : y;\n    }\n\n    double min(double x, double y) {\n        return x < y ? x : y;\n    }\n\n    long max(long x, long y) {\n        return x > y ? x : y;\n    }\n\n    long min(long x, long y) {\n        return x < y ? x : y;\n    }\n\n    int abs(int x) {\n        return x > 0 ? x : -x;\n    }\n\n    double abs(double x) {\n        return x > 0 ? x : -x;\n    }\n\n    long abs(long x) {\n        return x > 0 ? x : -x;\n    }\n\n    boolean zero(double x) {\n        return abs(x) < eps;\n    }\n    double sin(double x){return Math.sin(x);}\n    double cos(double x){return Math.cos(x);}\n    double tan(double x){return Math.tan(x);}\n    double sqrt(double x){return Math.sqrt(x);}\n}", "label": 3}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.util.TreeSet;\n\n/**\n * 111118315581\n *\n * -3 3 2 3 2 3 2 3 -3 3 -3 3 -3 3 2 3\n *\n * @author pttrung\n */\npublic class C {\n\n    //   public static long x, y, gcd;\n    //   public static int Mod = 1000000007;\n    public static int length, node;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        Scanner in = new Scanner();\n        // PrintWriter out = new PrintWriter(System.out);\n        PrintWriter out = new PrintWriter(new FileOutputStream(new File(\"output.txt\")));\n        int n = in.nextInt();\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            int l = in.nextInt();\n            ArrayList<Integer>[] list = new ArrayList[l];\n            for (int j = 0; j < l - 1; j++) {\n                int a = in.nextInt() - 1;\n                int b = in.nextInt() - 1;\n                if (list[a] == null) {\n                    list[a] = new ArrayList();\n                }\n                if (list[b] == null) {\n                    list[b] = new ArrayList();\n                }\n                list[a].add(b);\n                list[b].add(a);\n            }\n            length = 0;\n            node = 0;\n            dfs(0, -1, 0, list);\n            length = 0;\n            dfs(node, -1, 0, list);\n            result += length;\n        }\n        out.println(result);\n        out.close();\n    }\n\n    public static void dfs(int cur, int pa, int val, ArrayList<Integer>[] list) {\n        if (val > length) {\n            length = val;\n            node = cur;\n        }\n        for (int i : list[cur]) {\n            if (i != pa) {\n                dfs(i, cur, val + 1, list);\n            }\n        }\n\n    }\n\n    public static long pow(long a, long b) {\n        if (b == 0) {\n            return 1;\n        }\n        long val = pow(a, b / 2);\n        if (b % 2 == 0) {\n            return val * val;\n        } else {\n            return val * val * a;\n        }\n    }\n\n    public static int gcd(int a, int b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n//    public static void extendEuclid(long a, long b) {\n//        if (b == 0) {\n//            x = 1;\n//            y = 0;\n//            gcd = a;\n//            return;\n//        }\n//        extendEuclid(b, a % b);\n//        long x1 = y;\n//        long y1 = x - (a / b) * y;\n//        x = x1;\n//        y = y1;\n//\n//    }\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() throws FileNotFoundException {\n            // System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            //br = new BufferedReader(new InputStreamReader(System.in));\n            br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"input.txt\"))));\n        }\n\n        public String next() {\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}\n", "label": 3}
{"src": "import java.io.Closeable;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.Writer;\nimport java.util.Collection;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.io.FileOutputStream;\nimport java.io.FileInputStream;\nimport java.util.NoSuchElementException;\nimport java.util.StringTokenizer;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Jacob Jiang\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream;\n\t\ttry {\n\t\t\tinputStream = new FileInputStream(\"input.txt\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tOutputStream outputStream;\n\t\ttry {\n\t\t\toutputStream = new FileOutputStream(\"output.txt\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tQuickScanner in = new QuickScanner(inputStream);\n\t\tExtendedPrintWriter out = new ExtendedPrintWriter(outputStream);\n\t\tTaskF solver = new TaskF();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskF {\n\tpublic void solve(int testNumber, QuickScanner in, ExtendedPrintWriter out) {\n        int treeCount = in.nextInt();\n        int answer = 0;\n        for (int treeNo = 0; treeNo < treeCount; treeNo++) {\n            int n = in.nextInt();\n            int[] from = new int[n - 1];\n            int[] to = new int[n - 1];\n            ArrayUtils.readIntArrays(in, from, to);\n            ArrayUtils.decreaseByOne(from, to);\n            answer += getMaxLength(new FixedTree(n, from, to));\n        }\n        out.println(answer);\n\t}\n\n    private int getMaxLength(Tree tree) {\n        int n = tree.getVertexCount();\n        int[] depth = new int[n];\n        for (int i : tree.getLevelOrder()) {\n            int parent = tree.getParent(i);\n            depth[i] = parent == -1 ? 0 : depth[parent] + 1;\n        }\n        int maxIndex = ArrayUtils.maxElement(depth);\n        tree.setRoot(maxIndex);\n        for (int i : tree.getLevelOrder()) {\n            int parent = tree.getParent(i);\n            depth[i] = parent == -1 ? 0 : depth[parent] + 1;\n        }\n        return ArrayUtils.max(depth);\n    }\n}\n\nclass QuickScanner implements Iterator<String>, Closeable {\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    boolean endOfFile = false;\n\n    public QuickScanner(InputStream inputStream){\n        reader = new BufferedReader(new InputStreamReader(inputStream));\n        tokenizer = null;\n    }\n\n    public boolean hasNext() {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                checkNext();\n            } catch (NoSuchElementException ignored) {\n            }\n\n        }\n        return !endOfFile;\n    }\n\n    private void checkNext() {\n        if (endOfFile) {\n            throw new NoSuchElementException();\n        }\n        try {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(reader.readLine());\n            }\n        } catch (Exception e) {\n            endOfFile = true;\n            throw new NoSuchElementException();\n        }\n    }\n\n    public String next() {\n        checkNext();\n        return tokenizer.nextToken();\n    }\n\n    public void remove() {\n        throw new UnsupportedOperationException();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public void close() {\n        try {\n            reader.close();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n\n}\n\nclass ExtendedPrintWriter extends PrintWriter {\n\n\n    public ExtendedPrintWriter(Writer out) {\n        super(out);\n    }\n\n    public ExtendedPrintWriter(OutputStream out) {\n        super(out);\n    }\n\n    }\n\nclass ArrayUtils {\n\n    private ArrayUtils() {\n    }\n\n    public static int max(int[] array) {\n        if (array.length == 0) {\n            throw new IllegalArgumentException();\n        }\n        int result = array[0];\n        for (int i = 1; i < array.length; i++) {\n            result = Math.max(result, array[i]);\n        }\n        return result;\n    }\n\n    public static int maxElement(int[] array) {\n        int maxNumber = max(array);\n        for (int i = 0; i < array.length; i++) {\n            if (array[i] == maxNumber) {\n                return i;\n            }\n        }\n        return -1;\n    }\n\n    public static void readIntArrays(QuickScanner in, int[]... arrays) {\n        for (int i = 0; i < arrays[0].length; i++) {\n            for (int j = 0; j < arrays.length; j++) {\n                arrays[j][i] = in.nextInt();\n            }\n        }\n    }\n\n    public static void decreaseByOne(int[]... arrays) {\n        for (int[] array : arrays) {\n            for (int i = 0; i < array.length; i++) {\n                array[i]--;\n            }\n        }\n    }\n\n    }\n\ninterface Tree extends Graph {\n    public int getParent(int vertexNo);\n    public void setRoot(int root);\n    public int[] getLevelOrder();\n    }\n\nclass FixedTree extends BidirectionalFixedGraph implements Tree {\n    protected int[] parent;\n    protected int[] order;\n    protected int root;\n\n    public FixedTree(int vertexCount, int[] from, int[] to) {\n        this(vertexCount, from, to, 0);\n    }\n\n    public FixedTree(int vertexCount, int[] from, int[] to, int root) {\n        super(vertexCount, from, to);\n        if (from.length != vertexCount - 1) {\n            throw new IllegalArgumentException();\n        }\n        parent = new int[getVertexCount()];\n        order = new int[getVertexCount()];\n        setRoot(root);\n    }\n\n    public int getParent(int vertexNo) {\n        return parent[vertexNo];\n    }\n\n    public void setRoot(int root) {\n        this.root = root;\n        int orderIndex = 0;\n        order[orderIndex++] = root;\n        parent[root] = -1;\n        for (int i = 0; i < getVertexCount(); i++) {\n            int current = order[i];\n            for (int child : edges[current]) {\n                if (child != parent[current]) {\n                    order[orderIndex++] = child;\n                    parent[child] = current;\n                }\n            }\n        }\n    }\n\n    public int[] getLevelOrder() {\n        return order;\n    }\n\n    public int getDegree(int vertexNo) {\n        if (vertexNo == root) {\n            return super.getDegree(vertexNo);\n        } else {\n            return super.getDegree(vertexNo) - 1;\n        }\n    }\n\n    public int[] getConnectedEdgesArray(int vertexNo) {\n        int[] temp = super.getConnectedEdgesArray(vertexNo);\n        int[] result = new int[getDegree(vertexNo)];\n        int index = 0;\n        for (int item : temp) {\n            if (item != getParent(vertexNo)) {\n                result[index++] = item;\n            }\n        }\n        return result;\n    }\n}\n\ninterface Graph {\n    int getVertexCount();\n    }\n\nclass BidirectionalFixedGraph extends FixedGraph {\n    public BidirectionalFixedGraph(int vertexCount, int[] from, int[] to) {\n        if (from.length != to.length) {\n            throw new IllegalArgumentException();\n        }\n        edges = new int[vertexCount][];\n        int[] degree = new int[vertexCount];\n        for (int i = 0; i < from.length; i++) {\n            degree[from[i]]++;\n            degree[to[i]]++;\n        }\n        for (int i = 0; i < vertexCount; i++) {\n            edges[i] = new int[degree[i]];\n        }\n        for (int i = 0; i < from.length; i++) {\n            edges[from[i]][--degree[from[i]]] = to[i];\n            edges[to[i]][--degree[to[i]]] = from[i];\n        }\n    }\n}\n\nabstract class FixedGraph implements Graph {\n    protected int[][] edges;\n\n    public int getVertexCount() {\n        return edges.length;\n    }\n\n    public int getDegree(int vertexNo) {\n        return edges[vertexNo].length;\n    }\n\n    public int[] getConnectedEdgesArray(int vertexNo) {\n        return edges[vertexNo];\n    }\n\n    }\n\n", "label": 3}
{"src": "//package codeforces.practice.oneVone.Nov06_2020;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class B {\n    static InputReader in;\n    static PrintWriter out;\n\n    public static void main(String[] args) {\n        initReaderPrinter(true);\n        //initReaderPrinter(false);\n        //solve(in.nextInt());\n        solve(1);\n    }\n\n    static void solve(int testCnt) {\n        for (int testNumber = 0; testNumber < testCnt; testNumber++) {\n            int n = in.nextInt();\n            int ans = 0;\n            for(int i = 0; i < n; i++) {\n                int k = in.nextInt();\n                List<Integer>[] adj = new List[k];\n                for(int j = 0; j < k; j++) {\n                    adj[j] = new ArrayList<>();\n                }\n                for(int j = 0; j < k - 1; j++) {\n                    int u = in.nextInt() - 1;\n                    int v = in.nextInt() - 1;\n                    adj[u].add(v);\n                    adj[v].add(u);\n                }\n                ans += diameterBFS(adj);\n            }\n            out.println(ans);\n        }\n        out.close();\n    }\n\n    static int diameterBFS(List<Integer>[] g) {\n        if(g.length == 0) {\n            return 0;\n        }\n        int startV = 0;\n        int[] r = diameterBFSHelper(g, startV);\n        return diameterBFSHelper(g, r[1])[0];\n    }\n\n    /*\n        return an array r of size 2.\n        r[0]: is the longest path that starts from startV;\n        r[1]: is the node that is the furthest away from startV.\n     */\n    static int[] diameterBFSHelper(List<Integer>[] g, int startV) {\n        Queue<Integer> q = new LinkedList<>();\n        Set<Integer> visited = new HashSet<>();\n        q.add(startV);\n        visited.add(startV);\n\n        int maxDistance = 0, maxDistanceNode = startV;\n        while(q.size() > 0) {\n            int sz = q.size();\n            for(int i = 0; i < sz; i++) {\n                int v = q.poll();\n                for(int w : g[v]) {\n                    if(!visited.contains(w)) {\n                        q.add(w);\n                        visited.add(w);\n                        maxDistanceNode = w;\n                    }\n                }\n            }\n            maxDistance++;\n        }\n        return new int[]{maxDistance - 1, maxDistanceNode};\n    }\n\n    static void initReaderPrinter(boolean test) {\n        if (test) {\n            try {\n                in = new InputReader(new FileInputStream(\"input.txt\"));\n                out = new PrintWriter(new FileOutputStream(\"output.txt\"));\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        } else {\n            in = new InputReader(System.in);\n            out = new PrintWriter(System.out);\n        }\n    }\n\n    static class InputReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        InputReader(InputStream stream) {\n            try {\n                br = new BufferedReader(new InputStreamReader(stream), 32768);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        Integer[] nextIntArray(int n) {\n            Integer[] a = new Integer[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        Long[] nextLongArray(int n) {\n            Long[] a = new Long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n    }\n}\n\n\n", "label": 3}
{"src": "import java.io.*;\nimport java.lang.reflect.Array;\n//import java.util.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\nimport java.util.*;\npublic class Main\n{\n  static ArrayList<Integer> graph[];\n  static boolean vis[];\n  static int ans=0;\n  static int max=0;\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    public static void dfs(int u, int present_height)\n    {\n      vis[u]=true;\n\n      for( int i=0;i<graph[u].size();i++)\n      {\n        int v=graph[u].get(i);\n        if(!vis[v])\n        {\n          dfs(v,present_height+1);\n          max=Math.max(present_height+1,max);\n        }\n      }\n\n    }\n    public static void main(String[] args) throws IOException\n    {\n      Scanner in = new Scanner(new File(\"input.txt\"));\n      PrintWriter out = new PrintWriter(new File(\"output.txt\"));\n        StringBuilder sb=new StringBuilder();\n        int t=in.nextInt();\n        int max1=0;\n        while(t-->0)\n        {\n        int n=in.nextInt();\n        graph=new ArrayList[n+1];\n        for( int i=1;i<=n;i++)\n        {\n          graph[i]=new ArrayList<>();\n        }\n        for( int i=0;i<n-1;i++)\n        {\n          int u=in.nextInt();\n          int v=in.nextInt();\n          graph[u].add(v);\n          graph[v].add(u);\n        }\n\n        boolean check=true;\n        for( int i=1;i<=n;i++)\n        {\n        vis=new boolean[n+1];\n\n            dfs(i,0);\n            max1=Math.max(max1,max);\n            max=0;\n\n        }\n        ans+=max1;\n        max1=0;\n      }\n\n    //    sb.append(ans);\n      //  System.out.println(sb.toString());\n      out.println(ans);\n       out.close();\n  }\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.awt.Point;\nimport java.io.*;\n\npublic class Main{\n    public static void read(long[] a,int n) throws IOException{for (int i=0;i<n;i++){a[i]=Reader.nextLong();}}\n    public static <T> void print(T[] a,int n,PrintWriter out){for (T i : a){ out.print(i+\" \");}out.println();}\n    static int[] dist;\n    static int[] visited;\n    public static Point bfs(ArrayList<Integer>[] arr,int u){\n        Queue<Integer> q = new LinkedList<>();\n        q.add(u);\n        int max = 0;\n        int index = -1;\n        while(!q.isEmpty()){\n            int a = q.poll();\n            visited[a] = 1;\n            for (int i=0;i<arr[a].size();i++){\n                if (visited[arr[a].get(i)]==0){\n                    dist[arr[a].get(i)] = dist[a]+1;\n                    visited[arr[a].get(i)] = 1;\n                    if (max<dist[arr[a].get(i)]){\n                        max = dist[arr[a].get(i)];\n                        index = arr[a].get(i);\n                    }\n                    q.add(arr[a].get(i));\n                }\n            }\n        }\n        return new Point(index,max);\n    }\n    public static void main(String[] args) throws IOException{\n        Reader scan = new Reader();\n        scan.init(System.in);\n        BufferedReader br = new BufferedReader(new FileReader(\"input.txt\"));\n        // OutputStream output = System.out;\n        BufferedWriter output = new BufferedWriter(new FileWriter(\"output.txt\"));\n        PrintWriter out = new PrintWriter(output);\n        int n = Integer.parseInt(br.readLine());\n        long sum = 0;\n        for (int i=0;i<n;i++){\n            String[] A = br.readLine().split(\" \");\n            int N = Integer.parseInt(A[0]);\n            ArrayList<Integer>[] arr = new ArrayList[N];\n            for (int j=0;j<N;j++){\n                arr[j] = new ArrayList<Integer>();\n            }\n            for (int j=1;j<A.length;j+=2){\n                int x = Integer.parseInt(A[j])-1;\n                int y = Integer.parseInt(A[j+1])-1;\n                arr[x].add(y);\n                arr[y].add(x);\n            }\n            dist = new int[N];\n            visited = new int[N];\n            Point P = bfs(arr,0);\n            dist = new int[N];\n            visited = new int[N];\n            Point Q = bfs(arr,P.x);\n            sum += Q.y;\n        }\n        out.println(sum);\n        out.flush();\n        out.close();\n    }\n}\nclass Comp implements Comparator<Point>{\n    public int compare(Point a,Point b){\n        return (a.x-b.x);\n    } \n}\nclass dsu{\n    int[] arr;\n    dsu(int N){\n        arr = new int[N];\n        for (int i=0;i<N;i++){\n            arr[i] = i;\n        }\n    }\n    public void joint(int A,int B){\n        int a = find(A);\n        int b = find(B);\n        arr[a] = b;\n    }\n    public int find(int A){\n        while(A!=arr[A]){\n            A = arr[A];\n        }\n        return A;\n    }\n}\nclass Reader {\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n    static void init(InputStream input) {\n        reader = new BufferedReader(\n                     new InputStreamReader(input) );\n        tokenizer = new StringTokenizer(\"\");\n    }\n    static String next() throws IOException {\n        while ( ! tokenizer.hasMoreTokens() ) {\n            tokenizer = new StringTokenizer(\n                   reader.readLine() );\n        }\n        return tokenizer.nextToken();\n    }\n    static int nextInt() throws IOException {\n        return Integer.parseInt( next() );\n    }\n    static long nextLong() throws IOException {\n        return Long.parseLong( next() );\n    }\n    static double nextDouble() throws IOException {\n        return Double.parseDouble( next() );\n    }\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Codeforces {\n\n    StringTokenizer tok;\n    BufferedReader in;\n    PrintWriter out;\n\n    final boolean OJ = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n    String filename = \"input\";\n\n    void init() {\n        try {\n            if (OJ) {\n                if (filename == null) {\n                    in = new BufferedReader(new InputStreamReader(System.in));\n                    out = new PrintWriter(System.out);\n                } else {\n                    in = new BufferedReader(new FileReader(\"input.txt\"));\n                    out = new PrintWriter(\"output.txt\");\n                }\n            } else {\n                in = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    String readString() {\n        try {\n            while (tok == null || !tok.hasMoreTokens()) {\n                tok = new StringTokenizer(in.readLine());\n            }\n            return tok.nextToken();\n        } catch (Throwable t) {\n            throw new RuntimeException(t);\n        }\n    }\n\n    int readInt() {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() {\n        return Long.parseLong(readString());\n    }\n\n    public static void main(String[] args) {\n        new Codeforces().run();\n    }\n\n    void run() {\n        init();\n        long time = System.currentTimeMillis();\n        solve();\n        System.err.println(System.currentTimeMillis() - time);\n        out.close();\n    }\n\n    ArrayList<Integer>[] graph;\n    int[] d;\n\n\n    void dfs(int x, int p, int h) {\n        d[x] = h;\n        for (int to : graph[x]) {\n            if (to != p) {\n                dfs(to, x, h + 1);\n            }\n        }\n    }\n\n    void solve() {\n        int n = readInt();\n        int ans = 0;\n        for (int i=0;i<n;i++) {\n            int k = readInt();\n            graph = new ArrayList[k];\n            for (int j=0;j<k;j++) {\n                graph[j] = new ArrayList<>();\n            }\n            for (int j=0;j<k-1;j++) {\n                int x = readInt() - 1;\n                int y = readInt() - 1;\n                graph[x].add(y);\n                graph[y].add(x);\n            }\n            d = new int[k];\n            dfs(0,-1,0);\n            int max = -1;\n            int ind = -1;\n            for (int j=0;j<k;j++) {\n                if (d[j] > max) {\n                    max = d[j];\n                    ind = j;\n                }\n            }\n            d = new int[k];\n            dfs(ind,-1,0);\n\n            max = -1;\n            ind = -1;\n            for (int j=0;j<k;j++) {\n                if (d[j] > max) {\n                    max = d[j];\n                    ind = j;\n                }\n            }\n            ans += max;\n\n\n        }\n\n        out.println(ans);\n\n    }\n\n}", "label": 3}
{"src": "import java.util.*;\nimport java.util.Map.Entry;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n\t\n    void solve() throws Exception {\n    \tint q = sc.nextInt();\n    \tint ans = 0;\n    \twhile (q-- > 0) {\n    \t\tint n = sc.nextInt();\n    \t\tint[][] a = new int[n][n];\n    \t\tfor (int it = 0; it < n - 1; it++) {\n    \t\t\tint v = sc.nextInt() - 1;\n    \t\t\tint u = sc.nextInt() - 1;\n    \t\t\ta[v][u] = a[u][v] = 1;\n    \t\t}\n    \t\tfor (int k = 0; k < n; k++) {\n    \t\t\tfor (int i = 0; i < n; i++) {\n    \t\t\t\tfor (int j = 0; j < n; j++) {\n    \t\t\t\t\tif (a[i][k] > 0 && a[k][j] > 0) {\n    \t\t\t\t\t\tif (a[i][j] == 0 || a[i][j] > a[i][k] + a[k][j]) {\n    \t\t\t\t\t\t\ta[i][j] = a[i][k] + a[k][j];\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tint mx = 0;\n    \t\tfor (int i = 0; i < n; i++) {\n    \t\t\tfor (int j = i + 1; j < n; j++) {\n    \t\t\t\tmx = max(mx, a[i][j]);\n    \t\t\t}\n    \t\t}\n    \t\tans += mx;\n    \t}\n    \tout.println(ans);\n    }\n    \n    BufferedReader in;\n    PrintWriter out;\n    FastScanner sc;\n    \n    final String INPUT_FILE = \"input.txt\";\n    final String OUTPUT_FILE = \"output.txt\";\n    \n    static Throwable throwable;\n    \n    public static void main(String[] args) throws Throwable {\n        Thread thread = new Thread(null, new Solution(), \"\", (1 << 26));\n        thread.start();\n        thread.join();\n        thread.run();\n        if (throwable != null)\n            throw throwable;\n    }\n    \n    \n    public void run() {\n        try {\n            if (INPUT_FILE.equals(\"stdin\"))\n                in = new BufferedReader(new InputStreamReader(System.in));\n            else\n                in = new BufferedReader(new FileReader(INPUT_FILE));\n            if (OUTPUT_FILE.equals(\"stdout\"))\n                out = new PrintWriter(System.out);\n            else\n                out = new PrintWriter(new FileWriter(OUTPUT_FILE));\n            sc = new FastScanner(in);\n            solve();\n        } catch (Exception e) {\n            throwable = e;\n        } finally {\n            out.close();\n        }\n    }\n}\n\nclass FastScanner {\n    BufferedReader reader;\n    StringTokenizer strTok;\n    \n    FastScanner(BufferedReader reader) {\n        this.reader = reader;\n    }\n    \n    public String nextToken() throws Exception {\n        while (strTok == null || !strTok.hasMoreTokens())\n            strTok = new StringTokenizer(reader.readLine());\n        return strTok.nextToken();\n    }\n    \n    public boolean EOF() throws Exception {\n    \tif (strTok != null && strTok.hasMoreTokens()) {\n    \t\treturn false;\n    \t} else {\n    \t\tString line = reader.readLine();\n    \t\tif (line == null)\n    \t\t\treturn true;\n    \t\tstrTok = new StringTokenizer(line);\n    \t\treturn false;\n    \t}\n    }\n    \n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n    \n    public long nextLong() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n    \n    public double nextDouble() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Spiders {\n\t\n\tstatic int maxLen;\n\t\n\tstatic void dfs(HashMap<Integer,HashSet<Integer>> graph,int i,int vis[],int len) {\n\t\tvis[i] = 1;\n\t\tmaxLen = Math.max(maxLen, len);\n\t\tfor(int j : graph.get(i)) {\n\t\t\tif(vis[j] != 1) {\n\t\t\t\tdfs(graph,j,vis,len+1);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tScanner in  = new Scanner(new File(\"input.txt\"));\n        PrintWriter out = new PrintWriter(\"output.txt\");\n        int t = in.nextInt();\n        int totalLen = 0;\n        while(t-->0) {\n        \tint n = in.nextInt();\n        \tHashMap<Integer,HashSet<Integer>> graph = new HashMap<>();\n        \tfor(int i=1;i<=n;i++) {\n        \t\tgraph.put(i,new HashSet<>());\n        \t}\n        \tfor(int i=0;i<n-1;i++) {\n        \t\tint key = in.nextInt(); int data = in.nextInt();\n        \t\tHashSet<Integer> set1 = graph.get(key);\n        \t\tHashSet<Integer> set2 = graph.get(data);\n    \t\t\tset1.add(data);set2.add(key);\n    \t\t\tgraph.put(key, set1);graph.put(data, set2);\n        \t}\n        \tmaxLen = 0;\n        \tfor(int i : graph.keySet()) {\n        \t\tint vis[] = new int[n+1];\n        \t\tdfs(graph,i,vis,0);\n        \t}\n        \ttotalLen += maxLen;\n        }\n\t\tout.println(totalLen);\n\t\tout.close();\n\t}\n}\n\n\n\n\n\n", "label": 3}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.FileOutputStream;\nimport java.io.PrintWriter;\nimport java.io.FileInputStream;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream;\n\t\ttry {\n\t\t\tinputStream = new FileInputStream(\"input.txt\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tOutputStream outputStream;\n\t\ttry {\n\t\t\toutputStream = new FileOutputStream(\"output.txt\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskf solver = new Taskf();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass Taskf {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\tint n = in.nextInt();\n\t\tint ans = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint ni = in.nextInt();\n\t\t\tboolean [][]b = new boolean[ni][ni];\n\t\t\tfor(int j=0;j<ni-1;j++){\n\t\t\t\tint x = in.nextInt()-1;\n\t\t\t\tint y = in.nextInt()-1;\n\t\t\t\tb[x][y] = true;\n\t\t\t\tb[y][x] = true;\n\t\t\t}\n\t\t\t//int max =0 ;\n\t\t\t//for(int j=0;j<ni;j++)\n\t\t\t//max = Math.max(dfs(b,j,new boolean[ni]),max);\n\t\t\t//ans += max;\n\t\t\tint []depth = new int[ni];\n\t\t\tdfs(b,depth,new boolean[ni],0,0);\n\t\t\tint max = 0;\n\t\t\tint index =0;\n\t\t\tfor(int j=0;j<depth.length;j++)\n\t\t\t\tif(depth[j]>max){\n\t\t\t\t\tmax = depth[j];\n\t\t\t\t\tindex = j;\n\t\t\t\t}\n\t\t\tans += dfs(b,index,new boolean[ni]);\n\t\t}\n\t\tout.println(ans);\n\t}\n\tprivate int dfs(boolean[][] b, int i,boolean []v) {\n\t\tint res = 0;\n\t\tv[i] = true;\n\t\tfor(int j=0;j<b.length;j++)\n\t\t\tif(b[i][j] && !v[j])\n\t\t\t\tres = Math.max(res, 1+ dfs(b,j,v));\n\t\treturn res;\n\t}\n\t\n\tprivate void dfs(boolean [][]b,int []depth,boolean []v,int i,int len){\n\t\tv[i] = true;\n\t\tdepth[i] = len;\n\t\t\n\t\tfor(int j=0;j<b.length;j++)\n\t\t\tif(b[i][j] && !v[j])\n\t\t\t\tdfs(b,depth, v,j,len+1);\n\t}\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt(){\n        return Integer.parseInt(next());\n    }\n\n    }\n\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\nimport static java.lang.Math.*;\n\npublic class Main implements Runnable {\n\n    StreamTokenizer in;\n    BufferedReader reader;\n    PrintWriter out;\n    StringTokenizer tok;\n    Scanner sc;\n    boolean timus =true;// System.getProperty(\"ONLINE_JUDGE\")!=null;\n    boolean codeforces = false;\n    final double eps = 1e-9;\n    \n    public static void main(String[] args) throws Exception {\n        new Thread(new Main()).start();\n    }\n    \n    @Override\n    public void run() {\n        try {\n            if (codeforces) {\n                sc = new Scanner(System.in);\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                in = new StreamTokenizer(reader);\n                out= new PrintWriter (new OutputStreamWriter(System.out));\n                tok = new StringTokenizer(\"\");\n                solve();\n                out.flush();\n            } else\n                if (timus) {\n                    sc = new Scanner(\"input.txt\");\n                    reader = new BufferedReader(new FileReader(\"input.txt\"));\n                    in = new StreamTokenizer(reader);\n                    out= new PrintWriter (new FileWriter(\"output.txt\"));\n                    tok = new StringTokenizer(\"\");\n                    solve();\n                    out.flush();\n                    out.close();\n                } else\n                    if (!timus) {\n                long begMem = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n                long t1 = System.currentTimeMillis();\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                in = new StreamTokenizer(reader);\n                sc = new Scanner(System.in);\n                out= new PrintWriter (new OutputStreamWriter(System.out));\n                tok = new StringTokenizer(\"\");\n                solve();\n                long endMem = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();\n                out.flush();\n                long t2 = System.currentTimeMillis();\n                System.out.println(\"Time:\"+(t2-t1));\n                System.out.println(\"Memory:\"+(endMem-begMem));\n                System.out.println(\"Total memory: \" + (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()));\n            }\n        }\n        catch (Exception ex) {\n            System.out.println(\"fail\");\n            System.exit(1);\n        }\n    }\n    \n    public class Chess {\n        String coord;\n        \n        public Chess(String s){\n            this.coord=s;\n        }\n        \n        public int toInteger(char s) {\n            if (s=='a'||s=='A') return 1;\n            else if (s=='b'||s=='B') return 2;\n            else if (s=='c'||s=='C') return 3;\n            else if (s=='d'||s=='D') return 4;\n            else if (s=='e'||s=='E') return 5;\n            else if (s=='f'||s=='F') return 6;\n            else if (s=='g'||s=='G') return 7;\n            else if (s=='h'||s=='H') return 8;\n            else return -1;\n        }\n        \n        public String toString(int s) {\n            if (s==1) return \"a\";\n            else if (s==2) return \"b\";\n            else if (s==3) return \"c\";\n            else if (s==4) return \"d\";\n            else if (s==5) return \"e\";\n            else if (s==6) return \"f\";\n            else if (s==7) return \"g\";\n            else if (s==8) return \"h\";\n            else return \"0\";\n        }\n        \n        public pair getPair() {\n            String j=\"\";\n            j+=coord.charAt(1);\n            pair p = new pair(toInteger(coord.charAt(0)),Integer.parseInt(j));\n            if (p.x!=-1)\n            return p; else\n                return new pair(0,0);\n        }\n        \n        public String returnPair(pair p) {\n            return toString(p.x)+p.y;\n        }\n    }\n    \n    public int nextInt() throws Exception {\n        in.nextToken();\n        return (int) in.nval;\n    }\n    \n    public String next() throws Exception {\n        in.nextToken();\n        return in.sval;\n    }\n    \n    public String nextLine() throws Exception {\n        return reader.readLine();\n    }\n    \n    public String nextString() throws Exception {\n        while (!tok.hasMoreTokens())\n            tok = new StringTokenizer(reader.readLine());\n        return tok.nextToken();\n    }\n    \n    public long nextLong() throws Exception {\n        return Long.parseLong(nextString());\n    }\n    \n    public double nextDouble() throws Exception {\n        in.nextToken();\n        return in.nval;\n    }\n    \n    public class pair {\n        int x;\n        int y;\n        \n        public pair(int x, int y) {\n            this.x=x;\n            this.y=y;\n        }\n    }\n    \n    public int gcd(int a, int b) {\n        if (a== 0||b==0) return 1;\n        if (a<b) {\n                int c=b;\n                b=a;\n                a=c;\n        }\n        while (a%b!=0) {\n                a =a%b;\n                if (a<b) {\n                        int c=b;\n                        b=a;\n                        a=c;\n                }\n        }\n        return b;\n    }\n    \n     public int pow(int a, int n) {\n         if (n==0) return 1;\n         int k=n, b=1, c=a;\n         while (k!=0) {\n                 if (k%2==0) {\n                         k/=2;\n                         c*=c;\n                 } else {\n                         k--;\n                         b*=c;\n                 }\n         }\n         return b;\n     }\n    \n    public int lcm(int a, int b) {\n        return a*b/gcd(a,b);\n    }\n    \n    public class pairs implements Comparable<pairs> {\n        int x;\n        int y;\n        \n        public pairs(int x, int y) {\n            this.x=x;\n            this.y=y;\n        }\n\n        @Override\n        public int compareTo(pairs obj) {\n            if (this.x<((pairs)obj).x) return 1;\n            else if (this.x==(obj).x&&this.y<(obj).y) return 1;\n            else if (this.x==(obj).x&&this.y==(obj).y)return 0; else\n                return -1;\n        }   \n    }\n    \n    public class Graf {\n        \n        int [][] a;\n        int [] colors;\n        ArrayList <String> points = new ArrayList<String>();\n        LinkedList <Integer> queue = new LinkedList <Integer>();\n        boolean [] used;\n        boolean cycle;\n        int numberOfCycle;\n        \n        public Graf(int [][]a,String s[]) {\n            this.a=new int [s.length][s.length];\n            this.a=a;\n            this.colors=new int [s.length];\n            this.used=new boolean[s.length];\n            for (int i=0; i<s.length;i++) {\n                this.colors[i]=0;\n                this.points.add(s[i]);\n            }\n            Arrays.fill(this.used, false);\n        }\n        \n        public void bfs(int i) {\n            this.queue.add(i);\n            while (!this.queue.isEmpty())\n            {\n                i = this.queue.pop();\n                out.print(points.get(i)+\" \");\n                this.used[i]=true;\n                for (int j=0; j<this.points.size();j++) {\n                    if (this.a[i][j]==1&&!this.queue.contains(j)&&!this.used[j]) {\n                        this.a[i][j]=0;\n                        this.a[j][i]=0;\n                        this.queue.addLast(j);\n                    }\n                }\n            }\n        }\n        \n        public void dfs(int i) {\n            this.colors[i]=1;\n            out.print(points.get(i)+\" \");\n            for (int j=0; j<this.colors.length;j++) {\n                if (this.a[i][j]==1&&this.colors[j]==0) {\n                    this.colors[j]=1;\n                    this.a[i][j]=0;\n                    this.a[j][i]=0;\n                    dfs(j);\n                } else if (this.a[i][j]==1&&this.colors[j]==1) {\n                    this.cycle=true;\n                    this.numberOfCycle++;\n                }\n            }\n            this.colors[i]=2;\n        }   \n    }\n    \n    public class Time {\n        \n        int h;\n        int min;\n        int sec;\n        \n        public Time(String s) {\n            String [] st = s.split(\":\");\n            this.h =Integer.parseInt(st[0]);\n            this.min =Integer.parseInt(st[1]);\n            this.sec =(st[2]!=null)? Integer.parseInt(st[2]):0;\n        }\n        \n        public String toString(int a) {\n            String h = Integer.toString(this.h);\n            String min = Integer.toString(this.min);\n            String sec = Integer.toString(this.sec);\n            if (h.length()==1) {\n                h='0'+h;\n            }\n            if (min.length()==1) {\n                min='0'+min;\n            }\n            if (sec.length()==1) {\n                sec='0'+sec;\n            }\n            if (a==5) {\n                return h+\":\"+min;\n            } else {\n                return h+\":\"+min+\":\"+sec;\n            }\n        }\n        \n        public void to12HoursFormat () {\n            h%=12;\n        }\n        \n        public void add (int  h,int min,int s) {\n            this.sec+=s;\n            if (this.sec>=60) {\n                this.min++;\n                this.sec%=60;\n            }\n            this.min+=min;\n            if (this.min>=60) {\n                this.h++;\n                this.min%=60;\n            }\n            this.h+=h;\n            if (this.h>=24) {\n                this.h%=24;\n            }\n        }\n    }\n    \n    public int[] findPrimes(int x) {\n        boolean[] erat = new boolean[x-1];\n        List<Integer> t = new ArrayList<Integer>();\n        int l=0, j=0;\n        for (int i=2;i<x; i++) {\n                if (erat[i-2]) continue;\n                t.add(i);\n                l++;\n                j=i*2;\n                while (j<x) {\n                        erat[j-2]=true;\n                        j+=i;\n                }\n        }\n        int[] primes = new int[l];\n        Iterator<Integer> iterator = t.iterator();\n        for (int i = 0; iterator.hasNext(); i++) {\n                primes[i]=iterator.next().intValue();\n        }\n        return primes;\n    }\n    \n    public double dist(pair a,pair b) {\n        return sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));\n    }\n    \n    int max_val=Integer.MIN_VALUE;\n    \n    public void dfs (int current, int prev, int max,int a[][]) {\n        int n = a[0].length;\n        for (int i=0; i<n;i++) {\n            if (a[current][i]==1&&prev!=i) {\n                dfs(i,current,max+1,a);\n            }\n        }\n        max_val = max(max_val,max);\n    }\n    \n    public void solve() throws Exception {\n        int n = nextInt();\n        int ans=0;\n        for (int i=0; i<n;i++) {\n            int k = nextInt();\n            int [] b= new int [k];\n            int a[][] = new int [k][k];\n            for (int j=0; j<k-1;j++) {\n                int x = nextInt();\n                int y = nextInt();\n                a[x-1][y-1]=1;\n                a[y-1][x-1]=1;\n                b[x-1]++;\n                b[y-1]++;\n            }\n            ArrayList <Integer> al = new ArrayList <Integer>();\n            for (int j=0;j<k;j++) {\n                if (b[j]==1) {\n                    al.add(j);\n                }\n            }\n            for (int q:al) {\n                dfs(q,-1,0,a);\n            }\n            ans+=max_val;\n            max_val=Integer.MIN_VALUE;\n        }\n        out.println(ans);\n    }\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    int m;\n    int[][] graph = new int[110][110];\n    int[] path = new int[110];\n    LinkedList<Integer> stack = new LinkedList<Integer>();\n    \n    void clearGraph() {\n        for(int i = 0; i < m; ++i)\n            for(int j = 0; j < m; ++j)\n                graph[i][j] = 0;\n    }\n    \n    int dfs(int v) {\n        stack.clear();\n        \n        Arrays.fill(path, -1);\n        stack.addLast(v);\n        path[v] = 0;\n        \n        while(!stack.isEmpty()) {\n            int d = stack.removeLast();\n            \n            for(int i = 0; i < m; ++i)\n                if(graph[d][i] == 1 && path[i] == -1) {\n                    path[i] = path[d] + 1;\n                    stack.addLast(i);\n                }\n        }\n        \n        int res = 0;\n        for(int i = 0; i < m; ++i)\n            if(res < path[i])\n                res = path[i];\n        \n        return res;\n    }\n    \n    int graphLength() {\n        int res = 0;\n        \n        for(int i = 0; i < m; ++i) {\n            int v = dfs(i);\n            \n            if(v > res)\n                res = v;\n        }\n        \n        return res;\n    }\n    \n    void solve() throws IOException {\n        int n = nextInt();\n        \n        int ans = 0;\n        for(int i = 0; i < n; ++i) {\n            m = nextInt();\n            clearGraph();\n            \n            for(int j = 0; j < m - 1; ++j) {\n                int a = nextInt() - 1;\n                int b = nextInt() - 1;\n                graph[a][b] = 1;\n                graph[b][a] = 1;\n            }\n            \n            ans += graphLength();\n        }\n        \n        out.println(ans);\n    }\n    \n    void run() throws IOException {\n        in = new BufferedReader(new FileReader(\"input.txt\"));\n        out = new PrintWriter(new FileWriter(\"output.txt\"));\n        solve();\n        in.close();\n        out.close();\n    }\n    \n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok;\n    \n    String nextToken() throws IOException {\n        while(tok == null || !tok.hasMoreTokens())\n            tok = new StringTokenizer(in.readLine());\n        \n        return tok.nextToken();\n    }\n    \n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n    \n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n    \n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n    \n    public static void main(String[] args) throws IOException {\n        new Main().run();\n    }\n}\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n/**\n * \n */\n\n/**\n * @author antonio081014\n * @date Oct 18, 2011, 12:53:55 PM\n */\npublic class F {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\ttry {\n\t\t\tFileInputStream fis = new FileInputStream(\"input.txt\");\n\t\t\tFileWriter fstream = new FileWriter(\"output.txt\");\n\t\t\tBufferedWriter out = new BufferedWriter(fstream);\n\t\t\tDataInputStream in = new DataInputStream(fis);\n\t\t\tBufferedReader br = new BufferedReader(new InputStreamReader(in));\n\t\t\tint T = Integer.parseInt(br.readLine());\n\t\t\tint count = 0;\n\t\t\tfor (int i = 0; i < T; i++) {\n\t\t\t\tStringTokenizer stk = new StringTokenizer(br.readLine(), \" \");\n\t\t\t\tint n = Integer.parseInt(stk.nextToken());\n\t\t\t\tList<Node> node = new ArrayList<Node>();\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tnode.add(new Node(j));\n\t\t\t\t}\n\t\t\t\tfor (int j = 0; j < n - 1; j++) {\n\t\t\t\t\tint a = Integer.parseInt(stk.nextToken()) - 1;\n\t\t\t\t\tint b = Integer.parseInt(stk.nextToken()) - 1;\n\t\t\t\t\tnode.get(a).next.add(node.get(b));\n\t\t\t\t\tnode.get(b).next.add(node.get(a));\n\t\t\t\t}\n\t\t\t\t// for (int j = 0; j < node.size(); j++) {\n\t\t\t\t// System.out.print(\"Node \" + j + \":\");\n\t\t\t\t// for (int k = 0; k < node.get(j).next.size(); k++) {\n\t\t\t\t// System.out.print(node.get(j).next.get(k).data + \", \");\n\t\t\t\t// }\n\t\t\t\t// System.out.println();\n\t\t\t\t// }\n\t\t\t\tint ret = 0;\n\t\t\t\tfor (int j = 0; j < node.size(); j++) {\n\t\t\t\t\tint tmp = rec(node.get(j), new HashSet<Integer>());\n\t\t\t\t\tret = Math.max(tmp, ret);\n\t\t\t\t}\n\t\t\t\t// System.out.println(ret - 1);\n\t\t\t\tcount += ret - 1;\n\t\t\t}\n\t\t\tout.write(Integer.toString(count));\n\t\t\tout.close();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static int rec(Node node, HashSet<Integer> set) {\n\t\tint ret = 0;\n\t\tset.add(node.data);\n\t\tfor (int i = 0; i < node.next.size(); i++) {\n\t\t\tif (set.contains(node.next.get(i).data))\n\t\t\t\tcontinue;\n\t\t\tint tmp = rec(node.next.get(i), set);\n\t\t\tif (tmp > ret)\n\t\t\t\tret = tmp;\n\t\t}\n\t\treturn ret + 1;\n\t}\n}\n\nclass Node {\n\tint data;\n\tList<Node> next;\n\n\tpublic Node(int value) {\n\t\tthis.data = value;\n\t\tnext = new ArrayList<Node>();\n\t}\n}\n", "label": 3}
{"src": "\nimport java.awt.Point;\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class a implements Runnable {\n\n    private Edge[] first;\n\n    private void addToEdgeList(int a, int b) {\n        if (first[a] != null) {\n            Edge edge = new Edge(a, b, first[a].next);\n            first[a].next = edge;\n        }\n        else\n        {\n            Edge edge = new Edge(a, b, null);\n            first[a] = edge;\n        }\n    }\n\n    private void dfs(int i, int len, boolean[] visited, int[] maxid) {\n        if (visited[i])\n            return;\n        visited[i] = true;\n        if (maxid[1] < len)\n        {\n            maxid[0] = i;\n            maxid[1] = len;\n        }\n        for (Edge edge = first[i]; edge != null;edge = edge.next)\n            dfs(edge.b, len + 1, visited, maxid);\n    }\n\n    private static class Edge {\n\n        int a;\n        int b;\n        Edge next;\n\n        public Edge(int a, int b, Edge next) {\n            this.a = a;\n            this.b = b;\n            this.next = next;\n        }\n    }\n    BufferedReader in;\n    PrintWriter out;\n    StringTokenizer tok = new StringTokenizer(\"\");\n\n    public static void main(String[] args) {\n        new Thread(null, new a(), \"\", 256 * (1L << 20)).start();\n    }\n\n    public void run() {\n        try {\n            long t1 = System.currentTimeMillis();\n            {\n                in = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            }\n            Locale.setDefault(Locale.US);\n            solve();\n            in.close();\n            out.close();\n            long t2 = System.currentTimeMillis();\n        } catch (Throwable t) {\n            t.printStackTrace(System.err);\n            System.exit(-1);\n        }\n    }\n\n    String readString() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    int findLen() throws IOException {\n        int res = 0;\n        int n = readInt();\n        first = new Edge[n];\n        for (int i = 0; i < n - 1; i++) {\n            int a = readInt(), b = readInt();\n            a--;\n            b--;\n            addToEdgeList(a, b);\n            addToEdgeList(b, a);\n        }\n        boolean[] visited = new boolean[n];\n        int[] maxid = new int[2];\n        dfs(0, 0, visited, maxid);\n        for (int i = 0; i < n; i++)\n            visited[i] = false;\n        int[] maxmaxid = new int[2];\n        dfs(maxid[0], 0, visited, maxmaxid);\n        return maxmaxid[1];\n    }\n    // a\n\n    void solve() throws IOException {\n        int res = 0;\n        int n = readInt();\n        for (int i = 0; i < n; i++) {\n            res += findLen();\n        }\n        out.println(res);\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.InputMismatchException;\nimport java.util.LinkedList;\nimport java.util.Queue;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author El-Bishoy\n */\npublic class Main {\n    public static void main(String[] args) throws FileNotFoundException {\n        InputStream inputStream = new FileInputStream(\"input.txt\");\n        OutputStream outputStream = new FileOutputStream(\"output.txt\");\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        F120_Spiders solver = new F120_Spiders();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class F120_Spiders {\n        ArrayList<Integer>[] adj;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n\n\n            int ans = 0;\n            while (n-- > 0) {\n                int nn = in.nextInt();\n                adj = GraphUtils.buildAdjList(nn);\n\n                int e = nn - 1;\n                while (e-- > 0) {\n                    int u = in.nextInt() - 1, v = in.nextInt() - 1;\n                    adj[u].add(v);\n                    adj[v].add(u);\n\n                }\n\n\n                int max = 0;\n\n                for (int i = 0; i < nn; i++) {\n                    for (int j = i + 1; j < nn; j++) {\n                        max = Math.max(max, bfs(i, j));\n                    }\n                }\n\n\n                ans += max - 1;\n\n            }\n\n            out.println(ans);\n        }\n\n        private int bfs(int i, int j) {\n\n\n            boolean[] visited = new boolean[adj.length];\n            Queue<Integer> queue = new LinkedList<>();\n            int[] sizes = new int[adj.length];\n            queue.add(i);\n\n            while (!queue.isEmpty()) {\n                int u = queue.poll();\n\n                if (u == j) {\n\n                    return sizes[j] + 1;\n                }\n                visited[u] = true;\n                for (int v : adj[u]) {\n                    if (!visited[v]) {\n                        visited[v] = true;\n                        queue.add(v);\n                        sizes[v] = sizes[u] + 1;\n                    }\n                }\n            }\n\n            return 1;\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class GraphUtils {\n        public static ArrayList<Integer>[] buildAdjList(int n) {\n            ArrayList<Integer>[] adj = new ArrayList[n];\n\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n\n            return adj;\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\n\npublic class RSaratovqFSpiders {\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String args[] ) throws Exception {\n\t\t   \n\t\tBufferedReader br = new BufferedReader(new FileReader(\"input.txt\"));\n\t\tPrintWriter w = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n\t    \n\t    int ans = 0;\n\t    int t = ip(br.readLine());\n\t \n\t    while(t-- > 0){\n\t    \n\t    \tStringTokenizer st1 = new StringTokenizer(br.readLine());\n\t    \tint n = ip(st1.nextToken());\n\t    \t\n\t    \tArrayList<Integer> g[] = new ArrayList[n];\n\t \t\tfor(int i=0;i<n;i++)\n\t \t\t\tg[i] = new ArrayList<Integer>();\n\t \t\tfor(int i=1;i<n;i++){\n\t \t\t\tint u = ip(st1.nextToken()) - 1;\n\t \t\t\tint v = ip(st1.nextToken()) - 1;\n\t \t\t\tg[u].add(v);\n\t \t\t\tg[v].add(u);\n\t \t\t}\n\t \t\t\n\t \t\tint max = 0;\n\t \t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tboolean vis[] = new boolean[n];\n\t\t\t\tvis[i] = true;\n\t\t\t\tint dist[] = new int[n];\n\t\t\t\tdist[i] = 0;\n\t\t\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\t\t\tq.add(i);\n\t\t\t\t\n\t\t\t\twhile(!q.isEmpty()){\n\t\t\t\t\tint curr = q.remove();\n\t\t\t\t\tint s = g[curr].size();\n\t\t\t\t\tfor(int j=0;j<s;j++){\n\t\t\t\t\t\tint nxt = g[curr].get(j);\n\t\t\t\t\t\tif(!vis[nxt]){\n\t\t\t\t\t\t\tvis[nxt] = true;\n\t\t\t\t\t\t\tdist[nxt] = dist[curr] + 1;\n\t\t\t\t\t\t\tq.add(nxt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tmax = Math.max(max, dist[j]);\n\t\t\t}\n\t    \n\t    \tans += max;\n\t    }\n\t\n\t    w.println(ans);\n\t    w.close();\n\t    br.close();\n\t}\n\t\n\tpublic static int ip(String s){\n\t\treturn Integer.parseInt(s);\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class TaskF {\n\tBufferedReader br;\n\tPrintWriter out;\n\tStringTokenizer stok;\n\n\tString nextToken() throws IOException {\n\t\twhile (stok == null || !stok.hasMoreTokens()) {\n\t\t\tString s = br.readLine();\n\t\t\tif (s == null) {\n\t\t\t\treturn \"-1\";\n\t\t\t}\n\t\t\tstok = new StringTokenizer(s);\n\t\t}\n\t\treturn stok.nextToken();\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tchar nextChar() throws IOException {\n\t\treturn (char) (br.read());\n\t}\n\n\tString nextLine() throws IOException {\n\t\treturn br.readLine();\n\t}\n\n\tArrayList<Integer>[] gr;\n\tboolean[] used;\n\n\tint dfs(int v, int kol, int max) {\n\t\tused[v] = true;\n\t\tfor (Integer i : gr[v]) {\n\t\t\tif (!used[i]) {\n\t\t\t\tmax = Math.max(max, dfs(i, kol + 1, Math.max(max, kol + 1)));\n\t\t\t}\n\t\t}\n\t\treturn max;\n\t}\n\n\tvoid solve() throws IOException {\n\t\tint n = nextInt(), l, d, x, y;\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tl = nextInt();\n\t\t\tgr = new ArrayList[l];\n\t\t\tused = new boolean[l];\n\t\t\tfor (int g = 0; g < l; g++) {\n\t\t\t\tgr[g] = new ArrayList<Integer>();\n\t\t\t}\n\t\t\tfor (int g = 0; g < l - 1; g++) {\n\t\t\t\tx = nextInt() - 1;\n\t\t\t\ty = nextInt() - 1;\n\t\t\t\tgr[x].add(y);\n\t\t\t\tgr[y].add(x);\n\t\t\t}\n\t\t\tx = 0;\n\t\t\tfor (int g = 0; g < l; g++) {\n\t\t\t\tArrays.fill(used, false);\n\t\t\t\tx = Math.max(x, dfs(g, 0, 0));\n\t\t\t}\n\t\t\tans += x;\n\t\t}\n\t\tout.print(ans);\n\t}\n\n\tvoid run() throws IOException {\n\t\tbr = new BufferedReader(new FileReader(\"input.txt\"));\n\t\tout = new PrintWriter(\"output.txt\");\n\t\t// br = new BufferedReader(new InputStreamReader(System.in));\n\t\t// out = new PrintWriter(System.out);\n\t\tsolve();\n\t\tbr.close();\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// Locale.setDefault(Locale.US);\n\t\tnew TaskF().run();\n\t}\n}", "label": 3}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class F120 {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader in = new BufferedReader(new FileReader(\"input.txt\"));\n        PrintWriter out = new PrintWriter(\"output.txt\");\n        int n = Integer.parseInt(in.readLine());\n        int res = 0;\n        for (int i = 0 ; i < n ; i++) {\n            StringTokenizer st = new StringTokenizer(in.readLine());\n            int nn = Integer.parseInt(st.nextToken());\n            boolean[][] adj = new boolean[nn][nn];\n            for (int j = 0;  j < nn - 1; j++) {\n                int a = Integer.parseInt(st.nextToken()) - 1;\n                int b = Integer.parseInt(st.nextToken()) - 1;\n                adj[a][b] = adj[b][a] = true;\n            }\n            int maxL = Integer.MIN_VALUE;\n            for (int j = 0 ; j < nn ; j++) {\n                int[] d = new int[nn];\n                int[] q = new int[nn + 100];\n                int head = 0;\n                int tail = 1;\n                q[head] = j;\n                Arrays.fill(d, Integer.MAX_VALUE);\n                boolean[] vis = new boolean[nn];\n                vis[j] = true;\n                d[j] = 0;\n                int max = -1;\n                while (head < tail) {\n                    int v = q[head++];\n                    for (int k = 0 ; k < nn ; k++) {\n                        if (adj[v][k] && !vis[k]) {\n                            vis[k] = true;\n                            q[tail++] = k;\n                            d[k] = d[v] + 1;\n                            if (d[k] > max) max = d[k];\n                        }\n                    }\n                }\n                maxL = Math.max(maxL , max);\n            }\n            res += maxL;\n        }\n        out.println(res);\n        out.close();\n    }\n}\n", "label": 3}
{"src": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\nimport static java.lang.System.out;\n\npublic class Main {\n\n    Scanner scanner = new Scanner(System.in);\n\n    public static void main(String[] args) throws FileNotFoundException {\n        new Main().solve();\n    }\n\n\n    List<List<Integer>>  gr = new ArrayList<>();\n    int dfs(int v, int p) {\n        int ans = 0;\n\n        for (Integer next: gr.get(v)) {\n            if (next !=p) {\n                ans = Math.max(dfs(next, v), ans);\n            }\n        }\n        return ans + 1;\n    }\n\n    void solve() throws FileNotFoundException {\n        Scanner scanner = new Scanner(new File(\"input.txt\"));\n        PrintWriter out = new PrintWriter(new File(\"output.txt\"));\n\n        int m = scanner.nextInt();\n\n        int ans = 0;\n        for (int i = 0; i < m; i++) {\n            int n = scanner.nextInt();\n\n            gr = new ArrayList<>();\n            for (int j = 0; j < n; j++) {\n                gr.add(new ArrayList<>());\n            }\n            for (int j = 0; j < n - 1; j++) {\n                int u = scanner.nextInt() - 1, v = scanner.nextInt() - 1;\n                gr.get(u).add(v);\n                gr.get(v).add(u);\n            }\n\n\n            int max = 0;\n            for (int j = 0; j < n - 1; j++) {\n                max = Math.max(dfs(j, -1), max);\n            }\n            ans += max - 1;\n\n        }\n        out.println(ans);\n        out.close();\n    }\n}", "label": 3}
{"src": "import java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class F {\n\n\tprivate void work() throws IOException {\n\t\tScanner sc = new Scanner(new FileReader(\"input.txt\"));\n\t\tPrintWriter pw = new PrintWriter(new FileWriter(\"output.txt\"));\n\t\tint nc = sc.nextInt();\n\t\tint res = 0;\n\t\twhile (nc-- > 0) {\n\t\t\tres += getLongestPath(sc);\n\t\t}\n\t\tpw.println(res);\n\t\tpw.close();\n\t\tsc.close();\n\t}\n\n\tprivate int qs, qe, q[] = new int[111], d[] = new int[111];\n\tprivate Map<Integer, Set<Integer>> g = new HashMap<Integer, Set<Integer>>();\n\n\tprivate static final int oo = Integer.MAX_VALUE;\n\n\tprivate int getLongestPath(Scanner sc) {\n\n\t\tg.clear();\n\n\t\tint n = sc.nextInt();\n\t\twhile (--n > 0) {\n\t\t\tint u = sc.nextInt();\n\t\t\tint v = sc.nextInt();\n\t\t\tif (!g.containsKey(u))\n\t\t\t\tg.put(u, new HashSet<Integer>());\n\t\t\tif (!g.containsKey(v))\n\t\t\t\tg.put(v, new HashSet<Integer>());\n\t\t\tg.get(u).add(v);\n\t\t\tg.get(v).add(u);\n\t\t}\n\n\t\tArrays.fill(d, oo);\n\t\td[1] = 0;\n\t\tqs = qe = 0;\n\t\tq[qe++] = 1;\n\t\twhile (qs < qe) {\n\t\t\tint u = q[qs++];\n\t\t\tif (g.containsKey(u)) {\n\t\t\t\tfor (int v : g.get(u)) {\n\t\t\t\t\tif (d[v] > d[u] + 1) {\n\t\t\t\t\t\td[v] = d[u] + 1;\n\t\t\t\t\t\tq[qe++] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint last = q[qe - 1];\n\t\tArrays.fill(d, oo);\n\t\td[last] = 0;\n\t\tqs = qe = 0;\n\t\tq[qe++] = last;\n\t\twhile (qs < qe) {\n\t\t\tint u = q[qs++];\n\t\t\tif (g.containsKey(u)) {\n\t\t\t\tfor (int v : g.get(u)) {\n\t\t\t\t\tif (d[v] > d[u] + 1) {\n\t\t\t\t\t\td[v] = d[u] + 1;\n\t\t\t\t\t\tq[qe++] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn d[q[qe - 1]];\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew F().work();\n\t}\n\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n   // static class Scanner {\n   // StreamTokenizer in;\n   // boolean forceMode = false;\n   //\n   // Scanner(InputStream is, String codePage, boolean forceMode) {\n   // in = new StreamTokenizer(new BufferedReader(new InputStreamReader(is)));\n   // if (!forceMode) {\n   // in.resetSyntax();\n   // in.wordChars(33, 255);\n   // in.whitespaceChars(0, 32);\n   // }\n   // }\n   //\n   // Scanner(InputStream is, String codePage) {\n   // in = new StreamTokenizer(new BufferedReader(new InputStreamReader(is)));\n   // if (!forceMode) {\n   // in.resetSyntax();\n   // in.wordChars(33, 255);\n   // in.whitespaceChars(0, 32);\n   // }\n   // }\n   //\n   // String next() {\n   // try {\n   // in.nextToken();\n   // return in.sval;\n   // } catch (Exception e) {\n   // throw new Error();\n   // }\n   // }\n   //\n   // int nextInt() {\n   // if (forceMode) {\n   // try {\n   // in.nextToken();\n   // return (int) in.nval;\n   // } catch (Exception e) {\n   // throw new Error();\n   // }\n   // } else {\n   // return Integer.parseInt(next());\n   // }\n   // }\n   //\n   // long nextLong() {\n   // if (forceMode) {\n   // throw new Error(\"No long at force mod!\");\n   // } else {\n   // return Long.parseLong(next());\n   // }\n   //\n   // }\n   //\n   // double nextDouble() {\n   // if (forceMode) {\n   // try {\n   // in.nextToken();\n   // return in.nval;\n   // } catch (Exception e) {\n   // throw new Error();\n   // }\n   // } else {\n   // return Double.parseDouble(next());\n   // }\n   // }\n   // }\n\n   static class Assertion {\n      static void checkRE(boolean e) {\n         if (!e) {\n            throw new Error();\n         }\n      }\n\n      static void checkTL(boolean e) {\n         if (!e) {\n            int idx = 1;\n            while (idx > 0) {\n               idx++;\n            }\n         }\n      }\n   }\n\n   static class Node {\n      boolean wasUsed;\n      static int maxDepth;\n      ArrayList<Node> links = new ArrayList<Main.Node>();\n\n      public Node() {\n         // TODO Auto-generated constructor stub\n      }\n\n      void add(Node second) {\n         links.add(second);\n      }\n\n      void maxDepth(int parentDepth) {\n         this.wasUsed = true;\n         for (Node next : links) {\n            if (!next.wasUsed) {\n               maxDepth = Math.max(maxDepth, parentDepth + 1);\n               next.maxDepth(parentDepth + 1);\n            }\n         }\n      }\n   }\n\n   Scanner in;\n   PrintWriter out;\n\n   void solve() {\n      int n = in.nextInt();\n      int len = 0;\n      for (int t = 0; t < n; t++) {\n         int nNodes = in.nextInt();\n         Node nodes[] = new Node[1 + nNodes];\n         Node root = null;\n         for (int j = 1; j <= nNodes; j++) {\n            nodes[j] = new Node();\n         }\n         for (int i = 0; i < nNodes - 1; i++) {\n            int first = in.nextInt();\n            int second = in.nextInt();\n            nodes[first].add(nodes[second]);\n            nodes[second].add(nodes[first]);\n         }\n         int max = 0;\n         for (int j = 1; j <= nNodes; j++) {\n            for (int c = 1; c<=nNodes; c++){\n               nodes[c].wasUsed = false;\n            }\n            nodes[j].maxDepth(0);\n            max = Math.max(max, Node.maxDepth);\n            Node.maxDepth = 0;\n         }\n         len += max;\n\n      }\n      out.println(len);\n   }\n\n   final static String fileName = \"\";\n\n   void run() {\n      try {\n         in = new Scanner(new FileInputStream(\"input.txt\"), \"ISO-8859-1\");\n         out = new PrintWriter(\"output.txt\", \"ISO-8859-1\");\n      } catch (FileNotFoundException e) {\n         throw new Error(e);\n\n      } catch (UnsupportedEncodingException e) {\n         throw new Error(e);\n      }\n      // in = new Scanner(System.in);\n      // out = new PrintWriter(System.out);\n      try {\n         solve();\n      } catch (Exception e) {\n         throw new Error(e);\n      } finally {\n         out.close();\n      }\n   }\n\n   public static void main(String[] args) {\n      new Main().run();\n   }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\n// find diameter of tree by finding node furthest from a random node then finding node furthest from that node\n\npublic class cf120f_2 {\n\n    public static void main(String[] args) throws IOException {\n        __in = new BufferedReader(new FileReader(\"input.txt\"));\n        __out = new PrintWriter(new FileWriter(\"output.txt\"));\n        int n = ri(), ans = 0;\n        for(int i = 0; i < n; ++i) {\n            int sz = rni();\n            List<List<Integer>> g = graph(sz);\n            for(int j = 0; j < sz - 1; ++j) {\n                int u = ni() - 1, v = ni() - 1;\n                connect(g, u, v);\n            }\n            ans += dfs(g, dfs(g, 0, -1)[0], -1)[1];\n        }\n        prln(ans);\n        close();\n    }\n\n    // returns [furthest node, dist]\n    static int[] dfs(List<List<Integer>> g, int i, int p) {\n        int node = i, dist = 0;\n        for(int n : g.get(i)) {\n            if(n != p) {\n                int[] dfs = dfs(g, n, i);\n                if(dfs[1] >= dist) {\n                    node = dfs[0];\n                    dist = dfs[1] + 1;\n                }\n            }\n        }\n        return new int[] {node, dist};\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e10\n    // LMAX ~= 9e18\n    \n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if(x.length == 1) return x[0]; if(x.length == 2) return min(x[0], x[1]); if(x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if(x.length == 1) return x[0]; if(x.length == 2) return min(x[0], x[1]); if(x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if(x.length == 1) return x[0]; if(x.length == 2) return max(x[0], x[1]); if(x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if(x.length == 1) return x[0]; if(x.length == 2) return max(x[0], x[1]); if(x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if(a == 0) return 0; int ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if(a == 0) return 0; long ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int)d;}\n    static int cei(double d) {return (int)ceil(d);}\n    static long fll(double d) {return (long)d;}\n    static long cel(double d) {return (long)ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long hash(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for(int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for(int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for(int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for(int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for(int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for(int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for(int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for(int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static int[] sorted(int[] a) {int[] ans = copy(a); sort(ans); return ans;}\n    static long[] sorted(long[] a) {long[] ans = copy(a); sort(ans); return ans;}\n    static int[] rsorted(int[] a) {int[] ans = copy(a); rsort(ans); return ans;}\n    static long[] rsorted(long[] a) {long[] ans = copy(a); rsort(ans); return ans;}\n    // graph util\n    static List<List<Integer>> graph(int n) {List<List<Integer>> g = new ArrayList<>(); for(int i = 0; i < n; ++i) g.add(new ArrayList<>()); return g;}\n    static List<List<Integer>> graph(List<List<Integer>> g, int m) throws IOException {for(int i = 0; i < m; ++i) connect(g, rni() - 1, ni() - 1); return g;}\n    static List<List<Integer>> graph(int n, int m) throws IOException {return graph(graph(n), m);}\n    static List<List<Integer>> dgraph(List<List<Integer>> g, int m) throws IOException {for(int i = 0; i < m; ++i) connecto(g, rni() - 1, ni() - 1); return g;}\n    static List<List<Integer>> dgraph(List<List<Integer>> g, int n, int m) throws IOException {return dgraph(graph(n), m);}\n    static List<Set<Integer>> sgraph(int n) {List<Set<Integer>> g = new ArrayList<>(); for(int i = 0; i < n; ++i) g.add(new HashSet<>()); return g;}\n    static List<Set<Integer>> sgraph(List<Set<Integer>> g, int m) throws IOException {for(int i = 0; i < m; ++i) connect(g, rni() - 1, ni() - 1); return g;}\n    static List<Set<Integer>> sgraph(int n, int m) throws IOException {return sgraph(sgraph(n), m);}\n    static List<Set<Integer>> dsgraph(List<Set<Integer>> g, int m) throws IOException {for(int i = 0; i < m; ++i) connecto(g, rni() - 1, ni() - 1); return g;}\n    static List<Set<Integer>> dsgraph(List<Set<Integer>> g, int n, int m) throws IOException {return dsgraph(sgraph(n), m);}\n    static void connect(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v); g.get(v).add(u);}\n    static void connecto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v);}\n    static void dconnect(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v); g.get(v).remove(u);}\n    static void dconnecto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v);}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(__in.readLine());}\n    static int ri() throws IOException {return Integer.parseInt(__in.readLine());}\n    static long rl() throws IOException {return Long.parseLong(__in.readLine());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Integer.parseInt(input.nextToken()); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Integer.parseInt(input.nextToken()) - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Long.parseLong(input.nextToken()); return a;}\n    static char[] rcha() throws IOException {return __in.readLine().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static int rni() throws IOException {input = new StringTokenizer(__in.readLine()); return Integer.parseInt(input.nextToken());}\n    static int ni() {return Integer.parseInt(input.nextToken());}\n    static long rnl() throws IOException {input = new StringTokenizer(__in.readLine()); return Long.parseLong(input.nextToken());}\n    static long nl() {return Long.parseLong(input.nextToken());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {__out.println(\"yes\");}\n    static void pry() {__out.println(\"Yes\");}\n    static void prY() {__out.println(\"YES\");}\n    static void prno() {__out.println(\"no\");}\n    static void prn() {__out.println(\"No\");}\n    static void prN() {__out.println(\"NO\");}\n    static void pryesno(boolean b) {__out.println(b ? \"yes\" : \"no\");};\n    static void pryn(boolean b) {__out.println(b ? \"Yes\" : \"No\");}\n    static void prYN(boolean b) {__out.println(b ? \"YES\" : \"NO\");}\n    static void prln(int... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static void prln(long... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for(int i = 0; i < n; __out.print(iter.next()), __out.print(' '), ++i); if(n >= 0) __out.println(iter.next()); else __out.println();}\n    static void h() {__out.println(\"hlfd\");}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}", "label": 3}
{"src": "import java.io.InputStreamReader;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.FileOutputStream;\nimport java.io.PrintWriter;\nimport java.io.FileInputStream;\nimport java.util.StringTokenizer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream;\n\t\ttry {\n\t\t\tinputStream = new FileInputStream(\"input.txt\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tOutputStream outputStream;\n\t\ttry {\n\t\t\toutputStream = new FileOutputStream(\"output.txt\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskf solver = new Taskf();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass Taskf {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\tint n = in.nextInt();\n\t\tint ans = 0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint ni = in.nextInt();\n\t\t\tboolean [][]b = new boolean[ni][ni];\n\t\t\tfor(int j=0;j<ni-1;j++){\n\t\t\t\tint x = in.nextInt()-1;\n\t\t\t\tint y = in.nextInt()-1;\n\t\t\t\tb[x][y] = true;\n\t\t\t\tb[y][x] = true;\n\t\t\t}\n\t\t\tint max =0 ;\n\t\t\tfor(int j=0;j<ni;j++)\n\t\t\tmax = Math.max(dfs(b,j,new boolean[ni]),max);\n\t\t\tans += max;\n\t\t}\n\t\tout.println(ans);\n\t}\n\tprivate int dfs(boolean[][] b, int i,boolean []v) {\n\t\tint res = 0;\n\t\tv[i] = true;\n\t\tfor(int j=0;j<b.length;j++)\n\t\t\tif(b[i][j] && !v[j])\n\t\t\t\tres = Math.max(res, 1+ dfs(b,j,v));\n\t\treturn res;\n\t}\n}\n\nclass InputReader {\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    public InputReader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream));\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt(){\n        return Integer.parseInt(next());\n    }\n\n    }\n\n", "label": 3}
{"src": "import java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n \npublic class CF120F {\n\t\n\tpublic static int maxNode = -1;\n\tpublic static int mLen = -1;\n\t\n\tpublic static void dfs(int u,ArrayList<ArrayList<Integer>> adj,boolean[] vi, int len) {\n\t\tif(len > mLen) {\n\t\t\tmaxNode = u;\n\t\t\tmLen = len;\n\t\t}\n\t\tvi[u] = true;\n\t\tfor(int v : adj.get(u)) {\n\t\t\tif(!vi[v])\n\t\t\t\tdfs(v,adj,vi,len+1);\n\t\t}\n\t\tvi[u] = false;\n\t}\n\t\n\tpublic static int getLongestPath(int n,ArrayList<ArrayList<Integer>> adj) {\n\t\tmaxNode = mLen = -1;\n\t\tboolean[] vi = new boolean[n];\n\t\tdfs(0,adj,vi,0);\n\t\tint mNode = maxNode;\n\t\tmaxNode = mLen = -1;\n\t\tdfs(mNode,adj,vi,0);\n\t\treturn mLen;\n\t}\n\t\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tScanner in = new Scanner(new File(\"input.txt\"));\n\t\tPrintWriter out = new PrintWriter(new File(\"output.txt\"));\n\t\tint t = in.nextInt();\n\t\tint maxPath = 0;\n\t\twhile(t-- > 0) {\n\t\t\tint n = in.nextInt();\n\t\t\tArrayList<ArrayList<Integer>> adj = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\tadj.add(new ArrayList<Integer>());\n\t\t\tfor(int i=1; i<n; i++) {\n\t\t\t\tint u = in.nextInt() - 1;\n\t\t\t\tint v = in.nextInt() - 1;\n\t\t\t\tadj.get(u).add(v);\n\t\t\t\tadj.get(v).add(u);\n\t\t\t}\n\t\t\tmaxPath += getLongestPath(n,adj);\n\t\t}\n\t\tout.println(maxPath);\n\t\tout.close();\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class A implements Runnable {\n\n    public void run() {\n        long startTime = System.nanoTime();\n\n        int t = nextInt();\n\n        int ress = 0;\n\n        for (int iter = 0; iter < t; iter++) {\n\n            int n = nextInt();\n            int[][] d = new int[n][n];\n            for (int[] x : d) {\n                Arrays.fill(x, (int) 1e8);\n            }\n            for (int i = 0; i < n - 1; i++) {\n                int a = nextInt() - 1;\n                int b = nextInt() - 1;\n                d[a][b] = d[b][a] = 1;\n            }\n            for (int i = 0; i < n; i++) {\n                d[i][i] = 0;\n            }\n\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    for (int k = 0; k < n; k++) {\n                        d[j][k] = Math.min(d[j][k], d[i][j] + d[i][k]);\n                    }\n                }\n            }\n\n            int res = 0;\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (d[i][j] < 1e8 && d[i][j] > res) {\n                        res = d[i][j];\n                    }\n                }\n            }\n\n            ress += res;\n\n        }\n\n\n\n        println(ress);\n\n        if (fileIOMode) {\n            System.out.println((System.nanoTime() - startTime) / 1e9);\n        }\n        out.close();\n    }\n\n    //-----------------------------------------------------------------------------------\n\n    private static boolean fileIOMode;\n    private static String problemName = \"a\";\n    private static BufferedReader in;\n    private static PrintWriter out;\n    private static StringTokenizer tokenizer;\n\n    public static void main(String[] args) throws Exception {\n        fileIOMode = true;\n        if (fileIOMode) {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        } else {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }\n        tokenizer = new StringTokenizer(\"\");\n\n        new Thread(new A()).start();\n    }\n\n    private static String nextLine() {\n        try {\n            return in.readLine();\n        } catch (IOException e) {\n            return null;\n        }\n    }\n\n    private static String nextToken() {\n        while (!tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(nextLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    private static int nextInt() {\n        return Integer.parseInt(nextToken());\n    }\n\n    private static long nextLong() {\n        return Long.parseLong(nextToken());\n    }\n\n    private static double nextDouble() {\n        return Double.parseDouble(nextToken());\n    }\n\n    private static BigInteger nextBigInteger() {\n        return new BigInteger(nextToken());\n    }\n\n    private static void print(Object o) {\n        if (fileIOMode) {\n            System.out.print(o);\n        }\n        out.print(o);\n    }\n\n    private static void println(Object o) {\n        if (fileIOMode) {\n            System.out.println(o);\n        }\n        out.println(o);\n    }\n\n    private static void printf(String s, Object... o) {\n        if (fileIOMode) {\n            System.out.printf(s, o);\n        }\n        out.printf(s, o);\n    }\n}\n", "label": 3}
{"src": "import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tnew Main().start();\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tint map[][] = new int[100][100];\n\tint n;\n\tint dist[] = new int[100];\n\t\n\tprivate int bfs(int s) {\n\t\tLinkedList <Integer> que = new LinkedList<Integer>();\n\t\t\n\t\tque.add(s);\n\t\t\n\t\tdist[s] = 0;\n\t\t\n\t\tint ret = s;\n\t\t\n\t\twhile (que.size() > 0) {\n\t\t\tint t = que.pollFirst();\n\t\t\tret = t;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (map[t][i] == 1 && dist[i] == -1) {\n\t\t\t\t\tdist[i] = dist[t] + 1;\n\t\t\t\t\tque.addLast(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tprivate int solve() {\n\t\tArrays.fill(dist, -1);\n\t\t\n\t\tint t = bfs(0);\n\t\t\n\t\tArrays.fill(dist, -1);\n\t\t\n\t\tint q = bfs(t);\n\t\t\n\t\treturn dist[q];\n\t\t\n\t}\n\t\n\tprivate void start() throws Exception {\n\t\t//Scanner in = new Scanner(System.in);\n\t\tScanner in = new Scanner(new FileInputStream(new File(\"input.txt\")));\n\t\tPrintWriter out = new PrintWriter(new File(\"output.txt\"));\n\n\t\tint m = in.nextInt();\n\t\tint ans = 0;\n\t\tint u, v;\n\t\t\n\t\twhile (m-- != 0) {\n\t\t\tn = in.nextInt();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tArrays.fill(map[i], 0);\n\t\t\t}\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tu = in.nextInt();\n\t\t\t\tv = in.nextInt();\n\t\t\t\tu--;v--;\n\t\t\t\tmap[u][v] = map[v][u] = 1;\n\t\t\t}\n\t\t\tans += solve();\n\t\t}\n\t\tout.println(ans);\n\t\tout.close();\n\t\tin.close();\n\t}\n\n}\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class F {\n\n    /**\n     * @param args\n     */\n    public static void main(String[] args) {\n        // TODO Auto-generated method stub\n        try {\n            FileInputStream fis = new FileInputStream(\"input.txt\");\n            FileWriter fstream = new FileWriter(\"output.txt\");\n            BufferedWriter out = new BufferedWriter(fstream);\n            DataInputStream in = new DataInputStream(fis);\n            BufferedReader br = new BufferedReader(new InputStreamReader(in));\n            int T = Integer.parseInt(br.readLine());\n            int count = 0;\n            for (int i = 0; i < T; i++) {\n                StringTokenizer stk = new StringTokenizer(br.readLine(), \" \");\n                int n = Integer.parseInt(stk.nextToken());\n                List<Node> node = new ArrayList<Node>();\n                for (int j = 0; j < n; j++) {\n                    node.add(new Node(j));\n                }\n                for (int j = 0; j < n - 1; j++) {\n                    int a = Integer.parseInt(stk.nextToken()) - 1;\n                    int b = Integer.parseInt(stk.nextToken()) - 1;\n                    node.get(a).next.add(node.get(b));\n                    node.get(b).next.add(node.get(a));\n                }\n                // for (int j = 0; j < node.size(); j++) {\n                // System.out.print(\"Node \" + j + \":\");\n                // for (int k = 0; k < node.get(j).next.size(); k++) {\n                // System.out.print(node.get(j).next.get(k).data + \", \");\n                // }\n                // System.out.println();\n                // }\n                int ret = 0;\n                for (int j = 0; j < node.size(); j++) {\n                    int tmp = rec(node.get(j), new HashSet<Integer>());\n                    ret = Math.max(tmp, ret);\n                }\n                // System.out.println(ret - 1);\n                count += ret - 1;\n            }\n            out.write(Integer.toString(count));\n            out.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static int rec(Node node, HashSet<Integer> set) {\n        int ret = 0;\n        set.add(node.data);\n        for (int i = 0; i < node.next.size(); i++) {\n            if (set.contains(node.next.get(i).data))\n                continue;\n            int tmp = rec(node.next.get(i), set);\n            if (tmp > ret)\n                ret = tmp;\n        }\n        return ret + 1;\n    }\n}\n\nclass Node {\n    int data;\n    List<Node> next;\n\n    public Node(int value) {\n        this.data = value;\n        next = new ArrayList<Node>();\n    }\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileNotFoundException;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\n\npublic class Spiders {\n\t\n\tstatic class Scanner{\n\t\tBufferedReader br=null;\n\t\tStringTokenizer tk=null;\n\t\tpublic Scanner() throws FileNotFoundException{\n\t\t\tbr=new BufferedReader(new FileReader(\"input.txt\"));\n\t\t}\n\t\tpublic String next() throws IOException{\n\t\t\twhile(tk==null || !tk.hasMoreTokens())\n\t\t\t\ttk=new StringTokenizer(br.readLine());\n\t\t\treturn tk.nextToken();\n\t\t}\n\t\tpublic int nextInt() throws NumberFormatException, IOException{\n\t\t\treturn Integer.valueOf(next());\n\t\t}\n\t\tpublic double nextDouble() throws NumberFormatException, IOException{\n\t\t\treturn Double.valueOf(next());\n\t\t}\n\t}\n\t\n\tstatic class Node{\n\t\tint id;\n\t\tboolean visited;\n\t\tLinkedList<Integer> v;\n\t\tpublic Node(int idd){\n\t\t\tid = idd;\n\t\t\tv = new LinkedList<Integer>();\n\t\t\tvisited = false;\n\t\t}\n\t}\n\t\n\tstatic int S;\n\t\n\t\n\tstatic class Pair{\n\t\tint u,v;\n\t\tpublic Pair(int uu, int vv){\n\t\t\tu = uu;\n\t\t\tv = vv;\n\t\t}\n\t}\n\t\n\tstatic Pair dfs(int inicio,Node[] array){\n\t\tif (array[inicio].visited)\n\t\t\treturn null;\n\t\tarray[inicio].visited = true;\n\t\tPair ret = new Pair(0, inicio);\n\t\tfor(int v: array[inicio].v){\n\t\t\tPair sig = dfs(v, array);\n\t\t\tif (sig == null)\n\t\t\t\tcontinue;\n\t\t\tsig.u++;\n\t\t\tif (ret.u < sig.u)\n\t\t\t\tret = sig;\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic int solve(int start,Node[] array){\n\t\tPair p = dfs(start, array);\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tarray[i].visited = false;\n\t\tp = dfs(p.v, array);\n\t\treturn p.u;\n\t}\n\t\n\tpublic static void main(String args[]) throws NumberFormatException, IOException{\n\t\tScanner sc = new Scanner();\n\t\tBufferedWriter bw = new BufferedWriter(new FileWriter(\"output.txt\"));\n\t\tS = sc.nextInt();\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < S; i++){\n\t\t\tint Nodos = sc.nextInt();\n\t\t\tNode[] array = new Node[Nodos];\n\t\t\tfor(int j = 0; j < Nodos; j++)\n\t\t\t\tarray[j] = new Node(j);\n\t\t\tfor(int j = 0; j < Nodos - 1; j++){\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\ta--;b--;\n\t\t\t\tarray[a].v.add(b);\n\t\t\t\tarray[b].v.add(a);\n\t\t\t}\n\t\t\tint tam = solve(0, array);\n\t\t\tsum += tam;\n\t\t}\n\t\tbw.write(sum+\"\");\n\t\tbw.flush();\n\t}\n\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.*; \n public class B{\nstatic int[] dx={-1,1,0,0};\nstatic int[] dy={0,0,1,-1};\n    static FastReader scan=new FastReader();\n   public static PrintWriter out = new PrintWriter (new BufferedOutputStream(System.out));\n  static ArrayList<Pair>es;\n  static LinkedList<Integer>edges[];\n   static boolean prime[];\n   static void sieve(int n) \n    { \n        \n        prime = new boolean[n+1]; \n        for(int i=0;i<n;i++) \n            prime[i] = true; \n          \n        for(int p = 2; p*p <=n; p++) \n        { \n           \n            if(prime[p] == true) \n            { \n                \n                for(int i = p*p; i <= n; i += p) \n                    prime[i] = false; \n            } \n        } \n          \n        \n    }      \n     public static int lowerBound(long[] array, int length, long value) {\n        int low = 0;\n        int high = length;\n        while (low < high) {\n            final int mid = (low + high) / 2;\n            //checks if the value is less than middle element of the array\n            if (value <= array[mid]) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return low;\n    }\n    public static int upperBound(ArrayList<Long> array, int length, long value) {\n        int low = 0;\n        int high = length;\n        while (low < high) {\n            final int mid = low+(high-low) / 2;\n            if ( array.get(mid)>value) {\n                high = mid ;\n            } else {\n                low = mid+1;\n            }\n        }\n        return low;\n    }\nstatic long mod(long x,long y)\n    {\n        if(x<0)\n            x=x+(-x/y+1)*y;\n        return x%y;\n    }    \n     static boolean isPowerOfTwo(long n) \n    { \n        if (n == 0) \n            return false; \n  \n        while (n != 1) { \n            if (n % 2 != 0) \n                return false; \n            n = n / 2; \n        } \n        return true; \n    } \n\n  \n   \nstatic boolean isprime(long x)\n           {\n            for(long i=2;i*i<=x;i++)\n                if(x%i==0)\n                    return false;\n                return true;\n           }\n\n\nstatic int dist(int x1,int y1,int x2,int y2){\nreturn Math.abs(x1-x2)+Math.abs(y1-y2);\n}\n\n\n    static long cuberoot(long x)\n    {\n        long lo = 0, hi = 1000005;\n        while(lo<hi)\n        {\n            long m = (lo+hi+1)/2;\n            if(m*m*m>x)\n                hi = m-1;\n            else\n                lo = m;\n        }\n        return lo;\n    }\n     public static int log2(int N) \n    { \n  \n        // calculate log2 N indirectly \n        // using log() method \n        int result = (int)(Math.log(N) / Math.log(2)); \n  \n        return result; \n    } \n  \n    \n   \n       static long gcd(long a, long b) {\n    if(a!=0&&b!=0)\n        while((a%=b)!=0&&(b%=a)!=0);\n    return a^b;\n}\n    static long LCM(long a,long b){\n    return (Math.abs(a*b))/gcd(a,b);\n   }\n   public static class comp1 implements Comparator<ArrayList<Integer>>{  \npublic int compare(ArrayList<Integer> o1,ArrayList<Integer> o2){\n    if(o1.size()>0&&o2.size()>0&&o1.get(o1.size()-1)>o2.get(o2.size()-1))\n        return 1;\n\n return -1;\n}\n  }\n     public static class comp2 implements Comparator<Pair>{  \npublic int compare(Pair o1,Pair o2){\n \nreturn (o2.ab-o1.ab)>0?1:-1;\n}\n  }\n static boolean can(int m,int s)\n {\n    return (s>=0&&s<=m*9);\n }\n   static boolean collinear(long x1, long y1, long x2,  \n                          long y2, long x3, long y3) \n{\n    long a = x1 * (y2 - y3) +  \n                x2 * (y3 - y1) +  \n                x3 * (y1 - y2); \n                if(a==0)\n                    return true;\n                return false;\n}\nstatic StringBuilder s;\nstatic boolean vis[]=new boolean[101];\nstatic long k,a,b;\nstatic long mod=(long)1e9+7;\nstatic int cnt=0;\nstatic Pair bfs(int x){\n    ArrayDeque<Integer>dq=new ArrayDeque<Integer>();\n    dq.add(x);\n    int dist[]=new int[101];\n    Arrays.fill(dist,-1);\n    dist[x]=0;\n    while(!dq.isEmpty()){\n        int i=dq.poll();\n        for(int k:edges[i])\n        {\n           // out.println(k);\n            if(dist[k]==-1){\n                dist[k]=dist[i]+1;\n                dq.add(k);\n                //out.println(\"FUCK\");\n            }\n\n        }\n    }\n    int max=0,id=0;\n    for(int i=0;i<101;i++)\n        if(dist[i]>max)\n        {\n            max=dist[i];\n            id=i;\n        }\n        //out.println(max);\n        Pair ret=new Pair(max,id);\n        return ret;\n}\npublic static void main(String[] args)  throws Exception \n{\n    /*int xx=253;\n    for(int i=1;i*i<=xx;i++)\n    {\n        if(xx%i==0)\n        {\n            System.out.println(i);\n            System.out.println(xx/i);\n        }\n    }*/\n//java.util.Scanner scan=new java.util.Scanner(new File(\"mootube.in\"));\n //PrintWriter out = new PrintWriter (new FileWriter(\"mootube.out\"));\nscan=new FastReader(\"input.txt\");\nout = new PrintWriter (\"output.txt\");\n//System.out.println(3^2);\n//System.out.println(19%4);\n   //StringBuilder news=new StringBuilder(\"ab\");\n   //news.deleteCharAt(1);\n   //news.insert(0,'c');\n   //news.deleteCharAt(0);\n   //System.out.println(news);\n   //System.out.println(can(2,15));\n    //System.out.println(LCM(2,2));00\n  // System.out.println(31^15);\n //System.out.println(\"bbabbbabbbabbbabbbabbbabbbabbbabbbabbbab\".length());\nint tt=1;\n//tt=scan.nextInt();\n//System.out.println(calc(91));\n//sieve(21000);\n  outer:while(tt-->0)\n {\n int  n=scan.nextInt();\n   edges=new LinkedList[10000];\n   for(int i=0;i<10000;i++)\n    edges[i]=new LinkedList();\nint res=0;\n   for(int i=0;i<n;i++)\n    {\n        int ni=scan.nextInt();\n        int arr[]=new int[(ni-1)*2];\n        for(int k=0;k<ni-1;k++)\n        {\n            int x=scan.nextInt(),y=scan.nextInt();\n            edges[x].add(y);\n            edges[y].add(x);\n        }\n     \n    Pair r=bfs(1); \n    Pair rr=bfs(r.y);\n    //out.println(rr.x);\n    res+=rr.x;\n       edges=new LinkedList[101];\n   for(int j=0;j<101;j++)\n    edges[j]=new LinkedList();\n\n      \n    }\nout.println(res);\n\n \n}\n\nout.close();\n}    \n\n\nstatic class dsu{\n    static int id[]=new int[101];\n    dsu()\n    {\n        for(int i=0;i<101;i++)\n            id[i]=i;\n    }\n    static int find(int x)\n    {\n        if(x==id[x])\n            return x;\n        return find(id[x]);\n    }\n    static void connect(int i,int j)\n    {\n        i=find(i);\n        j=find(j);\n        id[i]=j;\n    }\n    static boolean is(int i,int j)\n    {\n        return find(i)==find(j);\n    }\n}\nstatic long binexp(long a,long n,long mod)\n{\n    if(n==0)\n       return 1;\n    long res=binexp(a,n/2,mod)%mod;\n    res=res*res;\n    if(n%2==1)\n        return (res*a)%mod;\n    else \n        return res%mod;\n}\nstatic class special implements Comparable<special> {\n    char x;\n    int id;\n    special(char x,int id)\n    {\n        this.id=id;\n       this.x=x;\n    }\n    public int compareTo(special o)\n    {\n        return o.id-id;\n    }\n   \n}\nstatic long powMod(long base, long exp, long mod) {\n       if (base == 0 || base == 1) return base;\n       if (exp == 0) return 1;\n       if (exp == 1) return base % mod;\n       long R = powMod(base, exp/2, mod) % mod;\n       R *= R;\n       R %= mod;\n       if ((exp & 1) == 1) {\n           return base * R % mod;\n       }\n       else return R % mod;\n   }\n public static  long pow(long b, long e) {\n            long r = 1;\n            while (e > 0) {\n                if (e % 2 == 1) r = r * b ;\n                b = b * b;\n                e >>= 1;\n            }\n            return r;\n        }\n\nprivate static void sort(int[] arr) {\n        List<Integer> list = new ArrayList<>();\n        for (int object : arr) list.add(object);\n        Collections.sort(list);\n        for (int i = 0; i < list.size(); ++i) arr[i] = list.get(i);\n    }\n public static class FastReader {\n        BufferedReader br;\n        StringTokenizer root;\n        \n \n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        FastReader(String filename)throws Exception\n        {\n\n            br=new BufferedReader(new FileReader(filename));\n        }\n \n        String next() {\n            while (root == null || !root.hasMoreTokens()) {\n                try {\n                    root = new StringTokenizer(br.readLine());\n                } catch (Exception addd) {\n                    addd.printStackTrace();\n                }\n            }\n            return root.nextToken();\n        }\n \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n \n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (Exception addd) {\n                addd.printStackTrace();\n            }\n            return str;\n        }\n         public int[] nextIntArray(int arraySize) {\n            int array[] = new int[arraySize];\n \n            for (int i = 0; i < arraySize; i++) {\n                array[i] = nextInt();\n            }\n \n            return array;\n        }\n}\npublic static class Pair implements Comparable<Pair>{\n         int x;\n         int y;\n         long ab;\n        \n        int z;\n        public Pair(){}\n        public Pair(int x1, int y1,int z) {\n            x=x1;\n            y=y1;\n            this.z=z;\n        }\n        public Pair(int x1, int y1) {\n            x=x1;\n            y=y1;\n            this.ab=x+y;\n        \n        }\n        @Override\n        public int hashCode() {\n            return (int)(x + 31 * y);\n        }\n        public String toString() {\n            return x + \" \" + y;\n        }\n        @Override\n        public boolean equals(Object o){\n            if (o == this) return true;\n            if (o.getClass() != getClass()) return false;\n            Pair t = (Pair)o;\n            return t.x == x && t.y == y;\n        }\n        public  int compareTo(Pair o)\n        {\n            return o.x-x;    \n        }\n}\n\n}\n\n\n\n\n\n\n\n", "label": 3}
{"src": "\nimport java.util.*;\nimport java.io.*;\n\n\npublic class F\n{\n   public static void main(String[] args) throws Exception\n   {\n      new F(new Scanner(new File(\"input.txt\")));\n   }\n\n   Graph g;\n   int deepest;\n   int bestDepth;\n\n   void go(int i, int par, int d)\n   {\n      if (d > bestDepth)\n      {\n         deepest = i;\n         bestDepth = d;\n      }\n\n      for (int j : g.adj[i])\n         if (j != par)\n            go(j, i, d+1);\n   }\n\n   public F(Scanner in) throws Exception\n   {\n      PrintWriter out = new PrintWriter(\"output.txt\");\n   \n      int res = 0;\n      int M = in.nextInt();\n      while (M-->0)\n      {\n         int N = in.nextInt();\n         g = new Graph(N);\n         for (int u=1; u<N; u++)\n         {\n            int i=in.nextInt()-1;\n            int j=in.nextInt()-1;\n            g.add(i, j);\n         }\n         \n         bestDepth = -1;\n         deepest = 0;\n         go(0, -1, 0);\n         go(deepest, -1, 0);\n         res += bestDepth;\n      }\n\n      out.printf(\"%d%n\", res);\n\n      out.close();\n   }\n}\n\n\nclass Graph\n{\n   ArrayList<Integer>[] adj;\n   int N;\n\n   public Graph(int n)\n   {\n      N = n;\n      adj = new ArrayList[N];\n      for (int i=0; i<N; i++)\n         adj[i] = new ArrayList<Integer>();\n   }\n\n   void add(int i, int j)\n   {\n      adj[i].add(j);\n      adj[j].add(i);\n   }\n}\n", "label": 3}
{"src": "import java.io.File;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class F120 {\n\n    public static void main(String[] args) throws IOException {\n        //Scanner in = new Scanner(System.in);\n        Scanner in = new Scanner(new File(\"input.txt\"));\n        int spiderCount = in.nextInt();\n        int answer = 0;\n        for (int spiderNo=0; spiderNo<spiderCount; spiderNo++) {\n            int N = in.nextInt();\n            Node[] nodes = new Node[N];\n            for (int n=0; n<N; n++) {\n                nodes[n] = new Node();\n            }\n            for (int n=1; n<N; n++) {\n                int u = in.nextInt()-1;\n                int v = in.nextInt()-1;\n                nodes[u].next.add(nodes[v]);\n                nodes[v].next.add(nodes[u]);\n            }\n            Queue<Node> queue = new LinkedList<>();\n            for (Node node : nodes) {\n                node.degree = node.next.size();\n                if (node.degree == 1) {\n                    queue.add(node);\n                }\n            }\n            int diameter = 0;\n            int removedCount = 0;\n            while (true) {\n                if (queue.size() == 1) { // single node of degree 0\n                    break;\n                }\n                Queue<Node> newQueue = new LinkedList<>();\n                for (Node node : queue) {\n                    node.removed = true;\n                    removedCount++;\n                    for (Node n : node.next) {\n                        if (!n.removed) {\n                            if (--n.degree == 1) {\n                                newQueue.add(n);\n                            }\n                        }\n                    }\n                }\n                if (removedCount == N) {\n                    diameter++; // two nodes of degree 1\n                    break;\n                } else {\n                    diameter += 2;\n                }\n                queue = newQueue;\n            }\n            answer += diameter;\n        }\n        PrintWriter out = new PrintWriter(new File(\"output.txt\"));\n        out.println(answer);\n        out.close();\n    }\n\n    static class Node {\n        List<Node> next = new ArrayList<>();\n        int degree;\n        boolean removed;\n    }\n    \n}\n\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n        static int n, m, p, q, k, a, b, c, d, t, cnt = 0, ans = 0;\n        static int[][] ar;\n\n        public static void Floyd(){\n                for(int k = 1; k <= n; ++k)\n                        for(int i = 1; i <= n; ++i)\n                                for(int j = 1; j <= n; ++j)\n                                        if(i != j)\n                                                ar[i][j] = Math.min(ar[i][j], ar[i][k] + ar[k][j]);\n        }\n\n        public static void main(String[] args) throws Exception {\n\n                //MyScanner sc = new MyScanner();\n                //out = new PrintWriter(new BufferedOutputStream(System.out));\n\n                BufferedReader sc = new BufferedReader(new FileReader(\"input.txt\"));\n                PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n\n                t = Integer.parseInt(sc.readLine());\n                while(t-- > 0){\n\n                        StringTokenizer st = new StringTokenizer(sc.readLine());\n\n                        n = Integer.parseInt(st.nextToken());\n                        ar = new int[n + 1][n + 1];\n                        for(int[] row : ar)\n                                Arrays.fill(row, 1000000000);\n                        for(int i = 1; i < n; ++i){\n                                a = Integer.parseInt(st.nextToken());\n                                b = Integer.parseInt(st.nextToken());\n                                ar[a][b] = 1;\n                                ar[b][a] = 1;\n                        }\n                        Floyd();\n                        int maxi = 1;\n                        for(int i = 1; i <= n; ++i)\n                                for(int j = 1; j <= i; ++j){\n                                        if(ar[i][j] != 1000000000)\n                                                maxi = Math.max(maxi, ar[i][j]);\n                                }\n                        ans += maxi;\n                }\n                out.print(ans);\n\n                sc.close();\n                out.close();\n\n                //out.close();\n        }\n\n        public static PrintWriter out;\n\n        public static class MyScanner {\n                BufferedReader br;\n                StringTokenizer st;\n\n                public MyScanner() {\n                        br = new BufferedReader(new InputStreamReader(System.in));\n                }\n\n                String next() {\n                        while (st == null || !st.hasMoreElements()) {\n                                try {\n                                        st = new StringTokenizer(br.readLine());\n                                } catch (IOException e) {\n                                        e.printStackTrace();\n                                }\n                        }\n                        return st.nextToken();\n                }\n\n                int nextInt() {\n                        return Integer.parseInt(next());\n                }\n\n                long nextLong() {\n                        return Long.parseLong(next());\n                }\n\n                double nextDouble() {\n                        return Double.parseDouble(next());\n                }\n\n                String nextLine(){\n                        String str = \"\";\n                        try {\n                                str = br.readLine();\n                        } catch (IOException e) {\n                                e.printStackTrace();\n                        }\n                        return str;\n                }\n\n        }\n}\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author unknown\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream;\n        try {\n            inputStream = new FileInputStream(\"input.txt\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        OutputStream outputStream;\n        try {\n            outputStream = new FileOutputStream(\"output.txt\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        FSpiders solver = new FSpiders();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FSpiders {\n        int IINF = (int) 1e9 + 331;\n        int largestDia = 0;\n        ArrayList<Integer>[] graph;\n        int[] heightarr;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int tlength = 0;\n            for (int k = 0; k < n; k++) {\n                int m = in.nextInt();\n                largestDia = 0;\n                graph = new ArrayList[m + 1];\n                heightarr = new int[m + 1];\n                for (int i = 0; i < m + 1; i++) {\n                    graph[i] = new ArrayList<>();\n                    heightarr[i] = 0;\n                }\n                for (int i = 0; i < (m - 1); i++) {\n                    int u = in.nextInt();\n                    int v = in.nextInt();\n                    graph[u].add(v);\n                    graph[v].add(u);\n                }\n                getDiameter(graph, heightarr, 1, 0);\n                tlength += largestDia;\n            }\n            out.println(tlength);\n        }\n\n        int getDiameter(ArrayList<Integer>[] graph, int[] heightarr, int to, int from) {\n            heightarr[to] = -1;\n            int max1 = -IINF;\n            int max2 = -IINF;\n            for (Integer node : graph[to]) {\n                if (node != from) {\n                    int temph = getDiameter(graph, heightarr, node, to);\n                    heightarr[to] = _F.max(heightarr[to], temph);\n                    if (temph > max1) {\n                        max2 = max1;\n                        max1 = temph;\n                    } else if (temph > max2) {\n                        max2 = temph;\n                    }\n                }\n            }\n            heightarr[to] += 1;\n            int diameterAtCurrNode = _F.max(heightarr[to], max1 + max2 + 2);\n            largestDia = _F.max(largestDia, diameterAtCurrNode);\n            return heightarr[to];\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class _F {\n        public static <T extends Comparable<T>> T max(T... list) {\n            T candidate = list[0];\n            for (T i : list) {\n                if (candidate.compareTo(i) < 0) {\n                    candidate = i;\n                }\n            }\n            return candidate;\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "//package codeforce;\nimport java.io.*;\nimport java.util.*;\n\npublic class spider {\npublic static void main(String[] args) throws Exception\n{\n    BufferedReader br=new BufferedReader(new FileReader(\"input.txt\"));\n    PrintWriter pw=new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n    int n=Integer.parseInt(br.readLine());\n    int ans=0;\n    for(int i=0;i<n;i++)\n    {\n        String[] temp1=br.readLine().split(\" \");\n        int count=0;\n        int m=Integer.parseInt(temp1[count++]);\n        ArrayList<ArrayList<Integer>> arr=new ArrayList<ArrayList<Integer>>();\n        for(int k=0;k<m;k++)\n        {\n            arr.add(new ArrayList<Integer>());\n        }\n        for(int j=0;j<m-1;j++)\n        {\n            int u=Integer.parseInt(temp1[count++])-1;\n            int v=Integer.parseInt(temp1[count++])-1;\n            arr.get(u).add(v);\n            arr.get(v).add(u);\n            \n            \n        }\n        \n        int max=0;\n        for(int c=0;c<m;c++)\n        {\n    \n        boolean[] visited=new boolean[m];\n        int[] dist=new int[m];\n        dist[c]=0;\n        Queue<Integer> q=new LinkedList<Integer>();\n        q.add(c);\n        visited[c]=true;\n        \n        while(!q.isEmpty())\n        {\n            \n            int d=q.remove();\n            int h=arr.get(d).size();\n            for(int w=0;w<h;w++)\n            {\n                int temp=arr.get(d).get(w);\n                if(!visited[temp])\n                {\n                    dist[temp]=dist[d]+1;\n                    visited[temp]=true;\n                    q.add(temp);\n                }\n            }\n        }\n        \n        for(int u=0;u<m;u++)\n        {\n            max=Math.max(dist[u], max);\n        }\n        }\n        ans+=max;\n    }\n    pw.println(ans);\n    pw.close();\n}\n\n}\n", "label": 3}
{"src": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.Stack;\nimport java.util.ArrayList;\nimport java.util.Vector;\nimport java.io.OutputStream;\nimport java.io.FileOutputStream;\nimport java.io.PrintWriter;\nimport java.io.FileInputStream;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author bkand1908\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream;\n\t\ttry {\n\t\t\tinputStream = new FileInputStream(\"input.txt\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tOutputStream outputStream;\n\t\ttry {\n\t\t\toutputStream = new FileOutputStream(\"output.txt\");\n\t\t} catch (IOException e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskF solver = new TaskF();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n}\n\nclass TaskF {\n\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n        int nn = in.readInt();\n        int n;\n        int ans = 0;\n        for (int i = 0; i < nn; ++i) {\n            n = in.readInt();\n            ArrayList<Integer>[] adj = new ArrayList[n];\n            for (int j = 0; j < n; ++j)\n                adj[j] = new ArrayList<Integer>();\n            for (int j = 0; j < n - 1; ++j) {\n                int u = in.readInt() - 1;\n                int v = in.readInt() - 1;\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n\n            int u, l, max_l, max_u;\n            Stack<Integer> stack = new Stack<Integer>();\n            max_u = -1;\n            max_l = -1;\n            stack.push(0);  // u = 0\n            stack.push(0);  // length = 0\n            boolean[] taken = new boolean[n];\n            while (!stack.isEmpty()) {\n                l = stack.pop();\n                u = stack.pop();\n                taken[u] = true;\n                if (l > max_l) {\n                    max_l = l;\n                    max_u = u;\n                }\n                for (Integer v : adj[u])\n                    if (!taken[v]) {\n                        stack.push(v);\n                        stack.push(l + 1);\n                    }\n            }\n\n            max_l = -1;\n            stack.push(max_u);  // u = 0\n            stack.push(0);  // length = 0\n            Arrays.fill(taken, false);\n            while (!stack.isEmpty()) {\n                l = stack.pop();\n                u = stack.pop();\n                taken[u] = true;\n                if (l > max_l) {\n                    max_l = l;\n                }\n                for (Integer v : adj[u])\n                    if (!taken[v]) {\n                        stack.push(v);\n                        stack.push(l + 1);\n                    }\n            }\n\n            ans += max_l;\n        }\n        out.println(ans);\n\t}\n}\n\nclass InputReader {\n\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n                this.stream = stream;\n        }\n\n        public int read() {\n                if (numChars == -1)\n                        throw new InputMismatchException();\n                if (curChar >= numChars) {\n                        curChar = 0;\n                        try {\n                                numChars = stream.read(buf);\n                        } catch (IOException e) {\n                                throw new InputMismatchException();\n                        }\n                        if (numChars <= 0)\n                                return -1;\n                }\n                return buf[curChar++];\n        }\n\n        public int readInt() {\n                int c = read();\n                while (isSpaceChar(c))\n                        c = read();\n                int sgn = 1;\n                if (c == '-') {\n                        sgn = -1;\n                        c = read();\n                }\n                int res = 0;\n                do {\n                        if (c < '0' || c > '9')\n                                throw new InputMismatchException();\n                        res *= 10;\n                        res += c - '0';\n                        c = read();\n                } while (!isSpaceChar(c));\n                return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n                return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        }\n\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author unknown\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream;\n        try {\n            inputStream = new FileInputStream(\"input.txt\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        OutputStream outputStream;\n        try {\n            outputStream = new FileOutputStream(\"output.txt\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        FSpiders solver = new FSpiders();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class FSpiders {\n        int IINF = (int) 1e9 + 331;\n        int dia = 0;\n        ArrayList<Integer>[] graph;\n        _C.Pair<Integer, Integer>[] nodeProps;\n\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int tlength = 0;\n            for (int k = 0; k < n; k++) {\n                int m = in.nextInt();\n                dia = 0;\n                graph = new ArrayList[m + 1];\n                nodeProps = new _C.Pair[m + 1];\n                for (int i = 0; i < m + 1; i++) {\n                    graph[i] = new ArrayList<>();\n                    nodeProps[i] = new _C.Pair<>(0, 0);\n                }\n                for (int i = 0; i < (m - 1); i++) {\n                    int u = in.nextInt();\n                    int v = in.nextInt();\n                    graph[u].add(v);\n                    graph[v].add(u);\n                }\n                getDiameter(1, 0);\n//            debug(\"graph\",graph);\n//            debug(\"NOde Props\",nodeProps);\n                tlength += dia;\n            }\n            out.println(tlength);\n        }\n\n        int getDiameter(int to, int from) {\n            int height = -1;\n            int max1 = -IINF;\n            int max2 = -IINF;\n            for (Integer node : graph[to]) {\n                if (node != from) {\n                    int temph = getDiameter(node, to);\n                    height = _F.max(height, temph);\n                    if (temph > max1) {\n                        max2 = max1;\n                        max1 = temph;\n                    } else if (temph > max2) {\n                        max2 = temph;\n                    }\n                }\n            }\n            nodeProps[to].f = height + 1;\n            nodeProps[to].s = _F.max(nodeProps[to].f, max1 + max2 + 2);\n            dia = _F.max(dia, nodeProps[to].s);\n            return nodeProps[to].f;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class _F {\n        public static <T extends Comparable<T>> T max(T... list) {\n            T candidate = list[0];\n            for (T i : list) {\n                if (candidate.compareTo(i) < 0) {\n                    candidate = i;\n                }\n            }\n            return candidate;\n        }\n\n    }\n\n    static class _C {\n        static public class Pair<F extends Comparable<F>, S extends Comparable<S>> implements Comparable<_C.Pair<F, S>> {\n            public F f;\n            public S s;\n\n            public Pair(F f, S s) {\n                this.f = f;\n                this.s = s;\n            }\n\n            public int compareTo(_C.Pair<F, S> o) {\n                int t = f.compareTo(o.f);\n                if (t == 0) return s.compareTo(o.s);\n                return t;\n            }\n\n            public int hashCode() {\n                return (31 + f.hashCode()) * 31 + s.hashCode();\n            }\n\n            public boolean equals(Object o) {\n                if (!(o instanceof _C.Pair)) return false;\n                if (o == this) return true;\n                _C.Pair p = (_C.Pair) o;\n                return f.equals(p.f) && s.equals(p.s);\n            }\n\n            public String toString() {\n                return \"{\" + f + \", \" + s + \"}\";\n            }\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(long i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class cf120f {\n    static ArrayList<ArrayList<Integer>> g;\n    public static void main(String[] args) throws Exception {\n        Scanner in = new Scanner(new File(\"input.txt\"));\n        PrintWriter out = new PrintWriter(new File(\"output.txt\"));\n        int n = in.nextInt();\n        int ret = 0;\n        for(int z=0; z<n; z++) {\n            int s = in.nextInt();\n            g = new ArrayList<ArrayList<Integer>>();\n            for(int i=0; i<s; i++)\n                g.add(new ArrayList<Integer>());\n            for(int i=0; i<s-1; i++) {\n                int a = in.nextInt()-1;\n                int b = in.nextInt()-1;\n                g.get(a).add(b);\n                g.get(b).add(a);\n            }\n            int cur = 0;\n            for(int i=0; i<s; i++)\n                cur = Math.max(cur,dfs(i,-1));\n            ret += cur;\n        }\n        out.println(ret);\n        out.close();\n    }\n    static int dfs(int cur, int last) {\n        int h = 0;\n        for(int x : g.get(cur))\n            if(x != last)\n                h = Math.max(h,1+dfs(x,cur));\n        return h;\n    }\n}", "label": 3}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\n\n\npublic class F {\n\t\n\tint n, INF = Integer.MAX_VALUE;\n\tArrayList<Integer> g[];\n\tboolean used[];\n\t\n\tprivate void Problem() throws IOException {\n\t\tint t = nextInt(), l = 0;\n\t\twhile (t-- > 0) {\n\t\t\tint length = 0;\n\t\t\tn = nextInt();\n\t\t\tg = new ArrayList[n];\n\t\t\tfor (int i = 0; i < n; i++)\n                g[i] = new ArrayList<Integer>();\n\t\t\tfor (int i = 0; i < n-1; i++) {\n\t\t\t\tint x = nextInt()-1, y = nextInt()-1;\n\t\t\t\tg[x].add(y);\n\t\t\t\tg[y].add(x);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tused = new boolean[n];\n\t\t\t\tlength = max(length, depth(i));\n\t\t\t}\n\t\t\tl += length;\n\t\t}\n\t\tout.println(l);\n\t}\n\t\n\tint depth(int v) {\n\t\tused[v] = true;\n\t\tint res = 0;\n\t\tfor (int i: g[v]) \n\t\t\tif(!used[i]) res = max(res, depth(i)+1);\n\t\treturn res;\n\t}\n\t\n\tint max(int... n) {\n        int m = -INF;\n        for (int i: n) \n        \tif (i > m) m = i;\n        return m;\n    }\n\t\n\tBufferedReader in;\n\tStringTokenizer tokenizer;\n\tPrintWriter out;\n\t\n\tint nextInt() throws IOException, NumberFormatException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\t\n\tString nextToken() throws IOException {\n        if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(in.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\t\n\tpublic void Solution() throws IOException {\n\t\tin = new BufferedReader(new FileReader(new File(\"input.txt\")));\n\t\tout = new PrintWriter(new File(\"output.txt\"));\n\t\ttokenizer = null;\n\t\tProblem();\n\t\tin.close();\n\t\tout.close(); \n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew F().Solution();\n\t}\n}\n", "label": 3}
{"src": "import java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedWriter;\nimport java.util.InputMismatchException;\nimport java.util.Comparator;\nimport java.io.FileOutputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.FileInputStream;\nimport java.util.NoSuchElementException;\nimport java.io.Writer;\nimport java.math.BigInteger;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n * @author Nguyen Trung Hieu - vuondenthanhcong11@yahoo.com\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream;\n        try {\n            inputStream = new FileInputStream(\"input.txt\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        OutputStream outputStream;\n        try {\n            outputStream = new FileOutputStream(\"output.txt\");\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        TaskF solver = new TaskF();\n        solver.solve(1, in, out);\n        out.close();\n    }\n}\n\nclass TaskF {\n    public void solve(int testNumber, InputReader in, OutputWriter out) {\n        int count = in.readInt();\n        int answer = 0;\n        for (int i = 0; i < count; i++)\n            answer += processSpider(in);\n        out.printLine(answer);\n    }\n    private int processSpider(InputReader in) {\n        int size = in.readInt();\n        int[] from = new int[size - 1];\n        int[] to = new int[size - 1];\n        IOUtils.readIntArrays(in, from, to);\n        for (int i = 0; i < size - 1; i++) {\n            from[i]--;\n            to[i]--;\n        }\n        int[][] graph = GraphUtils.buildSimpleGraph(size, from, to);\n        int result = 0;\n        for (int i = 0; i < size; i++)\n            result = Math.max(result, dfs(i, -1, graph));\n        return result;\n    }\n\n    private int dfs(int vertex, int last, int[][] graph) {\n        int result = 0;\n        for (int next : graph[vertex]) {\n            if (next != last)\n                result = Math.max(result, 1 + dfs(next, vertex, graph));\n        }\n        return result;\n    }\n}\n\nclass InputReader {\n    private InputStream stream;\n    private byte[] buf = new byte[1024];\n    private int curChar;\n    private int numChars;\n    private SpaceCharFilter filter;\n\n    public InputReader(InputStream stream) {\n        this.stream = stream;\n    }\n\n    public int read() {\n        if (numChars == -1)\n            throw new InputMismatchException();\n        if (curChar >= numChars) {\n            curChar = 0;\n            try {\n                numChars = stream.read(buf);\n            } catch (IOException e) {\n                throw new InputMismatchException();\n            }\n            if (numChars <= 0)\n                return -1;\n        }\n        return buf[curChar++];\n    }\n\n    public int readInt() {\n        int c = read();\n        while (isSpaceChar(c))\n            c = read();\n        int sgn = 1;\n        if (c == '-') {\n            sgn = -1;\n            c = read();\n        }\n        int res = 0;\n        do {\n            if (c < '0' || c > '9')\n                throw new InputMismatchException();\n            res *= 10;\n            res += c - '0';\n            c = read();\n        } while (!isSpaceChar(c));\n        return res * sgn;\n    }\n\n    public boolean isSpaceChar(int c) {\n        if (filter != null)\n            return filter.isSpaceChar(c);\n        return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n    }\n\n    public interface SpaceCharFilter {\n        public boolean isSpaceChar(int ch);\n    }\n\n    }\n\nclass OutputWriter {\n    private final PrintWriter writer;\n\n    public OutputWriter(OutputStream outputStream) {\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n    }\n\n    public OutputWriter(Writer writer) {\n        this.writer = new PrintWriter(writer);\n    }\n\n    public void print(Object...objects) {\n        for (int i = 0; i < objects.length; i++) {\n            if (i != 0)\n                writer.print(' ');\n            writer.print(objects[i]);\n        }\n    }\n\n    public void printLine(Object...objects) {\n        print(objects);\n        writer.println();\n    }\n\n    public void close() {\n        writer.close();\n    }\n\n}\n\nclass IOUtils {\n\n    public static void readIntArrays(InputReader in, int[]... arrays) {\n        for (int i = 0; i < arrays[0].length; i++) {\n            for (int j = 0; j < arrays.length; j++)\n                arrays[j][i] = in.readInt();\n        }\n    }\n\n    }\n\nclass GraphUtils {\n    public static int[][] buildGraph(int vertexCount, int[] from, int[] to) {\n        int edgeCount = from.length;\n        int[] degree = new int[vertexCount];\n        for (int i = 0; i < edgeCount; i++) {\n            degree[from[i]]++;\n            degree[to[i]]++;\n        }\n        int[][] graph = new int[vertexCount][];\n        for (int i = 0; i < vertexCount; i++)\n            graph[i] = new int[degree[i]];\n        for (int i = 0; i < edgeCount; i++) {\n            graph[from[i]][--degree[from[i]]] = i;\n            graph[to[i]][--degree[to[i]]] = i;\n        }\n        return graph;\n    }\n\n    public static int otherVertex(int vertex, int from, int to) {\n        return from + to - vertex;\n    }\n\n    public static int[][] buildSimpleGraph(int vertexCount, int[] from, int[] to) {\n        int[][] graph = buildGraph(vertexCount, from, to);\n        simplifyGraph(from, to, graph);\n        return graph;\n    }\n\n    private static void simplifyGraph(int[] from, int[] to, int[][] graph) {\n        for (int i = 0; i < graph.length; i++) {\n            for (int j = 0; j < graph[i].length; j++) {\n                graph[i][j] = otherVertex(i, from[graph[i][j]], to[graph[i][j]]);\n            }\n        }\n    }\n\n    }\n", "label": 3}
{"src": "\nimport java.io.*;\nimport java.util.*;\n\npublic class CodeForces {\n    \n    private void solve() throws IOException {\n        int N = nextInt();\n        int ret = 0;\n        for(int n = 0; n < N; n++) {\n            int n_i = nextInt();\n            int [][]C = new int[n_i][]; for(int i = 0; i < n_i; i++) {\n                C[i] = new int[n_i];\n                Arrays.fill(C[i], 1000000);\n            }\n            for(int i = 0; i < 2 * (n_i - 1); i += 2) {\n                int a = nextInt() - 1, b = nextInt() - 1;\n                C[a][b] = C[b][a] = 1;\n            }\n            int c = 0;\n            for(int k = 0; k < n_i; k++) for(int i = 0; i < n_i; i++) for(int j = 0; j < n_i; j++) {\n                C[i][j] = Math.min(C[i][j], C[i][k] + C[k][j]);\n                if(C[i][j] < 100000 && i != j)\n                    c = Math.max(c, C[i][j]);\n            }\n            ret += c;\n        }\n        \n        writer.println(ret);\n    }\n    \n    public static void main(String[] args) {\n        new CodeForces().run();\n    }\n\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n    PrintWriter writer;\n\n    public void run() {\n        try {\n            reader = new BufferedReader(new FileReader(new File(\"input.txt\")));\n            tokenizer = null;\n            writer = new PrintWriter(new FileOutputStream(new File(\"output.txt\")));\n            solve();\n            reader.close();\n            writer.close();\n        } catch (Exception e) {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n\n    int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n\n    double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n    \n    String nextLine() throws IOException {\n        return reader.readLine();\n    }\n\n    String nextToken() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\n// find diameter of tree by finding node furthest from a random node then finding node furthest from that node\n\npublic class cf120f_2 {\n\n    public static void main(String[] args) throws IOException {\n        __in = new BufferedReader(new FileReader(\"input.txt\"));\n        __out = new PrintWriter(new FileWriter(\"output.txt\"));\n        int n = ri(), ans = 0;\n        for(int i = 0; i < n; ++i) {\n            int sz = rni();\n            List<List<Integer>> g = graph(sz);\n            for(int j = 0; j < sz - 1; ++j) {\n                int u = ni() - 1, v = ni() - 1;\n                connect(g, u, v);\n            }\n            int far = dfs(g, 0, -1)[0];\n            ans += dfs(g, far, -1)[1];\n        }\n        prln(ans);\n        close();\n    }\n\n    // returns [furthest node, dist]\n    static int[] dfs(List<List<Integer>> g, int i, int p) {\n        int node = i, dist = 0;\n        for(int n : g.get(i)) {\n            if(n != p) {\n                int[] dfs = dfs(g, n, i);\n                if(dfs[1] >= dist) {\n                    node = dfs[0];\n                    dist = dfs[1] + 1;\n                }\n            }\n        }\n        return new int[] {node, dist};\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e10\n    // LMAX ~= 9e18\n    \n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if(x.length == 1) return x[0]; if(x.length == 2) return min(x[0], x[1]); if(x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if(x.length == 1) return x[0]; if(x.length == 2) return min(x[0], x[1]); if(x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if(x.length == 1) return x[0]; if(x.length == 2) return max(x[0], x[1]); if(x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if(x.length == 1) return x[0]; if(x.length == 2) return max(x[0], x[1]); if(x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if(a == 0) return 0; int ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if(a == 0) return 0; long ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int)d;}\n    static int cei(double d) {return (int)ceil(d);}\n    static long fll(double d) {return (long)d;}\n    static long cel(double d) {return (long)ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long hash(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for(int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for(int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for(int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for(int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for(int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for(int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for(int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for(int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static int[] sorted(int[] a) {int[] ans = copy(a); sort(ans); return ans;}\n    static long[] sorted(long[] a) {long[] ans = copy(a); sort(ans); return ans;}\n    static int[] rsorted(int[] a) {int[] ans = copy(a); rsort(ans); return ans;}\n    static long[] rsorted(long[] a) {long[] ans = copy(a); rsort(ans); return ans;}\n    // graph util\n    static List<List<Integer>> graph(int n) {List<List<Integer>> g = new ArrayList<>(); for(int i = 0; i < n; ++i) g.add(new ArrayList<>()); return g;}\n    static List<List<Integer>> graph(List<List<Integer>> g, int m) throws IOException {for(int i = 0; i < m; ++i) connect(g, rni() - 1, ni() - 1); return g;}\n    static List<List<Integer>> graph(int n, int m) throws IOException {return graph(graph(n), m);}\n    static List<List<Integer>> dgraph(List<List<Integer>> g, int m) throws IOException {for(int i = 0; i < m; ++i) connecto(g, rni() - 1, ni() - 1); return g;}\n    static List<List<Integer>> dgraph(List<List<Integer>> g, int n, int m) throws IOException {return dgraph(graph(n), m);}\n    static List<Set<Integer>> sgraph(int n) {List<Set<Integer>> g = new ArrayList<>(); for(int i = 0; i < n; ++i) g.add(new HashSet<>()); return g;}\n    static List<Set<Integer>> sgraph(List<Set<Integer>> g, int m) throws IOException {for(int i = 0; i < m; ++i) connect(g, rni() - 1, ni() - 1); return g;}\n    static List<Set<Integer>> sgraph(int n, int m) throws IOException {return sgraph(sgraph(n), m);}\n    static List<Set<Integer>> dsgraph(List<Set<Integer>> g, int m) throws IOException {for(int i = 0; i < m; ++i) connecto(g, rni() - 1, ni() - 1); return g;}\n    static List<Set<Integer>> dsgraph(List<Set<Integer>> g, int n, int m) throws IOException {return dsgraph(sgraph(n), m);}\n    static void connect(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v); g.get(v).add(u);}\n    static void connecto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v);}\n    static void dconnect(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v); g.get(v).remove(u);}\n    static void dconnecto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v);}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(__in.readLine());}\n    static int ri() throws IOException {return Integer.parseInt(__in.readLine());}\n    static long rl() throws IOException {return Long.parseLong(__in.readLine());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Integer.parseInt(input.nextToken()); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Integer.parseInt(input.nextToken()) - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Long.parseLong(input.nextToken()); return a;}\n    static char[] rcha() throws IOException {return __in.readLine().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static int rni() throws IOException {input = new StringTokenizer(__in.readLine()); return Integer.parseInt(input.nextToken());}\n    static int ni() {return Integer.parseInt(input.nextToken());}\n    static long rnl() throws IOException {input = new StringTokenizer(__in.readLine()); return Long.parseLong(input.nextToken());}\n    static long nl() {return Long.parseLong(input.nextToken());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {__out.println(\"yes\");}\n    static void pry() {__out.println(\"Yes\");}\n    static void prY() {__out.println(\"YES\");}\n    static void prno() {__out.println(\"no\");}\n    static void prn() {__out.println(\"No\");}\n    static void prN() {__out.println(\"NO\");}\n    static void pryesno(boolean b) {__out.println(b ? \"yes\" : \"no\");};\n    static void pryn(boolean b) {__out.println(b ? \"Yes\" : \"No\");}\n    static void prYN(boolean b) {__out.println(b ? \"YES\" : \"NO\");}\n    static void prln(int... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static void prln(long... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for(int i = 0; i < n; __out.print(iter.next()), __out.print(' '), ++i); if(n >= 0) __out.println(iter.next()); else __out.println();}\n    static void h() {__out.println(\"hlfd\");}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}", "label": 3}
{"src": "//package com.pb.codeforces.practice;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class CF120F {\n\t\n\tpublic static int maxNode = -1;\n\tpublic static int mLen = -1;\n\t\n\tpublic static void dfs(int u,ArrayList<ArrayList<Integer>> adj,boolean[] vi, int len) {\n\t\tif(len > mLen) {\n\t\t\tmaxNode = u;\n\t\t\tmLen = len;\n\t\t}\n\t\tvi[u] = true;\n\t\tfor(int v : adj.get(u)) {\n\t\t\tif(!vi[v])\n\t\t\t\tdfs(v,adj,vi,len+1);\n\t\t}\n\t\tvi[u] = false;\n\t}\n\t\n\tpublic static int getLongestPath(int n,ArrayList<ArrayList<Integer>> adj) {\n\t\tmaxNode = mLen = -1;\n\t\tboolean[] vi = new boolean[n];\n\t\tdfs(0,adj,vi,0);\n\t\tint mNode = maxNode;\n\t\tmaxNode = mLen = -1;\n\t\tdfs(mNode,adj,vi,0);\n\t\treturn mLen;\n\t}\n\t\n\tpublic static void main(String[] args) throws FileNotFoundException {\n\t\tScanner in = new Scanner(new File(\"input.txt\"));\n\t\tPrintWriter out = new PrintWriter(new File(\"output.txt\"));\n\t\tint t = in.nextInt();\n\t\tint maxPath = 0;\n\t\twhile(t-- > 0) {\n\t\t\tint n = in.nextInt();\n\t\t\tArrayList<ArrayList<Integer>> adj = new ArrayList<ArrayList<Integer>>();\n\t\t\tfor(int i=0; i<n; i++)\n\t\t\t\tadj.add(new ArrayList<Integer>());\n\t\t\tfor(int i=1; i<n; i++) {\n\t\t\t\tint u = in.nextInt() - 1;\n\t\t\t\tint v = in.nextInt() - 1;\n\t\t\t\tadj.get(u).add(v);\n\t\t\t\tadj.get(v).add(u);\n\t\t\t}\n\t\t\tmaxPath += getLongestPath(n,adj);\n\t\t}\n\t\tout.println(maxPath);\n\t\tout.close();\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main\n{\n    static ArrayList<ArrayList<Integer>> graph;\n    static int[] length;\n    static boolean[] visited;\n    \n    static void DFS(int i, int start, int len)\n    {\n        visited[start] = true;\n        if (len > length[i])\n        {\n            length[i] = len;\n        }\n        for (int e : graph.get(start))\n        {\n            if (!visited[e])\n            {\n                DFS(i, e, len + 1);\n            }\n        }\n    }\n    \n    public static void main(String[] args) throws Exception\n    {\n        FileInputStream istream = new FileInputStream(\"input.txt\");\n        PrintWriter pw = new PrintWriter(\"output.txt\");\n        \n        InputStreamReader ireader = new InputStreamReader(istream);\n        BufferedReader reader = new BufferedReader(ireader);\n        Scanner sc = new Scanner(ireader);\n        \n        int n = sc.nextInt();\n        length = new int[n];\n        \n        for (int i = 0; i < n; i++)\n        {\n            int ni = sc.nextInt();\n            graph = new ArrayList<ArrayList<Integer>>();\n            \n            for (int j = 0; j < ni; j++)\n            {\n                graph.add(new ArrayList<Integer>());\n            }\n            for (int j = 0; j < ni - 1; j++)\n            {\n                int s = sc.nextInt() - 1;\n                int e = sc.nextInt() - 1;\n                graph.get(s).add(e);\n                graph.get(e).add(s);\n            }\n            for (int j = 0; j < ni; j++)\n            {\n                visited = new boolean[ni];\n                DFS(i, j, 0);\n            }\n        }\n        \n        int result = 0;\n        for (int i = 0; i < n; i++)\n        {\n            result += length[i];\n        }\n        pw.println(result);\n        \n        pw.close();\n        istream.close();\n    }\n}\n", "label": 3}
{"src": "import java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class WorkFile {\n    public static int dfs(ArrayList<Integer>[] graph, int prev, int item) {\n        int max = 0;\n        for (int elem:graph[item]) {\n            if (elem!=prev) {\n                max = Math.max(max, dfs(graph, item, elem)+1);\n            }\n        }\n        return max;\n    }\n    public static void main(String[] args) throws IOException {\n        Scanner s = new Scanner(new FileReader(\"input.txt\"));\n        int spiders = s.nextInt();\n        int result = 0;\n        while (spiders-->0) {\n            int n = s.nextInt();\n            ArrayList[] graph = new ArrayList[n];\n            for (int i=0; i<n; i++) {\n                graph[i] = new ArrayList<Integer>();\n            }\n            for (int i=1; i<n; i++) {\n                int x = s.nextInt()-1, y = s.nextInt()-1;\n                graph[x].add(y);\n                graph[y].add(x);\n            }\n            int res = 0;\n            for (int i=0; i<n; i++) {\n                if (graph[i].size()==1) {\n                    res = Math.max(res, dfs(graph, -1, i));\n                }\n            }\n            result+=res;\n        }\n        FileWriter writer = new FileWriter(\"output.txt\");\n        writer.write(Integer.toString(result));\n        writer.close();\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n    BufferedReader in;\n    StringTokenizer st;\n    PrintWriter out;\n\n    int[] q = new int[100000];\n    int b, e;\n\n    void bfs(ArrayList<Integer>[] g, int[] d, int v) {\n        Arrays.fill(d, 1 << 29);\n        d[v] = 0;\n        b = e = 0;\n        for (q[e++] = v; b < e; ++b) {\n            v = q[b];\n            for (int i = 0; i < g[v].size(); ++i) {\n                int u = g[v].get(i);\n                if (d[u] > d[v] + 1) {\n                    d[u] = d[v] + 1;\n                    q[e++] = u;\n                }\n            }\n        }\n    }\n\n    int len(ArrayList<Integer>[] g, int n) {\n        int[] d = new int[n];\n        bfs(g, d, 0);\n        int mx = -1;\n        int v = -1;\n        for (int i = 0; i < n; ++i)\n            if (d[i] > mx) {\n                mx = d[i];\n                v = i;\n            }\n        bfs(g, d, v);\n        mx = -1;\n        v = -1;\n        for (int i = 0; i < n; ++i)\n            if (d[i] > mx) {\n                mx = d[i];\n                v = i;\n            }\n        return mx;\n    }\n\n    void solve() throws IOException {\n        int n = ni();\n        int ret = 0;\n        for (int it = 0; it < n; ++it) {\n            int sz = ni();\n            ArrayList<Integer>[] g = new ArrayList[sz];\n            for (int j = 0; j < g.length; j++) {\n                g[j] = new ArrayList<Integer>();\n            }\n            for (int i = 1; i < sz; ++i) {\n                int a = ni() - 1;\n                int b = ni() - 1;\n                g[a].add(b);\n                g[b].add(a);\n            }\n            ret += len(g, sz);\n        }\n        out.println(ret);\n    }\n\n    public Main() throws IOException {\n        Locale.setDefault(Locale.US);\n        in = new BufferedReader(new FileReader(\"input.txt\"));\n        out = new PrintWriter(\"output.txt\");\n        solve();\n        in.close();\n        out.close();\n    }\n\n    String ns() throws IOException {\n        while (st == null || !st.hasMoreTokens())\n            st = new StringTokenizer(in.readLine());\n        return st.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.valueOf(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.valueOf(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.valueOf(ns());\n    }\n\n    public static void main(String[] args) throws IOException {\n        new Main();\n    }\n}\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Locale;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Main implements Runnable {\n\n\tprivate int n;\n\tprivate ArrayList<Integer>[] adj;\n\n\tvoid solve() throws IOException {\n\t\tint t = nextInt();\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < t; i++) {\n\t\t\tn = nextInt();\n\t\t\tallocate();\n\t\t\tfor (int j = 0; j < n - 1; j++) {\n\t\t\t\tint a = nextInt();\n\t\t\t\tint b = nextInt();\n\t\t\t\tadj[a].add(b);\n\t\t\t\tadj[b].add(a);\n\t\t\t}\n\t\t\tint d = diameter();\n\t\t\tans += d;\n\t\t\t// out.println(\"diam \" + (i + 1) + \" = \" + d);\n\t\t}\n\n\t\tout.println(ans);\n\t}\n\n\tprivate int diameter() {\n\t\tint[] d = new int[n + 1];\n\t\tArrays.fill(d, -1);\n\n\t\tQueue<Integer> q = new ArrayDeque<Integer>();\n\t\td[1] = 0;\n\t\tq.add(1);\n\t\twhile (!q.isEmpty()) {\n\t\t\tint u = q.remove();\n\t\t\tfor (int v : adj[u]) {\n\t\t\t\tif (d[v] == -1) {\n\t\t\t\t\td[v] = d[u] + 1;\n\t\t\t\t\tq.add(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint root = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (d[i] > d[root]) {\n\t\t\t\troot = i;\n\t\t\t}\n\t\t}\n\n\t\tArrays.fill(d, -1);\n\t\td[root] = 0;\n\t\tq.add(root);\n\t\twhile (!q.isEmpty()) {\n\t\t\tint u = q.remove();\n\t\t\tfor (int v : adj[u]) {\n\t\t\t\tif (d[v] == -1) {\n\t\t\t\t\td[v] = d[u] + 1;\n\t\t\t\t\tq.add(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\troot = 1;\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (d[i] > d[root]) {\n\t\t\t\troot = i;\n\t\t\t}\n\t\t}\n\t\treturn d[root];\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate void allocate() {\n\t\tadj = new ArrayList[n + 1];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t}\n\t}\n\n\tprivate BufferedReader in;\n\tprivate PrintWriter out;\n\tprivate StringTokenizer st;\n\n\tprivate void eat(String s) {\n\t\tst = new StringTokenizer(s);\n\t}\n\n\tString next() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\teat(line);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\n\tint nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tlong nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tdouble nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Thread(null, new Main(), \"Main\", 1 << 23).start();\n\t}\n\n\tpublic void run() {\n\t\ttry {\n\t\t\tLocale.setDefault(Locale.US);\n\t\t\t// in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\t// out = new PrintWriter(System.out);\n\t\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t\tout = new PrintWriter(\"output.txt\");\n\t\t\teat(\"\");\n\t\t\tsolve();\n\t\t\tin.close();\n\t\t\tout.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}", "label": 3}
{"src": "import static java.util.Arrays.*;\nimport static java.lang.Math.*;\nimport static java.math.BigInteger.*;\nimport java.util.*;\nimport java.math.*;\nimport java.io.*;\n\npublic class F implements Runnable\n{\n    String file = \"input\";\n    \n    boolean TEST = false;\n    \n    void solve() throws IOException\n    {\n        int n = nextInt();\n        int res = 0;\n        for(int i = 0; i < n; i++)\n        {\n            int m = nextInt();\n            List<Integer>[] adj = new ArrayList[m + 1];\n            for(int j = 1; j <= m; j++) adj[j] = new ArrayList<Integer>();\n            for(int j = 0; j < m - 1; j++)\n            {\n                int u = nextInt(), v = nextInt();\n                adj[u].add(v);\n                adj[v].add(u);\n            }\n            res += get(adj);\n        }\n        out.println(res);\n    }\n    \n    int get(List<Integer>[] adj)\n    {\n        int[] d = BFS(1, adj);\n        int maxlen = 0;\n        for(int i = 1; i < d.length; i++)\n            maxlen = max(maxlen, d[i]);\n        for(int i = 1; i < d.length; i++)\n            if(d[i] == maxlen)\n            {\n                int[] d2 = BFS(i, adj);\n                int maxlen2 = 0;\n                for(int j = 1; j < d2.length; j++) maxlen2 = max(maxlen2, d2[j]);\n                return maxlen2;\n            }\n        return -1;\n    }\n    \n    int[] BFS(int st, List<Integer>[] adj)\n    {\n        int n = adj.length;\n        int[] d = new int[n];\n        fill(d, -1);\n        d[st] = 0;\n        Queue<Integer> q = new LinkedList<Integer>();\n        q.offer(st);\n        while(!q.isEmpty())\n        {\n            int u = q.poll();\n            \n            for(int v : adj[u])\n                if(d[v] == -1)\n                {\n                    d[v] = d[u] + 1;\n                    q.offer(v);\n                }\n        }\n        return d;\n    }\n    \n    String next() throws IOException\n    {\n        while(st == null || !st.hasMoreTokens()) st = new StringTokenizer(input.readLine());\n        return st.nextToken();\n    }\n    \n    int nextInt() throws IOException\n    {\n        return Integer.parseInt(next());\n    }\n    \n    long nextLong() throws IOException\n    {\n        return Long.parseLong(next());\n    }\n    \n    double nextDouble() throws IOException\n    {\n        return Double.parseDouble(next());\n    }\n    \n    void print(Object... o)\n    {\n        System.out.println(deepToString(o));\n    }\n    \n    void gcj(Object o)\n    {\n        String s = String.valueOf(o);\n        out.println(\"Case #\" + test + \": \" + s);\n        System.out.println(\"Case #\" + test + \": \" + s);\n    }\n    \n    BufferedReader input;\n    PrintWriter out;\n    StringTokenizer st;\n    int test;\n    \n    void init() throws IOException\n    {\n        input = new BufferedReader(new FileReader(file + \".txt\")); \n        if(TEST) out = new PrintWriter(new BufferedOutputStream(System.out));\n        else out = new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n    }\n    \n    public static void main(String[] args) throws IOException\n    {\n        new Thread(null, new F(), \"\", 1 << 20).start();\n    }\n    \n    public void run()\n    {\n        try\n        {\n            init();\n            if(TEST) \n            {\n                int runs = nextInt();\n                for(int i = 0; i < runs; i++) solve();\n            }\n            else solve();\n            out.close();        \n        }\n        catch(Exception e)\n        {\n            e.printStackTrace();\n            System.exit(1);\n        }\n    }\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Queue;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Thread(null, new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\ttry {\n\t\t\t\t\tlong prevTime = System.currentTimeMillis();\n\t\t\t\t\tnew Main().run();\n\t\t\t\t\tSystem.err.println(\"Total time: \"\n\t\t\t\t\t\t\t+ (System.currentTimeMillis() - prevTime) + \" ms\");\n\t\t\t\t\tSystem.err.println(\"Memory status: \" + memoryStatus());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}, \"1\", 1L << 24).start();\n\t}\n\n\tvoid run() throws IOException {\n\t\tin = new BufferedReader(new FileReader(\"input.txt\"));\n\t\tout = new PrintWriter(\"output.txt\");\n\t\tObject o = solve();\n\t\tif (o != null)\n\t\t\tout.println(o);\n\t\tout.close();\n\t\tin.close();\n\t}\n\n\tprivate Object solve() throws IOException {\n\t\tint n = ni();\n\t\tint ret =0;\n\t\tfor(int i =0;i<n;i++)\n\t\t\tret+=f();\n\t\treturn ret;\n\t}\n\n\tprivate int f() throws IOException {\n\t\tint n = ni();\n\t\tList<Integer>[] g = (List<Integer>[]) new List[n];\n\t\tfor(int i =0;i<n;i++)\n\t\t\tg[i]= new ArrayList<Integer>();\n\t\tfor(int i =0;i<n-1;i++){\n\t\t\tint u = ni()-1;\n\t\t\tint v = ni()-1;\n\t\t\tg[u].add(v);\n\t\t\tg[v].add(u);\n\t\t\t\n\t\t}\n\t\tint[][] bfs = new int[n][n];\n\t\tfor(int i =0;i<n;i++)\n\t\t\tbfs(g,bfs[i],i);\n\t\tint max =0;\n\t\tfor(int i =0;i<n;i++)\n\t\t\tfor(int j =0;j<n;j++)\n\t\t\t\tmax = Math.max(max, bfs[i][j]);\n\t\treturn max;\n\t}\n\n\tprivate void bfs(List<Integer>[] g, int[] bfs, int source) {\n\t\tArrays.fill(bfs, Integer.MAX_VALUE);\n\t\tbfs[source]=0;\n\t\tQueue<Integer> q = new LinkedList<Integer>();\n\t\tq.add(source);\n\t\twhile(!q.isEmpty()){\n\t\t\tint u = q.poll();\n\t\t\tfor(int v : g[u]){\n\t\t\t\tif(bfs[v]==Integer.MAX_VALUE){\n\t\t\t\t\tbfs[v]= 1 + bfs[u];\n\t\t\t\t\tq.add(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\tBufferedReader in;\n\tPrintWriter out;\n\tStringTokenizer st = new StringTokenizer(\"\");\n\n\tString nextToken() throws IOException {\n\t\twhile (!st.hasMoreTokens())\n\t\t\tst = new StringTokenizer(in.readLine());\n\t\treturn st.nextToken();\n\t}\n\n\tint ni() throws IOException {\n\t\treturn Integer.parseInt(nextToken());\n\t}\n\n\tlong nl() throws IOException {\n\t\treturn Long.parseLong(nextToken());\n\t}\n\n\tdouble nd() throws IOException {\n\t\treturn Double.parseDouble(nextToken());\n\t}\n\n\tint[] nia(int size) throws IOException {\n\t\tint[] ret = new int[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tret[i] = ni();\n\t\treturn ret;\n\t}\n\n\tlong[] nla(int size) throws IOException {\n\t\tlong[] ret = new long[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tret[i] = nl();\n\t\treturn ret;\n\t}\n\n\tdouble[] nda(int size) throws IOException {\n\t\tdouble[] ret = new double[size];\n\t\tfor (int i = 0; i < size; i++)\n\t\t\tret[i] = nd();\n\t\treturn ret;\n\t}\n\n\tString nextLine() throws IOException {\n\t\tst = new StringTokenizer(\"\");\n\t\treturn in.readLine();\n\t}\n\n\tboolean EOF() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString s = in.readLine();\n\t\t\tif (s == null)\n\t\t\t\treturn true;\n\t\t\tst = new StringTokenizer(s);\n\t\t}\n\t\treturn false;\n\t}\n\n\tvoid printRepeat(String s, int count) {\n\t\tfor (int i = 0; i < count; i++)\n\t\t\tout.print(s);\n\t}\n\n\tvoid printArray(int[] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tout.print(' ');\n\t\t\tout.print(array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\n\tvoid printArray(long[] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tout.print(' ');\n\t\t\tout.print(array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\n\tvoid printArray(double[] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tout.print(' ');\n\t\t\tout.print(array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\n\tvoid printArray(double[] array, String spec) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tif (i > 0)\n\t\t\t\tout.print(' ');\n\t\t\tout.printf(Locale.US, spec, array[i]);\n\t\t}\n\t\tout.println();\n\t}\n\n\tvoid printArray(Object[] array) {\n\t\tboolean blank = false;\n\t\tfor (Object x : array) {\n\t\t\tif (blank)\n\t\t\t\tout.print(' ');\n\t\t\telse\n\t\t\t\tblank = true;\n\t\t\tout.print(x);\n\t\t}\n\t\tout.println();\n\t}\n\n\t@SuppressWarnings(\"rawtypes\")\n\tvoid printCollection(Collection collection) {\n\t\tboolean blank = false;\n\t\tfor (Object x : collection) {\n\t\t\tif (blank)\n\t\t\t\tout.print(' ');\n\t\t\telse\n\t\t\t\tblank = true;\n\t\t\tout.print(x);\n\t\t}\n\t\tout.println();\n\t}\n\n\tstatic String memoryStatus() {\n\t\treturn (Runtime.getRuntime().totalMemory()\n\t\t\t\t- Runtime.getRuntime().freeMemory() >> 20)\n\t\t\t\t+ \"/\" + (Runtime.getRuntime().totalMemory() >> 20) + \" MB\";\n\t}\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf120f {\n\n    public static void main(String[] args) throws IOException {\n        __in = new BufferedReader(new FileReader(\"input.txt\"));\n        __out = new PrintWriter(new FileWriter(\"output.txt\"));\n        int n = ri(), ans = 0;\n        for(int i = 0; i < n; ++i) {\n            int sz = rni();\n            List<List<Integer>> g = graph(sz);\n            for(int j = 0; j < sz - 1; ++j) {\n                int u = ni() - 1, v = ni() - 1;\n                connect(g, u, v);\n            }\n            ans += dia(g, 0, -1)[0];\n        }\n        prln(ans);\n        close();\n    }\n\n    static int[] dia(List<List<Integer>> g, int i, int p) {\n        int dia = 0, dep = 0, dep2 = 0;\n        for(int n : g.get(i)) {\n            if(n != p) {\n                int[] e = dia(g, n, i);\n                dia = max(dia, e[0]);\n                if(e[1] + 1 >= dep) {\n                    dep2 = dep;\n                    dep = e[1] + 1;\n                } else if (e[1] + 1 > dep2) {\n                    dep2 = e[1] + 1;\n                }\n            }\n        }\n        // prln(i, dep, dep2);\n        return new int[]{max(dia, dep + dep2), dep};\n    }\n\n    static BufferedReader __in = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __out = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __rand = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e10\n    // LMAX ~= 9e18\n    \n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final int IMIN = -2147483648;\n    static final long LMAX = 9223372036854775807L;\n    static final long LMIN = -9223372036854775808L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if(x.length == 1) return x[0]; if(x.length == 2) return min(x[0], x[1]); if(x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if(x.length == 1) return x[0]; if(x.length == 2) return min(x[0], x[1]); if(x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if(x.length == 1) return x[0]; if(x.length == 2) return max(x[0], x[1]); if(x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if(x.length == 1) return x[0]; if(x.length == 2) return max(x[0], x[1]); if(x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for(int i = 1; i < x.length; ++i) if(x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if(a == 0) return 0; int ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if(a == 0) return 0; long ans = 1; while(b > 0) {if((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int)d;}\n    static int cei(double d) {return (int)ceil(d);}\n    static long fll(double d) {return (long)d;}\n    static long cel(double d) {return (long)ceil(d);}\n    static int gcf(int a, int b) {return b == 0 ? a : gcf(b, a % b);}\n    static long gcf(long a, long b) {return b == 0 ? a : gcf(b, a % b);}\n    static int randInt(int min, int max) {return __rand.nextInt(max - min + 1) + min;}\n    static long hash(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for(int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for(int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for(int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for(int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for(int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for(int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for(int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for(int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static int[] sorted(int[] a) {int[] ans = copy(a); sort(ans); return ans;}\n    static long[] sorted(long[] a) {long[] ans = copy(a); sort(ans); return ans;}\n    static int[] rsorted(int[] a) {int[] ans = copy(a); rsort(ans); return ans;}\n    static long[] rsorted(long[] a) {long[] ans = copy(a); rsort(ans); return ans;}\n    // graph util\n    static List<List<Integer>> graph(int n) {List<List<Integer>> g = new ArrayList<>(); for(int i = 0; i < n; ++i) g.add(new ArrayList<>()); return g;}\n    static List<List<Integer>> graph(List<List<Integer>> g, int m) throws IOException {for(int i = 0; i < m; ++i) connect(g, rni() - 1, ni() - 1); return g;}\n    static List<List<Integer>> graph(int n, int m) throws IOException {return graph(graph(n), m);}\n    static List<List<Integer>> dgraph(List<List<Integer>> g, int m) throws IOException {for(int i = 0; i < m; ++i) connecto(g, rni() - 1, ni() - 1); return g;}\n    static List<List<Integer>> dgraph(List<List<Integer>> g, int n, int m) throws IOException {return dgraph(graph(n), m);}\n    static List<Set<Integer>> sgraph(int n) {List<Set<Integer>> g = new ArrayList<>(); for(int i = 0; i < n; ++i) g.add(new HashSet<>()); return g;}\n    static List<Set<Integer>> sgraph(List<Set<Integer>> g, int m) throws IOException {for(int i = 0; i < m; ++i) connect(g, rni() - 1, ni() - 1); return g;}\n    static List<Set<Integer>> sgraph(int n, int m) throws IOException {return sgraph(sgraph(n), m);}\n    static List<Set<Integer>> dsgraph(List<Set<Integer>> g, int m) throws IOException {for(int i = 0; i < m; ++i) connecto(g, rni() - 1, ni() - 1); return g;}\n    static List<Set<Integer>> dsgraph(List<Set<Integer>> g, int n, int m) throws IOException {return dsgraph(sgraph(n), m);}\n    static void connect(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v); g.get(v).add(u);}\n    static void connecto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).add(v);}\n    static void dconnect(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v); g.get(v).remove(u);}\n    static void dconnecto(List<? extends Collection<Integer>> g, int u, int v) {g.get(u).remove(v);}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(__in.readLine());}\n    static int ri() throws IOException {return Integer.parseInt(__in.readLine());}\n    static long rl() throws IOException {return Long.parseLong(__in.readLine());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Integer.parseInt(input.nextToken()); return a;}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Integer.parseInt(input.nextToken()) - 1; return a;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; input = new StringTokenizer(__in.readLine()); for(int i = 0; i < n; ++i) a[i] = Long.parseLong(input.nextToken()); return a;}\n    static char[] rcha() throws IOException {return __in.readLine().toCharArray();}\n    static String rline() throws IOException {return __in.readLine();}\n    static int rni() throws IOException {input = new StringTokenizer(__in.readLine()); return Integer.parseInt(input.nextToken());}\n    static int ni() {return Integer.parseInt(input.nextToken());}\n    static long rnl() throws IOException {input = new StringTokenizer(__in.readLine()); return Long.parseLong(input.nextToken());}\n    static long nl() {return Long.parseLong(input.nextToken());}\n    // output\n    static void pr(int i) {__out.print(i);}\n    static void prln(int i) {__out.println(i);}\n    static void pr(long l) {__out.print(l);}\n    static void prln(long l) {__out.println(l);}\n    static void pr(double d) {__out.print(d);}\n    static void prln(double d) {__out.println(d);}\n    static void pr(char c) {__out.print(c);}\n    static void prln(char c) {__out.println(c);}\n    static void pr(char[] s) {__out.print(new String(s));}\n    static void prln(char[] s) {__out.println(new String(s));}\n    static void pr(String s) {__out.print(s);}\n    static void prln(String s) {__out.println(s);}\n    static void pr(Object o) {__out.print(o);}\n    static void prln(Object o) {__out.println(o);}\n    static void prln() {__out.println();}\n    static void pryes() {__out.println(\"yes\");}\n    static void pry() {__out.println(\"Yes\");}\n    static void prY() {__out.println(\"YES\");}\n    static void prno() {__out.println(\"no\");}\n    static void prn() {__out.println(\"No\");}\n    static void prN() {__out.println(\"NO\");}\n    static void pryesno(boolean b) {__out.println(b ? \"yes\" : \"no\");};\n    static void pryn(boolean b) {__out.println(b ? \"Yes\" : \"No\");}\n    static void prYN(boolean b) {__out.println(b ? \"YES\" : \"NO\");}\n    static void prln(int... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static void prln(long... a) {for(int i = 0, len = a.length - 1; i < len; __out.print(a[i]), __out.print(' '), ++i); __out.println(a[a.length - 1]);}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for(int i = 0; i < n; __out.print(iter.next()), __out.print(' '), ++i); if(n >= 0) __out.println(iter.next()); else __out.println();}\n    static void h() {__out.println(\"hlfd\");}\n    static void flush() {__out.flush();}\n    static void close() {__out.close();}\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.io.StreamTokenizer;\nimport java.util.ArrayList;\nimport java.util.Arrays;\n\npublic class Main {\n    \n    /////////////////////////////////////////////////////////////////\n    // IO\n    /////////////////////////////////////////////////////////////////\n    private static StreamTokenizer in;\n    private static PrintWriter out;\n    private static BufferedReader inB;\n    \n    private static boolean FILE=true;\n    \n    private static int nextInt() throws Exception{\n        in.nextToken();\n        return (int)in.nval;\n    }\n    \n    private static String nextString() throws Exception{\n        in.nextToken();\n        return in.sval;\n    }\n    \n    static{\n        \n        try {\n            out = new PrintWriter(FILE ? (new FileOutputStream(\"output.txt\")) : System.out);\n            inB = new BufferedReader(new InputStreamReader(FILE ? new FileInputStream(\"input.txt\") : System.in));\n        } catch(Exception e) {e.printStackTrace();}\n        in = new StreamTokenizer(inB);\n    }\n    /////////////////////////////////////////////////////////////////\n    \n\n    \n    public static void main(String[] args)throws Exception {\n        int n = nextInt();\n        \n        int sum = 0;\n        for(int i = 0 ;i<n; i++) {\n            int m = nextInt();\n            boolean[][] gr = new boolean[m][m];\n            \n            for(int j = 0; j<m-1; j++) {\n                int a = nextInt()-1, b = nextInt()-1;\n                gr[a][b] = gr[b][a] = true;\n            }\n            \n            int max = MINF;\n            boolean[] used = new boolean[m];\n            for(int j = 0; j<m; j++) {\n                Arrays.fill(used, false);\n                int cur = dfs(gr, used, j);\n                if(cur > max) {\n                    max = cur;\n                }\n            }\n            sum += (max-1);\n        }\n        println(sum);\n    }\n    \n    private static int dfs(boolean[][] fr, boolean[] used, int j) {\n        if(used[j])return 0;\n        used[j] = true;\n        \n        int max = MINF;\n        for(int i = 0; i<fr.length; i++) {\n            if(!fr[i][j])continue;\n            int cur = dfs(fr, used, i);\n            if(cur > max)max = cur;\n        }\n        if(max == MINF)return 1;\n        return max+1;\n    }\n    \n    /////////////////////////////////////////////////////////////////\n    // pre - written\n    /////////////////////////////////////////////////////////////////\n    private static void println(Object o) throws Exception {\n        out.println(o);\n        out.flush();\n    }\n    private static void exit(Object o) throws Exception {\n        println(o);\n        exit();\n    }\n    private static void exit() {\n        System.exit(0);\n    }\n    private static final int  INF = Integer.MAX_VALUE;\n    private static final int MINF = Integer.MIN_VALUE;\n    //////////////////////////////////////////////////////////////////\n}\n\nclass cl {\n    boolean[][] mas;\n    boolean petr;\n    \n    cl(boolean[][] m, boolean p) {\n        petr = p; mas = m;\n    }\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class F {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n\n    void solve()\n    {\n        int t=ni();\n        long sum=0;\n        while (t-->0){\n            n=ni();\n            l=new ArrayList[n];\n            for (int i = 0; i <n ; i++) {\n                l[i]=new ArrayList<>();\n            }\n            for (int i = 0; i <n-1 ; i++) {\n                int u=ni()-1;\n                int v=ni()-1;\n                l[u].add(v);\n                l[v].add(u);\n            }\n            inside=new int[n];\n            outside=new int[n];\n            dfs(0,-1);\n            dfs2(0,-1);\n            int max=0;\n            for (int i = 0; i <n ; i++) {\n                max=Math.max(max,Math.max(inside[i],outside[i]));\n            }\n            sum+=max;\n        }\n        out.println(sum);\n    }\n\n\n    static void dfs(int u,int par){\n        for(int v:l[u]){\n            if(v==par)continue;\n            dfs(v,u);\n            inside[u]=Math.max(inside[v]+1,inside[u]);\n        }\n    }\n\n    static void dfs2(int u,int par){\n        int mx1=-100000,mx2=-100000;\n        for(int v:l[u]){\n            if(v==par)continue;\n            if(inside[v]>mx1){\n                mx2=mx1;\n                mx1=inside[v];\n            }\n            else if(inside[v]>mx2){\n                mx2=inside[v];\n            }\n        }\n        for(int v:l[u]){\n            if(v==par)continue;\n            int use=mx1;\n            if(use==inside[v])use=mx2;\n            outside[v]=Math.max(1+outside[u],2+use);\n            dfs2(v,u);\n        }\n    }\n\n    static int n,inside[],outside[];\n    static ArrayList<Integer> l[];\n\n\n    int[] farthest(int[][] g, int x)\n    {\n        int n = g.length;\n        int[] q = new int[n];\n        int[] d = new int[n];\n        Arrays.fill(d, 1000000);\n        int p = 0;\n        d[x] = 0;\n        q[p++] = x;\n        for(int i = 0;i < p;i++){\n            int cur = q[i];\n            for(int e : g[cur]){\n                if(d[e] > d[cur] + 1){\n                    d[e] = d[cur] + 1;\n                    q[p++] = e;\n                }\n            }\n        }\n        return new int[]{q[n-1], d[q[n-1]]};\n    }\n\n    static int[][] packU(int n, int[] from, int[] to) {\n        int[][] g = new int[n][];\n        int[] p = new int[n];\n        for(int f : from)\n            p[f]++;\n        for(int t : to)\n            p[t]++;\n        for(int i = 0;i < n;i++)\n            g[i] = new int[p[i]];\n        for(int i = 0;i < from.length;i++){\n            g[from[i]][--p[from[i]]] = to[i];\n            g[to[i]][--p[to[i]]] = from[i];\n        }\n        return g;\n    }\n\n    void run() throws Exception\n    {\n        is = oj ? new FileInputStream(\"input.txt\") : new ByteArrayInputStream(INPUT.getBytes());\n        out = oj ? new PrintWriter(\"output.txt\") : new PrintWriter(System.out);\n\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        tr(System.currentTimeMillis()-s+\"ms\");\n    }\n\n    public static void main(String[] args) throws Exception\n    {\n        new F().run();\n    }\n\n    public int ni()\n    {\n        try {\n            int num = 0;\n            boolean minus = false;\n            while((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n            if(num == '-'){\n                num = 0;\n                minus = true;\n            }else{\n                num -= '0';\n            }\n\n            while(true){\n                int b = is.read();\n                if(b >= '0' && b <= '9'){\n                    num = num * 10 + (b - '0');\n                }else{\n                    return minus ? -num : num;\n                }\n            }\n        } catch (IOException e) {\n        }\n        return -1;\n    }\n\n    public long nl()\n    {\n        try {\n            long num = 0;\n            boolean minus = false;\n            while((num = is.read()) != -1 && !((num >= '0' && num <= '9') || num == '-'));\n            if(num == '-'){\n                num = 0;\n                minus = true;\n            }else{\n                num -= '0';\n            }\n\n            while(true){\n                int b = is.read();\n                if(b >= '0' && b <= '9'){\n                    num = num * 10 + (b - '0');\n                }else{\n                    return minus ? -num : num;\n                }\n            }\n        } catch (IOException e) {\n        }\n        return -1;\n    }\n\n    public String ns()\n    {\n        try{\n            int b = 0;\n            StringBuilder sb = new StringBuilder();\n            while((b = is.read()) != -1 && (b == '\\r' || b == '\\n' || b == ' '));\n            if(b == -1)return \"\";\n            sb.append((char)b);\n            while(true){\n                b = is.read();\n                if(b == -1)return sb.toString();\n                if(b == '\\r' || b == '\\n' || b == ' ')return sb.toString();\n                sb.append((char)b);\n            }\n        } catch (IOException e) {\n        }\n        return \"\";\n    }\n\n    public char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        try{\n            int b = 0, p = 0;\n            while((b = is.read()) != -1 && (b == ' ' || b == '\\r' || b == '\\n'));\n            if(b == -1)return null;\n            buf[p++] = (char)b;\n            while(p < n){\n                b = is.read();\n                if(b == -1 || b == ' ' || b == '\\r' || b == '\\n')break;\n                buf[p++] = (char)b;\n            }\n            return Arrays.copyOf(buf, p);\n        } catch (IOException e) {\n        }\n        return null;\n    }\n\n\n    double nd() { return Double.parseDouble(ns()); }\n    boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n    void tr(Object... o) { if(!oj)System.out.println(Arrays.deepToString(o)); }\n}\n", "label": 3}
{"src": "\nimport java.io.*;\nimport java.math.BigInteger;\nimport static java.math.BigInteger.*;\nimport java.util.*;\n\npublic class ForFile\n  {\n      void solve()throws Exception\n      {\n\n          int res=0;\n          int n=nextInt();\n          for(int step=1;step<=n;step++)\n              res+=doIt();\n          writer.println(res);\n\n      }\n      int doIt()throws Exception\n      {\n          int n=nextInt();\n          int[][]g=new int[n][n];\n          for(int i=0;i<n;i++)\n              for(int j=0;j<n;j++)\n                  if(i!=j)\n                      g[i][j]=Integer.MAX_VALUE/10;\n          for(int i=0;i<n-1;i++)\n          {\n              int a=nextInt()-1;\n              int b=nextInt()-1;\n              g[a][b]=g[b][a]=1;\n          }\n          for(int k=0;k<n;k++)\n              for(int i=0;i<n;i++)\n                  for(int j=0;j<n;j++)\n                      g[i][j]=Math.min(g[i][j],g[i][k]+g[k][j]);\n          int res=0;\n              for(int i=0;i<n;i++)\n                  for(int j=0;j<n;j++)\n                      res=Math.max(res,g[i][j]);\n          return res;\n\n\n\n\n\n      }\n\n\n      ////////////\n    BufferedReader reader;\n    PrintWriter writer;\n    StringTokenizer stk;\n    void run()throws Exception\n    {\n        reader=new BufferedReader(new FileReader(\"input.txt\"));\n        stk=null;\n        writer=new PrintWriter(new BufferedWriter(new FileWriter(\"output.txt\")));\n        solve();\n        reader.close();\n        writer.close();\n    }\n    int nextInt()throws Exception\n    {\n        return Integer.parseInt(nextToken());\n    }\n\n    long nextLong()throws Exception\n    {\n        return Long.parseLong(nextToken());\n\n    }\n    double nextDouble()throws Exception\n    {\n        return Double.parseDouble(nextToken());\n\n\n    }\n\n    String nextString()throws Exception\n    {\n        return nextToken();\n    }\n    String nextLine()throws Exception\n    {\n        return reader.readLine();\n    }\n    String nextToken()throws Exception\n    {\n        if(stk==null || !stk.hasMoreTokens())\n        {\n            stk=new StringTokenizer(nextLine());\n            return nextToken();\n\n        }\n        return stk.nextToken();\n    }\n\n    public static void main(String[]args) throws Exception\n    {\n        new ForFile().run();\n    }\n\n\n\n}", "label": 3}
{"src": "//package CodeForces.DPTree;\n\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\n\npublic class Task120F {\n    FastScanner in;\n    PrintWriter out;\n    static ArrayList<Integer>[] g;\n    static boolean[] used;\n    static int[] dp;\n    static int maxSpider = 0;\n    static void dfs(int v){\n        used[v]=true;\n        ArrayList<Integer> lengths = new ArrayList<>();\n        for(int i = 0; i<g[v].size(); i++){\n            int to = g[v].get(i);\n            if(!used[to]){\n                dfs(to);\n                lengths.add(dp[to]);\n            }\n        }\n        int max = -1;\n        int maxInd = -1;\n        int max2 = -1;\n        for(int i = 0; i<lengths.size(); i++){\n            if(lengths.get(i)>max){\n                max=lengths.get(i);\n                maxInd=i;\n            }\n        }\n        for(int i = 0; i<lengths.size(); i++){\n            if(i!=maxInd && lengths.get(i)>max2){\n                max2=lengths.get(i);\n            }\n        }\n        dp[v]=Math.max(max, max2)+1;\n        maxSpider=Math.max(maxSpider, max+max2+2);\n    }\n\n    public void solve () throws IOException {\n        int m = in.nextInt();\n        int res = 0;\n        for(int i = 0; i<m; i++){\n            int n = in.nextInt();\n            used = new boolean[n];\n            dp = new int[n];\n            g = new ArrayList[n];\n            for(int j = 0; j<n; j++){\n                g[j] = new ArrayList<>();\n            }\n            for(int j = 0; j<n-1; j++){\n                int a = in.nextInt()-1;\n                int b = in.nextInt()-1;\n                g[a].add(b);\n                g[b].add(a);\n            }\n            maxSpider = 0;\n            dfs(0);\n            res+=maxSpider;\n        }\n        out.println(res);\n    }\n\n    public void run () {\n        try {\n            boolean isFile = true;\n            if (isFile) {\n                in = new FastScanner(new File(\"input.txt\"));\n                out = new PrintWriter(new File(\"output.txt\"));\n            } else {\n                in = new FastScanner(System.in);\n                out = new PrintWriter(System.out);\n            }\n            solve();\n\n            out.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        FastScanner(File f) {\n            try {\n                br = new BufferedReader(new FileReader(f));\n            } catch (FileNotFoundException e) {\n                e.printStackTrace();\n            }\n        }\n\n        public FastScanner(InputStream in) {\n            br = new BufferedReader(new InputStreamReader(in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        String nextLine() {\n            try {\n                return br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return \"\";\n        }\n    }\n\n    public static void main (String[]arg){\n        new Task120F().run();\n    }\n}\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.ArrayList;\nimport java.util.Locale;\nimport java.util.StringTokenizer;\n\n\npublic class F {\n    BufferedReader in;\n    StringTokenizer st;\n    PrintWriter out;\n\n    String _token() throws IOException {\n        while (in.ready() && !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    int _int() throws NumberFormatException, IOException {\n        return Integer.parseInt(_token());\n    }\n\n    long _long() throws NumberFormatException, IOException {\n        return Long.parseLong(_token());\n    }\n\n    double _double() throws NumberFormatException, IOException {\n        return Double.parseDouble(_token());\n    }\n\n    void deb(String s) {\n        System.err.println(s);\n    }\n\n    void deb(Object a) {\n        System.err.println(a.toString());\n    }\n\n    void init(boolean FILE, String name) throws NumberFormatException,\n            IOException {\n        Locale.setDefault(Locale.US);\n        if (FILE) {\n            in = new BufferedReader(new FileReader(\"input.txt\"));\n            out = new PrintWriter(\"output.txt\");\n        } else {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n        }\n        st = new StringTokenizer(\"\");\n    }\n\n    ArrayList<Integer> c[];\n    int dist;\n    \n    void go(int x, int prev, int len) {\n        for(int i=0; i<c[x].size(); i++) {\n            if (c[x].get(i) == prev) {\n                continue;\n            }\n            go(c[x].get(i), x, len+1);\n        }\n        if (len > dist) {\n            dist = len;\n        }\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    void mainProgram() throws NumberFormatException, IOException {\n        init(true, \"\");\n        int num=_int();\n        int sum=0;\n        \n        for(int I=0;I<num;I++) {\n            int n = _int();\n            c = new ArrayList[n];\n            for(int i=0;i<n;i++) {\n                c[i] = new ArrayList<Integer>(0);\n            }\n            for(int i=0;i<n-1;i++) {\n                int a = _int()-1;\n                int b = _int()-1;\n                c[a].add(b);\n                c[b].add(a);\n            } \n            \n            int maxdist = 0;\n            for(int x=0;x<n;x++) {\n                dist = 0;\n                go(x,-1,0);\n                maxdist = Math.max(maxdist, dist);\n            }\n            sum += maxdist;\n        }\n        \n        out.println(sum);\n        out.close();\n    }\n\n    public static void main(String[] args) throws NumberFormatException,\n            IOException {\n        long T = System.currentTimeMillis();\n        new F().mainProgram();\n        System.err.println(\"Time of working: \"\n                + (System.currentTimeMillis() - T) + \" ms\");\n    }\n\n    BigInteger add(BigInteger A, BigInteger B) {\n        return A.add(B);\n    }\n\n    BigInteger mult(BigInteger A, BigInteger B) {\n        return A.multiply(B);\n    }\n\n    BigInteger sub(BigInteger A, BigInteger B) {\n        return A.subtract(B);\n    }\n\n    BigInteger div(BigInteger A, BigInteger B) {\n        return A.divide(B);\n    }\n\n    BigInteger mi(BigInteger A) {\n        return (BigInteger.ZERO).subtract(A);\n    }\n\n    BigInteger sq(BigInteger A) {\n        return A.multiply(A);\n    }\n\n    BigInteger val(long a) {\n        return BigInteger.valueOf(a);\n    }\n\n    int cmp(BigInteger a, BigInteger b) {\n        return a.compareTo(b);\n    }\n\n}\n", "label": 3}
{"src": "import java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class WorkFile {\n    public static int dfs(ArrayList<Integer>[] graph, int prev, int item) {\n        int max = 0;\n        for (int elem:graph[item]) {\n            if (elem!=prev) {\n                max = Math.max(max, dfs(graph, item, elem)+1);\n            }\n        }\n        return max;\n    }\n    public static void main(String[] args) throws IOException {\n        FileReader reader = new FileReader(\"input.txt\");\n        Scanner s = new Scanner(reader);\n        int spiders = s.nextInt();\n        int result = 0;\n        while (spiders-->0) {\n            int n = s.nextInt();\n            ArrayList[] graph = new ArrayList[n];\n            for (int i=0; i<n; i++) {\n                graph[i] = new ArrayList<Integer>();\n            }\n            for (int i=1; i<n; i++) {\n                int x = s.nextInt()-1, y = s.nextInt()-1;\n                graph[x].add(y);\n                graph[y].add(x);\n            }\n            int res = 0;\n            for (int i=0; i<n; i++) {\n                if (graph[i].size()==1) {\n                    res = Math.max(res, dfs(graph, -1, i));\n                }\n            }\n            result+=res;\n        }\n        FileWriter writer = new FileWriter(\"output.txt\");\n        writer.write(Integer.toString(result));\n        reader.close();\n        writer.close();\n    }\n}", "label": 3}
{"src": "import java.util.Scanner;\n\npublic class A\n{\n    public static void main(String[] args)\n    {\n        Scanner scnr = new Scanner(System.in);\n        int numCities = scnr.nextInt();\n        int tankCapacity = scnr.nextInt();\n        int gasAmount = 0;\n        int cost = 0;\n        int refill = 0;\n        for(int i = 1; i <= numCities; i++)\n        {\n            if(gasAmount < numCities - i)\n            {\n                if(numCities - i < tankCapacity)\n                {\n                    refill = numCities - i;\n                }\n                else\n                {\n                    refill = tankCapacity - gasAmount;\n                }\n                gasAmount += refill;\n                cost += refill * i;\n            }            \n            gasAmount--;\n        }\n        System.out.println(cost);\n    }\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Question1113A {\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int v=sc.nextInt();\n        if(v>n){\n            System.out.println(n-1);\n        }\n        else {\n            int sum=n-v;\n            int result=(((sum*(sum+1))/2)-1)+v;\n            System.out.println(result);\n\n        }\n\n    }\n}\n", "label": 1}
{"src": "import java.util.*;\npublic class Solution{\n    public static void main(String[] args){\n        Scanner s=new Scanner(System.in);\n        int n=s.nextInt();\n        int v=s.nextInt();\n        int count=v;\n        if(v<n-1){\n            for(int i=2;i<=n;i++){\n                    count=count+i*1;\n                    if(n-i==v)\n                        break;\n                    \n                }\n            \n        }\n        else if(v==n-1){\n            count=v;\n        }\n        else{\n            n=n-1;\n            count=Math.min(n,v);\n        }\n        System.out.println(count);\n    }\n}\n   \n", "label": 1}
{"src": "import java.util.*; \nimport java.lang.*;\nimport java.io.*;\npublic class Main \n{ \n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    } \n    static FastReader s=new FastReader();\n  \n    public static void main(String[] args) \n    { \n        int n = s.nextInt();\n        int v = s.nextInt();\n        int len = n-v;\n        int result = (v-1)+ (((len+1)*len)/2);\n        if(v<n){\n            System.out.println(result);\n        }\n        else{\n            System.out.println(n-1);\n        }\n    } \n}", "label": 1}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Ideone\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint v=sc.nextInt();\n\t\tif(n-1<=v)\n\t\t{\n\t\t\tSystem.out.println(n-1);\n\t\t\treturn;\n\t\t}\n\t\tlong cost=v-1;\n\t\tfor(int i=1;i<=n-v;i++)\n\t\t\tcost+=i;\n\t\tSystem.out.println(cost);\n\t}\n}", "label": 1}
{"src": "import java.io.*;\n\nimport java.util.*;\n\n\npublic class timepass {\n\n\tpublic static void main(String args[] ) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tint n = Integer.parseInt(st.nextToken())-1;\n\t\tint v = Integer.parseInt(st.nextToken());\n\t\t\n\t\tif(n <= v) System.out.println(n);\n\t\telse{\n\t\t\tint curr = v;\n\t\t\tint req = n-v;\n\t\t\tint i = 2;\n\t\t\t//System.out.println(req + \" \" + curr);\n\t\t\twhile(req > 0){\n\t\t\t\t//System.out.println(\"Mahin\");\n\t\t\t\tcurr+=i;\n\t\t\t\ti++;\n\t\t\t\treq--;\n\t\t\t}\n\t\t\tSystem.out.println(curr);\n\t\t}\n\t}\n\t\n\t\n}\n\n", "label": 1}
{"src": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner( System.in );\n\t\tint n = input.nextInt();\n\t\tint v = input.nextInt();\n\t\tif(v >= n) {\n\t\t\tSystem.out.println(n-1);\n\t\t}else {\n\t\t\tint i = 2;\n\t\t\tint s = v;\n\t\t\twhile(v < n-1) {\n\t\t\t\ts += i;\n\t\t\t\ti++;\n\t\t\t\tv++;\n\t\t\t}\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}", "label": 1}
{"src": "import java.util.*;\n\npublic class codeforces {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n=sc.nextInt();\n        int v=sc.nextInt();\n        System.out.println(solve(n,v));\n        \n\n        \n\n\n    }\n    static int  solve(int n,int v){\n        if(v>=n)return n-1;\n        int cost=1*v;\n        int i=2;\n        while(i+v<=n){\n            cost+=i;\n            i++;\n        }\n\n        return cost;\n\n        \n    }  \n}\n\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class SashaandHisTrip_1113A {\n\tpublic static void main(String[] args) {\n\t\tScanner input = new Scanner(System.in);\n\t\tint n = input.nextInt(), v = input.nextInt();\n\t\tint sum = Math.min(v, n - 1);\n\t\tfor (int i = 2; i <= n - v; i++)\n\t\t\tsum += i;\n\t\tSystem.out.println(sum);\n\t\tinput.close();\n\t}\n}\n", "label": 1}
{"src": "\nimport java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class A implements Runnable {\n\tFastReader scn;\n\tPrintWriter out;\n\tString INPUT =\"5 6\";\n\t\n\n\tvoid solve(){\n\t\t int n = scn.nextInt();\n\t        int v = scn.nextInt();\n\t        int res = v;\n\t        \n\t        int temp = n-v;\n\t        temp--;\n\t        if(temp<=0) {\n\t        \tout.println(n-1);\n\t        \treturn;\n\t        }\n\t        \n\t        int i=2;\n\t        \n\t        while(temp>0)\n\t        {\n\t        \t\n\t\t\t\tres=res+i;\n\t\t\t\ti++;\n\t\t\t\ttemp--;\n\t        }\n\t       \tout.println(res);\n\t}\n\n\t\n\t\n\tint[][] packU(int n, int[] from, int[] to) {\n\t\tint[][] g = new int[n][];\n\t\tint[] p = new int[n];\n\t\tfor (int f : from)\n\t\t\tp[f]++;\n\t\tfor (int t : to)\n\t\t\tp[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tg[i] = new int[p[i]];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\tg[from[i]][--p[from[i]]] = to[i];\n\t\t\tg[to[i]][--p[to[i]]] = from[i];\n\t\t}\n\t\treturn g;\n\t}\n\n\t\n\tpublic void run() {\n\t\tlong time = System.currentTimeMillis();\n\t\tboolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\t\tout = new PrintWriter(System.out);\n\t\tscn = new FastReader(oj);\n\t\tsolve();\n\t\tout.flush();\n\t\tif (!oj) {\n\t\t\tSystem.out.println(Arrays.deepToString(new Object[] { System.currentTimeMillis() - time + \" ms\" }));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Thread(null, new A(), \"Main\", 1 << 26).start();\n\t}\n\n\tclass FastReader {\n\t\tInputStream is;\n\n\t\tpublic FastReader(boolean onlineJudge) {\n\t\t\tis = onlineJudge ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\t}\n\n\t\tbyte[] inbuf = new byte[1024];\n\t\tpublic int lenbuf = 0, ptrbuf = 0;\n\n\t\tint readByte() {\n\t\t\tif (lenbuf == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (ptrbuf >= lenbuf) {\n\t\t\t\tptrbuf = 0;\n\t\t\t\ttry {\n\t\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (lenbuf <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn inbuf[ptrbuf++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn !(c >= 33 && c <= 126);\n\t\t}\n\n\t\tint skip() {\n\t\t\tint b;\n\t\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t\t;\n\t\t\treturn b;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tchar nextChar() {\n\t\t\treturn (char) skip();\n\t\t}\n\n\t\tString next() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint b = skip();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\twhile ((!isSpaceChar(b) || b == ' ')) { // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tchar[] next(int n) {\n\t\t\tchar[] buf = new char[n];\n\t\t\tint b = skip(), p = 0;\n\t\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\t\tbuf[p++] = (char) b;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t\t}\n\n\t\tint nextInt() {\n\t\t\tint num = 0, b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tlong num = 0;\n\t\t\tint b;\n\t\t\tboolean minus = false;\n\t\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t\t;\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\n\t\t\twhile (true) {\n\t\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t\t} else {\n\t\t\t\t\treturn minus ? -num : num;\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tchar[][] nextMatrix(int n, int m) {\n\t\t\tchar[][] map = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tmap[i] = next(m);\n\t\t\treturn map;\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tvoid printArray(long[] k)\n\t\t{\n\t\t\tfor(int i =0;i<k.length;i++)\n\t\t\t\tout.print(k[i]);\n\t\t}\n\t\tArrayList<Integer> nArray(int n) {\n\t\t\tArrayList<Integer> a = new ArrayList<>();\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta.add(nextInt());\n\t\t\t\n\t\t\treturn a;\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] a = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextLong();\n\t\t\treturn a;\n\t\t}\n\n\t\tint[][] next2DInt(int n, int m) {\n\t\t\tint[][] arr = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tlong[][] next2DLong(int n, int m) {\n\t\t\tlong[][] arr = new long[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLongArray(m);\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] shuffle(int[] arr) {\n\t\t\tRandom r = new Random();\n\t\t\tfor (int i = 1, j; i < arr.length; i++) {\n\t\t\t\tj = r.nextInt(i);\n\t\t\t\tarr[i] = arr[i] ^ arr[j];\n\t\t\t\tarr[j] = arr[i] ^ arr[j];\n\t\t\t\tarr[i] = arr[i] ^ arr[j];\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t\tint[] uniq(int[] arr) {\n\t\t\tArrays.sort(arr);\n\t\t\tint[] rv = new int[arr.length];\n\t\t\tint pos = 0;\n\t\t\trv[pos++] = arr[0];\n\t\t\tfor (int i = 1; i < arr.length; i++) {\n\t\t\t\tif (arr[i] != arr[i - 1]) {\n\t\t\t\t\trv[pos++] = arr[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn Arrays.copyOf(rv, pos);\n\t\t}\n\t}\n}", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int v = sc.nextInt();\n        int ans;\n        if (n - 1<= v) {\n            ans = Math.min(n - 1, v);\n        } else {\n            int pos = 1;\n            ans = v;\n            while (pos + 1 != n) {\n                if (n - pos <= v) {\n                    break;\n                } else {\n                    ++pos;\n                    ans += pos;\n                }\n            }\n        }\n        System.out.println(ans);\n    }\n}", "label": 1}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\n/**\n *\n * @author Saju\n *\n */\n\npublic class Main {\n\n    private static int dx[] = { 1, 0, -1, 0 };\n    private static int dy[] = { 0, -1, 0, 1 };\n\n    private static final long INF = (long) Math.pow(10, 16);\n    private static final int INT_INF = Integer.MAX_VALUE;\n    private static final long NEG_INF = Long.MIN_VALUE;\n    private static final int NEG_INT_INF = Integer.MIN_VALUE;\n    private static final double EPSILON = 1e-10;\n\n    private static final long MAX = (long) 1e12;\n    \n    private static final long MOD = 1000000007;\n\n    private static final int MAXN = 200001;\n    private static final int MAXA = 1000007;\n    private static final int MAXLOG = 22;\n    private static final double PI = Math.acos(-1);\n    \n\tpublic static void main(String[] args) throws IOException {\n\n\t\tInputReader in = new InputReader(System.in);\n//\t\tScanner in = new Scanner(System.in);\n\t\tPrintWriter out = new PrintWriter(System.out);\n\n//         InputReader in = new InputReader(new FileInputStream(\"src/test.in\"));\n//         PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(\"src/test.out\")));\n\n\t\t\n\t\t\n/*\n\n\n\n\n*/\t\t\n\t\t\n\t\tint n = in.nextInt();\n\t\tint v = in.nextInt();\n\t\t\n\t\tif(v >= n) {\n\t\t\tout.println(n - 1);\n\t\t}\n\t\telse {\n\t\t\tint sum = v;\n\t\t\tfor(int i = 2; i <= n - v; i++) {\n\t\t\t\tsum += i;\n\t\t\t}\n\t\t\tout.println(sum);\n\t\t}\n\t\t\n\t\t\n\t\tin.close();\n\t\tout.flush();\n\t\tout.close();\n\t\tSystem.exit(0);\n\t}\n\t\n\n\t/*\n\t * return the number of elements in list that are less than or equal to the val\n\t */\n\tprivate static long upperBound(List<Long> list, long val) {\n\t\tint start = 0;\n\t\tint len = list.size();\n\t\tint end = len - 1;\n\t\tint mid = 0;\n\n\t\twhile (true) {\n\t\t\tif (start > end) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmid = (start + end) / 2;\n\t\t\tlong v = list.get(mid);\n\t\t\tif (v == val) {\n\t\t\t\tstart = mid;\n\t\t\t\twhile(start < end) {\n\t\t\t\t\tmid = (start + end) / 2;\n\t\t\t\t\tif(list.get(mid) == val) {\n\t\t\t\t\t\tif(mid + 1 < len && list.get(mid + 1) == val) {\n\t\t\t\t\t\t\tstart = mid + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\treturn mid + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tend = mid - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn start + 1;\n\t\t\t}\n\t\t\tif (v > val) {\n\t\t\t\tend = mid - 1;\n\t\t\t} else {\n\t\t\t\tstart = mid + 1;\n\t\t\t}\n\t\t}\n\t\tif (list.get(mid) < val) {\n\t\t\treturn mid + 1;\n\t\t}\n\t\treturn mid;\n\t}\n\n\n\tprivate static boolean isPalindrome(String str) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tsb.append(str);\n\t\tString str1 = sb.reverse().toString();\n\t\treturn str.equals(str1);\n\t}\n\n\tprivate static String getBinaryStr(long n, int j) {\n\t\tString str = Long.toBinaryString(n);\n\t\tint k = str.length();\n\t\tfor (int i = 1; i <= j - k; i++) {\n\t\t\tstr = \"0\" + str;\n\t\t}\n\n\t\treturn str;\n\t}\n\t\n\tprivate static long modInverse(long r) {\n\t\treturn bigMod(r, MOD - 2, MOD);\n\t}\n\t\n\tprivate static long bigMod(long n, long k, long m) {\n\n        long ans = 1;\n        while (k > 0) {\n            if ((k & 1) == 1) {\n                ans = (ans * n) % m;\n            }\n            n = (n * n) % m;\n            k >>= 1;\n        }\n        return ans;\n    }\n    \n\tprivate static long ceil(long n, long x) {\n\t\tlong div = n / x;\n        if(div * x != n) {\n            div++;\n        }\n        return div;\n\t}\n\t\n    private static int ceil(int n, int x) {\n        int div = n / x;\n        if(div * x != n) {\n            div++;\n        }\n        return div;\n    }\n\n    \n    private static int abs(int x) {\n        if (x < 0) {\n            return -x;\n        }\n        return x;\n    }\n    \n    private static double abs(double x) {\n        if (x < 0) {\n            return -x;\n        }\n        return x;\n    }\n\n    private static long abs(long x) {\n        if(x < 0) {\n            return -x;\n        }\n        return x;\n    }\n    \n    private static long lcm(long a, long b) {\n        return (a * b) / gcd(a, b);\n    }\n\n    private static int lcm(int a, int b) {\n        return (a * b) / gcd(a, b);\n    }\n\n    private static int gcd(int a, int b) {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n    \n    private static long gcd(long a, long b) {\n        if (a == 0)\n            return b;\n        return gcd(b % a, a);\n    }\n\n    private static int log(long x, int base) {\n        return (int) (Math.log(x) / Math.log(base));\n    }\n\n    private static int log(long x, long base) {\n        return (int) (Math.log(x) / Math.log(base));\n    }\n    \n    private static long min(long a, long b) {\n        if (a < b) {\n            return a;\n        }\n        return b;\n    }\n\n    private static int min(int a, int b) {\n        if (a < b) {\n            return a;\n        }\n        return b;\n    }\n\n    private static long max(long a, long b) {\n        if (a < b) {\n            return b;\n        }\n        return a;\n    }\n\n    private static int max(int a, int b) {\n        if (a < b) {\n            return b;\n        }\n        return a;\n    }\n\n    private static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n            tokenizer = null;\n        }\n\n        public String next() {\n            try {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(reader.readLine());\n\n                }\n            } catch (IOException e) {\n                return null;\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextLine() {\n            String line = null;\n            try {\n                tokenizer = null;\n                line = reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return line;\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public boolean hasNext() {\n            try {\n                while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                }\n            } catch (Exception e) {\n                return false;\n            }\n            return true;\n        }\n        \n        public int[] nextIntArr(int n) {\n        \tint arr[] = new int[n];\n    \t\tfor(int i = 0; i < n; i++) {\n    \t\t\tarr[i] = nextInt();\n    \t\t}\n    \t\treturn arr;\n        }\n        \n        public long[] nextLongArr(int n) {\n        \tlong arr[] = new long[n];\n    \t\tfor(int i = 0; i < n; i++) {\n    \t\t\tarr[i] = nextLong();\n    \t\t}\n    \t\treturn arr;\n        }\n        \n        public int[] nextIntArr1(int n) {\n        \tint arr[] = new int[n + 1];\n    \t\tfor(int i = 1; i <= n; i++) {\n    \t\t\tarr[i] = nextInt();\n    \t\t}\n    \t\treturn arr;\n        }\n        \n        public long[] nextLongArr1(int n) {\n        \tlong arr[] = new long[n + 1];\n    \t\tfor(int i = 1; i <= n; i++) {\n    \t\t\tarr[i] = nextLong();\n    \t\t}\n    \t\treturn arr;\n        }\n       \n        public void close() {\n        \ttry {\n        \t\tif(reader != null) {\n        \t\t\treader.close();\n        \t\t}\n        \t}\n        \tcatch(Exception e) {\n        \t\t\n        \t}\n        \t\n        \t\n        }\n    }\n\n}", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class A1113 {\n    public static Scanner input=new Scanner(System.in);\n\n    public static void main(String[] args) {\n        int n=input.nextInt();\n        int v=input.nextInt();\n        int cost=0;\n        int tank=0;\n        if(n>v){\n            cost=v;\n            tank=v-1;\n            for(int i=2;i<=n;++i,tank--){\n                if(tank<(n-i)){\n                    cost+=i;\n                    tank++;\n                }\n\n            }\n            System.out.println(cost);\n            return;\n        }else{\n            cost=n-1;\n        }\n        System.out.println(cost);\n    }\n}", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Aprilfool {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int n, v, v1;\n        double v3;\n        n = input.nextInt();\n        v = input.nextInt();\n        if (n > v) {\n            v1 = n - v;\n            double v2 = (v1 / 2.0) * (v1 + 1);\n            v3 = v + v2 - 1;\n            System.out.printf(\"%.0f\\n\", v3);\n        } else {\n            System.out.println(n - 1);\n        }\n\n    }\n\n}", "label": 1}
{"src": "\timport java.util.*;\n\tpublic class cars {\n\t\tpublic static void main(String args[])\n\t\t{\n\t\t\tScanner sc=new Scanner(System.in);\n\t\t\tint n=sc.nextInt();\n\t\t\tint v=sc.nextInt();\n\t\t\tint cur=0;\n\t\t\tint cost=0;\n\t\t\tfor(int i=1;i<n;i++)\n\t\t\t{\n\t\t\t\tcur--;\n\t\t\t\tif(i==1)\n\t\t\t\t\t{\n\t\t\t\t\t\tcur=Math.min(n-1, v);\n\t\t\t\t\t\tcost=cur;\n\t\t\t\t\t}\n\t\t\t\telse if(n-cur-i>0) {\n\t\t\t\t\tcur++;\n\t\t\t\t\tcost+=i;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\tSystem.out.println(cost);\n\t\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n", "label": 1}
{"src": "import java.util.*;\nimport java.util.Arrays;\npublic class Main\n{\n    public static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int v=sc.nextInt();\n        if(n-1<=v)\n        {\n            System.out.println(n-1);\n        }\n        else\n        {\n            int result=v-1;\n            for(int i=1;i<=n-v;i++)\n            {\n                result=result+i;\n            }\n            System.out.println(result);\n        }\n        \n    }\n}", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class SashaAndrip1113A {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        \n        int n = scan.nextInt();\n        int v = scan.nextInt();\n        \n        if(n <= v || n == v + 1){\n            System.out.println(n-1);\n            return;\n        }\n        \n        int amount = v; \n        int pos = 1;\n        for(int i = 2; i < n; i++){\n            if(pos + v != n){\n                amount += i;\n                pos++;\n            }\n            else break;\n        }\n        \n        System.out.println(amount);\n    }\n}", "label": 1}
{"src": "/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\n \npublic class Codechef\n{\n  \n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t   Scanner z=new Scanner(System.in);\n\t   int n=z.nextInt();\n\t   int v=z.nextInt();\n\t   int ans=0;\n\t   int f=0;\n\t   for(int i=1;i<n;i++)\n\t   {\n\t       if((n-i)>(f))\n\t       {\n\t           int diff=(n-i)-f;\n\t           if((diff+f)>v)\n\t           {\n\t               int bb=v-f;\n\t               ans+=(i*bb);\n\t               f+=bb;\n\t           }\n\t           else\n\t           {\n\t               int bb=diff;\n\t               ans+=(bb*i);\n\t               f+=bb;\n\t           }\n\t           f--;\n\t       }\n\t       //System.out.println(ans);\n\t   }\n\t   System.out.println(ans);\n\t\n\t}\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int n = in.nextInt();\n        int v = in.nextInt();\n        if (n - v > 1) {\n            int sum = v;\n            for (int i = 2; i <= n - v; i++) {\n                sum += i;\n            }\n            System.out.println(sum);\n        } else {\n            System.out.println(n - 1);\n        }\n    }\n}\n", "label": 1}
{"src": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n//        int n = sc.nextInt();\n//        int v = sc.nextInt();\n        String[] s = sc.nextLine().split(\" \");\n        int n = Integer.parseInt(s[0]);\n        int v = Integer.parseInt(s[1]);\n        int p = 2,i=0,c=n,j=1;\n        long sum = 0;\n        if(n<=v){\n            System.out.println(n-1);\n            System.exit(0);\n        }\n        for(i=1;i<=n;i++){\n            if(i==1){\n                int x = Integer.min(n,v);\n                sum+=x;\n                i+=x;\n            }\n            else {\n                sum+=p;\n                p++;\n            }\n        }\n        System.out.println(sum);\n    }\n}\n", "label": 1}
{"src": "import java.awt.font.FontRenderContext;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Stuff  {\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc=new Scanner(System.in);\n\n        try {\n            int n = sc.nextInt();\n            int v = sc.nextInt();\n            if (v > n) {\n                System.out.println(n - 1);\n                System.exit(0);\n            }\n            if (v == n) {\n                System.out.println(n - 1);\n                System.exit(0);\n            } else {\n                int d, a;\n                d = n - 1 - v;\n                a = v;\n                for (int i = 1; i <= d; i++)\n                    a += i + 1;\n                System.out.println(a);\n            }\n\n            } catch(Exception e){\n                System.out.println(e);\n            }\n    }\n\n}\n", "label": 1}
{"src": "import java.util.*;\npublic class ProblemA {\n    public static void main(String[] argc)\n    {\n        Scanner sc = new Scanner(System.in);\n        int n, v;\n        n = sc.nextInt();\n        v = sc.nextInt();\n        int status = 1;\n        int cost = 0;\n        int avail_gas = 0;\n        int avail_v = v;\n        while(status < n)\n        {\n            if(avail_gas >= (n - status))\n                break;\n\n            // Add gas in one station\n            int add_gas = Math.min((n-status), avail_v);\n            avail_gas += add_gas;\n            avail_v -= add_gas;\n            cost += status * add_gas;\n\n            // Drive to next station\n            status++;\n            avail_gas -= 1;\n            avail_v += 1;\n        }\n        System.out.println(cost);\n    }\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Sasha {\n\n\tpublic static void main(String args[])\n\t{\n\t\tScanner s = new Scanner(System.in);\n\t\tint n, v;\n\t\t\n\t\tn = s.nextInt();\n\t\t\n\t\tv = s.nextInt();\n\t\t\n\t\tif (v>=n-1)\n\t\t\tSystem.out.println(n-1);\n\t\telse\n\t\t{\n\t\t\tn = n-v+1;\n\t\t\tint cost = v +((n*(n-1))/2)-1;\n\t\t\tSystem.out.println(cost);\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n}\n", "label": 1}
{"src": "import java.util.*;\n\npublic class Solution{\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int n = sc.nextInt();\n        int v = sc.nextInt();\n        int max = 0;\n        int res = v- 1;\n\n        if(n - 1 <= v){\n            System.out.println(n - 1);\n        }\n        \n        \n        for(int i=1;i<=n-v;i++){\n            res += i;\n        }\n\n        if(n - 1 > v){\n            System.out.println(res);    \n        }\n\n        \n\n    }\n}", "label": 1}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\nimport java.awt.geom.*;\n\nimport static java.lang.Math.*;\n\npublic class Solution implements Runnable {\n\tint min=(int)1e9;\n\tint dp[];\n    public void solve() throws Exception {\n//        int t=sc.nextInt();\n//        for(int ii=1;ii<=t;ii++)\n//        {\n        \t//System.out.print(\"Case #\"+ii+\": \");\n    \tint n=sc.nextInt();\n    \tint k=sc.nextInt();\n    \tint result=0;\n    \t\n    \tif(k>=n-1)\n    \t\tresult=n-1;\n    \telse\n    \t{\n    \t\tresult+=k;\n    \t\tn-=k;\n    \t\tn--;\n    \t\tfor(int i=0;i<n;i++)\n    \t\t{\n    \t\t\tresult+=i+2;\n    \t\t}\n    \t}\n    \tout.println(result);\n    \t\n//        }\n    }\n    \t\n\n    static Throwable uncaught;\n\n    BufferedReader in;\n    FastScanner sc;\n    PrintWriter out;\n\n    @Override\n    public void run() {\n        try {\n            in = new BufferedReader(new InputStreamReader(System.in));\n            out = new PrintWriter(System.out);\n            sc = new FastScanner(in);\n            solve();\n        } catch (Throwable uncaught) {\n            Solution.uncaught = uncaught;\n        } finally {\n            out.close();\n        }\n    }\n\n    public static void main(String[] args) throws Throwable {\n        Thread thread = new Thread(null, new Solution(), \"\", (1 << 26));\n        thread.start();\n        thread.join();\n        if (Solution.uncaught != null) {\n            throw Solution.uncaught;\n        }\n    }\n\n}\n\nclass FastScanner {\n\n    BufferedReader in;\n    StringTokenizer st;\n\n    public FastScanner(BufferedReader in) {\n        this.in = in;\n    }\n\n    public String nextToken() throws Exception {\n        while (st == null || !st.hasMoreTokens()) {\n            st = new StringTokenizer(in.readLine());\n        }\n        return st.nextToken();\n    }\n\n    public int nextInt() throws Exception {\n        return Integer.parseInt(nextToken());\n    }\n\n    public long nextLong() throws Exception {\n        return Long.parseLong(nextToken());\n    }\n\n    public double nextDouble() throws Exception {\n        return Double.parseDouble(nextToken());\n    }\n\n}", "label": 1}
{"src": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class p1113_A {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        int n = in.nextInt();\n        int v= in.nextInt();\n        System.out.println(process(n,v));\n    }\n    private static int process(int n, int v) {\n        if(v>=n-1)\n            return n-1;\n        int ul=n-v;\n        int sum=((ul*(ul+1))/2) + v-1;\n        return sum;\n\n    }\n}\n", "label": 1}
{"src": "import java.io.PrintWriter;\nimport java.lang.reflect.Array;\nimport java.util.*;\nimport java.util.Scanner;\npublic class Solution {\n    static Scanner sc = new Scanner(System.in);\n    static PrintWriter pw = new PrintWriter(System.out);\n    public static void solve(int c, int n, int v){\n        int curr = 1;\n        int sum = Math.min(v, n - curr);\n        int tank = Math.min(v, n - curr);\n        while (curr != n){\n            if (curr + tank < n && tank < v){\n                sum += curr * (v - tank);\n                tank = v;\n            }\n            curr += 1;\n            tank -= 1;\n        }\n        System.out.println(sum);\n    }\n\n    public static void main(String[] args) {\n        int t = 1;\n        for (int i = 0; i < t; i ++){\n            int n = sc.nextInt();\n            int v = sc.nextInt();\n            solve(i + 1, n, v);\n        }\n        pw.close();\n    }\n}\n\n\n\n\n\n\n\n\n\n\n//    public static void floodfill(char[][] arr, boolean[][] visited, int row, int col){\n//        visited[row][col] = true;\n//        if (row != 0){\n//            if (arr[row - 1][col] == '#' && !visited[row - 1][col]){\n//                floodfill(arr, visited, row - 1, col);\n//                visited[row - 1][col] = true;\n//            }\n//        }\n//        if (row != arr.length - 1){\n//            if (arr[row + 1][col] == '#' && !visited[row + 1][col]){\n//                floodfill(arr, visited, row + 1, col);\n//                visited[row + 1][col] = true;\n//            }\n//        }\n//        if (col != 0){\n//            if (arr[row][col - 1] == '#' && !visited[row][col - 1]){\n//                floodfill(arr, visited, row, col - 1);\n//                visited[row][col - 1] = true;\n//            }\n//        }\n//        if (col != arr[0].length - 1){\n//            if (arr[row][col + 1] == '#' && !visited[row][col + 1]){\n//                floodfill(arr, visited, row, col + 1);\n//                visited[row][col + 1] = true;\n//            }\n//        }\n//    }\n", "label": 1}
{"src": "\n\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class program {\n    public static FastIO file = new FastIO();\n\n    private static void solve() {\n//        int tt = nextInt();\n        int tt = 1;\n        long start = 0;\n        while (tt-- > 0) {\n            int n = nextInt(), v = nextInt();\n            int needed = n - 1;\n            int ans = Math.min(needed, v);\n            needed -=ans;\n            for (int i = 0; i < needed; i++) {\n                ans+=i+2;\n            }\n            System.out.println(ans);\n        }\n    }\n\n    private static void swap(int[] a, int i, int j) {\n        int temp = a[i];\n        a[i] = a[j];\n        a[j] = temp;\n    }\n\n    private static int[] nextArray(int n) {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = nextInt();\n        return a;\n    }\n\n    public static int[][] nextArray2D(int n, int m) {\n        int[][] result = new int[n][];\n        for (int i = 0; i < n; i++) {\n            result[i] = nextArray(m);\n        }\n        return result;\n    }\n\n    public static long pow(long n, long p) {\n        long ret = 1L;\n        while (p > 0) {\n            if (p % 2 != 0L)\n                ret *= n;\n            n *= n;\n            p >>= 1L;\n        }\n        return ret;\n    }\n\n    public static String next() {\n        return file.next();\n    }\n\n    public static int nextInt() {\n        return file.nextInt();\n    }\n\n    public static long nextLong() {\n        return file.nextLong();\n    }\n\n    public static double nextDouble() {\n        return file.nextDouble();\n    }\n\n    public static String nextLine() {\n        return file.nextLine();\n    }\n\n    public static class FastIO {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastIO() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n\n    public static void main(String[] args) {\n        solve();\n    }\n\n\n}", "label": 1}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class SashaTrip\n{\n\n    public static void main(String[] args)throws IOException\n    {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(br.readLine().trim());\n        int n=Integer.parseInt(st.nextToken());\n        int v=Integer.parseInt(st.nextToken());\n        int req=n-1;\n        if(req<=v)\n            System.out.println(req);\n        else\n            System.out.println((2*v+(n-v+1)*(n-v)-2)/2);\n\n    }\n}", "label": 1}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Solution\n{\n    public static void main(String args[])throws IOException\n    {\n       Scanner sc=new Scanner(System.in);\n       int n=sc.nextInt();\n       int v=sc.nextInt();\n       int s=0;\n      if(v>=(n-1))\n       {\n          System.out.println(n-1);\n          return;\n       }\n       s=s+v;\n       int k=v;\n       v=v-1;\n       for(int i=2;i<n;i++)\n       {\n           \n           if(n-i>v)\n           {\n           s=s+i;\n           v=v+1;\n           }\n           v=v-1;\n       }\n       System.out.println(s);\n   \n    }\n}", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class que3 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scn = new Scanner(System.in);\n\t\tint n = scn.nextInt();\n\t\tint v = scn.nextInt();\n\t\tif(v>=(n-1)){\n\t\t\tSystem.out.println(Math.min(n-1,v ));\n\t\t}else{\n\t\tint x = n - v;\n\t\tlong ans = v;\n\t\tfor (int i = 2; i <= x; i++) {\n\t\t\tans += i;\n\t\t}\n\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n}\n", "label": 1}
{"src": "import java.util.*;\npublic class noone {\n    public static void main(String[] args) {\n\n        Scanner sc = new Scanner(System.in);\n\n\n        int n = sc.nextInt();\n\n        int v = sc.nextInt();\n\n        long ans = 0;\n\n        if(n <= v)\n            ans = n-1;\n        else {\n            ans = v;\n            int dist = n-1;\n            for (int i = 2; i <=n ;i++){\n                if(dist-v <=0)\n                    break;\n                ans+=i;\n\n                dist-=1;\n            }\n\n        }\n        System.out.println(ans);\n\n    }\n}\n", "label": 1}
{"src": "import java.util.*;\nimport java.util.Arrays;\npublic class Main\n{\n    public static void main(String args[])\n    {\n        Scanner sc=new Scanner(System.in);\n        int n = sc.nextInt();\n        int v = sc.nextInt();\n        int fuel = 0,count=0;\n        \n        if(n<v) {\n            fuel = n-1;\n        }\n        else if(n-1 == v) {\n            fuel = n-1;\n        }\n        else {\n            \n           fuel = v + (n - 1 - v) * (n - v) / 2 + (n - 1 - v);\n\n        }    \n        \n    System.out.println(fuel);    \n    }\n        \n    \n        \n}\n", "label": 1}
{"src": "import java.util.*;\npublic class Main\n{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint mon=0;\n\t\tint n=sc.nextInt();\n\t\tint v=sc.nextInt();\n\t\tint m=n-1;\n\t\tif(n-v==1)\n\t\tSystem.out.println(v);\n\t\telse if(v>=n)\n\t\tSystem.out.println(n-1);\n\t\telse{\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t    if(i==1)\n\t\t    {\n\t\t        mon=mon+v;\n\t\t        m=m-v;\n\t\t        continue;\n\t\t    }\n\t\t  mon=mon+(1*i);\n\t\t  m=m-1;\n\t\t  \n\t\t    if(m==0)\n\t\t    break;\n\t\t}\n\t\tSystem.out.println(mon);\n\t\t}\n\t}\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Test {\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        byte cityCnt = s.nextByte();\n        byte capacity = s.nextByte();\n        int price = capacity;\n    \n        if(cityCnt-1 <=capacity)\n           System.out.print(cityCnt-1);\n        else{\n           \n        \tbyte distance = (byte) (cityCnt-1);\n        \tbyte remDist = (byte) (distance - capacity);\n        \tbyte count =2;\n        \twhile(remDist!=0) {\n        \t\tprice = price + count++;\n        \t\tremDist--;\n        \t}\n            System.out.print(price);\n        }\n        s.close();\n\n    }\n}", "label": 1}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.text.*;\nimport java.lang.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.regex.*;\nimport java.util.stream.LongStream;\n\npublic class Myclass{\n         public static ArrayList adj[]=new ArrayList[3000001];\n         \n         public static void main(String[] args) throws FileNotFoundException \n        {\n            InputReader in=new InputReader(System.in);\n            PrintWriter pw = new PrintWriter(System.out);\n            int n=in.nextInt();\n            int v=in.nextInt();\n            if(v>=n-1) {\n            \tpw.println(n-1);\n            }\n            else\n            {\n            \tlong tot=v;\n            \tint start=2;\n            \tfor(int i=v+1;i<n;i++){\n            \t\ttot+=start;\n            \t\tstart++;\n            \t}\n            \tpw.println(tot);\n            }\n            pw.flush();\n            pw.close();\n        \n        \n        }\n         private static void debug(Object... o) {\n             System.out.println(Arrays.deepToString(o));\n         }\n        static class InputReader \n        {\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n        private SpaceCharFilter filter;\n \n        public InputReader(InputStream stream) \n        { \n            this.stream = stream;\n        }\n        public int snext() \n        {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) \n            {\n                curChar = 0;\n                try \n                {\n                    snumChars = stream.read(buf);\n                } \n                \n                catch (IOException e) \n                {\n                    throw new InputMismatchException();\n                }\n                \n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n \n        public int nextInt() \n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = snext();\n            }\n            int res = 0;\n            do \n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public long nextLong()\n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            int sgn = 1;\n            if (c == '-') \n            {\n                sgn = -1;\n                c = snext();\n            }\n            long res = 0;\n            do \n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n \n        public int[] nextIntArray(int n) \n        {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) \n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n        static class tri implements Comparable<tri> {\n            int p, c, l;\n \n            tri(int p, int c, int l) {\n                this.p = p;\n                this.c = c;\n                this.l = l;\n            }\n \n            public int compareTo(tri o) {\n                return Integer.compare(l, o.l);\n            }\n        }\n \n        public String readString()\n        {\n            int c = snext();\n            while (isSpaceChar(c)) \n            {\n                c = snext();\n            }\n            StringBuilder res = new StringBuilder();\n            do \n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n \n        public String nextLine() \n        {\n            int c = snext();\n            while (isSpaceChar(c))\n                c = snext();\n            StringBuilder res = new StringBuilder();\n            do \n            {\n                res.appendCodePoint(c);\n                c = snext();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n \n        public boolean isSpaceChar(int c) \n        {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n \n        private boolean isEndOfLine(int c) \n        {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n \n        public interface SpaceCharFilter\n        {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n        public static long mod = 1000000007;\n        public static int d;\n        public static int p;\n        public static int q;\n        \n        public static int[] suffle(int[] a,Random gen)\n        {\n            int n = a.length;\n            for(int i=0;i<n;i++)\n            {\n                int ind = gen.nextInt(n-i)+i;\n                int temp = a[ind];\n                a[ind] = a[i];\n                a[i] = temp;\n            }\n            return a;\n        }\n        \n        public static void swap(int a, int b){\n            int temp = a;\n            a = b;\n            b = temp;\n        }\n        \n       /* public static long primeFactorization(long n)\n        {\n             HashSet<Integer> a =new HashSet<Integer>();\n            long cnt=0;\n            for(int i=2;i*i<=n;i++)\n            {\n                while(a%i==0)\n                {\n                    a.add(i);\n                    a/=i;\n                }\n            }\n            if(a!=1)\n                cnt++;\n                //a.add(n);\n            return cnt;\n        }*/\n        \n        public static void sieve(boolean[] isPrime,int n)\n        {\n            for(int i=1;i<n;i++)\n                isPrime[i] = true;\n            \n            isPrime[0] = false;\n            isPrime[1] = false;\n            \n            for(int i=2;i*i<n;i++)\n            {\n                if(isPrime[i] == true)\n                {\n                    for(int j=(2*i);j<n;j+=i)\n                        isPrime[j] = false;\n                }\n            }\n        }\n        \n        public static int GCD(int a,int b)\n        {\n            if(b==0)\n                return a;\n            else\n                return GCD(b,a%b);\n        }\n        \n        public static long GCD(long a,long b)\n        {\n            if(b==0)\n                return a;\n            else\n                return GCD(b,a%b);\n        }\n        \n        public static void extendedEuclid(int A,int B)\n        {\n            if(B==0)\n            {\n                d = A;\n                p = 1 ;\n                q = 0;\n            }\n            else\n            {\n                extendedEuclid(B, A%B);\n                int temp = p;\n                p = q;\n                q = temp - (A/B)*q;\n            }\n        }\n        \n        public static long LCM(long a,long b)\n        {\n            return (a*b)/GCD(a,b);\n        }\n        \n        public static int LCM(int a,int b)\n        {\n            return (a*b)/GCD(a,b);\n        }\n        \n        public static int binaryExponentiation(int x,int n)\n        {\n            int result=1;\n            while(n>0)\n            {\n                if(n % 2 ==1)\n                    result=result * x;\n                x=x*x;\n                n=n/2;\n            }\n            return result;\n        }\n        \n        public static long binaryExponentiation(long x,long n)\n        {\n            long result=1;\n            while(n>0)\n            {\n                if(n % 2 ==1)\n                    result=result * x;\n                x=x*x;\n                n=n/2;\n            }\n            return result;\n        }\n        \n        public static int modularExponentiation(int x,int n,int M)\n        {\n            int result=1;\n            while(n>0)\n            {\n                if(n % 2 ==1)\n                    result=(result * x)%M;\n                x=(x%M*x)%M;\n                n=n/2;\n            }\n            return result;\n        }\n        \n        public static long modularExponentiation(long x,long n,long M)\n        {\n            long result=1;\n            while(n>0)\n            {\n                if(n % 2 ==1)\n                    result=(result%M * x%M)%M;\n                x=(x%M * x%M)%M;\n                n=n/2;\n            }\n            return result;\n        }\n        \n        public static long modInverse(int A,int M)\n        {\n            return modularExponentiation(A,M-2,M);\n        }\n        \n        public static long modInverse(long A,long M)\n        {\n            return modularExponentiation(A,M-2,M);\n        }\n        \n        public static boolean isPrime(int n)\n        {\n            \n            if (n <= 1)  return false;\n            if (n <= 3)  return true;\n            \n            if (n%2 == 0 || n%3 == 0) \n                return false;\n         \n            for (int i=5; i*i<=n; i=i+6)\n            {\n                if (n%i == 0 || n%(i+2) == 0)\n                   return false;\n            }\n            \n            return true;\n        }\n        \n         public static long[] shuffle(long[] a, Random gen){ \n                for(int i = 0, n = a.length;i < n;i++){ \n                    int ind = gen.nextInt(n-i)+i; \n                    long d = a[i]; \n                    a[i] = a[ind]; \n                    a[ind] = d; \n                } \n                return a; \n            }\n         static class pair implements Comparable<pair>{\n             Long x;\n             Integer y;\n             pair(long x,int  y){\n                 this.x=x;\n                 this.y=y;\n             }\n              public int compareTo(pair o) {\n                     int result = x.compareTo(o.x);\n                     if(result==0)\n                         result = y.compareTo(o.y);\n                     \n                 return result;\n                 }  \n              public String toString(){\n                 return (x+\" \"+y);\n             }\n       }       \n \n      \n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class SashaAndHisTrip {\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint cities = in.nextInt(),\n\t\t\tliters = in.nextInt(),\n\t\t\tans = liters < cities - 1 ? liters + ((cities - liters)*(cities - liters + 1))/2 - 1 : cities - 1;\n\t\tSystem.out.println(ans);\n\t}\n\n}\n\n   \t    \t \t\t\t\t         \t\t\t\t\t \t", "label": 1}
{"src": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport java.math.*;\n\npublic class Solution\n{\n    public static void main(String args[])\n    {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int v = sc.nextInt();\n        int ans = 0;\n        if(n-1<v)\n         ans = (n-1);\n        else\n         ans = v;\n        int now = v;\n        for(int i=1 ;i<n ;i++)\n        {\n           now--;\n           if(i < n-1)\n           {\n            if(n-i-1>now)\n            {\n             ans = ans + (i+1);\n             //System.out.println(now+\" \"+ans);\n             now = v;\n                \n            }\n           }\n             \n        }\n        System.out.println(ans);\n    }\n}", "label": 1}
{"src": "import java.io.*;\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\nimport java.util.Scanner;\npublic class city \n{\n\tpublic static void main(String[] args) throws IOException\n\t{\n\t\tint n;\n\t\tScanner sc=new Scanner(System.in);\n\t\tn=sc.nextInt();\n\t\tint v=sc.nextInt();\n\t\tint s=0;\n\t\tint k=1;\n\t\tif(v<n-1)\n\t   {\n\t\t /*int h=(n-1)/v;\n\t\t int g=(n-1)%v;\n\t\t for(int i=0;i<h;i++)\n\t\t {\n\t\t \ts=s+k*v;\n\t\t \tk++;\n\t\t }\n\t\t g=g*(h+1);\n\t\t s=s+g;\n\t\t System.out.println(s);*/\n\t\t int h=n-v;\n\t\t for(int i=2;i<=h;i++)\n\t\t {\n\t\t \ts=s+i;\n\t\t }\n\t\t s=s+v;\n\t\t System.out.println(s);\n\t   }\n\t  else if(v>=n-1)\n\t  {\n\t  \tSystem.out.println(n-1);\n\t  }\n\t}\n}", "label": 1}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    static class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br=new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next(){\n            while (st==null||!st.hasMoreElements()){\n                try{\n                    st=new StringTokenizer(br.readLine());\n                }catch (IOException e){\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt(){\n            return Integer.parseInt(next());\n        }\n\n        long nextLong(){\n            return Long.parseLong(next());\n        }\n\n        double nextDouble(){\n            return Double.parseDouble(next());\n        }\n\n        String nextLine(){\n            String str=\"\";\n            try{\n                str=br.readLine();\n            }catch (IOException e){\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n    public static void main(String[] args) {\n\t    FastReader reader=new FastReader();\n\t    int n=reader.nextInt();\n\t    int v=reader.nextInt();\n\t    int money=Math.min(v,n-1);\n\t    for(int i=2;i<=n-v;i++){\n\t        money+=i;\n        }\n        System.out.println(money);\n    }\n}\n", "label": 1}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Task {\n\n    public static void main(String[] args) throws Exception {\n\n        new Task().go();\n    }\n\n    PrintWriter out;\n    Reader in;\n    BufferedReader br;\n\n    Task() throws IOException {\n\n        try {\n\n            //br = new BufferedReader( new FileReader(\"input.txt\") );\n            //in = new Reader(\"input.txt\");\n            in = new Reader(\"input.txt\");\n            out = new PrintWriter( new BufferedWriter(new FileWriter(\"output.txt\")) );\n        }\n        catch (Exception e) {\n\n            //br = new BufferedReader( new InputStreamReader( System.in ) );\n            in = new Reader();\n            out = new PrintWriter( new BufferedWriter(new OutputStreamWriter(System.out)) );\n        }\n    }\n\n    void go() throws Exception {\n\n        //int t = in.nextInt();\n        int t = 1;\n        while (t > 0) {\n            solve();\n            t--;\n        }\n\n        out.flush();\n        out.close();\n    }\n\n\n    int inf = 2000000000;\n    int mod = 1000000007;\n    double eps = 0.000000001;\n\n    int n;\n    int m;\n\n    void solve() throws IOException {\n\n        int n = in.nextInt();\n        int v = in.nextInt();\n\n        int ans = Math.min(n - 1, v);\n        int cur = 2;\n        for (int i = 0; i < n - 1; i++) {\n            if (v == 0) {\n                ans += cur;\n                v++;\n                cur++;\n            }\n            v--;\n        }\n        out.println(ans);\n    }\n\n\n    class Pair implements Comparable<Pair>{\n\n        int a;\n        int b;\n\n        Pair(int a, int b) {\n\n            this.a = a;\n            this.b = b;\n        }\n\n        public int compareTo(Pair p) {\n            if (a > p.a) return -1;\n            if (a < p.a) return 1;\n            if (b > p.b) return -1;\n            if (b < p.b) return 1;\n            return 0;\n        }\n    }\n\n    class Item {\n\n        int a;\n        int b;\n        int c;\n\n        Item(int a, int b, int c) {\n            this.a = a;\n            this.b = b;\n            this.c = c;\n        }\n\n    }\n\n\n    class Reader {\n\n        BufferedReader  br;\n        StringTokenizer tok;\n\n        Reader(String file) throws IOException {\n            br = new BufferedReader( new FileReader(file) );\n        }\n\n        Reader() throws IOException {\n            br = new BufferedReader( new InputStreamReader(System.in) );\n        }\n\n        String next() throws IOException {\n\n            while (tok == null || !tok.hasMoreElements())\n                tok = new StringTokenizer(br.readLine());\n            return tok.nextToken();\n        }\n\n        int nextInt() throws NumberFormatException, IOException {\n            return Integer.valueOf(next());\n        }\n\n        long nextLong() throws NumberFormatException, IOException {\n            return Long.valueOf(next());\n        }\n\n        double nextDouble() throws NumberFormatException, IOException {\n            return Double.valueOf(next());\n        }\n\n\n        String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n    }\n\n    static class InputReader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public InputReader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public InputReader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n\n} ", "label": 1}
{"src": "import java.util.*;\nimport java.io.*;\npublic class SashaandHisTrip\n{\n\tpublic static void main(String[] g)\n\t{\n\t\tint n,v;\n\t\tlong sum=0,rem;\n\t\tScanner sc=new Scanner(System.in);\n\t\tn=sc.nextInt();\n\t\tv=sc.nextInt();\n\t\tif(n>(v+1))\n\t\t{\n\t\t\tsum+=v;\n\t\t\trem=((n-1)-v);\n\t\t\tint i=2;\n\t\t\twhile(rem>0)\n\t\t\t{\n\t\t\t\tsum+=i;\n\t\t\t\ti++;\n\t\t\t\trem--;\n\t\t\t}\n\t\t}\n\t\telse if(n<=(v+1))\n\t\t\tsum=(n-1);\n\t\tSystem.out.println(sum);\n\t}\t\n}", "label": 1}
{"src": "import java.util.*;\n\nimport javax.lang.model.util.ElementScanner6;\n\nimport java.io.*;\n\npublic class Main{\n\n    public static void main(String[] args) {\n\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n        \n        }\n\n\n\n    static class Solver {\n\n\n        class Node implements Comparable<Node>{\n            int i;\n            long c;\n        \n            Node(int i,long c)\n            {\n                this.i=i;\n                this.c=c;\n\n\n            }\n\n        public int compareTo(Node n)\n            {\n                if(this.c==n.c)\n                {\n                    return Integer.compare(this.i, n.i);\n                }\n                return Long.compare(this.c, n.c);\n            }\n        }\n\n        public boolean done(int[] sp,int[] par)\n        {\n            int root;\n\n            root=findSet(sp[0],par);\n            \n        for(int i=1;i<sp.length;i++)\n        {\n                if(root!=findSet(sp[i], par))\n                    return false;\n        }\n        return true;\n        }\n    public int findSet(int i,int[] par)\n    {\n        int x =i;\n            boolean flag =false;\n            while(par[i]>=0)\n            {\n                flag = true;\n                i=par[i];\n            }\n            if(flag)\n                par[x]=i;\n            return i;\n    }\n\n    public void unionSet(int i,int j,int[] par)\n    {\n            int x = findSet(i, par);\n            int y = findSet(j, par);\n            if(x<y)\n            {\n                par[y]=x;\n            }\n            else\n            {\n                par[x]=y;\n            }\n    }\n\n    public  long pow(long a, long b, long MOD) {\n            if (b == 0) {\n                return 1;\n            }\n            if (b == 1) {\n                return a;\n            }\n            long val = pow(a, b / 2, MOD);\n            if (b % 2 == 0) {\n                return val * val % MOD;\n            } else {\n                return val * (val * a % MOD) % MOD;\n\n            }\n        \n        }\n\n\n        public void minPrimeFactor(int n,int[] s)\n        {\n            boolean prime[] = new boolean[n+1];\n            Arrays.fill(prime, true);\n            s[1]=1;\n            s[2]=2;\n            for(int i=4;i<=n;i+=2)\n            {\n                prime[i]=false;\n                s[i]=2;\n            }\n\n            for(int i=3;i<=n;i+=2)\n            {\n                if(prime[i])\n                {\n                    s[i]=i;\n                    for(int j=2*i;j<=n;j+=i)\n                    {\n                        prime[j]=false;\n                        s[j]=i;\n                    }\n                }\n            }\n            \n        }\n\n        \n        // public void findAllPrime(int n,ArrayList<Node> al,int s[])\n        // {\n        //     int curr = s[n];\n        //     int cnt = 1;\n        //     while(n>1)\n        //     {\n        //         n/=s[n];\n        //         if(curr==s[n])\n        //         {\n        //             cnt++;\n        //             continue;\n\n        //         }\n        //         Node n1 = new Node(curr,cnt);\n        //         al.add(n1);\n\n        //         curr=s[n];\n        //         cnt=1;\n        //     }\n        // }\n\n        \n\n        public int binarySearch(int n,int k)\n        {\n            int left=1;\n            int right=100000000+5;\n            int ans=0;\n            while(left<=right)\n            {\n                int mid = (left+right)/2;\n                if(n/mid>=k)\n                {\n                    left = mid+1;\n                    ans=mid;\n                }\n                else\n                {\n                    right=mid-1;\n                }\n            }\n\n            return ans;\n        }\n        public boolean checkPallindrom(String s)\n        {\n            char ch[] = s.toCharArray();\n\n            for(int i=0;i<s.length()/2;i++)\n            {\n                if(ch[i]!=ch[s.length()-1-i])\n                    return false;\n            }\n            return true;\n        }\n\n\n        public void dfs_util(ArrayList<Integer>[] al,boolean vis[],int x,int cnt[],int sts[],int fts[],long sv[])\n        {\n                \n            vis[x] = true;\n            long min=Long.MAX_VALUE;\n                sts[cnt[0]]=x+1;\n                for(int i=0;i<al[x].size();i++)\n                {\n                    \n                    if(!vis[al[x].get(i)])\n                    {\n                        cnt[0]++;\n                        dfs_util(al, vis, al[x].get(i),cnt,sts,fts,sv);\n                        if(sv[al[x].get(i)]<min&&sv[al[x].get(i)]!=-1)\n                        {\n                            min=sv[al[x].get(i)];\n                        }\n                        \n                        \n                    }    \n                    \n                }\n\n            \n                if(sv[x]==-1)\n                {\n                    if(min==Long.MAX_VALUE)\n                    {\n                        min=-1;\n                    }\n                    sv[x]=min;\n                }\n            \n            \n            return ;\n        }\n\n        public void dfs(ArrayList[] al,int sts[],int fts[],long sv[])\n        {\n            \n        boolean vis[] = new boolean[al.length];\n        int cnt[]= new int[2*al.length+2];\n        for(int i=0;i<al.length;i++)\n        {\n                if(!vis[i])\n                {\n                    \n                    dfs_util(al,vis,i,cnt,sts,fts,sv);\n                }\n        }\n        }\n\n        public void remove(ArrayList<Integer>[] al,int x)\n        {\n            for(int i=0;i<al.length;i++)\n            {\n                for(int j=0;j<al[i].size();j++)\n                {\n\n                    if(al[i].get(j)==x)\n                        al[i].remove(j);\n\n                }\n            }\n        }\n\n        public int gcd(int a, int b) \n        { \n            if (a == 0) \n                return b; \n            return gcd(b % a, a); \n        }\n\n\n        public void printDivisors(int n,ArrayList<Integer> al) \n        { \n            // Note that this loop runs till square root \n            for (int i=1; i<=Math.sqrt(n); i++) \n            { \n                if (n%i==0) \n                { \n                    // If divisors are equal, print only one \n                    if (n/i == i) \n                    {\n                        al.add(i);\n                    }\n                      \n        \n                    else // Otherwise print both \n                    {\n                        al.add(i);\n                        al.add(n/i);\n                    }\n                        \n                } \n            } \n        } \n\n        public static long constructSegment(long seg[],long arr[], int low,int high,int pos)\n        {\n            if(low==high)\n            {\n                seg[pos] = arr[low]; \n                return seg[pos];\n            }\n            int mid = (low+high)/2;\n            long t1=constructSegment(seg, arr,low , mid,(2*pos)+1);\n            long t2=constructSegment(seg,arr,mid+1,high,(2*pos)+2);\n            seg[pos] = t1+t2;\n            return seg[pos];\n\n        }\n        public static long querySegment(long seg[],int low,int high,int qlow, int qhigh,int pos)\n        {\n            \n             if(qlow<=low&&qhigh>=high)\n             {\n                return seg[pos];\n             }\n             else if(qlow>high||qhigh<low )\n             {\n                 return 0;\n             }\n             else{\n                long ans=0;\n                int mid=(low+high)/2;\n                ans+=querySegment(seg,low , mid, qlow, qhigh,  (2*pos)+1);\n                ans+=querySegment(seg, mid+1, high, qlow, qhigh, (2*pos)+2);\n               return ans; \n             }\n\n        }\n        public static int lcs( char[] X, char[] Y, int m, int n ) \n        { \n            if (m == 0 || n == 0) \n            return 0; \n            if (X[m-1] == Y[n-1]) \n            return 1 + lcs(X, Y, m-1, n-1); \n            else\n            return Integer.max(lcs(X, Y, m, n-1), lcs(X, Y, m-1, n)); \n        } \n\n        public static long recursion(long start,long end,long cnt[],int a, int b)\n        {\n\n            long min=0;\n            long count=0;\n            int ans1=-1;\n            int ans2=-1;\n            int l=0;\n            int r=cnt.length-1;\n            while(l<=r)\n            {\n                int mid=(l+r)/2;\n                if(cnt[mid]>=start)\n                {\n                    ans1=mid;\n                    r=mid-1;\n                }\n                else\n                {\n                    l=mid+1;\n                }\n            }\n\n            l=0;\n            r=cnt.length-1;\n            while(l<=r)\n            {\n                int mid=(l+r)/2;\n                if(cnt[mid]<=end)\n                {\n                    ans2=mid;\n                    l=mid+1;\n                }\n                else\n                {\n                    r=mid-1;\n                }\n            }\n            \n            if(ans1==-1||ans2==-1||ans2<ans1)\n            {\n                // System.out.println(\"min1 \"+min);\n                min=a;\n                return a;\n\n            }\n            else\n            {\n                min=b*(end-start+1)*(ans2-ans1+1);\n            }\n            if(start==end)\n            {\n                // System.out.println(\"min \"+min);\n                return min;\n            }\n            long mid = (end+start)/2;\n            min = Long.min(min,recursion(start, mid, cnt, a, b)+recursion(mid+1, end, cnt, a, b));\n            // System.out.println(\"min \"+min);\n            return min;\n        }\n\n        public void dfs(int x, ArrayList<Integer> al[], boolean[] vis)\n        {\n            vis[x]=true;\n            System.out.print((x+1)+\" \");\n            for(int i=0;i<al[x].size();i++)\n            {\n                if(!vis[al[x].get(i)])\n                {\n                    dfs(al[x].get(i),al,vis);\n                }\n            }\n        }\n\n        private void solve(InputReader inp, PrintWriter out1) {\n           int n =inp.nextInt();\n           int v = inp.nextInt();\n           n--;\n           if(v>n)\n           {\n               out1.println(n);\n               return;\n           }\n           int ans =1*v;\n            int i=2;\n            n-=v;\n           while(n>0)\n           {\n                ans+=i;\n                n-=1;\n                i++;\n           }\n           out1.println(ans);\n           \n\n        }\n}\n\n\n\n\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\nclass ele{\n    long value;\n    long i;\n    boolean flag;\n    public ele(long value,long i)\n    {\n        this.value = value;\n        this.i=i;\n        this.flag = false;\n    }\n}", "label": 1}
{"src": "import java.io.BufferedWriter;\nimport java.io.DataInputStream;\nimport java.io.FileInputStream;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.io.OutputStreamWriter;\nimport java.util.*;\nimport java.util.Map.Entry;\n\n\n\npublic class Main \n{\n    \n    public static void main(String[] args) throws Exception\n    {\n        /*\n        FileWriter writer = new FileWriter(\"input.txt\");\n        for(int i=1;i<=10000000;++i)\n        {\n            long a = Mother_Class.getRandomInteger(1, 100000000);\n            long b = Mother_Class.getRandomInteger(1, 100000000);\n            writer.write(a+\" \"+b+\"\\n\");\n        }        \n        writer.close();*/\n        \n        //long start = System.currentTimeMillis();\n        \n        Reader r = new Reader();\n        Print p = new Print();\n        int n, tank;\n        n = r.rint(); tank = r.rint();\n        \n        int fuel_req = n-1;\n        if(tank>=fuel_req) { p.println(fuel_req); }\n        else\n        {\n            int city = 1, fuel = 0, cost = 0;\n            while(city<n)\n            {\n                int empty = tank - fuel;\n                if(fuel<fuel_req && fuel_req>0 && fuel_req>=empty) \n                {\n                    fuel += empty;\n                    cost += empty*city;\n                }\n                else if(fuel<fuel_req && fuel_req>0 && fuel_req<empty) \n                {\n                    fuel += fuel_req;\n                    cost += empty*city;\n                }\n                --fuel;\n                ++city;\n                fuel_req = n - city;\n            }\n            p.println(cost);\n        }\n        //long end = System.currentTimeMillis();\n       //p.println(\"Execution Time: \"+(end-start)+\"ms\");\n        p.close();\n    }\n    \n    \n}\n\nclass Pair\n{\n    public int first;\n    public int second;\n\n    public Pair(int first, int second)\n    {\n        this.first = first;\n        this.second = second;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"{\"+first+\", \"+second+\"}\";\n    }\n\n    \n}\n\nclass CustomCompare implements Comparator<Pair>\n{\n\n    @Override\n    public int compare(Pair o1, Pair o2) \n    {\n        return o2.first - o1.first;\n    }\n    \n}\n\nclass Triplet\n{\n    public int first;\n    public int second;\n    public int third;\n\n    public Triplet(int first, int second, int third)\n    {\n        this.first = first;\n        this.second = second;\n        this.third = third;\n    }\n\n    @Override\n    public String toString()\n    {\n        return \"{\"+first+\", \"+second+\", \"+third+\"}\";\n    }\n}\n\n\n\nclass Reader \n{\n    final private int BUFFER_SIZE = 1 << 16;\n    private DataInputStream din;\n    private byte[] buffer;\n    private int bufferPointer, bytesRead;\n\n    public Reader()\n    {\n        din = new DataInputStream(System.in);\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public Reader(String file_name) throws IOException\n    {\n        din = new DataInputStream(new FileInputStream(file_name));\n        buffer = new byte[BUFFER_SIZE];\n        bufferPointer = bytesRead = 0;\n    }\n\n    public String rstren() throws IOException\n    {\n        byte[] buf = new byte[500000]; // line length\n        int cnt = 0, c;\n        while ((c = read()) != -1) \n        {\n            if (c=='\\n' || c==13) \n            {\n                if (cnt != 0) \n                {\n                    break;\n                }\n                else \n                {\n                    continue;\n                }\n            }\n            buf[cnt++] = (byte)c;\n        }\n        return new String(buf, 0, cnt);\n    }\n\n    public int rint() throws IOException\n    {\n        int ret = 0;\n        byte c = read();\n        while ((c <= 47 || c>=58) && c!=45) \n        {\n            c = read();\n        }\n        boolean neg = (c == '-');\n        if (neg) { c = read(); }\n        do \n        {\n            ret = ret * 10 + c - '0';\n        } \n        while ((c = read()) >= '0' && c <= '9');\n\n        if (neg) { return -ret; }\n        return ret;\n    }\n\n    public long rlong() throws IOException\n    {\n        long ret = 0;\n        byte c = read();\n        while ((c <= 47 || c>=58) && c!=45) { c = read(); }\n        boolean neg = (c == '-');\n        if (neg) { c = read(); }\n        do \n        {\n            ret = ret * 10 + c - '0';\n        } \n        while ((c = read()) >= '0' && c <= '9');\n        if (neg) { return -ret; }\n        return ret;\n    }\n\n    public double rdouble() throws IOException\n    {\n        double ret = 0, div = 1;\n        byte c = read();\n        while ((c <= 47 || c>=58) && c!=45) { c = read(); }\n        boolean neg = (c == '-');\n        if (neg) { c = read(); }\n        do \n        {\n            ret = ret * 10 + c - '0';\n        } \n        while ((c = read()) >= '0' && c <= '9');\n\n        if (c == '.') \n        {\n            while ((c = read()) >= '0' && c <= '9') \n            {\n                ret += (c - '0') / (div *= 10);\n            }\n        }\n        if (neg) { return -ret; }\n        return ret;\n    }\n\n    private void fillBuffer() throws IOException\n    {\n        bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n        if (bytesRead == -1) { buffer[0] = -1; }\n    }\n\n    private byte read() throws IOException\n    {\n        if (bufferPointer == bytesRead) { fillBuffer(); }\n        return buffer[bufferPointer++];\n    }\n\n    public void close() throws IOException\n    {\n        if (din == null) { return; }\n        din.close();\n    }\n}\n\nclass Print\n{\n    private final BufferedWriter bw;\n    public Print()\n    {\n        this.bw=new BufferedWriter(new OutputStreamWriter(System.out));\n    }\n    public void print(Object object)throws IOException\n    {\n        bw.append(\"\"+object);\n    }\n    public void println(Object object)throws IOException\n    {\n        print(object);\n        bw.append(\"\\n\");\n    }\n    public void close()throws IOException\n    {\n        bw.close();\n    }\n}\n", "label": 1}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.*;\n\npublic class Main implements Runnable {\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n        private BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        public int nextInt() {\n            int c = read();\n\n            while (isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.') {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n\n    public static void main(String args[]) throws Exception {\n        new Thread(null, new Main(), \"Main\", 1 << 27).start();\n    }\n\n    static class Pair {\n        int f;\n        int s;\n        int p;\n        PrintWriter w;\n\n        // int t;\n\n        Pair(int f, int s) {\n            // Pair(int f,int s, PrintWriter w){\n            this.f = f;\n            this.s = s;\n            // this.p = p;\n            // this.w = w;\n            // this.t = t;\n\n        }\n\n        public static Comparator<Pair> wc = new Comparator<Pair>() {\n            public int compare(Pair e1, Pair e2) {\n\n                // 1 for swap\n                if (Math.abs(e1.f) - Math.abs(e2.f) != 0) {\n                    // e1.w.println(\"**\"+e1.f+\" \"+e2.f);\n                    return (Math.abs(e1.f) - Math.abs(e2.f));\n                } else {\n                    // e1.w.println(\"##\"+e1.f+\" \"+e2.f);\n                    return (Math.abs(e1.s) - Math.abs(e2.s));\n                }\n\n            }\n        };\n    }\n\n    public static ArrayList<Integer> sieve(int N) {\n        int i, j, flag;\n\n        ArrayList<Integer> p = new ArrayList<Integer>();\n\n        for (i = 1; i < N; i++) {\n\n            if (i == 1 || i == 0)\n                continue;\n\n            flag = 1;\n\n            for (j = 2; j <= i / 2; ++j) {\n                if (i % j == 0) {\n                    flag = 0;\n                    break;\n                }\n            }\n            if (flag == 1) {\n                p.add(i);\n            }\n        }\n        return p;\n    }\n\n    public static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        else\n            return gcd(b, a % b);\n    }\n\n    //// recursive dfs\n    public static int dfs(int s, ArrayList<Integer>[] g, long[] dist, boolean[] v, PrintWriter w, int p) {\n        v[s] = true;\n        int ans = 1;\n        // int n = dist.length - 1;\n        int t = g[s].size();\n        // int max = 1;\n        for (int i = 0; i < t; i++) {\n            int x = g[s].get(i);\n            if (!v[x]) {\n                // dist[x] = dist[s] + 1;\n                ans = Math.min(ans, dfs(x, g, dist, v, w, s));\n            } else if (x != p) {\n                // w.println(\"* \" + s + \" \" + x + \" \" + p);\n                ans = 0;\n            }\n        }\n        // max = Math.max(max,(n-p));\n        return ans;\n    }\n\n    //// iterative BFS\n    public static int bfs(int s, ArrayList<Integer>[] g, long[] dist, boolean[] b, PrintWriter w, int p) {\n        b[s] = true;\n        int siz = 1;\n        // dist--;\n        Queue<Integer> q = new LinkedList<>();\n        q.add(s);\n        while (q.size() != 0) {\n            int i = q.poll();\n            Iterator<Integer> it = g[i].listIterator();\n            int z = 0;\n            while (it.hasNext()) {\n                z = it.next();\n                if (!b[z]) {\n                    b[z] = true;\n                    // dist--;\n                    dist[z] = dist[i] + 1;\n                    // siz++;\n                    q.add(z);\n                } else if (z != p) {\n                    siz = 0;\n                }\n            }\n\n        }\n        return siz;\n    }\n\n    public static int lower(int key, int[] a) {\n        int l = 0;\n        int r = a.length - 1;\n        int res = 0;\n\n        while (l <= r) {\n            int mid = (l + r) / 2;\n\n            if (a[mid] <= key) {\n                l = mid + 1;\n                res = mid + 1;\n            } else {\n                r = mid - 1;\n            }\n        }\n\n        return res;\n    }\n\n    public static long power(long x, long y, long m) {\n        if (y == 0)\n            return 1;\n\n        long p = power(x, y / 2, m) % m;\n        p = (p * p) % m;\n\n        if (y % 2 == 0)\n            return p;\n        else\n            return (x * p) % m;\n    }\n\n    //////////////////////////////////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////////////////////////////////////\n    // code here\n    int[] parent;\n    int[] dist;\n    int[] height;\n    boolean[] vis;\n    ArrayList<Integer>[] g;\n    int[] col;\n\n    public void run() {\n\n        InputReader sc = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n        int defaultValue = 0;\n        int mod = 1000000007;\n        int oo = (int) 1e9;\n\n        int test = 1;\n        // test = sc.nextInt();\n        while (test-- > 0) {\n            int n = sc.nextInt();\n            int v = sc.nextInt();\n            long ans = 0;\n            if (v >= n - 1) {\n                ans = n - 1;\n            } else {\n\n                for (int i = 1; i <= n - v; i++) {\n                    ans += i;\n                }\n                ans += (v - 1);\n            }\n\n            w.println(ans);\n\n        }\n\n        w.flush();\n        w.close();\n\n    }\n\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Sasha_and_His_Trip {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt() - 1;\n        int v = sc.nextInt();\n        int a = n - v;\n        if (v >= n)\n            System.out.println(n);\n        else\n            System.out.println(v + (a + 2) * (a + 1) / 2 - 1);\n\n\n    }\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class CFTrip {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\tScanner scanner = new Scanner(System.in);\n\t\tint n  = scanner.nextInt();\n\t\tint v = scanner.nextInt();\n\t\tif(v>=n) {\n\t\t\tSystem.out.println(n-1);\n\t\t}\n\t\telse {\n\t\t\tint sum = v;\n\t\t\tfor(int i = 2; i <= n-v;i++) {\n\t\t\t\tsum += i;\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t\tscanner.close();\n\t\t\n\t}\n\n}", "label": 1}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class MAIN {\n\n\tstatic class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n        \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n\t\n\n\tpublic static void main(String[] args){\n\t\t// TODO Auto-generated method \n\t\tOutputStream outputStream = System.out;\n        FastReader scn = new FastReader();\n        PrintWriter out = new PrintWriter(outputStream);\n        int n = scn.nextInt();\n        int v = scn.nextInt();\n        int res = 0;\n        if(n<=v)\n        {\n        \tout.println(n-1);\n        \tout.close();\n        \treturn;\n        }\n        else\n        {\n        \tint stops = Math.abs(v-n)-1;\n        \tfor(int i=2;stops>0;i++,stops--)\n        \t\tv+=i;\n        }\n        out.println(v);\n        out.close();\n\t\t\n\n\t}\n\n\n\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class SashaAndHisTrip {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint cities = sc.nextInt();\n        int gas = sc.nextInt();\n        \n\t\tSystem.out.println(tripCost(cities, gas));\n\t\tsc.close();\n\t}\n\n\tstatic int tripCost(int c, int g) {\n        int cost = g;\n        \n\t\tif (c - 1 <= g) return c - 1;\n\t\tfor (int i = 0; i < c - 1 - g; i++) cost += i + 2;\n        \n\t\treturn cost;\n\t}\n}\n\n\t\t \t   \t\t\t  \t \t  \t \t\t \t\t     \t\t", "label": 1}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        Scan s = new Scan();\n        int n = s.scanInt();\n        int v = s.scanInt();\n        // int[] arr = new int[n];\n        // for(int i=0;i<arr.length;++i) arr[i] = s.scanInt();\n        System.out.println(solve(n,v));\n    }\n    \n    private static int solve(int n,int v){\n       if(v >= n) return n-1; \n       int petrol = 0,money_spent = 0;\n       for(int i=1;i<=n;++i){\n           if((n-i) > petrol){\n               money_spent += (v-petrol) * i; \n               petrol = v;\n           }\n           petrol--;\n       }\n       \n       return money_spent;\n    }\n}\n\nclass Scan\n{\n    private byte[] buf=new byte[1024];    //Buffer of Bytes\n    private int index;\n    private InputStream in;\n    private int total;\n    public Scan()\n    {\n        in=System.in;\n    }\n    public int scan()throws IOException    //Scan method used to scan buf\n    {\n        if(total<0)\n        throw new InputMismatchException();\n        if(index>=total)\n        {\n            index=0;\n            total=in.read(buf);\n            if(total<=0)\n            return -1;\n        }\n        return buf[index++];\n    }\n    public int scanInt()throws IOException\n    {\n        int integer=0;\n        int n=scan();\n        while(isWhiteSpace(n))    //Removing starting whitespaces\n        n=scan();\n        int neg=1;\n        if(n=='-')                //If Negative Sign encounters\n        {\n            neg=-1;\n            n=scan();\n        }\n        while(!isWhiteSpace(n))\n        {\n            if(n>='0'&&n<='9')\n            {\n                integer*=10;\n                integer+=n-'0';\n                n=scan();\n            }\n            else throw new InputMismatchException();\n        }\n        return neg*integer;\n    }\n    private boolean isWhiteSpace(int n)\n    {\n        if(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n        return true;\n        return false;\n    }\n}", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Main4 {\n\t\n\tpublic static void main(String args[]){\n\t\t\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint total = sc.nextInt();\n\t\tint cnt = Math.min(n-1, total);\n\t\tint fuel = Math.min(n-1, total) - 1;\n\t\t//System.out.println(\"g \" + cnt + \"  \" + fuel);\n\t\tfor(int i=2;i<n;i++){\n\t\t\tif(n-i > fuel){\n\t\t\t\tcnt += Math.min(n-i-fuel, total-fuel)*i;\n\t\t\t\tfuel += Math.min(n-i-fuel, total-fuel);\n\t\t\t\t\n\t\t\t\t//System.out.println(\"g \" + cnt + \"  \" + fuel + \"  \" + Math.min(n-i-fuel, total-fuel));\n\t\t\t}\n\t\t\tfuel--;\n\t\t}\n\t\tSystem.out.println(cnt);\n\t\t\n\t}\n}\n", "label": 1}
{"src": "//1113A\n//SashaAndTrip\n\nimport java.util.*;\n\npublic class SashaAndTrip\n{\n    public static void main(String[] args) \n    {\n        Scanner sc = new Scanner(System.in);\n        \n        int n = sc.nextInt();\n        int v = sc.nextInt();\n\n        int cur = Math.max((n - 1) - v, 0);\n        int total = cur == 0 ? n - 1 : v;\n        for(int i = 2; i < n; i++)\n        {\n           if(cur > 0)\n           {\n               cur--;\n               total += i;\n           }\n\n        }\n        System.out.println(total);\n    }\n}", "label": 1}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Soln0 {\n\n\tfinal BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\n\tfinal PrintWriter pw = new PrintWriter(System.out);\n\n\tpublic static void main(String[] args) {\n\n\t\tSoln0 solution = new Soln0();\n\n\t\tsolution.solve();\n\t\tsolution.close();\n\n\t}\n\n\t\n\tvoid solve() {\n\t\tint arr[]=readIntArr();\n\t\tint n=arr[0];\n\t\tint v=arr[1];\n\t\tint mn=Math.min(n-1, v);\n\t\tint nc=mn;\n\t\tint diff=Math.max(n-1-v, 0);\n\t\tfor(int i=1;i<n-1;i++) {\n\t\t\tif(diff>0) {\n\t\t\t\tnc+=i+1;\n\t\t\t\tdiff--;\n\t\t\t}\n\t\t}\n\t\tpw.println(nc);\n\t\t\n\t}\n\n\tvoid close() {\n\n\t\tpw.close();\n\n\t}\n\n\tString readLine() {\n\t\tString line = null;\n\t\ttry {\n\t\t\tline = br.readLine();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn line;\n\n\t}\n\n\tString readString() {\n\t\treturn readLine();\n\n\t}\n\n\tpublic long readlong() {\n\t\treturn Long.parseLong(readLine());\n\t}\n\n\tpublic int readInt() {\n\t\treturn Integer.parseInt(readLine());\n\t}\n\n\tString[] stringArray() {\n\n\t\tStringTokenizer st = new StringTokenizer(readLine());\n\t\tint n = st.countTokens();\n\t\tString ret[] = new String[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tret[i] = st.nextToken();\n\t\t}\n\t\treturn ret;\n\n\t}\n\n\tpublic int[] readIntArr() {\n\t\tString[] str = stringArray();\n\t\tint arr[] = new int[str.length];\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tarr[i] = Integer.parseInt(str[i]);\n\t\treturn arr;\n\t}\n\n\tpublic double[] readDoubleArr() {\n\t\tString[] str = stringArray();\n\t\tdouble arr[] = new double[str.length];\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tarr[i] = Double.parseDouble(str[i]);\n\t\treturn arr;\n\t}\n\n\tpublic long[] readLongArr() {\n\t\tString[] str = stringArray();\n\t\tlong arr[] = new long[str.length];\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tarr[i] = Long.parseLong(str[i]);\n\t\treturn arr;\n\t}\n\n\tpublic double readDouble() {\n\t\treturn Double.parseDouble(readLine());\n\t}\n}\n", "label": 1}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main1 {\n\n\tstatic FastReader input = new FastReader();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tint n = input.nextInt();\n\t\tint v = input.nextInt();\n\t\tint current = 0 ;\n\t\tint money = 0 ; \n\t\tint i = 1; \n\t\t\n\t\twhile (n-i>current) {\n\t\t\tint minFuel = Math.min(n-i, v-current);\n\t\t\tcurrent+=minFuel;\n\t\t\tmoney+=(i*minFuel);\n\t\t\t\n\t\t\tcurrent--;\n\t\t\ti++;\n\t\t\t\n\t\t}\n\n\t\tSystem.out.println(money);\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws NumberFormatException, IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\tString str = \"\";\n\t\t\tstr = br.readLine();\n\t\t\treturn str;\n\t\t}\n\t}\n\n}", "label": 1}
{"src": "import java.util.Scanner;\nimport static java.lang.Math.*;\npublic class Main{\n    public static void main(String[]args){\n         Scanner x = new Scanner (System.in);\n        int y = x.nextInt();\n        int z = x.nextInt();\n        y-=1;\n        int i=1,r=0,w;\n        while(y!=0){\n           if(r==0) { w = min(y,z);\n               int u = w*i;\n               r+=u;\n               y-=w;}\n           else {i++;r+=i;y-=1;}\n\n        }\n        System.out.println(r);\n    }\n}", "label": 1}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n/**\n *\n * @author Admin\n */\npublic class A1113 {\n\n    static BufferedReader br = new BufferedReader(new InputStreamReader(\n            System.in));\n\n    static long getInt() throws Exception {\n        long n = Long.parseLong(br.readLine());\n        return n;\n    }\n\n    static int[] getIntarr() throws Exception {\n        String arr[] = br.readLine().split(\" \");\n        int a[] = new int[arr.length];\n        for (int i = 0; i < a.length; i++) {\n            a[i] = Integer.parseInt(arr[i]);\n        }\n        return a;\n    }\n\n    public static void main(String[] args) throws Exception {\n        int y[] = getIntarr();\n        int n = y[0];\n        int v = y[1];\n        int cnt = 0;\n        int ans = Math.min(v, n - 1);\n        for (int i = 2; i <= n - v; i++) {\n            ans += i;\n\n        }\n        System.out.println(ans);\n    }\n\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class some {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n\n        long n = in.nextLong();\n        long v = in.nextLong();\n\n        if (v >= n - 1) {\n            System.out.println(n-1);\n            return;\n        }\n\n\n        System.out.println(v + (n - v) * (n - v + 1) / 2 - 1);\n    }\n\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class Code {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint v = sc.nextInt();\n\t\t\n\t\tint fuel = 0;\n\t\tint money = 0;\n\t\t\n\t\tfor (int i = 1; i < n + 1; i ++)\n\t\t{\n \t\t\tif (fuel < v)\n\t\t\t{\n\t\t\t\tif (i + v < n)\n\t\t\t\t{\n\t\t\t\t\tmoney += i * (v - fuel);\n\t\t\t\t\tfuel = v;\n\t\t\t\t}\n\t\t\t\telse if (i + fuel < n)\n\t\t\t\t{\n\t\t\t\t\tmoney += i * (n - i - fuel);\n\t\t\t\t\tfuel = (n - i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i + fuel >= n)\n\t\t\t{\n\t\t\t\tSystem.out.println(money);\n\t\t\t\tSystem.exit(0);\n\t\t\t}\n\t\t\tfuel -= 1;\n\t\t}\n\t}\n\n}\n", "label": 1}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\npublic class main {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tBufferedWriter wr = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\tString[] s = br.readLine().split(\" \");\n\t\tint n = Integer.parseInt(s[0]);\n\t\tint v = Integer.parseInt(s[1]);\n\t\tint fuelSum = v;\n\t\tint cash = v;\n\t\tif (v >= n)\n\t\t\tcash = n - 1;\n\t\telse\n\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\tif (fuelSum < n - i && fuelSum < v) {\n\t\t\t\t\tint f = Math.min(v, n -i) - fuelSum;\n\t\t\t\t\tfuelSum ++;\n\t\t\t\t\tcash += i * f;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\tfuelSum--;\n\t\t\t}\n\t\twr.write(Integer.toString(cash));\n\t\tbr.close();\n\t\twr.close();\n\n\t}\n\n}\n", "label": 1}
{"src": "import java.util.Scanner;\n\npublic class A1113 {\n\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tint n = scan.nextInt();\n\t\tint v = scan.nextInt();\n\t\tint result = 0;\n\t\tif(v>=(n-1)) {\n\t\t\tresult = n-1;\n\t\t}else\n\t\t{\n\t\t\tresult = v+ (n-v)*(n-v+1)/2 -1;\n\t\t}\n\t\t\n\t\tSystem.out.println(result);\n\t}\n\n}", "label": 1}
{"src": "/**\n * @(#)SashaRunner.java\n *\n *\n * @author\n * @version 1.00 2019/2/20\n */\nimport java.io.*;\nimport java.util.*;\nimport static java.lang.System.out;\n\npublic class SashaRunner {\n\n    public SashaRunner() {\n    }\n\n\tpublic static int findTotal(int n, int v) {\n\t\tint total=0;\n\t\tint tank=0;\n\t\tint ind=1;\n\t\tif (v>=(n-1)) {\n\t\t\ttank=n-1;\n\t\t\ttotal=n-1;\n\t\t} else {\n\t\t\ttank=v;\n\t\t\ttotal+=v;\n\t\t\ttotal+=((n-v)*(n-v+1))/2;\n\t\t\ttotal-=1;\n\n\t\t}\n\n\t\treturn total;\n\t}\n    public static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tint v=in.nextInt();\n\t\tout.println(findTotal(n, v));\n    }\n}", "label": 1}
{"src": "import java.util.*;\n\npublic class Main {\n\n    public static void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int nCity= sc.nextInt();\n        int vCap= sc.nextInt();\n        sc.nextLine();\n\n        int cost =0;\n        int gas = 0;\n\n        for(int i=1 ; i< nCity;i++){\n            int addGas = Math.min(vCap-gas, nCity-i );\n            cost += addGas*i;\n            gas += addGas;\n\n            if(gas >= nCity-i) {\n                System.out.println(cost);\n                return;\n            };\n            gas--;\n        }\n        System.out.println(cost);\n\n    }\n}", "label": 1}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.OutputStream;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        ASashaAndHisTrip solver = new ASashaAndHisTrip();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ASashaAndHisTrip {\n        public void solve(int testNumber, FastReader in, PrintWriter out) {\n            Debug debug = new Debug();\n            int n = in.nextInt();\n            int v = in.nextInt();\n\n            int fuel = 0;\n            int ans = 0;\n            int last = 1;\n            for (int i = 2; i <= n; ++i) {\n                while (fuel < v && last + fuel < n) {\n                    fuel += 1;\n                    ans += last;\n                }\n                --fuel;\n                last = i;\n//            debug.tr(last, fuel, i);\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class Debug {\n        PrintWriter out;\n        boolean oj;\n        long timeBegin;\n        Runtime runtime;\n\n        public Debug(PrintWriter out) {\n            oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n            this.out = out;\n            this.timeBegin = System.currentTimeMillis();\n            this.runtime = Runtime.getRuntime();\n        }\n\n        public Debug() {\n            oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n            OutputStream outputStream = System.err;\n            this.out = new PrintWriter(outputStream);\n            this.timeBegin = System.currentTimeMillis();\n            this.runtime = Runtime.getRuntime();\n        }\n\n        public void finalize() {\n            out.flush();\n            out.close();\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[8192];\n        private int curChar;\n        private int pnumChars;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int pread() {\n            if (pnumChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= pnumChars) {\n                curChar = 0;\n                try {\n                    pnumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (pnumChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = pread();\n            while (isSpaceChar(c))\n                c = pread();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = pread();\n            }\n            int res = 0;\n            do {\n                if (c == ',') {\n                    c = pread();\n                }\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = pread();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "label": 1}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author tarek\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        ASashaAndHisTrip solver = new ASashaAndHisTrip();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ASashaAndHisTrip {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            int v = in.nextInt();\n            int sum = 0;\n            if (v == n - 1) {\n                out.println(v);\n            } else if (v > n - 1) {\n                out.println(n - 1);\n            } else {\n                sum = v;\n                for (int i = 2; i <= (n - v); i++) {\n                    v--;\n                    sum += i;\n                    v++;\n\n                }\n\n                out.println(sum);\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "label": 1}
{"src": "import java.io.*;\nimport java.util.Scanner;\n\n/**\n * @author ashevenkov 05.05.16 19:14.\n */\npublic class ProblemA {\n\n    public static final String TITLE = \"A-large\";\n    private static BufferedReader in = testIn();\n    private static BufferedWriter out = testOut();\n\n    private static BufferedWriter prodOut() {\n        try {\n            return new BufferedWriter(new FileWriter(\"codeforces/output/\" + TITLE + \".out\"));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n    private static BufferedReader prodIn() {\n        try {\n            return new BufferedReader(new FileReader(\"codeforces/input/\" + TITLE + \".in\"));\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        }\n        return null;\n    }\n\n\n    private static BufferedWriter testOut() {\n        return new BufferedWriter(new OutputStreamWriter(System.out));\n    }\n\n    private static BufferedReader testIn() {\n        return new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    public static void main(String[] args) throws Exception {\n        new ProblemA().solve(in, out);\n        out.flush();\n        out.close();\n    }\n\n    //implement\n    private void solve(BufferedReader in, BufferedWriter out) throws Exception {\n        Scanner scanner = new Scanner(in);\n        int n = scanner.nextInt();\n        int v = scanner.nextInt();\n        int result = doSolve(n, v);\n        out.write(Integer.toString(result));\n    }\n\n    private int doSolve(int n, int v) {\n        if(v >= n - 1) {\n            return n - 1;\n        } else {\n            int result = v;\n            for(int i = 2; i <= n - v; i++) {\n                result += i;\n            }\n            return result;\n        }\n    }\n\n}\n", "label": 1}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class P1113A {\n\n  private static void solve() {\n    int n = nextInt();\n    int v = nextInt();\n\n    int cap = v;\n    int cost = v;\n    for (int i = 2; i <= n; i++) {\n      cost += i;\n    }\n\n    if (cap > 0) {\n      for (int i = n; i >= 2 && cap > 0; i--) {\n        cap--;\n        cost -= i;\n      }\n\n      if (cap > 0) {\n        cost -= cap;\n      }\n    }\n\n    System.out.println(cost);\n  }\n\n  private static void run() {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    out = new PrintWriter(System.out);\n\n    solve();\n\n    out.close();\n  }\n\n  private static StringTokenizer st;\n  private static BufferedReader br;\n  private static PrintWriter out;\n\n  private static String next() {\n    while (st == null || !st.hasMoreElements()) {\n      String s;\n      try {\n        s = br.readLine();\n      } catch (IOException e) {\n        return null;\n      }\n      st = new StringTokenizer(s);\n    }\n    return st.nextToken();\n  }\n\n  private static int nextInt() {\n    return Integer.parseInt(next());\n  }\n\n  private static long nextLong() {\n    return Long.parseLong(next());\n  }\n\n  public static void main(String[] args) {\n    run();\n  }\n}", "label": 1}
{"src": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\nimport static java.lang.Math.*;\npublic class Main\n{\n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int ni() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }  while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nl() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nd() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n    static class Pair implements Comparable<Pair> {\n        int x,y;\n\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        public int compareTo(Pair o) {\n            if(this.x!=o.x)\n                return this.x-o.x;\n            return this.y-o.y;\n        }\n        public String toString(){\n            return x+\" \"+y;\n        }\n    }\n    static long MOD=(long)1e9+7;\n    static PrintWriter pw = new PrintWriter(System.out,true);\n    static StringBuilder sb = new StringBuilder();\n    public static void main(String[] args) throws IOException\n    {\n        Reader sc=new Reader();\n        //Scanner sc = new Scanner(System.in);\n        //Code start from here\n        int n = sc.ni()-1,v = sc.ni();\n        int cost = min(v,n),fuel=v;\n        for(int i =2;i<=n;i++) {\n            if(fuel>=n)\n                break;\n            cost+=i;\n            fuel++;\n           //System.out.println(cost);\n        }\n        System.out.println(cost);\n\n\n\n\n\n\n\n\n        pw.print(sb);\n        pw.flush();\n        pw.close();\n    }\n}", "label": 1}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            int v = in.nextInt();\n            int f = 1;\n            int ans = 0;\n            for (int city = 1; city <= n; city++) {\n                f--;\n                int buy = Math.min(Math.max(n - city - f, 0), v - f);\n                f += buy;\n                ans += buy * city;\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class InputReader {\n        private BufferedReader reader;\n        private StringTokenizer stt;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream));\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                return null;\n            }\n        }\n\n        public String next() {\n            while (stt == null || !stt.hasMoreTokens()) {\n                stt = new StringTokenizer(nextLine());\n            }\n            return stt.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "label": 1}
{"src": "import java.util.*;\npublic class Main {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int v=sc.nextInt();\n        int f=v;\n        int p=v;\n        if(v<n-1){\n        while(f!=n-1){\n            f++;\n            p=p+1+f-v;\n        }\n        System.out.println(p);\n        }\n        else{\n            System.out.println(n-1);\n        }\n    }\n}", "label": 1}
{"src": "import java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\n\n\npublic class GFG77\n{\n    static int mod1 = (int) (1e9 + 7);\n    static class Reader\n    {\n        final private int BUFFER_SIZE = 1 << 16;\n        Scanner scan = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n        public String nextString() throws IOException\n        {\n            String str00=scan.next();\n            return str00;\n        }\n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1)\n            {\n                if (c == '\\n')\n                    break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n\n            do\n            {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.')\n            {\n                while ((c = read()) >= '0' && c <= '9')\n                {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg)\n                return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n\n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n\n        public int[] nextArray(int n) throws IOException\n        {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n    }\n    static boolean primeCheck(long num0)\n    {\n        boolean b1 = true;\n        if(num0==1)\n        {\n            b1=false;\n        }\n        else\n        {\n            int num01 = (int) (Math.sqrt(num0)) + 1;\n            me1: for (int i = 2; i < num01; i++)\n            {\n                if (num0 % i == 0)\n                {\n                    b1 = false;\n                    break me1;\n                }\n            }\n        }\n        return b1;\n    }\n    static HashMap<Long,Long> primeDivisor(long num0)\n    {\n        HashMap<Long,Long> hMap0=new HashMap<>();\n        long count1=0;\n        while(num0%2==0)\n        {\n            count1++;\n            num0/=2;\n        }\n        if(count1>0)\n        {\n            hMap0.put((long)2,count1);\n        }\n        for(long i=3;i<Math.sqrt(num0)+1;i++)\n        {\n            long count2=0;\n            while(num0%i==0)\n            {\n                count2++;\n                num0/=i;\n            }\n            if(count2>0)\n            {\n                hMap0.put(i,count2);\n            }\n        }\n        if(num0>2)\n        {\n            hMap0.put(num0,1L);\n        }\n        return hMap0;\n    }\n\n    static long GCD (long num0,long num00)\n    {\n        BigInteger big1=BigInteger.valueOf(num0);\n        BigInteger big2=BigInteger.valueOf(num00);\n        big1=big1.gcd(big2);\n        long num000=Long.parseLong(big1.toString());\n        return num000;\n    }\n\n    static long power1 (long num0,long num00)\n    {\n        long res1 = 1;\n        while (num00 > 0)\n        {\n            if (num00 % 2 != 0)\n            {\n                res1 = (res1 * (num0 % 100006)) % 1000016;\n            }\n            num0 *= num0;\n            num0 %= 1000016;\n            num00 /= 2;\n        }\n        return res1;\n    }\n\n    static HashSet<Integer> primeDivi(int num0)\n    {\n        HashSet<Integer> hSet1=new HashSet<>();\n        int num00=(int)Math.sqrt(num0);\n        hSet1.add(1);\n        for(int i=2;i<num00+1;i++)\n        {\n            if(num0%i==0)\n            {\n                hSet1.add(i);\n                hSet1.add(num0/i);\n            }\n        }\n        return hSet1;\n    }\n\n    static int nCrModp(int n, int r, int p)\n    {\n        int C[]=new int[r+1];\n        Arrays.fill(C,0);\n        C[0] = 1;\n\n        for (int i = 1; i <= n; i++)\n        {\n\n            for (int j = Math.min(i, r); j > 0; j--)\n            {\n                C[j] = (C[j] + C[j - 1]) % p;\n            }\n        }\n        return C[r];\n    }\n\n    static long gcd(long num0,long num00)\n    {\n        if(num00==0)\n        {\n            return num0;\n        }\n        return gcd(num00,num0%num00);\n    }\n\n\n    static boolean heapCheck(int arr[], int i, int n) {\n        if (i > (n - 2) / 2) {\n            return true;\n        }\n\n        if (arr[i] >= arr[2 * i + 1] && arr[i] >= arr[2 * i + 2]\n                && heapCheck(arr, 2 * i + 1, n) && heapCheck(arr, 2 * i + 2, n)) {\n            return true;\n        }\n        return false;\n    }\n\n    static class Node\n    {\n        int data;\n        Node left,right;\n        Node(int data0)\n        {\n            this.data=data0;\n            this.left=null;\n            this.right=null;\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        Reader r = new Reader();\n        //PrintWriter writer=new PrintWriter(System.out);\n        //Scanner r = new Scanner(new BufferedReader(new InputStreamReader(System.in)));\n        OutputWriter77 out77=new OutputWriter77(System.out);\n\n        int num1=r.nextInt();\n        int num2=r.nextInt();\n        long price=0;\n        long tank=0;\n        me1: for(int i=1;i<num1;i++)\n        {\n\n            price+=(num2-tank)*i;\n            tank=num2;\n            //System.out.println(price+\" \"+tank);\n            if(tank>=(num1-i))\n            {\n                break me1;\n            }\n\n            tank--;\n        }\n        if(num2>num1)\n        {\n            price=num1-1;\n        }\n        if(num2==num1)\n        {\n            price=num1-1;\n        }\n        out77.print(price+\"\\n\");\n        r.close();\n        out77.close();\n\n\n    }\n}\nclass OutputWriter77\n{\n    BufferedWriter writer;\n\n    public OutputWriter77(OutputStream stream)\n    {\n        writer = new BufferedWriter(new OutputStreamWriter(stream));\n    }\n\n    public void print(int i) throws IOException\n    {\n        writer.write(i + \"\");\n    }\n\n    public void println(int i) throws IOException\n    {\n        writer.write(i + \"\\n\");\n    }\n\n    public void print(String s) throws IOException\n    {\n        writer.write(s + \"\");\n    }\n\n    public void println(String s) throws IOException\n    {\n        writer.write(s + \"\\n\");\n    }\n\n    public void print(char[] c) throws IOException\n    {\n        writer.write(c);\n    }\n\n    public void close() throws IOException\n    {\n        writer.flush();\n        writer.close();\n    }\n}", "label": 1}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\n \n \npublic class CodingLegacy {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Palindrome solver = new Palindrome();\n        solver.solve(1, in, out);\n        out.close();\n    }\n \n    static class Palindrome {\n \n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n \n            int n =in.nextInt();\n            int v =in.nextInt();\n \n \n            if(v +1 >= n){\n                out.println(Math.min(v,n-1));\n            }else{\n                n=n-v -1;\n                int cost = v;\n                int i =2;\n                while(n-->0){\n                    cost += i;\n                    i++;\n                }\n                out.println(cost);\n            }\n        }\n \n        private static long gcd(long a, long b)\n        {\n            if (a == 0)\n                return b;\n            return gcd(b % a, a);\n        }\n    }\n \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n \n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n \n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n \n        public int nextInt(){\n            return Integer.parseInt(next());\n        }\n \n        public Long nextLong(){\n            return Long.parseLong(next());\n        }\n    }\n}", "label": 1}
{"src": "var nv = readline().split(' ').map((v)=>(parseInt(v)));\nvar n = nv[0];\nvar v = nv[1];\n\n\nvar res = Math.min(n-1, v); //1st city\nvar c = Math.min(n-1, v);\n\nvar literPrice = 1// - citiesLeft\n\nfor(var i=1;i<=n;i++) {\n    \n    //print('city#', i, n-i, c)\n    if (c <(n-i) && c<v) {\n        var fuel = Math.min(v-c, n-i);\n        c+= fuel;\n        res+= fuel*i;\n//        print('fuel', fuel, i, fuel*i)\n    }\n    c--;\n}\n\nprint(res)", "label": 1}
{"src": "import java.util.Scanner;\n\n/**\n *\n * @author Acer\n */\npublic class SashaAndHisTrip {\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int v = sc.nextInt();\n        int x = n-1;\n        int f = Math.min(x, v);\n        int p = Math.min(x, v);\n        int count = 1;\n        for(int i = 0; i <= x; i++){\n            if(f == x){\n               break; \n            }\n            count++;\n            p+=count;\n            f++;\n        }\n        System.out.println(p);\n    }\n    \n}", "label": 1}
{"src": "import java.util.Scanner;\npublic class Div2 {\n    public static void main(String args[]){\n        Scanner in=new Scanner(System.in);\n        int n=in.nextInt(), v=in.nextInt(), dollars=v>n-1?n-1:v;\n        if(v>=n-1){\n            System.out.print(n-1);\n            return;\n        }\n\n        for(int i=2;i<=n;i++){\n            dollars+=i;\n            if(v>=(n-i)){\n            System.out.print(dollars);\n            return;\n        }\n        }\n        System.out.print(dollars);\n    }\n}\n", "label": 1}
{"src": "import java.lang.reflect.Array;\nimport java.util.*;\nimport java.io.*;\n\npublic class Main {\n//            File file = new File(\"input.txt\");\n//            Scanner in = new Scanner(file);\n//            PrintWriter out = new PrintWriter(new FileWriter(\"output.txt\"));\n    public static void main(String[] args) {\n//        Scanner in = new Scanner(System.in);\n        FastReader in = new FastReader();\n\n        int n = in.nextInt(), v = in.nextInt();\n        int distance = n-v;\n        if(v >= n-1){\n            System.out.println(n-1);\n        }else{\n            int money = 1*v - 1 + distance*(distance+1)/2;\n            System.out.println(money);\n        }\n\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "label": 1}
{"src": "import java.util.*;\npublic class SashaAndHisTrip {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt(),v=sc.nextInt();\n\t\tif(n-1<=v) {\n\t\t\tSystem.out.println(n-1);return;\n\t\t}\n\t\tint cnt=v-1;\n\t\tfor(int i=1;i<=n-v;i++)cnt+=i;\n\t\tSystem.out.println(cnt);\n\t\t\n\n\t}\n\n}", "label": 1}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Solution\n{\n    static class A{\n        int index;\n        int count;\n        A(int index,int count)\n        {\n            this.index=index;\n            this.count=count;\n        }\n    }\n\tpublic static void main (String[] args)\n\t{\n            FastReader s1 = new FastReader();\n            int n = s1.I()-1;\n            int v=s1.I();\n            int sum=0;\n            int capacity=v;\n            int cost=1;\n            if(n<=v)\n            {\n                sum=n;\n            }\n            else{\n                sum=n;\n                v=1;\n            while(n>capacity)\n            {\n                sum+=cost*v;\n             //   System.out.println(cost+\" \"+v+\" \"+sum);\n                cost++;\n                n--;\n            }\n            }\n            System.out.println(sum);\n\t}\n//        static int getFirst(ArrayList<A> a,int j)\n//        {\n//            for(int i=j)\n//        }\n\tstatic class FastReader{\n        BufferedReader br; \n        StringTokenizer st; \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int I() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long L() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double D() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n    static int gcd(int a,int b)\n\t\t{\n\t\t    if(a%b==0)\n\t\t    return b;\n\t\t    return gcd(b,a%b);\n\t\t}\n\tstatic float power(float x, int y) \n    { \n        float temp; \n        if( y == 0) \n            return 1; \n        temp = power(x, y/2);  \n          \n        if (y%2 == 0) \n            return temp*temp; \n        else\n        { \n            if(y > 0) \n                return x * temp * temp; \n            else\n                return (temp * temp) / x; \n        } \n    } \n    static long pow(int a,int b)\n    {\n        long result=1;\n        if(b==0)\n        return 1;\n        long x=a;\n        while(b>0)\n        {\n            if(b%2!=0)\n            result*=x;\n            \n            x=x*x;\n            b=b/2;\n        }\n        return result;\n    }\n    \n    static ArrayList<Integer> sieveOfEratosthenes(int n) \n    { \n        ArrayList<Integer> arr=new ArrayList<Integer>();\n        boolean prime[] = new boolean[n+1]; \n        for(int i=2;i<n;i++) \n            prime[i] = true; \n          \n        for(int p = 2; p*p <=n; p++) \n        { \n            if(prime[p] == true) \n            { \n                arr.add(p);\n                for(int i = p*p; i <= n; i += p) \n                    prime[i] = false; \n            } \n        } \n        return arr;\n    } \n}", "label": 1}
{"src": "import java.util.*;\npublic class sah{\n\tpublic static void main(String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint n=sc.nextInt();\n\t\tint v=sc.nextInt();\n\t\tint c=n;\n\t\tint cp=v;\n\t\tint i=1,r=0;\n\t\twhile(true){\n\t\t\tif(c-1<cp){\n\t\t\t\tr=r+(i)*(c-1);\n\t\t\t\tcp=cp-(c-1);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tr=r+i*cp;\n\t\t\t\tcp=0;\n\t\t\t}\n\t\t\tif(v-cp==c-1){\n\t\t\t\tSystem.out.println(r);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ti++;\n\t\t\tcp++;\n\t\t\tc--;\n\t\t}\n\t}\n}", "label": 1}
{"src": "\n/**\n * Date: 16 Feb, 2019\n * Link:\n *\n * @author Prasad-Chaudhari\n * @linkedIn: https://www.linkedin.com/in/prasad-chaudhari-841655a6/\n * @git: https://github.com/Prasad-Chaudhari\n */\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\n\npublic class newProgram3 {\n\n    public static void main(String[] args) throws IOException {\n        // TODO code application logic here\n        FastIO in = new FastIO();\n        int n = in.ni();\n        int v = in.ni();\n        if (n <= v + 1) {\n            System.out.println(Math.min(n-1, v));\n        } else {\n            int cost = v;\n            for (int i = 2; i <= n - v; i++) {\n                cost += i;\n            }\n            System.out.println(cost);\n        }\n    }\n\n    static class FastIO {\n\n        private final BufferedReader br;\n        private final BufferedWriter bw;\n        private String s[];\n        private int index;\n        private StringBuilder sb;\n\n        public FastIO() throws IOException {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            bw = new BufferedWriter(new OutputStreamWriter(System.out, \"UTF-8\"));\n            s = br.readLine().split(\" \");\n            sb = new StringBuilder();\n            index = 0;\n        }\n\n        public int ni() throws IOException {\n            return Integer.parseInt(nextToken());\n        }\n\n        public double nd() throws IOException {\n            return Double.parseDouble(nextToken());\n        }\n\n        public long nl() throws IOException {\n            return Long.parseLong(nextToken());\n        }\n\n        public String next() throws IOException {\n            return nextToken();\n        }\n\n        public String nli() throws IOException {\n            try {\n                return br.readLine();\n            } catch (IOException ex) {\n\n            }\n            return null;\n        }\n\n        public int[] gia(int n) throws IOException {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public int[] gia(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            int a[] = new int[n];\n            for (int i = start; i < end; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public double[] gda(int n) throws IOException {\n            double a[] = new double[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nd();\n            }\n            return a;\n        }\n\n        public double[] gda(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            double a[] = new double[n];\n            for (int i = start; i < end; i++) {\n                a[i] = nd();\n            }\n            return a;\n        }\n\n        public long[] gla(int n) throws IOException {\n            long a[] = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nl();\n            }\n            return a;\n        }\n\n        public long[] gla(int n, int start, int end) throws IOException {\n            validate(n, start, end);\n            long a[] = new long[n];\n            for (int i = start; i < end; i++) {\n                a[i] = nl();\n            }\n            return a;\n        }\n\n        public int[][][] gwtree(int n) throws IOException {\n            int m = n - 1;\n            int adja[][] = new int[n + 1][];\n            int weight[][] = new int[n + 1][];\n            int from[] = new int[m];\n            int to[] = new int[m];\n            int count[] = new int[n + 1];\n            int cost[] = new int[n + 1];\n            for (int i = 0; i < m; i++) {\n                from[i] = i + 1;\n                to[i] = ni();\n                cost[i] = ni();\n                count[from[i]]++;\n                count[to[i]]++;\n            }\n            for (int i = 0; i <= n; i++) {\n                adja[i] = new int[count[i]];\n                weight[i] = new int[count[i]];\n            }\n            for (int i = 0; i < m; i++) {\n                adja[from[i]][count[from[i]] - 1] = to[i];\n                adja[to[i]][count[to[i]] - 1] = from[i];\n                weight[from[i]][count[from[i]] - 1] = cost[i];\n                weight[to[i]][count[to[i]] - 1] = cost[i];\n                count[from[i]]--;\n                count[to[i]]--;\n            }\n            return new int[][][]{adja, weight};\n        }\n\n        public int[][][] gwg(int n, int m) throws IOException {\n            int adja[][] = new int[n + 1][];\n            int weight[][] = new int[n + 1][];\n            int from[] = new int[m];\n            int to[] = new int[m];\n            int count[] = new int[n + 1];\n            int cost[] = new int[n + 1];\n            for (int i = 0; i < m; i++) {\n                from[i] = ni();\n                to[i] = ni();\n                cost[i] = ni();\n                count[from[i]]++;\n                count[to[i]]++;\n            }\n            for (int i = 0; i <= n; i++) {\n                adja[i] = new int[count[i]];\n                weight[i] = new int[count[i]];\n            }\n            for (int i = 0; i < m; i++) {\n                adja[from[i]][count[from[i]] - 1] = to[i];\n                adja[to[i]][count[to[i]] - 1] = from[i];\n                weight[from[i]][count[from[i]] - 1] = cost[i];\n                weight[to[i]][count[to[i]] - 1] = cost[i];\n                count[from[i]]--;\n                count[to[i]]--;\n            }\n            return new int[][][]{adja, weight};\n        }\n\n        public int[][] gtree(int n) throws IOException {\n            int adja[][] = new int[n + 1][];\n            int from[] = new int[n - 1];\n            int to[] = new int[n - 1];\n            int count[] = new int[n + 1];\n            for (int i = 0; i < n - 1; i++) {\n                from[i] = i + 1;\n                to[i] = ni();\n                count[from[i]]++;\n                count[to[i]]++;\n            }\n            for (int i = 0; i <= n; i++) {\n                adja[i] = new int[count[i]];\n            }\n            for (int i = 0; i < n - 1; i++) {\n                adja[from[i]][--count[from[i]]] = to[i];\n                adja[to[i]][--count[to[i]]] = from[i];\n            }\n            return adja;\n        }\n\n        public int[][] gg(int n, int m) throws IOException {\n            int adja[][] = new int[n + 1][];\n            int from[] = new int[m];\n            int to[] = new int[m];\n            int count[] = new int[n + 1];\n            for (int i = 0; i < m; i++) {\n                from[i] = ni();\n                to[i] = ni();\n                count[from[i]]++;\n                count[to[i]]++;\n            }\n            for (int i = 0; i <= n; i++) {\n                adja[i] = new int[count[i]];\n            }\n            for (int i = 0; i < m; i++) {\n                adja[from[i]][--count[from[i]]] = to[i];\n                adja[to[i]][--count[to[i]]] = from[i];\n            }\n            return adja;\n        }\n\n        public void print(String s) throws IOException {\n            bw.write(s);\n        }\n\n        public void println(String s) throws IOException {\n            bw.write(s);\n            bw.newLine();\n        }\n\n        private String nextToken() throws IndexOutOfBoundsException, IOException {\n            if (index == s.length) {\n                s = br.readLine().split(\" \");\n                index = 0;\n            }\n            return s[index++];\n        }\n\n        private void validate(int n, int start, int end) {\n            if (start < 0 || end >= n) {\n                throw new IllegalArgumentException();\n            }\n        }\n    }\n\n    static class Data implements Comparable<Data> {\n\n        int a, b;\n\n        public Data(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n\n        @Override\n        public int compareTo(Data o) {\n            if (a == o.a) {\n                return Integer.compare(b, o.b);\n            }\n            return Integer.compare(a, o.a);\n        }\n\n        public static void sort(int a[]) {\n            Data d[] = new Data[a.length];\n            for (int i = 0; i < a.length; i++) {\n                d[i] = new Data(a[i], 0);\n            }\n            Arrays.sort(d);\n            for (int i = 0; i < a.length; i++) {\n                a[i] = d[i].a;\n            }\n        }\n    }\n}\n", "label": 1}
{"src": "import java.util.*;\nimport java.io.*;\npublic class A {\n\tpublic static void main(String args[]) {\n\t\tFastScanner in = new FastScanner();\n\t\tint n=in.nextInt();\n\t\tint v=in.nextInt();\n\t\tint ans=Math.min(v, n-1);\n\t\tfor(int i=2;i<=n-v;i++) {\n\t\t\tans=ans+i;\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n\n\t///////////////////////////\n\tstatic class FastScanner {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\ta[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}\n", "label": 1}
{"src": "import java.util.*;\nimport java.io.*;\n        public class Main{\n            public static void main(String[] args)\n            {\n                System.out.println(0+\"\\n\"+1+\"\\n\"+1+\"\\n\"+0+\"\\n\"+1+\"\\n\"+1+\"\\n\"+0+\"\\n\"+1+\"\\n\"+1+\"\\n\"+1+\"\\n\"+1+\"\\n\"+1+\"\\n\"+0+\"\\n\"+1+\"\\n\"+0+\"\\n\"+1+\"\\n\"+1+\"\\n\"+1+\"\\n\"+0+\"\\n\"+1+\"\\n\"+1+\"\\n\"+1+\"\\n\"+1+\"\\n\"+1+\"\\n\"+0+\"\\n\"+1+\"\\n\"+0+\"\\n\"+1+\"\\n\"+1+\"\\n\"+1);\n            }\n        }", "label": 0}
{"src": "public class CodeForces1April2019E {\n    public static void main(String[] args) {\n        for (int i = 21; i < 51; i++) {\n            System.out.println(((Math.min(i, 25) + i) % (2 + i % 3)) > 0 ? 1 : 0);\n        }\n    }\n\n}\n", "label": 0}
{"src": "import static java.lang.Math.min;\n\npublic class FourierDoddles {\n    public static void main(String[] args) {\n        for (int i = 21; i <= 50 ; i++) {\n            if(((min(i, 25) + i) % (2 + i % 3)) > 0){\n                System.out.println(\"1\");\n            }\n            else System.out.println(0);\n//            System.out.println( ((min(i, 25) + i) % (2 + i % 3)) > 0 );\n        }\n    }\n}\n", "label": 0}
{"src": "print(\"0\\n1\\n1\\n0\\n1\\n1\\n0\\n1\\n1\\n1\\n1\\n1\\n0\\n1\\n0\\n1\\n1\\n1\\n0\\n1\\n1\\n1\\n1\\n1\\n0\\n1\\n0\\n1\\n1\\n1\");\n", "label": 0}
{"src": "import java.util.*;\nimport java.io.*;\n \npublic class SolutionA{\n      public static void main(String[] args){\n          Scanner sc=new Scanner(System.in);\n          int t=sc.nextInt();\n          while(t-->0){\n             int n=sc.nextInt();\n             int[] ar=new int[n];\n             int[] br=new int[n];\n             int sum=0,sume=0;\n             for(int i=0;i<n;i++){\n                 ar[i]=sc.nextInt();\n                 sum+=ar[i];\n             }\n             for(int j=0;j<n;j++){\n                 br[j]=sc.nextInt();\n                 sume+=br[j];\n             }\n             if(sum!=sume){\n                 System.out.println(\"-1\");\n             }\n             else{\n                 ArrayList<Pair> ans=new ArrayList<>();\n                 int fix=10;\n                 while(fix-->0){\n                     \n                 for(int i=0;i<n;i++){\n                    if(ar[i]>br[i]){\n                             int pos=-1;\n                             int min=1000;\n                             for(int j=0;j<n;j++){\n                             if(ar[j]<br[j]){\n                                 min=br[j];\n                                 pos=j;\n                             }\n                           }\n                          int v=br[pos];\n                           while(pos>=0 &&ar[i]!=br[i] && ar[pos]<min ){\n                                 ans.add(new Pair(i+1,pos+1));\n                               ar[i]--;\n                               ar[pos]++;\n                              \n                              v--;\n                           }\n                         }\n                     }\n                 \n                 boolean ok=false;\n                 for(int i=0;i<n;i++)if(ar[i]!=br[i])ok=true;\n                // for(int i=0;i<n;i++)System.out.println(ar[i]+\" \");\n                  if(ok==false)break;\n                 \n                 }\n                 System.out.println(ans.size());\n                 for(int i=0;i<ans.size();i++){\n                     System.out.println(ans.get(i).x+\" \"+ans.get(i).y);\n                 }\n                 \n             }\n              \n          }\n      }\n}\nclass Pair{\n    int x, y;\n     Pair(int x,int y){\n        this.x=x;\n        this.y=y;\n     }\n}", "label": 3}
{"src": "\nimport java.util.*;\nimport java.lang.*;\n\npublic class GFG {\n\tpublic static void main (String[] args) {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint t=sc.nextInt();\n\t\tfor(int o=0;o<t;o++){\n\t\t    int N=sc.nextInt();\n\t\t    int[] A1=new int[N];\n\t\t    int[] B1=new int[N];\n\t\t    for(int i=0;i<N;i++){\n\t\t        A1[i]=sc.nextInt();\n\t\t    }\n\t\t    for(int i=0;i<N;i++){\n\t\t        B1[i]=sc.nextInt();\n\t\t    }\n\t\t    int sum=0;\n\t\t    Array(N,A1,B1,sum);\n\t\t}\n\t}\n\tstatic void Array(int n,int[] a,int[] b,int s){\n\t    for(int i=0;i<n;i++){\n\t        a[i]=a[i]-b[i];\n\t        s+=a[i];\n\t    }\n\t    if(s!=0){\n\t        System.out.println(-1);\n\t        return;\n\t    }\n\t    ArrayList<Integer> is=new ArrayList<Integer>();\n\t    ArrayList<Integer> js=new ArrayList<Integer>();\n\t    for (int i = 0; i < n; i++)\n\t    {\n\t\tif (a[i] > 0)\n\t\t    {\n\t\t\tfor (int j = 0; j < a[i]; j++)\n\t\t\t\tis.add(i);\n\t\t    }\n\t    }\n\t    for (int i = 0; i < n; i++)\n\t    {\n\t\tif (a[i] < 0)\n\t\t    {\n\t\t\tfor (int j = 0; j < Math.abs(a[i]); j++)\n\t\t\t\tjs.add(i);\n\t\t    }\n\t    }\n\t    System.out.println(is.size());\n\t\tfor(int i=0;i<is.size();i++){\n\t\t  System.out.println((is.get(i)+1)+\" \"+(js.get(i)+1));\n\t\t}\n\t    \n\t}\n}", "label": 3}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class AquaMoon_and_Two_Arrays {\n    static class RealScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) a[i] = nextInt();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n    public static final class Pair<T1, T2> {\n        public T1 first;\n        public T2 second;\n\n        public Pair() {\n            first = null;\n            second = null;\n        }\n\n        public Pair(T1 firstValue, T2 secondValue) {\n            first = firstValue;\n            second = secondValue;\n        }\n\n        public Pair(Pair<T1, T2> pair) {\n            first = pair.first;\n            second = pair.second;\n        }\n\n    }\n    public static void main(String[] args) {\n        RealScanner sc = new RealScanner();\n        int t = sc.nextInt();\n        while (t-- > 0) {\n            int n = sc.nextInt();\n            List<Integer> l1 = new ArrayList<>();\n            List<Integer> l2 = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                l1.add(sc.nextInt());\n            }\n            for (int i = 0; i < n; i++) {\n                l2.add(sc.nextInt());\n            }\n\n            List<Pair<Integer, Integer>> ans = new ArrayList<>();\n            List<Pair<Integer, Integer>> l = new ArrayList<>();\n            List<Pair<Integer, Integer>> r = new ArrayList<>();\n            int s1 = 0, s2 = 0;\n            for (int i = 0; i < n; i++) {\n                if (l1.get(i) < l2.get(i)) {\n                    l.add(new Pair(i, l2.get(i) - l1.get(i)));\n                } else if (l1.get(i) > l2.get(i)) {\n                    r.add(new Pair(i, l1.get(i) - l2.get(i)));\n                }\n                s1 += l1.get(i);\n                s2 += l2.get(i);\n            }\n            if (s1 != s2) {\n                System.out.println(-1);\n                continue;\n            }\n\n            int x = 0;\n            int y = 0;\n            while (x < l.size() && y < r.size()) {\n                int c = Math.min(l.get(x).second, r.get(y).second);\n                for (int i = 0; i < c; i++) {\n                    ans.add(new Pair(l.get(x).first, r.get(y).first));\n                }\n                l.get(x).second -= c;\n                r.get(y).second -= c;\n                if (l.get(x).second == 0) x++;\n                if (r.get(y).second == 0) y++;\n            }\n            if (x == l.size() && y == r.size()) {\n                System.out.println(ans.size());\n                for (int i = 0; i < ans.size(); i++) {\n                    System.out.println(ans.get(i).second + 1 + \" \" + (ans.get(i).first + 1));\n                }\n            } else {\n                System.out.println(-1);\n            }\n        }\n    }\n}\n", "label": 3}
{"src": "import java.util.ArrayList;\nimport java.util.Scanner;\n\n/**\n *\n * @author Acer\n */\npublic class AquamoonAndTwoArrays {\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int T = sc.nextInt();\n        while(T-- > 0){\n            int n = sc.nextInt();\n            int a[] = new int[n];\n            int b[] = new int[n];\n            long sum1 = 0, sum2 = 0;\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextInt();\n                sum1+=a[i];\n            }\n            \n            for (int i = 0; i < n; i++) {\n                b[i] = sc.nextInt();\n                sum2+=b[i];\n            }\n            \n            if(sum1 != sum2){\n                System.out.println(-1);\n                continue;\n            }\n            \n            ArrayList<Integer> arr1 = new ArrayList<Integer>();\n            ArrayList<Integer> arr2 = new ArrayList<Integer>();\n            for (int i = 0; i < n; i++) {\n                if(a[i] > b[i]){\n                    int dif = a[i] - b[i];\n                    for (int j = 0; j < dif; j++) {\n                        arr1.add(i+1);\n                    }\n                }\n                if(a[i] < b[i]){\n                    int dif = b[i] - a[i];\n                    for (int j = 0; j < dif; j++) {\n                        arr2.add(i+1);\n                    }\n                }\n            }\n            \n            if(arr1.size() == 0){\n                System.out.println(0);\n            }\n            else{\n                System.out.println(arr1.size());\n                for (int i = 0; i < arr1.size(); i++) {\n                    System.out.println(arr1.get(i)+\" \"+arr2.get(i));\n                }\n            }\n            \n            //System.out.println(arr1.size()+\" \"+arr2.size());\n        }\n    }\n    \n}", "label": 3}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Codeforces {\n    static FastReader sc=new FastReader();\n\tstatic PrintWriter out=new PrintWriter(System.out);\n\tstatic long mod=1000000007;\n\tstatic long mod1=998244353;\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tint t=I();\n\t\twhile(t-->0)\n\t\t{\n\t\t\tint n=I();\n\t\t\tint a[]=new int[n];\n\t\t\tint b[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ta[i]=I();\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tb[i]=I();\n\t\t\t}\n\t\t\tArrayList<Integer> inc=new ArrayList<>();\n\t\t\tArrayList<Integer> dec=new ArrayList<>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(a[i]>b[i]){\n\t\t\t\t\tfor(int j=0;j<a[i]-b[i];j++){\n\t\t\t\t\t\tdec.add(i);\n\t\t\t\t\t}\n\t\t\t\t}else if(a[i]<b[i]){\n\t\t\t\t\tfor(int j=0;j<b[i]-a[i];j++){\n\t\t\t\t\t\tinc.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(inc.size()==dec.size()){\n\t\t\t\tout.println(inc.size());\n\t\t\t\tfor(int i=0;i<inc.size();i++){\n\t\t\t\t\tout.println((dec.get(i)+1)+\" \"+(inc.get(i)+1));\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tout.println(\"-1\");\n\t\t\t}\n\t\t}\n\t\tout.close();\n\t}\n\tpublic static long kadane(long a[],int n)\n\t{\n\t\tlong max_sum=Long.MIN_VALUE,max_end=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tmax_end+=a[i];\n\t\t\tif(max_sum<max_end){max_sum=max_end;}\n\t\t\tif(max_end<0){max_end=0;}\n\t\t}\n\t\treturn max_sum;\n\t}\n\tpublic static void DFS(ArrayList<Integer> arr[],int s,boolean visited[])\n\t{\n\t\tvisited[s]=true;\n\t\tfor(int i:arr[s]){\n\t\t\tif(!visited[i]){\n\t\t\t\tDFS(arr,i,visited);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static int BS(long a[],long x,int ii,int jj)\n\t{\n\t\t// int n=a.length;\n\t\tint mid=0;\n\t\tint i=ii,j=jj;\n\t\twhile(i<j)\n\t\t{\n\t\t\tmid=(i+j)/2;\n\t\t\tif(a[mid]>x)\n\t\t\tj=mid-1;\n\t\t\telse if(a[mid]<x)\n\t\t\ti=mid+1;\n\t\t\telse return mid;\n\t\t}\n\t\tif(a[i]>x)\n\t\treturn i-1;\n\t\treturn i;\n\t}\n\tpublic static ArrayList<Integer> prime(int n)\n\t{\n\t    ArrayList<Integer> arr=new ArrayList<>();\n\t    boolean prime[] = new boolean[n + 1];\n        for (int i = 0; i <= n; i++)\n        prime[i] = true;\n        for (int p = 2; p * p <= n; p++)\n        {\n            if (prime[p] == true)\n            {\n                for (int i = p * p; i <= n; i += p)\n                prime[i] = false;\n            }\n        }\n        for (int i = 2; i <= n; i++)\n        {\n            if (prime[i] == true)\n            arr.add(i);\n        }\n        return arr;\n\t}\n\tpublic static HashSet<Integer> primeSet(int n)\n\t{\n\t    HashSet<Integer> arr=new HashSet<>();\n\t    boolean prime[] = new boolean[n + 1];\n        for (int i = 0; i <= n; i++)\n        prime[i] = true;\n        for (int p = 2; p * p <= n; p++)\n        {\n            if (prime[p] == true)\n            {\n                for (int i = p * p; i <= n; i += p)\n                prime[i] = false;\n            }\n        }\n        for (int i = 2; i <= n; i++)\n        {\n            if (prime[i] == true)\n            arr.add(i);\n        }\n        return arr;\n\t}\n\n\t// Fenwick / BinaryIndexed  Tree  USE IT - FenwickTree ft1=new FenwickTree(n);\n\tpublic static class FenwickTree\n\t{\n\t\tlong farr[];\n\t\tint n;\n\t\tpublic FenwickTree(int c)\n\t\t{\n\t\t\tn=c+1;\n\t\t\tfarr=new long[n];\n\t\t}\n\t\tpublic void update_range(int l,int r,long p)\n\t\t{\n\t\t\tupdate(l,p);\n\t\t\tupdate(r+1,(-1)*p);\n\t\t}\n\t\tpublic void update(int x,long p)\n\t\t{\n\t\t\tfor(;x<n;x+=x&(-x))\n\t\t\t{\n\t\t\t\tfarr[x]+=p;\n\t\t\t}\n\t\t}\n\t\tpublic long get(int x)\n\t\t{\n\t\t\tlong ans=0;\n\t\t\tfor(;x>0;x-=x&(-x))\n\t\t\t{\n\t\t\t\tans=ans+farr[x];\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\t//Disjoint Set Union\n\tpublic static class DSU\n\t{\n\t    static int par[],rank[];\n\t    public DSU(int c)\n\t    {\n\t        par=new int[c+1];\n\t        rank=new int[c+1];\n\t        for(int i=0;i<=c;i++)\n\t        {\n\t            par[i]=i;\n\t            rank[i]=0;\n\t        }\n\t    }\n\t    public static int find(int a)\n\t    {\n\t        if(a==par[a])\n\t        return a;\n\t        return par[a]=find(par[a]);\n\t    }\n\t    public static void union(int a,int b)\n\t    {\n\t        int a_rep=find(a),b_rep=find(b);\n\t        if(a_rep==b_rep)\n\t        return;\n\t        if(rank[a_rep]<rank[b_rep])\n\t        par[a_rep]=b_rep;\n\t        else if(rank[a_rep]>rank[b_rep])\n\t        par[b_rep]=a_rep;\n\t        else\n\t        {\n\t            par[b_rep]=a_rep;\n\t            rank[a_rep]++;\n\t        }\n\t    }\n\t}\n\n\t//SEGMENT TREE CODE\n\n\t// public static void segmentUpdate(int si,int ss,int se,int qs,int qe,long x)\n\t// {\n\t// \tif(ss>qe || se<qs)return;\n\t// \tif(qs<=ss && qe>=se)\n\t// \t{\n\t// \t\tseg[si][0]+=1L;\n\t// \t\tseg[si][1]+=x*x;\n\t// \t\tseg[si][2]+=2*x;\n\t// \t\treturn;\n\t// \t}\n\t// \tint mid=(ss+se)/2;\n\t// \tsegmentUpdate(2*si+1,ss,mid,qs,qe,x);\n\t// \tsegmentUpdate(2*si+2,mid+1,se,qs,qe,x);\n\t// }\n\t// public static long segmentGet(int si,int ss,int se,int x,long f,long s,long t,long a[])\n\t// {\n\t// \tif(ss==se && ss==x)\n\t// \t{\n\t// \t\tf+=seg[si][0];\n\t// \t\ts+=seg[si][1];\n\t// \t\tt+=seg[si][2];\n\t// \t\tlong ans=a[x]+(f*((long)x+1L)*((long)x+1L))+s+(t*((long)x+1L));\n\t// \t\treturn ans;\n\t// \t}\n\t// \tint mid=(ss+se)/2;\n\t// \tif(x>mid){\n\t// \t\treturn segmentGet(2*si+2,mid+1,se,x,f+seg[si][0],s+seg[si][1],t+seg[si][2],a);\n\t// \t}else{\n\t// \t\treturn segmentGet(2*si+1,ss,mid,x,f+seg[si][0],s+seg[si][1],t+seg[si][2],a);\n\t// \t}\n\t// }\n\n\tpublic static class pair\n    {\n    \tint a;\n    \tint b;\n    \tpublic pair(int val,int index)\n    \t{\n    \t    a=val;\n    \t    b=index;\n    \t}\n    }\n\tpublic static class myComp implements Comparator<pair>\n\t{\n\t\t//sort in ascending order.\n\t\t// public int compare(pair p1,pair p2)\n\t\t// {\n\t\t// \tif(p1.a==p2.a)\n    \t//     return 0;\n    \t//     else if(p1.a<p2.a)\n    \t//     return -1;\n    \t//     else\n    \t//     return 1;\n\t\t// }\n\t\t//sort in descending order.\n\t\tpublic int compare(pair p1,pair p2)\n    \t{\n    \t    if(p1.a==p2.a)\n    \t    return 0;\n    \t    else if(p1.a<p2.a)\n    \t    return 1;\n    \t    else\n    \t    return -1;\n    \t}\n\t}\n    public static class myComp1 implements Comparator<pair1>\n    {\n\t\t//sort in ascending order.\n    \tpublic int compare(pair1 p1,pair1 p2)\n    \t{\n    \t    if(p1.a==p2.a)\n    \t    return 0;\n    \t    else if(p1.a<p2.a)\n    \t    return -1;\n    \t    else\n    \t    return 1;\n    \t}\n\t\t//sort in descending order.\n\t\t// public int compare(pair p1,pair p2)\n    \t// {\n    \t//     if(p1.a==p2.a)\n    \t//     return 0;\n    \t//     else if(p1.a<p2.a)\n    \t//     return 1;\n    \t//     else\n    \t//     return -1;\n    \t// }\n    }\n\tpublic static class pair1\n    {\n    \tlong a;\n    \tlong b;\n    \tpublic pair1(long val,long index)\n    \t{\n    \t    a=val;\n    \t    b=index;\n    \t}\n    }\n    public static ArrayList<pair1> mergeIntervals(ArrayList<pair1> arr)\n\t{\n\t    //****************use this in main function-Collections.sort(arr,new myComp1());\n\t    ArrayList<pair1> a1=new ArrayList<>();\n\t    if(arr.size()<=1)\n\t    return arr;\n\t    a1.add(arr.get(0));\n\t    int i=1,j=0;\n\t    while(i<arr.size())\n\t    {\n\t        if(a1.get(j).b<arr.get(i).a)\n\t        {\n\t           a1.add(arr.get(i));\n\t           i++;\n\t           j++;\n\t        }\n\t        else if(a1.get(j).b>arr.get(i).a && a1.get(j).b>=arr.get(i).b)\n\t        {\n\t            i++;\n\t        }\n\t        else if(a1.get(j).b>=arr.get(i).a)\n\t        {\n\t            long a=a1.get(j).a;\n\t            long b=arr.get(i).b;\n\t            a1.remove(j);\n\t            a1.add(new pair1(a,b));\n\t            i++;\n\t        }\n\t    }\n\t    return a1;\n\t}\n\tpublic static boolean palindrome(String s,int n)\n\t{\n\t\tfor(int i=0;i<=n/2;i++){\n\t\t\tif(s.charAt(i)!=s.charAt(n-i-1)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static long countDigit(long n)\n\t{\n\t    long sum=0;\n\t    while(n!=0)\n\t    {\n\t        sum++;\n\t        n=n/10;\n\t    }\n\t    return sum;\n\t}\n\tpublic static long digitSum(long n)\n\t{\n\t    long sum=0;\n\t    while(n!=0)\n\t    {\n\t        sum=sum+n%10;\n\t        n=n/10;\n\t    }\n\t    return sum;\n\t}\n\tpublic static long gcd(long a,long b)\n\t{\n\t    if(b==0)\n\t    return a;\n\t    else\n\t    return gcd(b,a%b);\n\t}\n\tpublic static int gcd(int a,int b)\n\t{\n\t    if(b==0)\n\t    return a;\n\t    else\n\t    return gcd(b,a%b);\n\t}\n\tpublic static void printArray(long a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(ArrayList<Long> arr)\n\t{\n\t\tfor(int i=0;i<arr.size();i++){\n\t\t\tout.print(arr.get(i)+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static long pwr(long m,long n)\n\t{\n\t\tlong res=1;\n\t\tm=m%mod;\n\t\tif(m==0)\n\t\treturn 0;\n\t\twhile(n>0)\n\t\t{\n\t\t\tif((n&1)!=0)\n\t\t\t{\n\t\t\t\tres=(res*m)%mod;\n\t\t\t}\n\t\t\tn=n>>1;\n\t\t\tm=(m*m)%mod;\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static void sort(int[] A)\n\t{\n        int n = A.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i)\n\t\t{\n            int tmp = A[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            A[i] = A[randomPos];\n            A[randomPos] = tmp;\n        }\n        Arrays.sort(A);\n    }\n    public static void sort(long[] A)\n\t{\n\t    int n = A.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i)\n\t\t{\n            long tmp = A[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            A[i] = A[randomPos];\n            A[randomPos] = tmp;\n        }\n\t    Arrays.sort(A);\n\t}\n\tpublic static int I(){return sc.I();}\n    public static long L(){return sc.L();}\n    public static String S(){return sc.S();}\n    public static double D(){return sc.D();}\n}\nclass FastReader {  \n    BufferedReader br;\n    StringTokenizer st;\n    public FastReader(){\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n    String next(){\n        while (st == null || !st.hasMoreElements()){\n            try {\n                st = new StringTokenizer(br.readLine());\n            }\n            catch (IOException e){\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    int I(){ \n        return Integer.parseInt(next());\n    }\n    long L(){ \n        return Long.parseLong(next());\n    }\n    double D(){\n         return Double.parseDouble(next());\n    }\n    String S(){\n        String str = \"\";\n        try \n        {\n            str = br.readLine();\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}\n", "label": 3}
{"src": "import java.util.*;\n\npublic class codeforces_aquamoon\n{\n\tpublic static void main(String args[])\n\t{\n\t\tScanner sc = new Scanner(System.in);\n\n\t\tint t, n, i, s, increase, decrease;\n\t\tt = sc.nextInt();\n\t\twhile(t>0)\n\t\t{\n\t\t\tn = sc.nextInt();\n\t\t\tint a[] = new int[n];\n\t\t\tint b[] = new int[n];\n\n\t\t\tfor(i=0; i<n; i++)\n\t\t\t{\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tfor(i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t}\n\n\t\t\tQueue<Integer> queue1 = new LinkedList<Integer>();\n\t\t\tQueue<Integer> queue2 = new LinkedList<Integer>();\n\n\t\t\tdecrease = 0;\n\t\t\tfor(i=0; i<n; i++)\n\t\t\t{\n\t\t\t\ts=0;\n\t\t\t\tif(a[i]>b[i])\n\t\t\t\t{\n\t\t\t\t\ts = a[i]-b[i];\n\t\t\t\t}\n\t\t\t\tdecrease += s;\n\t\t\t\twhile(s!=0)\n\t\t\t\t{\n\t\t\t\t\tqueue1.add(i+1);\n\t\t\t\t\ts--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tincrease = 0;\n\t\t\tfor(i=0; i<n; i++)\n\t\t\t{\n\t\t\t\ts=0;\n\t\t\t\tif(a[i]<b[i])\n\t\t\t\t{\n\t\t\t\t\ts = b[i]-a[i];\n\t\t\t\t}\n\t\t\t\tincrease += s;\n\t\t\t\twhile(s!=0)\n\t\t\t\t{\n\t\t\t\t\tqueue2.add(i+1);\n\t\t\t\t\ts--;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(increase!=decrease)\n\t\t\t\tSystem.out.println(-1);\n\t\t\telse if(increase == 0)\n\t\t\t\tSystem.out.println(0);\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(increase);\n\t\t\t\tfor(i=0; i<increase; i++)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(queue1.remove() + \" \" + queue2.remove());\n\t\t\t\t}\n\t\t\t}\n\t\t\tt--;\n\t\t}\n\t}\n}", "label": 3}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class aquaMoon {\n    public static int sum(int[] a) {\n        int sum = 0;\n        for(int i=0; i<a.length; i++)\n            sum+= a[i];\n        return sum;\n    }\n    public static void main(String[] args) {\n        Scanner sc= new Scanner(System.in);\n        int tCase = sc.nextInt();\n        while(tCase-- >0) {\n            int n = sc.nextInt();\n            int[] a = new int[n];\n            int[] b = new int[n];\n            int[][] res = new int[100][3];\n\n            for(int z = 0; z<n; z++)\n                a[z] = sc.nextInt();\n\n            for(int z = 0; z< n; z++)\n                b[z] = sc.nextInt();\n\n            if(sum(a) != sum(b)){\n                System.out.println(\"-1\");\n                continue;\n            }\n\n//            if( tCase > 60 && tCase < 80 ) {\n//                System.out.println(\"testcase\"+ tCase+ \"    n\"+ n);\n//                System.out.println(Arrays.toString(a));\n//                System.out.println(Arrays.toString(b));\n//\n//            }\n            int i=0, j=0, t=0;\n            while(i!=n-1 || j!=n-1) {\n                while(a[i] <= b[i] && i<n-1) i++;         // i contains index of element to increment;\n                while(a[j] >= b[j] && j<n-1) j++;        // j contains index of element to decrement;\n                int diff = ( (a[i]-b[i]) < (b[j]-a[j]) )? (a[i]-b[i]) : (b[j]-a[j]);\n                a[i] -= diff;\n                a[j] += diff;\n           //     System.out.println(Arrays.toString(a)+ \"i:\"+ i + \"j:\"+ j);\n                res[t][0] = i;\n                res[t][1] = j;\n                res[t][2] = diff;\n                t++;\n            }\n            res[t][0] = -1;\n            int x;\n            for(x=0; x<n; x++) {\n                if(a[x] != b[x]) break;\n            }\n            if(x != n ) {\n                System.out.println(\"-1\");\n            }\n            else {\n                int act=0;\n                for(int y=0; y<n; y++)\n                    act += res[y][2];\n                System.out.println(act);\n        //       if(act >7) continue;\n                for(int y=0; res[y][0] != -1; y++) {\n                    while(res[y][2]-- >0)\n                        System.out.println((res[y][0]+1) + \" \" + (res[y][1]+1));\n                }\n            }\n        }\n    }\n}\n", "label": 3}
{"src": "import java.util.*;\npublic class a {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tint t=in.nextInt();\n\t\twhile(t!=0) {\n\t\tint n=in.nextInt();\n\t\tint a1[]=new int[n];\n\t\tint a2[]=new int[n];\n\t\tint sum1=0,sum2=0;\n\t\tfor(int i=0;i<a1.length;i++) {\n\t\t\ta1[i]=in.nextInt();\n\t\t\tsum1=sum1+a1[i];\n\t\t}\n\t\tfor(int j=0;j<a2.length;j++) {\n\t\t\ta2[j]=in.nextInt();\n\t\t\tsum2=sum2+a2[j];\n\t\t}\n\t\tArrayList<ArrayList<Integer>> arr=new ArrayList<ArrayList<Integer>>();\n\t\tif(sum1==sum2) {\n\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\twhile(a1[i]!=a2[i]) {\n\t\t\t\t\tif(a1[i]>a2[i]) {\n\t\t\t\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\t\t\t\tif(a1[j]<a2[j]) {\n\t\t\t\t\t\t\t\tArrayList<Integer> a=new ArrayList<Integer>();\n\t\t\t\t\t\t\t\ta.add(i+1);\n\t\t\t\t\t\t\t\ta.add(j+1);\n\t\t\t\t\t\t\t\ta1[j]+=1;\n\t\t\t\t\t\t\t\ta1[i]-=1;\n\t\t\t\t\t\t\t\tarr.add(a);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int j=i+1;j<n;j++) {\n\t\t\t\t\t\t\tif(a1[j]>a2[j]) {\n\t\t\t\t\t\t\t\tArrayList<Integer> a=new ArrayList<Integer>();\n\t\t\t\t\t\t\t\ta.add(j+1);\n\t\t\t\t\t\t\t\ta.add(i+1);\n\t\t\t\t\t\t\t\ta1[j]-=1;\n\t\t\t\t\t\t\t\ta1[i]+=1;\n\t\t\t\t\t\t\t\tarr.add(a);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(arr.size()==0) {\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tSystem.out.println(arr.size());\n\t\t\t\tfor(ArrayList<Integer> List:arr) {\n\t\t\t\t\tSystem.out.println(List.get(0)+\" \"+List.get(1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tSystem.out.println(\"-1\");\n\t\t}\n\t\tt--;\n\t\t}\n\t}\n}\n", "label": 3}
{"src": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class first {\n    public static void main(String[] args) {\n\n        Scanner scn = new Scanner(System.in);\n        int t = scn.nextInt();\n        for (int i = 0; i < t; i++) {\n            int n = scn.nextInt();\n            int[] a = new int[n];\n            int[] b = new int[n];\n            for (int j = 0; j < n; j++)\n                a[j] = scn.nextInt();\n            for (int j = 0; j < n; j++)\n                b[j] = scn.nextInt();\n            fun(a, b);\n        }\n\n    }\n\n    public static void fun(int[] a, int[] b) {\n\n        ArrayList<int[]> res = new ArrayList<>();\n        long sum = 0;\n        for (int ele : a)\n            sum += ele;\n        for (int ele : b)\n            sum -= ele;\n        if (sum != 0) {\n            System.out.println(-1);\n            return;\n        }\n\n        for (int i = 0; i < a.length; i++) {\n            while (a[i] > b[i]) {\n                int idx = -1;\n                for (int j = 0; j < a.length; j++) {\n                    if (i == j)\n                        continue;\n                    if (a[j] < b[j]) {\n                        idx = j;\n                        break;\n                    }\n                }\n                if (idx == -1) {\n                    System.out.println(-1);\n                    return;\n                }\n                a[i]--;\n                a[idx]++;\n                res.add(new int[] { i + 1, idx + 1 });\n            }\n        }\n\n        for (int i = 0; i < a.length; i++) {\n            if (a[i] != b[i]) {\n                System.out.println(-1);\n                return;\n            }\n        }\n        System.out.println(res.size());\n        for (int[] arr : res)\n            System.out.println(arr[0] + \" \" + arr[1]);\n        System.out.println();\n    }\n\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class a {\n    static final int mod = 1000000007;\n    static FastReader sc = new FastReader();\n    static PrintWriter out = new PrintWriter(System.out);\n    public static void main (String[] args) throws java.lang.Exception {        \n        int t = sc.nextInt();        \n        while(t-->0) {\n            int n = sc.nextInt();\n            int a[] = new int[n];\n            int b[] = new int[n];\n            for(int i = 0 ;i < n; i++)\n                a[i] = sc.nextInt();\n            for(int i = 0 ; i < n; i++)\n                b[i] = sc.nextInt();\n\n            ArrayList<Integer> in = new ArrayList<>();\n            ArrayList<Integer> de = new ArrayList<>();\n            int inc = 0 ,dec = 0 ;\n            for(int i = 0 ; i < n; i++) {\n                if(a[i] < b[i]) {\n                    inc += b[i]-a[i];\n                    while(a[i] != b[i]) {\n                        in.add(i+1);\n                        a[i]++;\n                    }\n                }else if(a[i] > b[i]) {\n                    dec += a[i]-b[i];\n                    while(a[i] != b[i]) {\n                        de.add(i+1);\n                        a[i]--;\n                    }\n                }\n            } \n            if(inc != dec) {\n                out.println(-1);\n            }else {\n                out.println(inc);\n                for(int i = 0 ;i < in.size(); i++) {\n                    out.println(de.get(i)+\" \"+in.get(i));\n                }\n            }\n           \n        }\n        out.flush();\n    }\n}\nclass FastReader{ \n     \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.LinkedList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskA solver = new TaskA();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskA {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int t = in.readInt();\n            while (t-- > 0) {\n                int n = in.readInt();\n                int[] a = in.readIntArray(n);\n                int[] b = in.readIntArray(n);\n                LinkedList<Integer> inc = new LinkedList<>();\n                LinkedList<Integer> dec = new LinkedList<>();\n                for (int i = 0; i < n; i++) {\n                    if (a[i] > b[i]) {\n                        for (int j = 0; j < a[i] - b[i]; j++)\n                            dec.add(i + 1);\n                    }\n                    if (a[i] < b[i]) {\n                        for (int j = 0; j < b[i] - a[i]; j++)\n                            inc.add(i + 1);\n                    }\n                }\n                if (inc.size() != dec.size()) {\n                    out.println(-1);\n                } else {\n                    out.println(inc.size());\n                    while (dec.size() > 0) {\n                        out.println(dec.poll() + \" \" + inc.poll());\n                    }\n                }\n\n            }\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int readInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int[] readIntArray(int size) {\n            int[] ans = new int[size];\n            for (int i = 0; i < size; i++) ans[i] = readInt();\n            return ans;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n}\n\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\n\npublic class Main{\n\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n\n        // Start writing your solution here. -------------------------------------\n        //   try {\n        int t=sc.nextInt();\n        while(t-->0) {\n            int n = sc.nextInt();\n            int arr1[] = new int[n];\n            int arr2[] = new int[n];\n            boolean f = false;\n            for (int i = 0; i < n; i++) {\n                arr1[i] = sc.nextInt();\n            }\n            for (int i = 0; i < n; i++) {\n                arr2[i] = sc.nextInt();\n            }\n            ArrayList<Integer> add = new ArrayList<>();\n            ArrayList<Integer> sub = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                if (arr1[i] < arr2[i]) {\n                    while (arr1[i] < arr2[i]) {\n                        arr1[i] += 1;\n                        add.add(i);\n                    }\n                } else if (arr1[i] > arr2[i]) {\n                    while (arr1[i] > arr2[i]) {\n                        arr1[i] -= 1;\n                        if (arr1[i] < 0) {\n                            f = true;\n                            break;\n                        }\n                        sub.add(i);\n                    }\n                }\n            }\n            if(f || add.size()!=sub.size()) out.println(-1);\n            else{\n                out.println(add.size());\n            for (int i = 0; i < add.size(); i++) {\n                out.println((sub.get(i)+1) + \" \" + (add.get(i)+1));\n            }\n            }\n        }\n            //   }catch(Exception e){}\n      /*\n      int n      = sc.nextInt();        // read input as integer\n      long k     = sc.nextLong();       // read input as long\n      double d   = sc.nextDouble();     // read input as double\n      String str = sc.next();           // read input as String\n      String s   = sc.nextLine();       // read whole line as String\n\n      int result = 3*n;\n      out.println(result);                    // print via PrintWriter\n      */\n\n        // Stop writing your solution here. -------------------------------------\n        out.close();\n    }\n\n\n\n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n    //--------------------------------------------------------\n}\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.*;\n\npublic class Practice {\n\tpublic static long mod = (long) Math.pow(10, 9) + 7;\n\tpublic static long mod2 = 998244353;\n\tpublic static int tt = 1;\n\tpublic static ArrayList<Integer> prime;\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint t = Integer.parseInt(br.readLine());\n\t\t// int c = 1;\n\n\t\twhile (t-- > 0) {\n\t\t\tString[] s1 = br.readLine().split(\" \");\n\t\t\tint n = Integer.valueOf(s1[0]);\n\t\t\tint[] arr1 = new int[n];\n\t\t\tString str = (br.readLine());\n\t\t\tString[] s2 = str.split(\" \");\n\t\t\tint sum=0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr1[i] = Integer.parseInt(s2[i]);\n\t\t\t\tsum+=arr1[i];\n\t\t\t}\n\t\t\tint[] arr2 = new int[n];\n\t\t\tstr = (br.readLine());\n\t\t\tString[] s3 = str.split(\" \");\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr2[i] = Integer.parseInt(s3[i]);\n\t\t\t\tsum-=arr2[i];\n\t\t\t}\n\t\t\tif(sum!=0) {\n\t\t\t\tpw.println(-1);\n\t\t\t}else {\n\t\t\t\tint ss=0;\n\t\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\t\tss+=Math.abs(arr1[i]-arr2[i]);\n\t\t\t\t}\n\t\t\t\tpw.println(ss/2);\n\t\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\t\tint curr=arr1[i]-arr2[i];\n\t\t\t\t\tif(curr>0) {\n\t\t\t\t\t\tfor(int j=i+1;j<n&&curr>0;) {\n\t\t\t\t\t\t\tif(arr1[j]<arr2[j]) {\n\t\t\t\t\t\t\t\tpw.println((i+1)+\" \"+(j+1));\n\t\t\t\t\t\t\t\tarr1[j]++;\n\t\t\t\t\t\t\t\tcurr--;\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}else {\n\t\t\t\t\t\tcurr=Math.abs(curr);\n\t\t\t\t\t\tfor(int j=i+1;j<n&&curr>0;) {\n\t\t\t\t\t\t\tif(arr1[j]>arr2[j]) {\n\t\t\t\t\t\t\t\tpw.println((j+1)+\" \"+(i+1));\n\t\t\t\t\t\t\t\tarr1[j]--;\n\t\t\t\t\t\t\t\tcurr--;\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\tj++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tpw.close();\n\t}\n\n}\n\n//\tprivate static void getFac(long n, PrintWriter pw) {\n//\t\t// TODO Auto-generated method stub\n//\t\tint a = 0;\n//\t\twhile (n % 2 == 0) {\n//\t\t\ta++;\n//\t\t\tn = n / 2;\n//\t\t}\n//\t\tif (n == 1) {\n//\t\t\ta--;\n//\t\t}\n//\t\tfor (int i = 3; i <= Math.sqrt(n); i += 2) {\n//\t\t\twhile (n % i == 0) {\n//\t\t\t\tn = n / i;\n//\t\t\t\ta++;\n//\t\t\t}\n//\t\t}\n//\t\tif (n > 1) {\n//\t\t\ta++;\n//\t\t}\n//\t\tif (a % 2 == 0) {\n//\t\t\tpw.println(\"Bob\");\n//\t\t} else {\n//\t\t\tpw.println(\"Alice\");\n//\t\t}\n//\t\t//System.out.println(a);\n//\t\treturn;\n//\t}\n\n//\tprivate static long power(long a, long p) {\n//\t\t// TODO Auto-generated method stub\n//\t\tlong res = 1;\n//\t\twhile (p > 0) {\n//\t\t\tif (p % 2 == 1) {\n//\t\t\t\tres = (res * a) % mod;\n//\t\t\t}\n//\t\t\tp = p / 2;\n//\t\t\ta = (a * a) % mod;\n//\t\t}\n//\t\treturn res;\n//\t}\n//\n//\tprivate static void fac() {\n//\t\tfac[0] = 1;\n//\t\t// TODO Auto-generated method stub\n//\t\tfor (int i = 1; i < fac.length; i++) {\n//\t\t\tif (i == 1) {\n//\t\t\t\tfac[i] = 1;\n//\t\t\t} else {\n//\t\t\t\tfac[i] = i * fac[i - 1];\n//\t\t\t}\n//\t\t\tif (fac[i] > mod) {\n//\t\t\t\tfac[i] = fac[i] % mod;\n//\t\t\t}\n//\t\t}\n//\t}\n//\n//\tprivate static int getLower(Long long1, Long[] st) {\n//\t\t// TODO Auto-generated method stub\n//\t\tint left = 0, right = st.length - 1;\n//\t\tint ans = -1;\n//\t\twhile (left <= right) {\n//\t\t\tint mid = (left + right) / 2;\n//\t\t\tif (st[mid] <= long1) {\n//\t\t\t\tans = mid;\n//\t\t\t\tleft = mid + 1;\n//\t\t\t} else {\n//\t\t\t\tright = mid - 1;\n//\t\t\t}\n//\t\t}\n//\t\treturn ans;\n//\t}\n\n//\tprivate static long getGCD(long l, long m) {\n//\n//\t\tlong t1 = Math.min(l, m);\n//\t\tlong t2 = Math.max(l, m);\n//\t\twhile (true) {\n//\t\t\tlong temp = t2 % t1;\n//\t\t\tif (temp == 0) {\n//\t\t\t\treturn t1;\n//\t\t\t}\n//\t\t\tt2 = t1;\n//\t\t\tt1 = temp;\n//\t\t}\n//\t}", "label": 3}
{"src": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\n/**\n * A. AquaMoon and Two Arrays\n * AquaMoon and Cirno are playing an interesting game with arrays.\n * Cirno has prepared two arrays a and b, both consist of n non-negative\n * integers. AquaMoon can perform the following operation an arbitrary number\n * of times (possibly zero):\n * - She chooses two indices i and j (1\u2264i,j\u2264n), then decreases the i-th element\n * of array a by 1, and increases the j-th element of array a by 1. The resulting\n * values at i-th and j-th index of array a are ai\u22121 and aj+1, respectively. Each\n * element of array a must be non-negative after each operation. If i=j this\n * operation doesn't change the array a.\n * AquaMoon wants to make some operations to make arrays a and b equal. Two arrays\n * a and b are considered equal if and only if ai=bi for all 1\u2264i\u2264n.\n * Help AquaMoon to find a sequence of operations that will solve her problem or\n * find, that it is impossible to make arrays a and b equal.\n * Please note, that you don't have to minimize the number of operations.\n * <p>\n * Input\n * The input consists of multiple test cases. The first line contains a single\n * integer t (1\u2264t\u2264100) \u2014 the number of test cases.\n * <p>\n * The first line of each test case contains a single integer n (1\u2264n\u2264100).\n * <p>\n * The second line of each test case contains n integers a1,a2,\u2026,an (0\u2264ai\u2264100).\n * The sum of all ai does not exceed 100.\n * <p>\n * The third line of each test case contains n integers b1,b2,\u2026,bn (0\u2264bi\u2264100).\n * The sum of all bi does not exceed 100.\n * <p>\n * <p>\n * Output\n * For each test case print \"-1\" on the only line if it is impossible to make two\n * arrays equal with some sequence of operations.\n * <p>\n * Otherwise, print an integer m (0\u2264m\u2264100) in the first line \u2014 the number of\n * operations. Then print m lines, each line consists of two integers i and j \u2014 the\n * indices you choose for the operation.\n * <p>\n * It can be proven that if it is possible to make two arrays equal with some sequence\n * of operations, there exists a sequence with m\u2264100.\n * <p>\n * If there are multiple possible solutions, you can print any.\n * <p>\n * <p>\n * Example 1\n * input\n * 4\n * 4\n * 1 2 3 4\n * 3 1 2 4\n * 2\n * 1 3\n * 2 1\n * 1\n * 0\n * 0\n * 5\n * 4 3 2 1 0\n * 0 1 2 3 4\n * <p>\n * output\n * 2\n * 2 1\n * 3 1\n * -1\n * 0\n * 6\n * 1 4\n * 1 4\n * 1 5\n * 1 5\n * 2 5\n * 2 5\n * <p>\n * <p>\n * Note\n * In the first example, we do the following operations:\n * - i=2, j=1: [1,2,3,4]\u2192[2,1,3,4];\n * - i=3, j=1: [2,1,3,4]\u2192[3,1,2,4];\n * In the second example, it's impossible to make two arrays equal.\n * <p>\n * link: https://codeforces.com/contest/1546/problem/A\n */\npublic class Div_2_732_A {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while (t-- > 0) {\n            int n = sc.nextInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextInt();\n            }\n            int[] b = new int[n];\n            for (int i = 0; i < n; i++) {\n                b[i] = sc.nextInt();\n            }\n\n            boolean canHandle = canHandle(a, b, n);\n            if (!canHandle) {\n                System.out.println(-1);\n            } else {\n                solve(a, b, n);\n            }\n        }\n    }\n\n    static boolean canHandle(int[] a, int[] b, int n) {\n        int sumA = Arrays.stream(a).sum();\n        int sumB = Arrays.stream(b).sum();\n\n        return sumA == sumB;\n    }\n\n    static boolean equals(int[] a, int[] b, int n){\n        for(int i = 0; i < n; i++){\n            if(a[i] != b[i]){\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    static void solve(int[] a, int[] b, int n) {\n        if(equals(a, b, n)){\n            System.out.println(0);\n            return;\n        }\n\n        ArrayList<int[]> data = new ArrayList<int[]>();\n        while(!equals(a, b, n)){\n            /*int[] row = new int[2];\n            for(int i = 0; i < n; i++){\n                if(a[i] > b[i]){\n                    a[i]--;\n                    row[0] = i + 1;\n                    break;\n                }\n            }\n\n            for(int j = 0; j < n; j++){\n                if(a[j] < b[j]){\n                    a[j]++;\n                    row[1] = j + 1;\n                    break;\n                }\n            }\n            data.add(row);*/\n            for(int i = 0; i < n; i++){\n                if(a[i] > b[i]){\n                    for(int j = 0; j < n; j++){\n                        if(a[j] == b[j]){\n                            continue;\n                        }\n\n                        if(a[j] < b[j]){\n                            a[i]--;\n                            a[j]++;\n                            data.add(new int[]{i + 1, j + 1});\n                            break;\n                        }\n                    }\n                    break;\n                } else if(a[i] < b[i]){\n                    for(int j = 0; j < n; j++){\n                        if(a[j] == b[j]){\n                            continue;\n                        }\n\n                        if(a[j] > b[j]){\n                            a[i]++;\n                            a[j]--;\n                            data.add(new int[]{j + 1, i + 1});\n                            break;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        System.out.println(data.size());\n\n        if(data.isEmpty()){\n            return ;\n        }\n\n        for(int[] d : data){\n            System.out.println(d[0] + \" \" + d[1]);\n        }\n    }\n}", "label": 3}
{"src": "import java.util.*;\n\npublic class prg{\n     \n     \n     public static void main(String args[]){\n          Scanner sc = new Scanner(System.in);\n          int d= sc.nextInt();\n          sc.nextLine();\n          for(int i=0;i<d;i++){\n               int s=0;\n               int n= sc.nextInt();\n               int arr[] = new int [n];\n               int arr2[]= new int [n];\n               for(int w=0;w<n;w++){\n                    arr[w]=sc.nextInt();\n                    \n               }\n               for(int k=0;k<n;k++){\n                    arr2[k]=sc.nextInt();\n                    \n               } int max=0;\n               for(int q=0;q<n;q++){\n                    if((arr2[q]-arr[q])>0)\n                    max = max+ (arr2[q]-arr[q]);\n               s= s+(arr2[q]-arr[q]);\n               }\n               if(s!=0){\n                    System.out.println(\"-1\");\n               }\n               else{\n                    System.out.println(max);\n                    while(max>0){\n                    for(int h=0;h<n;h++){\n                         if(arr[h]>arr2[h]){\n                         System.out.print((h+1)+\" \");\n                         arr[h]--;\n                   break;\n                    }} for(int e=0;e<n;e++){\n                         if(arr[e]<arr2[e]){\n                         System.out.print((e+1));\n                         arr[e]++;\n                   break;\n                    }\n                    }\n                    System.out.println(\"\");\n                    max--;\n                    \n                    \n               }}}}}\n          ", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\npublic class aquamoonandtwoarrays {\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(f.readLine());\n\t\tint t = Integer.parseInt(st.nextToken());\n\t\twhile(t > 0) {\n\t\t\tt --;\n\t\t\tint n = Integer.parseInt(f.readLine());\n\t\t\tst = new StringTokenizer(f.readLine());\n\t\t\tint[] a = new int[n];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i ++) a[i] = Integer.parseInt(st.nextToken());\n\t\t\tint[] b = new int[n];\n\t\t\tst = new StringTokenizer(f.readLine());\n\t\t\tfor(int i = 0; i < n; i ++) a[i] -= Integer.parseInt(st.nextToken());\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor(int i : a) sum += i;\n\t\t\tif(sum != 0) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint m = 0;\n\t\t\tArrayList<int[]> ans = new ArrayList<int[]>();\n\t\t\tfor(int i = 0; i < n; i ++) {\n\t\t\t\tif(a[i] > 0) for(int j = a[i]; j >= 0; j --) {\n\t\t\t\t\tfor(int k = 0; k < n; k ++) {\n\t\t\t\t\t\tif(a[k] < 0 && a[i] > 0) {\n\t\t\t\t\t\t\tm ++;\n\t\t\t\t\t\t\ta[i] --;\n\t\t\t\t\t\t\ta[k] ++;\n\t\t\t\t\t\t\tans.add(new int[] {i, k});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(m);\n\t\t\tfor(int[] i : ans) {\n\t\t\t\tSystem.out.println((i[0] + 1) + \" \" + (i[1] + 1));\n\t\t\t}\n\t\t}\n\t}\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.lang.*;\n\npublic class Main{\n\n    public static void main(String args[]){\n        Scanner in = new Scanner(System.in);\n        long test = in.nextLong();\n        in.nextLine();\n        while(test-- > 0){\n           int n = in.nextInt();\n           int a[] = new int[n];\n           int b[] = new int[n];\n           int suma = 0;\n           int sumb = 0;\n\n           for(int i = 0 ; i < n ; i++){ a[i] = in.nextInt(); suma+=a[i];}\n           for(int i = 0 ; i < n ; i++){ b[i] = in.nextInt(); sumb+=b[i];}\n\n           int diff[] = new int[n];\n\n           int steps = 0;\n           for(int i = 0 ; i < n ; i++){ diff[i] = a[i] - b[i]; steps += Math.abs(diff[i]);}\n            \n           if(suma != sumb || steps%2 != 0)\n                System.out.println(\"-1\");\n            else{\n                System.out.println(steps/2);\n                int inc = 0;\n                int dec = 0;\n                for(int i = 0 ; i  < n ; i++){\n\n                   // System.out.println(a[i] +\" - \"+b[i]+\" = \"+diff[i]);\n                    while(a[i] != b[i]){\n                        if(diff[i] < 0){\n                            inc = i;\n                            for(int j = i+1 ; j < n ; j++){\n                                if(diff[j] > 0){\n                                    dec = j;\n                                    break;\n                                }\n                            }\n                        }else{\n                            dec = i;\n                            for(int j = i ; j < n ; j++){\n                                if(diff[j] < 0){\n                                    inc = j;\n                                    break;\n                                }\n                            }\n                        }\n\n                        a[inc]++;\n                        a[dec]--;\n\n                        diff[inc]++;\n                        diff[dec]--;\n                        System.out.println(dec+1+\" \"+(inc+1));\n                    }\n                }\n                \n            }\n        }\n    }\n}\n\n\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n\npublic class AquaMoonandTwoArrays {\n    public static void main(String[] args) throws IOException\n    {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        int t = Integer.parseInt(br.readLine());\n        while (t-- > 0) {\n            int n = Integer.parseInt(br.readLine());\n            String s[] = br.readLine().split(\" \");\n            int a[] = new int[n];\n            for(int i = 0; i < n;i++) {\n                a[i] = Integer.parseInt(s[i]);\n            }\n            String s1[] = br.readLine().split(\" \");\n            int b[] = new int[n];\n            for(int i = 0; i < n; i++) {\n                b[i] = Integer.parseInt(s1[i]);\n            }\n            ArrayList<Integer> pos = new ArrayList<>();\n            ArrayList<Integer> neg = new ArrayList<>();\n            int sum = 0;\n            for(int i = 0; i < n; i++) {\n                int val = b[i] - a[i];\n                sum += val;\n                if(val > 0) {\n                     for(int j = 0; j < val; j++) {\n                         pos.add(i+1);\n                     }\n                }\n                if(val < 0) {\n                    for(int j = 0; j < -1*val; j++) {\n                       neg.add(i+1);\n                    }\n                }\n            }\n            if(sum != 0) {\n                System.out.println(-1);\n                continue;\n            }\n            System.out.println(pos.size());\n            int ans[] = new int[pos.size()];\n            int j = 0;\n            for(int i : neg) {\n                ans[j] = i;\n                j++;\n            }\n            j = 0;\n            for(int val : pos) {\n                System.out.println(ans[j] +\" \" +val);\n                j++;\n            }\n        }\n    }\n}\n", "label": 3}
{"src": "import java.util.*;\n\npublic class AquamanAndTwoArrays {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\tint i;\n\t\tfor(i=0; i<t; i++) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] a = new int[n];\n\t\t\tint[] b = new int[n];\n\t\t\tint j;\n\t\t\tfor(j=0; j<n; j++) {\n\t\t\t\ta[j] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(j=0; j<n; j++) {\n\t\t\t\tb[j] = sc.nextInt();\n\t\t\t}\n\t\t\tArrayList<indices> list = solve(a,b);\n\t\t\tif(list.size() == 1 && list.get(0).i == -1 && list.get(0).j == -1) {\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tSystem.out.println(list.size());\n\t\t\tfor(j=0; j<list.size(); j++) {\n\t\t\t\tSystem.out.println(list.get(j).i + \" \" + list.get(j).j);\n\t\t\t}\n\t\t}\n\t\tsc.close();\n\n\t}\n\tstatic ArrayList<indices> solve(int[] a, int[] b){\n\t\tint n = a.length;\n\t\tint[][] arr = new int[n][2];\n\t\tArrayList<indices> list = new ArrayList<>();\n\t\tint i,j;\n\t\tint sum=0;\n\t\tfor(i=0; i<n; i++) {\n\t\t\tarr[i][0] = a[i] - b[i];\n\t\t\tsum += a[i] - b[i];\n\t\t\tarr[i][1] = i;\n\t\t}\n\t\tif(sum != 0) {\n\t\t\tlist.add(new indices(-1, -1));\n\t\t\treturn list;\n\t\t}\n\t\tArrays.sort(arr, new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] x, int[] y) {\n\t\t\t\treturn x[0] - y[0];\n\t\t\t}\n\t\t});\n\t\tj=0;\n\t\ti=n-1;\n\t\tint k,l,x,y;\n\t\twhile(j<i) {\n\t\t\tx = arr[i][1];\n\t\t\ty = arr[j][1];\n\t\t\tif(arr[i][0] + arr[j][0] > 0) {\n\t\t\t\tk = -arr[j][0];\n\t\t\t\tarr[i][0] += arr[j][0];\n\t\t\t\tarr[j][0] = 0;\n//\t\t\t\tSystem.out.println(\"k  \" + k + \"  arr[i][0]  \" + arr[i][0]);\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if(arr[i][0] + arr[j][0] < 0){\n\t\t\t\tk = arr[i][0];\n\t\t\t\tarr[j][0] += arr[i][0];\n\t\t\t\tarr[i][0] = 0;\n//\t\t\t\tSystem.out.println(\"k  \" + k + \"  arr[j][0]  \" + arr[j][0]);\n\t\t\t\ti--;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tk = arr[i][0];\n\t\t\t\tarr[i][0] = 0;\n\t\t\t\tarr[j][0] = 0;\n//\t\t\t\tSystem.out.println(\"k  \" + k);\n\t\t\t\ti--;\n\t\t\t\tj++;\n\t\t\t}\n\t\t\tfor(l=0; l<k; l++) {\n\t\t\t\tlist.add(new indices(x+1,y+1));\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\n}\nclass indices{\n\tint i;\n\tint j;\n\tindices(int x, int y){\n\t\ti=x;\n\t\tj=y;\n\t}\n}\n", "label": 3}
{"src": "import java.util.*;\n\npublic class Codechef {\n\n    public static void main(String args[]){\n\n        Scanner in = new Scanner(System.in);\n\n        int t = in.nextInt();\n        while(t-- > 0){\n\n            int n = in.nextInt();\n            ArrayList<Integer> arr = new ArrayList<>();\n            ArrayList<Integer> brr = new ArrayList<>();\n\n            for(int i=0;i<n;i++){\n                arr.add(in.nextInt());\n            }\n            for(int i=0;i<n;i++){\n                brr.add(in.nextInt());\n            }\n\n            int sum = 0;\n            ArrayList<Integer> front = new ArrayList<>();\n            ArrayList<Integer> end = new ArrayList<>();\n            for(int i=0;i<n;i++){\n                sum += (arr.get(i) - brr.get(i));\n                arr.set(i, arr.get(i) - brr.get(i));\n                if(arr.get(i) > 0){\n                    for(int j=0;j<arr.get(i);j++){\n                        front.add(i+1);\n                    }\n                }\n                else if(arr.get(i) < 0){\n                    for(int j=0;j<Math.abs(arr.get(i));j++){\n                        end.add(i+1);\n                    }\n                }\n            }\n\n            if(sum != 0) System.out.println(-1);\n            else{\n                System.out.println(front.size());\n                for(int i=0;i<front.size();i++){\n                    System.out.println(front.get(i) + \" \" + end.get(i));\n                }\n            }\n        }\n\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Solver {\n    public static void main(String[] args) throws IOException {\n        PrintWriter pw = new PrintWriter(System.out);\n        int t = nextInt();\n        for (int i = 0; i < t; i++) {\n            int n = nextInt();\n            int a[] = new int[n];\n            int b[] = new int[n];\n            int x = 0;\n            for (int j = 0; j < n; j++) {\n                a[j] = nextInt();\n                x += a[j];\n            }\n            int y = 0;\n            for (int j = 0; j < n; j++) {\n                b[j] = nextInt();\n                y += b[j];\n            }\n            if (x - y != 0) {\n                System.out.println(-1);\n                continue;\n            }\n\n            x = 0;\n            y = 0;\n            for (int j = 0; j < n; j++) {\n                if (a[j] - b[j] < 0) {\n                    x += -(a[j] - b[j]);\n                } else {\n                    y += a[j] - b[j];\n                }\n            }\n            int c[] = new int[x];\n            int d[] = new int[y];\n            System.out.println(x);\n            x = 0;\n            y = 0;\n            for (int j = 0; j < n; j++) {\n                if (a[j] - b[j] < 0) {\n                    c[x] = 1 + j;\n                    x++;\n                    a[j]++;\n                    j--;\n                } else if(a[j] - b[j] > 0) {\n                    d[y] = j + 1;\n                    y++;\n                    a[j]--;\n                    j--;\n                }\n            }\n            for (int j = 0; j < x; j++) {\n                System.out.println(d[j] + \" \" + c[j]);\n            }\n        }\n    }\n\n\n    static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter out = new PrintWriter(System.out);\n    static StringTokenizer in = new StringTokenizer(\"\");\n\n    public static boolean hasNext() throws IOException {\n        if (in.hasMoreTokens()) return true;\n        String s;\n        while ((s = br.readLine()) != null) {\n            in = new StringTokenizer(s);\n            if (in.hasMoreTokens()) return true;\n        }\n        return false;\n    }\n\n    public static String nextToken() throws IOException {\n        while (!in.hasMoreTokens()) {\n            in = new StringTokenizer(br.readLine());\n        }\n        return in.nextToken();\n    }\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(nextToken());\n    }\n\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(nextToken());\n    }\n\n    public static long nextLong() throws IOException {\n        return Long.parseLong(nextToken());\n    }\n}", "label": 3}
{"src": "//------------------>>>>>>>>>>>>>>>> HI . HOW ARE YOU? <<<<<<<<<<<<<<<<<<<<<<<<<<<<<------------------------------\n\nimport java.util.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\n//---------------------------->>>>>>>>>>>>>>>>>>>>>> FK OFF <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<-------------------\n\n//--------------------------->>>>>>>>>>>>>>>>>>>>>>>> HACKER MF <<<<<<<<<<<<-------------------------------------\n\npublic class practice{\n    static long[] count,count1,count2;\n    static boolean[] prime;\n    static boolean flag;\n    static int[] spf;\n    static Node[] nodes,nodes1,nodes2;\n    static long[] arr;\n    static long[][] cost;\n    static int[] arrInt,darrInt,farrInt;\n    static long[][] dp;\n    static char[] ch,ch1,ch2;\n    static long[] darr,farr;\n    static int[][] mat,mat1;\n    static boolean[] vis;\n    static long x,h;\n    static long maxl,sum,total;\n    static double dec;\n    static long mx = (long)1e7;\n    static long inf = (long)1e18;\n    static String s,s1,s2,s3,s4;\n    static long minl;\n    static long mod = (long)(1e9)+7;\n    // static int minl = -1;\n    // static long n;\n    static int n,n1,n2,q,r1,c1,r2,c2;\n    static int arr_size = (int)2e5+10;\n    static long a;\n    static long b;\n    static long c;\n    static long d;\n    static long y,z;\n    static int m,m1;\n    static long ans;\n    static long k;\n    static FastScanner sc;\n    static String[] str,str1;\n    static Set<Long> set,set1,set2;\n    static SortedSet<Long> ss;\n    static List<StringBuilder> list,list1,list2,list3;\n    static PriorityQueue<Node> pq,pq1;\n    static LinkedList<Node> ll,ll1,ll2;\n    static Map<Integer,List<Integer>> map;\n    static Map<Integer,Integer> map2;\n    static Map<Integer,Long> mapL,mapR;\n    static Map<Integer,Node> map1;\n    static StringBuilder sb,sb1,sb2;\n    static int index;\n    static int[] dx = {0,-1,0,1,-1,1,-1,1};\n    static int[] dy = {-1,0,1,0,-1,-1,1,1};\n\n    static class Node{\n        long first;\n        long second;\n        Node(long f,long s){\n            this.first = f;\n            this.second = s;\n        }\n    }\n\n//     public static void solve(){\n//\n//        FastScanner sc = new FastScanner();\n//        int t = sc.nextInt();\n//        // int t = 1;\n//        for(int tt = 1 ; tt <= t ; tt++){\n//\n//            System.out.println(\"Case #\"+tt+\": \"+ ans);\n//\n//        }\n//\n//     }\n\n    //--------------->>>>IF YOU ARE HERE FOR QUICKSORT HACK THEN SORRY NO HACK FOR YOU<<<------------------------------\n\n    public static void solve(){\n\n        long incr = 0;\n        long decr = 0;\n        sb = new StringBuilder();\n\n        for(int i = 0 ; i < n ; i++){\n            if(arr[i] > darr[i])\n                decr += arr[i] - darr[i];\n            else\n                incr += darr[i] - arr[i];\n        }\n\n        if(incr != decr){\n            System.out.println(-1);\n            return;\n        }\n\n        if(incr == 0){\n            System.out.println(0);\n            return;\n        }\n\n        int curr = 0;\n        for(int i = 0 ; i < n ; i++){\n            while(arr[i] > darr[i]){\n                for(int j = i+1 ; j < n ; j++){\n                    if(arr[j] < darr[j]){\n                        curr += 1;\n                        sb.append((i+1) + \" \" + (j+1) + \"\\n\");\n                        arr[i] -= 1;\n                        arr[j] += 1;\n                        break;\n                    }\n                }\n            }\n            while(arr[i] < darr[i]){\n                for(int j = i+1 ; j < n ; j++){\n                    if(arr[j] > darr[j]){\n                        curr += 1;\n                        sb.append((j+1) + \" \" + (i+1) + \"\\n\");\n                        arr[i] += 1;\n                        arr[j] -= 1;\n                        break;\n                    }\n                }\n            }\n        }\n        System.out.println(curr);\n        System.out.print(sb);\n\n    }\n\n\n    //----------->>>>>>> SPEED UP SPEED UP . THIS IS SPEEDFORCES . SPEED UP SPEEEEEEEEEEEEEEEEEEEEEEEEEEDDDDDD <<<<<<<------------------\n\n    public static void main(String[] args) {\n\n        sc = new FastScanner();\n        // Scanner sc = new Scanner(System.in);\n        sb = new StringBuilder();\n        int t = sc.nextInt();\n//        int t = 1;\n        while(t > 0){\n\n//             k = sc.nextLong();\n            // x = sc.nextLong();\n            // y = sc.nextLong();\n            // z = sc.nextLong();\n\n//             a = sc.nextLong();\n//             b = sc.nextLong();\n//             c = sc.nextLong();\n//             d = sc.nextLong();\n//\n//             x = sc.nextLong();\n//             y = sc.nextLong();\n//             z = sc.nextLong();\n            // d = sc.nextLong();\n\n            n = sc.nextInt();\n\n            // n1 = sc.nextInt();\n\n//            m = sc.nextInt();\n//             q = sc.nextInt();\n\n//             a = sc.nextLong();\n//             b = sc.nextLong();\n\n//             k = sc.nextLong();\n\n//            x = sc.nextLong();\n            // d = sc.nextLong();\n\n//            s = sc.next();\n\n//            ch = sc.next().toCharArray();\n            // ch1 = sc.next().toCharArray();\n\n//             m = sc.nextInt();\n            // n = 6;\n\n            arr = new long[n];\n            for(int i = 0 ; i < n ; i++){\n                arr[i] = sc.nextLong();\n            }\n\n//            arrInt = new int[n];\n//            for(int i = 0 ; i < n ; i++){\n//                arrInt[i] = sc.nextInt();\n//            }\n\n            // x = sc.nextLong();\n            // y = sc.nextLong();\n//             ch = sc.next().toCharArray();\n            m = n;\n//             m = sc.nextInt();\n            darr = new long[m];\n            for(int i = 0 ; i < m ; i++){\n                darr[i] = sc.nextLong();\n            }\n            // k = sc.nextLong();\n            // m = n;\n//             darrInt = new int[n];\n//             for(int i = 0 ; i < n ; i++){\n//                 darrInt[i] = sc.nextInt();\n//             }\n\n//             farr = new long[n];\n//             for(int i = 0 ; i < n ; i++){\n//                 farr[i] = sc.nextLong();\n//             }\n\n            // farrInt = new int[m];\n            // for(int i = 0; i < m ; i++){\n            //     farrInt[i] = sc.nextInt();\n            // }\n\n            // m = n;\n//            mat = new int[2][n];\n//            for(int i = 0 ; i < 2 ; i++){\n//                for(int j = 0 ; j < n ; j++){\n//                    mat[i][j] = sc.nextInt();\n//                }\n//            }\n\n//             m = n;\n//             mat = new char[n][m];\n//             for(int i = 0 ; i < n ; i++){\n//                 String s = sc.next();\n//                 for(int j = 0 ; j < m ; j++){\n//                     mat[i][j] = s.charAt(j);\n//                 }\n//             }\n//\n//             str = new String[n];\n//             for(int i = 0 ; i < n ; i++)\n//                 str[i] = sc.next();\n\n//             nodes = new Node[n];\n//             for(int i = 0 ; i < n ;i++)\n//                 nodes[i] = new Node(sc.nextLong(),(i));\n\n            solve();\n            t -= 1;\n        }\n//        System.out.print(sb);\n\n    }\n\n    public static int log(double n,double base){\n\n        if(n == 0 || n == 1)\n            return 0;\n\n        if(n == base)\n            return 1;\n\n        double num = Math.log(n);\n        double den = Math.log(base);\n\n        if(den == 0)\n            return 0;\n\n        return (int)(num/den);\n    }\n\n    public static boolean isPrime(long n) {\n        // Corner cases\n        if (n <= 1)\n            return false;\n\n        if (n <= 3)\n            return true;\n\n        // This is checked so that we can skip\n        // middle five numbers in below loop\n        if (n%2 == 0 || n%3 == 0)\n            return false;\n\n        for (int i=5; i*i<=n; i=i+6)\n            if (n%i == 0 || n%(i+2) == 0)\n                return false;\n\n        return true;\n    }\n\n    public static void SpecialSieve(int MAXN)\n    {\n        spf = new int[MAXN];\n        spf[1] = 1;\n        for (int i=2; i<MAXN; i++)\n\n            // marking smallest prime factor for every\n            // number to be itself.\n            spf[i] = i;\n\n        // separately marking spf for every even\n        // number as 2\n        for (int i=4; i<MAXN; i+=2)\n            spf[i] = 2;\n\n        for (int i=3; i*i<MAXN; i++)\n        {\n            // checking if i is prime\n            if (spf[i] == i)\n            {\n                // marking SPF for all numbers divisible by i\n                for (int j=i*i; j<MAXN; j+=i)\n\n                    // marking spf[j] if it is not\n                    // previously marked\n                    if (spf[j]==j)\n                        spf[j] = i;\n            }\n        }\n    }\n\n    public static ArrayList<Integer> getFactorization(int x)\n    {\n        ArrayList<Integer> ret = new ArrayList<Integer>();\n        while (x != 1)\n        {\n            ret.add(spf[x]);\n            x = x / spf[x];\n        }\n        return ret;\n    }\n\n    public static long gcd(long a, long b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    public static long lcm(long a, long b)\n    {\n        return (b/gcd(b, a % b)) * a;\n    }\n\n    public static long mod_inverse(long a,long mod){\n        long x1=1,x2=0;\n        long p=mod,q,t;\n        while(a%p!=0){\n            q = a/p;\n            t = x1-q*x2;\n            x1=x2; x2=t;\n            t=a%p;\n            a=p; p=t;\n        }\n        return x2<0 ? x2+mod : x2;\n    }\n\n    public static void swap(double[] curr,int i,int j){\n        double temp = curr[j];\n        curr[j] = curr[i];\n        curr[i] = temp;\n    }\n\n    static final Random random=new Random();\n\n    static void ruffleSortLong(long[] a) {\n        int n=a.length;//shuffle, then sort\n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            long temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static void ruffleSortInt(int[] a) {\n        int n=a.length;//shuffle, then sort\n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            int temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static void ruffleSortChar(char[] a) {\n        int n=a.length;//shuffle, then sort\n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n);\n            char temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n\n    static long binomialCoeff(long n, long k){\n\n        long res = 1;\n\n        // Since C(n, k) = C(n, n-k)\n        if (k > n - k)\n            k = n - k;\n\n        // Calculate value of\n        // [n * (n-1) *---* (n-k+1)] / [k * (k-1) *----* 1]\n        for (long i = 0; i < k; ++i) {\n            res = (res*(n - i));\n            res = (res/(i + 1));\n        }\n\n        return res;\n    }\n\n    static long mod(long x)\n    {\n        long y = mod;\n        long result = x % y;\n        while (result < 0)\n        {\n            result += y;\n        }\n        return result;\n    }\n\n    static long[] fact;\n\n    public static long inv(long n){\n        return power(n, mod-2);\n    }\n\n    public static void fact(int n){\n        fact = new long[n+1];\n        fact[0] = 1;\n        for(int j = 1;j<=n;j++)\n            fact[j] = (fact[j-1]*(long)j)%mod;\n    }\n\n    public static long binom(int n, int k){\n\n        long prod = fact[n];\n        prod*=inv(fact[n-k]);\n        prod%=mod;\n        prod*=inv(fact[k]);\n        prod%=mod;\n        return prod;\n    }\n\n    static long power(long x, long y){\n        if (y == 0)\n            return 1;\n        if (y%2 == 1)\n            return (x*power(x, y-1))%mod;\n        return power((x*x)%mod, y/2)%mod;\n    }\n\n    static void sieve(int n){\n\n        prime = new boolean[n+1];\n        for(int i=2;i<n;i++)\n            prime[i] = true;\n\n        for(int p = 2; p*p <=n; p++)\n        {\n            if(prime[p])\n            {\n                for(int i = p*p; i <= n; i += p)\n                    prime[i] = false;\n            }\n        }\n\n    }\n\n    static long abs(long a){\n        return Math.abs(a);\n    }\n\n    static int abs(int a){\n        return Math.abs(a);\n    }\n\n    static int max(int a,int b){\n        if(a>b)\n            return a;\n        else\n            return b;\n    }\n    static double max(double a,double b){\n        if(a>b)\n            return a;\n        else\n            return b;\n    }\n    static double min(double a,double b){\n        if(a>b)\n            return b;\n        else\n            return a;\n    }\n\n    static int min(int a,int b){\n        if(a>b)\n            return b;\n        else\n            return a;\n    }\n\n    static long max(long a,long b){\n        if(a>b)\n            return a;\n        else\n            return b;\n    }\n\n    static long min(long a,long b){\n        if(a>b)\n            return b;\n        else\n            return a;\n    }\n\n    static long sq(long num){\n        return num*num;\n    }\n\n    static double sq(double num){\n        return num*num;\n    }\n\n    static long sqrt(long num){\n        return (long)Math.sqrt(num);\n    }\n\n    static double sqrt(double num){\n        return Math.sqrt(num);\n    }\n\n    static class FastScanner {\n\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        //        void readArray(int n) {\n//            arr = new long[n];\n//            for (int i = 0; i < n; i++)\n//                arr[i] = nextLong();\n//        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n}", "label": 3}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\n\npublic class Main {\n\n    static final int MAX_N = 1000010;\n    static final int INF = 0x3f3f3f3f;\n    static final int mod = 1000000007;\n\n\n    public static void main(String[] args) throws IOException {\n        initReader(System.in);\n\n\n        int T = nextInt();\n        for (int i = 1; i <= T; i++) solve();\n\n\n        pw.close();\n    }\n\n\n    /*******************************************************************************************************************************/\n\n\n    public static void solve() throws IOException {\n        int n = nextInt();\n        int[] a = new int[n];\n        int[] b = new int[n];\n\n        for (int i = 0; i < n; i++) a[i] = nextInt();\n        for (int i = 0; i < n; i++) b[i] = nextInt();\n\n        int sum = 0;\n        int cnt = 0;\n        for (int i = 0; i < n; i++) {\n            sum += b[i] - a[i];\n            if (b[i] - a[i] > 0) cnt += b[i] - a[i];\n        }\n        if (sum != 0) {\n            pw.println(-1);\n            return ;\n        }\n\n        pw.println(cnt);\n\n        for (int i = 0; i < n; i++) {\n            while (a[i] != b[i]) {\n                if (a[i] < b[i]) {\n                    a[i]++;\n                    for (int j = i + 1; j < n; j++)\n                        if (a[j] > b[j]) {\n                            a[j]--;\n                            pw.println((j + 1) + \" \" + (i + 1));\n                            break;\n                        }\n                } else {\n                    a[i]--;\n                    for (int j = i + 1; j < n; j++) {\n                        if (a[j] < b[j]) {\n                            a[j]++;\n                            pw.println((i + 1) + \" \" + (j + 1));\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n\n\n    /*******************************************************************************************************************************/\n\n\n\n    /*******************************************************************************************************************************/\n\n    static BufferedReader reader;\n    static StringTokenizer tokenizer;\n    static PrintWriter pw;\n\n    public static void initReader(InputStream input) throws IOException {\n        reader = new BufferedReader(new InputStreamReader(input));\n        tokenizer = new StringTokenizer(\"\");\n        pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n//      reader = new BufferedReader(new FileReader(\"ate.in\"));\n//      tokenizer = new StringTokenizer(\"\");\n//      printWriter = new PrintWriter(new BufferedWriter(new FileWriter(\"ate.out\")));\n    }\n\n    public static boolean hasNext() {\n        try {\n            while (!tokenizer.hasMoreTokens()) {\n                tokenizer = new StringTokenizer(reader.readLine());\n            }\n        } catch (Exception e) {\n            return false;\n        }\n        return true;\n    }\n\n    public static String next() throws IOException {\n        while (!tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    public static String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n    public static int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public static long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public static double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n\n    public static char nextChar() throws IOException {\n        return next().charAt(0);\n    }\n\n    public static short nextShort() throws IOException {\n        return Short.parseShort(next());\n    }\n\n}", "label": 3}
{"src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int t = input.nextInt();\n        while(t-->0){\n            int n = input.nextInt();\n            int a [] = new int[n];\n            int b [] = new int[n];\n\n            for(int i=0 ; i<n ; i++){\n                a[i] = input.nextInt();\n            }\n            for(int i=0 ; i<n ; i++){\n                b[i] = input.nextInt();\n            }\n            ArrayList<Integer> ans1 = new ArrayList<>();\n            ArrayList<Integer> ans2 = new ArrayList<>();\n\n            int inc=0;\n            int dec=0;\n            for(int i=0 ; i<n ; i++){\n                if(a[i] == b[i]){\n                    continue;\n                }\n                else if(a[i]<b[i]){\n                    inc+= Math.abs(b[i]-a[i]);\n                    for(int j =0 ; j<Math.abs(b[i]-a[i]); j++){\n                        ans1.add(i+1);\n                    }\n\n                }\n                else{\n                    dec+= Math.abs(a[i]-b[i]);\n                    int k = Math.abs(b[i]-a[i]);\n                    for(int j=0 ; j<k ; j++){\n                        ans2.add(i+1);\n                    }\n                }\n            }\n//            5\n//            4 3 2 1 0\n//            0 1 2 3 4\n//            System.out.println(inc+\" \"+dec);\n            if(inc!=dec){\n                System.out.println(-1);\n                \n            }\n            else{\n                System.out.println(inc);\n                for(int i=0 ; i<inc; i++){\n                    System.out.println(ans2.get(i)+\" \"+ans1.get(i));\n                }\n\n            }\n            \n        }\n    }\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class A {\n\n\tprivate static FastScanner fs = new FastScanner();\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint cases = fs.nextInt();\n\t\twhile (cases-- > 0) {\n\t\t\tsolve();\n\t\t}\n\t}\n\tstatic void solve() throws IOException {\n\t\tint n = fs.nextInt();\n\t\tint[] a = fs.nextInts(n);\n\t\tint[] b = fs.nextInts(n);\n\t\tArrayList<Integer> decrease = new ArrayList<>();\n\t\tArrayList<Integer> increase = new ArrayList<>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint diff = b[i] - a[i];\n\t\t\tif (diff > 0) {\n\t\t\t\tfor (int j = 0; j < diff; j++) {\n\t\t\t\t\tincrease.add(i);\n\t\t\t\t}\n\t\t\t} else if (diff < 0) {\n\t\t\t\tfor (int j = 0; j < Math.abs(diff); j++) {\n\t\t\t\t\tdecrease.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (decrease.size() != increase.size()) {\n\t\t\tSystem.out.println(-1);\n\t\t} else {\n\t\t\tSystem.out.println(decrease.size());\n\t\t\tfor (int i = 0; i < increase.size(); i++) {\n\t\t\t\tSystem.out.println(decrease.get(i)+1 + \" \" + (increase.get(i)+1));\n\t\t\t}\n\t\t}\n\n \t}\n\n\tstatic class FastScanner\n\t{\n\t\t//I don't understand how this works lmao\n\t\tprivate int BS = 1 << 16;\n\t\tprivate char NC = (char) 0;\n\t\tprivate byte[] buf = new byte[BS];\n\t\tprivate int bId = 0, size = 0;\n\t\tprivate char c = NC;\n\t\tprivate double cnt = 1;\n\t\tprivate BufferedInputStream in;\n\t\n\t\tpublic FastScanner() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\t\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t\t} catch (Exception e) {\n\t\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t\t}\n\t\t}\n\t\n\t\tprivate char getChar() {\n\t\t\twhile (bId == size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}\n\t\t\t\tif (size == -1) return NC;\n\t\t\t\tbId = 0;\n\t\t\t}\n\t\t\treturn (char) buf[bId++];\n\t\t}\n\t\n\t\tpublic int nextInt() {\n\t\t\treturn (int) nextLong();\n\t\t}\n\t\n\t\tpublic int[] nextInts(int N) {\n\t\t\tint[] res = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tres[i] = (int) nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\n\t\tpublic long[] nextLongs(int N) {\n\t\t\tlong[] res = new long[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\n\t\tpublic long nextLong() {\n\t\t\tcnt = 1;\n\t\t\tboolean neg = false;\n\t\t\tif (c == NC) c = getChar();\n\t\t\tfor (; (c < '0' || c > '9'); c = getChar()) {\n\t\t\t\tif (c == '-') neg = true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor (; c >= '0' && c <= '9'; c = getChar()) {\n\t\t\t\tres = (res << 3) + (res << 1) + c - '0';\n\t\t\t\tcnt *= 10;\n\t\t\t}\n\t\t\treturn neg ? -res : res;\n\t\t}\n\t\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c != '.' ? cur : cur + nextLong() / cnt;\n\t\t}\n\t\n\t\tpublic double[] nextDoubles(int N) {\n\t\t\tdouble[] res = new double[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile (c <= 32) c = getChar();\n\t\t\twhile (c > 32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc = getChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\t\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile (c <= 32) c = getChar();\n\t\t\twhile (c != '\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc = getChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\t\n\t\tpublic boolean hasNext() {\n\t\t\tif (c > 32) return true;\n\t\t\twhile (true) {\n\t\t\t\tc = getChar();\n\t\t\t\tif (c == NC) return false;\n\t\t\t\telse if (c > 32) return true;\n\t\t\t}\n\t\t}\n\t}\n}", "label": 3}
{"src": "import static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n/**\n *\n * @Har_Har_Mahadev\n */\n\n/**\n * Main , Solution , Remove Public\n */\npublic class A {\n\n\tpublic static void process() throws IOException {\n\n\t\tint n = sc.nextInt();\n\t\tint a[] = sc.readArray(n);\n\t\tint b[] = sc.readArray(n);\n\t\tDeque<Integer> q1 = new LinkedList<Integer>();\n\t\tDeque<Integer> q0 = new LinkedList<Integer>();\n\t\tfor(int i = 0; i<n; i++) {\n\t\t\tint diff = b[i]-a[i];\n\t\t\tif(diff > 0) {\n\t\t\t\twhile(diff-- > 0)q1.add(i);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(diff < 0) {\n\t\t\t\tdiff = abs(diff);\n\t\t\t\twhile(diff-- > 0)q0.add(i);\n\t\t\t}\n\t\t}\n\t\tArrayList<Pair> lis = new ArrayList<A.Pair>();\n\t\t\n\t\twhile(!q1.isEmpty() && !q0.isEmpty()) {\n\t\t\tlis.add(new Pair(q0.poll()+1, (q1.poll()+1)));\n\t\t}\n\t\tif(q1.isEmpty() && q0.isEmpty()) {\n\t\t\tSystem.out.println(lis.size());\n\t\t\tfor(Pair e : lis)System.out.println(e.x+\" \"+e.y);\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.println(-1);\n\t\t\n\n\t}\n\n\t//=============================================================================\n\t//--------------------------The End---------------------------------\n\t//=============================================================================\n\tprivate static long INF = 2000000000000000000L, M = 1000000007, MM = 998244353;\n\tprivate static int N = 0;\n\n\tprivate static void google(int tt) {\n\t\tSystem.out.print(\"Case #\" + (tt) + \": \");\n\t}\n\n\tstatic FastScanner sc;\n\tstatic FastWriter out;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tboolean oj = true;\n\t\tif (oj) {\n\t\t\tsc = new FastScanner();\n\t\t\tout = new FastWriter(System.out);\n\t\t} else {\n\t\t\tsc = new FastScanner(\"input.txt\");\n\t\t\tout = new FastWriter(\"output.txt\");\n\t\t}\n\t\tlong s = System.currentTimeMillis();\n\t\tint t = 1;\n\t\tt = sc.nextInt();\n\t\tint TTT = 1;\n\t\twhile (t-- > 0) {\n\t\t\t//\t\t\tgoogle(TTT++);\n\t\t\tprocess();\n\t\t}\n\t\tout.flush();\n\t\t//\t\ttr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\n\tprivate static boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n\n\tprivate static void tr(Object... o) {\n\t\tif (!oj)\n\t\t\tSystem.err.println(Arrays.deepToString(o));\n\t}\n\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint x, y;\n\n\t\tPair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn Integer.compare(this.x, o.x);\n\t\t}\n\n\t\t/*\n\t\t \t@Override\n\t\t    public boolean equals(Object o) {\n\t\t        if (this == o) return true;\n\t\t        if (!(o instanceof Pair)) return false;\n\t\t        Pair key = (Pair) o;\n\t\t        return x == key.x && y == key.y;\n\t\t    }\n\t\t \n\t\t    @Override\n\t\t    public int hashCode() {\n\t\t        int result = x;\n\t\t        result = 31 * result + y;\n\t\t        return result;\n\t\t    }\n\t\t*/\n\t}\n\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\tstatic int ceil(int x, int y) {\n\t\treturn (x % y == 0 ? x / y : (x / y + 1));\n\t}\n\n\tstatic long ceil(long x, long y) {\n\t\treturn (x % y == 0 ? x / y : (x / y + 1));\n\t}\n\n\tstatic long sqrt(long z) {\n\t\tlong sqz = (long) Math.sqrt(z);\n\t\twhile (sqz * 1L * sqz < z) {\n\t\t\tsqz++;\n\t\t}\n\t\twhile (sqz * 1L * sqz > z) {\n\t\t\tsqz--;\n\t\t}\n\t\treturn sqz;\n\t}\n\n\tstatic int log2(int N) {\n\t\tint result = (int) (Math.log(N) / Math.log(2));\n\t\treturn result;\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\tif (a > b)\n\t\t\ta = (a + b) - (b = a);\n\t\tif (a == 0L)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}\n\n\tpublic static long lcm(long a, long b) {\n\t\treturn (a * b) / gcd(a, b);\n\t}\n\n\tpublic static int lower_bound(int[] arr, int x) {\n\t\tint low = 0, high = arr.length - 1, mid = -1;\n\t\tint ans = -1;\n\t\twhile (low <= high) {\n\t\t\tmid = (low + high) / 2;\n\n\t\t\tif (arr[mid] > x) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\tans = mid;\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tpublic static int upper_bound(int[] arr, int x) {\n\t\tint low = 0, high = arr.length - 1, mid = -1;\n\t\tint ans = arr.length;\n\t\twhile (low < high) {\n\t\t\tmid = (low + high) / 2;\n\n\t\t\tif (arr[mid] >= x) {\n\t\t\t\tans = mid;\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\tlow = mid + 1;\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tstatic void ruffleSort(int[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tint temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\n\tstatic void ruffleSort(long[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tlong temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\n\tstatic void reverseArray(int[] a) {\n\t\tint n = a.length;\n\t\tint arr[] = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tarr[i] = a[n - i - 1];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = arr[i];\n\t}\n\n\tstatic void reverseArray(long[] a) {\n\t\tint n = a.length;\n\t\tlong arr[] = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tarr[i] = a[n - i - 1];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = arr[i];\n\t}\n\n\t//custom multiset (replace with HashMap if needed)\n\tpublic static void push(TreeMap<Integer, Integer> map, int k, int v) {\n\t\t//map[k] += v;\n\t\tif (!map.containsKey(k))\n\t\t\tmap.put(k, v);\n\t\telse\n\t\t\tmap.put(k, map.get(k) + v);\n\t}\n\n\tpublic static void pull(TreeMap<Integer, Integer> map, int k, int v) {\n\t\t//assumes map[k] >= v\n\t\t//map[k] -= v\n\t\tint lol = map.get(k);\n\t\tif (lol == v)\n\t\t\tmap.remove(k);\n\t\telse\n\t\t\tmap.put(k, lol - v);\n\t}\n\n\t// compress Big value to Time Limit\n\tpublic static int[] compress(int[] arr) {\n\t\tArrayList<Integer> ls = new ArrayList<Integer>();\n\t\tfor (int x : arr)\n\t\t\tls.add(x);\n\t\tCollections.sort(ls);\n\t\tHashMap<Integer, Integer> map = new HashMap<Integer, Integer>();\n\t\tint boof = 1; //min value\n\t\tfor (int x : ls)\n\t\t\tif (!map.containsKey(x))\n\t\t\t\tmap.put(x, boof++);\n\t\tint[] brr = new int[arr.length];\n\t\tfor (int i = 0; i < arr.length; i++)\n\t\t\tbrr[i] = map.get(arr[i]);\n\t\treturn brr;\n\t}\n\n\t// Fast Writer \n\n\tpublic static class FastWriter {\n\t\tprivate static final int BUF_SIZE = 1 << 13;\n\t\tprivate final byte[] buf = new byte[BUF_SIZE];\n\t\tprivate final OutputStream out;\n\t\tprivate int ptr = 0;\n\n\t\tprivate FastWriter() {\n\t\t\tout = null;\n\t\t}\n\n\t\tpublic FastWriter(OutputStream os) {\n\t\t\tthis.out = os;\n\t\t}\n\n\t\tpublic FastWriter(String path) {\n\t\t\ttry {\n\t\t\t\tthis.out = new FileOutputStream(path);\n\t\t\t} catch (FileNotFoundException e) {\n\t\t\t\tthrow new RuntimeException(\"FastWriter\");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter write(byte b) {\n\t\t\tbuf[ptr++] = b;\n\t\t\tif (ptr == BUF_SIZE)\n\t\t\t\tinnerflush();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(char c) {\n\t\t\treturn write((byte) c);\n\t\t}\n\n\t\tpublic FastWriter write(char[] s) {\n\t\t\tfor (char c : s) {\n\t\t\t\tbuf[ptr++] = (byte) c;\n\t\t\t\tif (ptr == BUF_SIZE)\n\t\t\t\t\tinnerflush();\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(String s) {\n\t\t\ts.chars().forEach(c -> {\n\t\t\t\tbuf[ptr++] = (byte) c;\n\t\t\t\tif (ptr == BUF_SIZE)\n\t\t\t\t\tinnerflush();\n\t\t\t});\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(int l) {\n\t\t\tif (l >= 1000000000)\n\t\t\t\treturn 10;\n\t\t\tif (l >= 100000000)\n\t\t\t\treturn 9;\n\t\t\tif (l >= 10000000)\n\t\t\t\treturn 8;\n\t\t\tif (l >= 1000000)\n\t\t\t\treturn 7;\n\t\t\tif (l >= 100000)\n\t\t\t\treturn 6;\n\t\t\tif (l >= 10000)\n\t\t\t\treturn 5;\n\t\t\tif (l >= 1000)\n\t\t\t\treturn 4;\n\t\t\tif (l >= 100)\n\t\t\t\treturn 3;\n\t\t\tif (l >= 10)\n\t\t\t\treturn 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(int x) {\n\t\t\tif (x == Integer.MIN_VALUE) {\n\t\t\t\treturn write((long) x);\n\t\t\t}\n\t\t\tif (ptr + 12 >= BUF_SIZE)\n\t\t\t\tinnerflush();\n\t\t\tif (x < 0) {\n\t\t\t\twrite((byte) '-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor (int i = ptr + d - 1; i >= ptr; i--) {\n\t\t\t\tbuf[i] = (byte) ('0' + x % 10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tprivate static int countDigits(long l) {\n\t\t\tif (l >= 1000000000000000000L)\n\t\t\t\treturn 19;\n\t\t\tif (l >= 100000000000000000L)\n\t\t\t\treturn 18;\n\t\t\tif (l >= 10000000000000000L)\n\t\t\t\treturn 17;\n\t\t\tif (l >= 1000000000000000L)\n\t\t\t\treturn 16;\n\t\t\tif (l >= 100000000000000L)\n\t\t\t\treturn 15;\n\t\t\tif (l >= 10000000000000L)\n\t\t\t\treturn 14;\n\t\t\tif (l >= 1000000000000L)\n\t\t\t\treturn 13;\n\t\t\tif (l >= 100000000000L)\n\t\t\t\treturn 12;\n\t\t\tif (l >= 10000000000L)\n\t\t\t\treturn 11;\n\t\t\tif (l >= 1000000000L)\n\t\t\t\treturn 10;\n\t\t\tif (l >= 100000000L)\n\t\t\t\treturn 9;\n\t\t\tif (l >= 10000000L)\n\t\t\t\treturn 8;\n\t\t\tif (l >= 1000000L)\n\t\t\t\treturn 7;\n\t\t\tif (l >= 100000L)\n\t\t\t\treturn 6;\n\t\t\tif (l >= 10000L)\n\t\t\t\treturn 5;\n\t\t\tif (l >= 1000L)\n\t\t\t\treturn 4;\n\t\t\tif (l >= 100L)\n\t\t\t\treturn 3;\n\t\t\tif (l >= 10L)\n\t\t\t\treturn 2;\n\t\t\treturn 1;\n\t\t}\n\n\t\tpublic FastWriter write(long x) {\n\t\t\tif (x == Long.MIN_VALUE) {\n\t\t\t\treturn write(\"\" + x);\n\t\t\t}\n\t\t\tif (ptr + 21 >= BUF_SIZE)\n\t\t\t\tinnerflush();\n\t\t\tif (x < 0) {\n\t\t\t\twrite((byte) '-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tint d = countDigits(x);\n\t\t\tfor (int i = ptr + d - 1; i >= ptr; i--) {\n\t\t\t\tbuf[i] = (byte) ('0' + x % 10);\n\t\t\t\tx /= 10;\n\t\t\t}\n\t\t\tptr += d;\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(double x, int precision) {\n\t\t\tif (x < 0) {\n\t\t\t\twrite('-');\n\t\t\t\tx = -x;\n\t\t\t}\n\t\t\tx += Math.pow(10, -precision) / 2;\n\t\t\t//\t\tif(x < 0){ x = 0; }\n\t\t\twrite((long) x).write(\".\");\n\t\t\tx -= (long) x;\n\t\t\tfor (int i = 0; i < precision; i++) {\n\t\t\t\tx *= 10;\n\t\t\t\twrite((char) ('0' + (int) x));\n\t\t\t\tx -= (int) x;\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(char c) {\n\t\t\treturn write(c).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(int x) {\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long x) {\n\t\t\treturn write(x).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(double x, int precision) {\n\t\t\treturn write(x, precision).writeln();\n\t\t}\n\n\t\tpublic FastWriter write(int... xs) {\n\t\t\tboolean first = true;\n\t\t\tfor (int x : xs) {\n\t\t\t\tif (!first)\n\t\t\t\t\twrite(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter write(long... xs) {\n\t\t\tboolean first = true;\n\t\t\tfor (long x : xs) {\n\t\t\t\tif (!first)\n\t\t\t\t\twrite(' ');\n\t\t\t\tfirst = false;\n\t\t\t\twrite(x);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln() {\n\t\t\treturn write((byte) '\\n');\n\t\t}\n\n\t\tpublic FastWriter writeln(int... xs) {\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(long... xs) {\n\t\t\treturn write(xs).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[] line) {\n\t\t\treturn write(line).writeln();\n\t\t}\n\n\t\tpublic FastWriter writeln(char[]... map) {\n\t\t\tfor (char[] line : map)\n\t\t\t\twrite(line).writeln();\n\t\t\treturn this;\n\t\t}\n\n\t\tpublic FastWriter writeln(String s) {\n\t\t\treturn write(s).writeln();\n\t\t}\n\n\t\tprivate void innerflush() {\n\t\t\ttry {\n\t\t\t\tout.write(buf, 0, ptr);\n\t\t\t\tptr = 0;\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"innerflush\");\n\t\t\t}\n\t\t}\n\n\t\tpublic void flush() {\n\t\t\tinnerflush();\n\t\t\ttry {\n\t\t\t\tout.flush();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(\"flush\");\n\t\t\t}\n\t\t}\n\n\t\tpublic FastWriter print(byte b) {\n\t\t\treturn write(b);\n\t\t}\n\n\t\tpublic FastWriter print(char c) {\n\t\t\treturn write(c);\n\t\t}\n\n\t\tpublic FastWriter print(char[] s) {\n\t\t\treturn write(s);\n\t\t}\n\n\t\tpublic FastWriter print(String s) {\n\t\t\treturn write(s);\n\t\t}\n\n\t\tpublic FastWriter print(int x) {\n\t\t\treturn write(x);\n\t\t}\n\n\t\tpublic FastWriter print(long x) {\n\t\t\treturn write(x);\n\t\t}\n\n\t\tpublic FastWriter print(double x, int precision) {\n\t\t\treturn write(x, precision);\n\t\t}\n\n\t\tpublic FastWriter println(char c) {\n\t\t\treturn writeln(c);\n\t\t}\n\n\t\tpublic FastWriter println(int x) {\n\t\t\treturn writeln(x);\n\t\t}\n\n\t\tpublic FastWriter println(long x) {\n\t\t\treturn writeln(x);\n\t\t}\n\n\t\tpublic FastWriter println(double x, int precision) {\n\t\t\treturn writeln(x, precision);\n\t\t}\n\n\t\tpublic FastWriter print(int... xs) {\n\t\t\treturn write(xs);\n\t\t}\n\n\t\tpublic FastWriter print(long... xs) {\n\t\t\treturn write(xs);\n\t\t}\n\n\t\tpublic FastWriter println(int... xs) {\n\t\t\treturn writeln(xs);\n\t\t}\n\n\t\tpublic FastWriter println(long... xs) {\n\t\t\treturn writeln(xs);\n\t\t}\n\n\t\tpublic FastWriter println(char[] line) {\n\t\t\treturn writeln(line);\n\t\t}\n\n\t\tpublic FastWriter println(char[]... map) {\n\t\t\treturn writeln(map);\n\t\t}\n\n\t\tpublic FastWriter println(String s) {\n\t\t\treturn writeln(s);\n\t\t}\n\n\t\tpublic FastWriter println() {\n\t\t\treturn writeln();\n\t\t}\n\t}\n\n\t// Fast Inputs\n\tstatic class FastScanner {\n\t\t//I don't understand how this works lmao\n\t\tprivate int BS = 1 << 16;\n\t\tprivate char NC = (char) 0;\n\t\tprivate byte[] buf = new byte[BS];\n\t\tprivate int bId = 0, size = 0;\n\t\tprivate char c = NC;\n\t\tprivate double cnt = 1;\n\t\tprivate BufferedInputStream in;\n\n\t\tpublic FastScanner() {\n\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t}\n\n\t\tpublic FastScanner(String s) {\n\t\t\ttry {\n\t\t\t\tin = new BufferedInputStream(new FileInputStream(new File(s)), BS);\n\t\t\t} catch (Exception e) {\n\t\t\t\tin = new BufferedInputStream(System.in, BS);\n\t\t\t}\n\t\t}\n\n\t\tprivate char getChar() {\n\t\t\twhile (bId == size) {\n\t\t\t\ttry {\n\t\t\t\t\tsize = in.read(buf);\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\treturn NC;\n\t\t\t\t}\n\t\t\t\tif (size == -1)\n\t\t\t\t\treturn NC;\n\t\t\t\tbId = 0;\n\t\t\t}\n\t\t\treturn (char) buf[bId++];\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int) nextLong();\n\t\t}\n\n\t\tpublic int[] readArray(int N) {\n\t\t\tint[] res = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tres[i] = (int) nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] readArrayLong(int N) {\n\t\t\tlong[] res = new long[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic int[][] readArrayMatrix(int N, int M, int Index) {\n\t\t\tif (Index == 0) {\n\t\t\t\tint[][] res = new int[N][M];\n\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\tfor (int j = 0; j < M; j++)\n\t\t\t\t\t\tres[i][j] = (int) nextLong();\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tint[][] res = new int[N][M];\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tfor (int j = 1; j <= M; j++)\n\t\t\t\t\tres[i][j] = (int) nextLong();\n\t\t\t}\n\t\t\treturn res;\n\n\t\t}\n\n\t\tpublic long[][] readArrayMatrixLong(int N, int M, int Index) {\n\t\t\tif (Index == 0) {\n\t\t\t\tlong[][] res = new long[N][M];\n\t\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\t\tfor (int j = 0; j < M; j++)\n\t\t\t\t\t\tres[i][j] = nextLong();\n\t\t\t\t}\n\t\t\t\treturn res;\n\t\t\t}\n\t\t\tlong[][] res = new long[N][M];\n\t\t\tfor (int i = 1; i <= N; i++) {\n\t\t\t\tfor (int j = 1; j <= M; j++)\n\t\t\t\t\tres[i][j] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\tcnt = 1;\n\t\t\tboolean neg = false;\n\t\t\tif (c == NC)\n\t\t\t\tc = getChar();\n\t\t\tfor (; (c < '0' || c > '9'); c = getChar()) {\n\t\t\t\tif (c == '-')\n\t\t\t\t\tneg = true;\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tfor (; c >= '0' && c <= '9'; c = getChar()) {\n\t\t\t\tres = (res << 3) + (res << 1) + c - '0';\n\t\t\t\tcnt *= 10;\n\t\t\t}\n\t\t\treturn neg ? -res : res;\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\tdouble cur = nextLong();\n\t\t\treturn c != '.' ? cur : cur + nextLong() / cnt;\n\t\t}\n\n\t\tpublic double[] readArrayDouble(int N) {\n\t\t\tdouble[] res = new double[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tres[i] = nextDouble();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile (c <= 32)\n\t\t\t\tc = getChar();\n\t\t\twhile (c > 32) {\n\t\t\t\tres.append(c);\n\t\t\t\tc = getChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\twhile (c <= 32)\n\t\t\t\tc = getChar();\n\t\t\twhile (c != '\\n') {\n\t\t\t\tres.append(c);\n\t\t\t\tc = getChar();\n\t\t\t}\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tpublic boolean hasNext() {\n\t\t\tif (c > 32)\n\t\t\t\treturn true;\n\t\t\twhile (true) {\n\t\t\t\tc = getChar();\n\t\t\t\tif (c == NC)\n\t\t\t\t\treturn false;\n\t\t\t\telse if (c > 32)\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n}\n", "label": 3}
{"src": "\nimport java.io.*;\nimport java.util.*;\n\npublic class Bfs {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t\ttry {\n\t\t\tScanner s = new Scanner(System.in);\n\t\t\tint t =s.nextInt();\n\t\t\t\n\t\t\twhile (t-- > 0) {\n\t\t\t\tint sp = 0;\n\t\t\t\tint sn = 0;\n\t\t\t\tint n = s.nextInt();\n\t\t\t\tint arr[] = new int[n];\n\t\t\t\t\n\t\t\t\tfor(int i =0;i<n;i++) {\n\t\t\t\t\tarr[i]=s.nextInt();\n\t\t\t\t}\n\t\t\t\tint brr[] = new int[n];\n\t\t\t\t\n\t\t\t\tfor(int i =0;i<n;i++) {\n\t\t\t\t\tbrr[i]=s.nextInt();\n\t\t\t\t}\n\t\t\t\tArrayList<Integer> increment = new ArrayList<Integer>();\n\t\t\t\tArrayList<Integer> decrement = new ArrayList<Integer>();\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tint x = arr[i] - brr[i];\n\n\t\t\t\t\tif (x > 0) {\n\t\t\t\t\t\tsp = sp + x;\n\t\t\t\t\t\twhile (x-- > 0) {\n\t\t\t\t\t\t\tincrement.add(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (x < 0) {\n\t\t\t\t\t\tx *=-1;\n\t\t\t\t\t\tsn = sn + x;\n\t\t\t\t\t\twhile (x-- > 0) {\n\t\t\t\t\t\t\tdecrement.add(i);\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else if (x == 0) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif (sp == sn) {\n\t\t\t\t\tSystem.out.println(sp);\n\t\t\t\t\tfor (int i = 0; i < sn; i++) {\n\t\t\t\t\t\tint ans1=increment.get(i);\n\t\t\t\t\t\tint ans2=decrement.get(i);\n\t\t\t\t\t\tSystem.out.print(ans1+1 + \" \");\n\t\t\t\t\t\tSystem.out.println(ans2+1);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(\"-1\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(e);\n\t\t}\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTask solver = new Task();\n\t\tint t = in.nextInt();\n\t\tfor (int i=1;i<=t;i++)\n\t\t\tsolver.solve(i, in, out);\n\t\tout.close();\n\t}\n\n\tstatic class Task {\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\t\t\tint n = in.nextInt();\n\t\t\tint[] a = in.nextIntArray(n);\n\t\t\tint[] b = in.nextIntArray(n);\n\n\t\t\tint[] diff = new int[n];\n\t\t\tint totalDiff = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tdiff[i] = a[i] - b[i];\n\t\t\t\ttotalDiff += diff[i];\n\t\t\t}\n\t\t\tif (totalDiff != 0) {\n\t\t\t\tout.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tList<Pair> ans = new ArrayList<>();\n\n\t\t\tint negPtr = 0, posPtr = 0;\n\t\t\twhile(negPtr < n && posPtr < n) {\n\t\t\t\tif(diff[negPtr] >= 0) {\n\t\t\t\t\tnegPtr++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(diff[posPtr] <= 0) {\n\t\t\t\t\tposPtr++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tans.add(new Pair(posPtr + 1, negPtr + 1));\n\t\t\t\tdiff[negPtr]++;\n\t\t\t\tdiff[posPtr]--;\n\t\t\t}\n\n\t\t\tout.println(ans.size());\n\t\t\tfor(Pair p: ans)\n\t\t\t\tout.println(p.first + \" \" + p.second);\n\n\t\t}\n\n\t\tclass Pair {\n\t\t\tint first, second;\n\t\t\tpublic Pair(int first, int second) {\n\t\t\t\tthis.first = first;\n\t\t\t\tthis.second = second;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic class InputReader {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\n\t\tpublic InputReader(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\n\t\tpublic String nextToken() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttokenizer = new StringTokenizer(nextLine());\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextToken());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextToken());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextToken());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int size) {\n\t\t\tint[] arr = new int[size];\n\t\t\tfor (int i = 0; i < size; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\n\t}\n}", "label": 3}
{"src": "//WHEN IN DOUBT , USE BRUTE FORCE !!!!!!!!!\n//https://www.geeksforgeeks.org/count-pairs-with-given-sum/\nimport java.io.*;\nimport java.util.*;\n//class Main    //AtCoder\n//class Solution // Codechef\npublic class Solution2 //Codeforces\n{\n    public static void main(String args[])\n    {\n        try {\n            FastReader sc = new FastReader();\n            int TT = sc.nextInt();\n            for(int hehe=1 ; hehe  <= TT ; hehe++) {\n                int N=sc.nextInt();\n                long a[]=new long[N];\n                long b[]=new long[N];\n                long sum1=0,sum2=0;\n                for(int i=0;i<N;i++) {\n                    a[i] = sc.nextLong();\n                    sum1+=a[i];\n                }\n                for(int i=0;i<N;i++) {\n                    b[i] = sc.nextLong();\n                    sum2+=b[i];\n                }\n                if(sum1!=sum2){\n                    sopln(-1);\n                }else{\n                    Vector<String> ans=new Vector<>();\n                    for(int i=0;i<N;i++){\n                        for(int j=0;j<N;j++){\n                            long diff=a[i]-b[i];\n                            long diff2=a[j]-b[j];\n                            if((diff>0 && diff2<0) && i!=j)\n                            {\n                                long tt=Math.min(Math.abs(diff),Math.abs(diff2));\n                                //sopln(\"HEHE IS :- \" + tt);\n                                a[j]+=tt;\n                                a[i]-=tt;\n                                for(int jj=1;jj<=tt;jj++)\n                                    ans.add(i+1+\" \"+(j+1));\n                                //sop(\"AFTER OPERATION :- \");\n                                //printArray(a);\n                            }\n                            else if((diff<0 && diff2>0) && i!=j){\n                                long tt=Math.min(Math.abs(diff),Math.abs(diff2));\n                                //sopln(\"HEHE IS :- \" + tt);\n                                a[j]-=tt;\n                                a[i]+=tt;\n                                for(int jj=1;jj<=tt/1;jj++)\n                                    ans.add(j+1+\" \"+(i+1));\n                                //sop(\"AFTER OPERATION :- \");\n                                //printArray(a);\n                            }\n                        }\n                    }\n                    //printArray(a);\n                    //Collections.sort(ans);\n                    sopln(ans.size());\n                    for(String s: ans)\n                        sopln(s);\n                }\n            }\n            out.flush();\n        }catch(Exception e){\n            sopln(e.getCause());\n        }\n    }\n\n    static long countDigits(long num){\n        if(num < 10)return 1l;\n        else if(num < 100)return 2l;\n        else if(num < 1000)return 3l;\n        else if(num < 10000)return 4l;\n        else if(num < 100000)return 5l;\n        else if(num < 1000000)return 6l;\n        else if(num < 10000000)return 7l;\n        else if(num < 100000000)return 8l;\n        else if(num < 1000000000)return 9l;\n        else if(num < 10000000000l)return 10l;\n        else if(num < 100000000000l)return 11l;\n        else if(num < 1000000000000l)return 12l;\n        else if(num < 10000000000000l)return 13l;\n        else if(num < 100000000000000l)return 14l;\n        else if(num < 1000000000000000l)return 15l;\n        else if(num < 10000000000000000l)return 16l;\n        else if(num < 100000000000000000l)return 17l;\n        else if(num < 1000000000000000000l)return 18l;\n        else\n            return 19l;\n    }\n\n    static void ruffleSort(int[] a) {\n        ArrayList<Integer> l=new ArrayList<>();\n        for (int i:a) l.add(i);\n        Collections.sort(l);\n        for (int i=0; i<a.length; i++) a[i]=l.get(i);\n    }\n\n    static void ruffleSortRev(long[] a) {\n        ArrayList<Long> l=new ArrayList<>();\n        for (long i:a) l.add(i);\n        Collections.sort(l);Collections.reverse(l);\n        for (int i=0; i<a.length; i++) a[i]=l.get(i);\n    }\n\n    static int power(int x, int y, int p)\n    {\n\n        // Initialize result\n        int res = 1;\n\n        // Update x if it is more than or\n        // equal to p\n        x = x % p;\n\n        while (y > 0) {\n\n            // If y is odd, multiply x\n            // with result\n            if (y % 2 == 1)\n                res = (res * x) % p;\n\n            // y must be even now\n            y = y >> 1; // y = y/2\n            x = (x * x) % p;\n        }\n\n        return res;\n    }\n\n    // Returns n^(-1) mod p\n    static int modInverse(int n, int p)\n    {\n        return power(n, p - 2, p);\n    }\n\n    // Returns nCr % p using Fermat's\n    // little theorem.\n    static int nCrModPFermat(int n, int r,\n                             int p)\n    {\n\n        if (n<r)\n            return 0;\n        // Base case\n        if (r == 0)\n            return 1;\n\n        // Fill factorial array so that we\n        // can find all factorial of r, n\n        // and n-r\n        int[] fac = new int[n + 1];\n        fac[0] = 1;\n\n        for (int i = 1; i <= n; i++)\n            fac[i] = fac[i - 1] * i % p;\n\n        return (fac[n] * modInverse(fac[r], p)\n                % p * modInverse(fac[n - r], p)\n                % p)\n                % p;\n    }\n\n\n    static boolean isPrime(long n)\n    {\n\n        // Check if number is less than\n        // equal to 1\n        if (n <= 1)\n            return false;\n\n            // Check if number is 2\n        else if (n == 2)\n            return true;\n\n            // Check if n is a multiple of 2\n        else if (n % 2 == 0)\n            return false;\n\n        // If not, then just check the odds\n        for (int i = 3; i <= Math.sqrt(n); i += 2)\n        {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n\n    static long gcd(long a, long b)\n    {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    static long countDig(long N){\n        if(N < 10)\n            return 1;\n        else\n            return 1+countDig(N/10);\n    }\n\n\n    public final static int d = 256;\n    static int MOD = 1000000007;\n    static final double PI = Math.PI;\n    private static BufferedReader in = new BufferedReader (new InputStreamReader (System.in));\n    private static PrintWriter out = new PrintWriter (new OutputStreamWriter (System.out));\n    static class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader()\n        {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        char nextChar()\n        {\n            try {\n                return (char) (br.read());\n            }catch (IOException e){\n                return '~';\n            }\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    static void sop(Object o){out.print(o);}\n    static double ceil(double d){\n        return Math.ceil(d);\n    }\n    static double floor(double d){\n        return Math.floor(d);\n    }\n    static double round(double d){\n        return Math.round(d);\n    }\n\n    static void sopln(Object o){out.println(o);}\n    static void printArray(boolean[] arr){\n        for(int i=0;i<arr.length;i++){\n            sop(arr[i]+\" \");\n        }\n        sopln(\"\");\n    }\n    static void printArray(long[] arr){\n        for(int i=0;i<arr.length;i++){\n            sop(arr[i]+\" \");\n        }\n        sopln(\"\");\n    }\n    static long power(long x, long y, long p)\n    {\n\n        // Initialize result\n        long res = 1;\n\n        // Update x if it is more than or\n        // equal to p\n        x = x % p;\n\n        while (y > 0) {\n\n            // If y is odd, multiply x\n            // with result\n            if (y % 2 == 1)\n                res = (res * x) % p;\n\n            // y must be even now\n            y = y >> 1; // y = y/2\n            x = (x * x) % p;\n        }\n\n        return res;\n    }\n\n    // Returns n^(-1) mod p\n    static long modInverse(long n, int p)\n    {\n        return power(n, p - 2, p);\n    }\n\n    // Returns nCr % p using Fermat's\n    // little theorem.\n\n    ///\n\n    // Function to find modular\n// inverse of a under modulo p\n// using Fermat's method.\n// Assumption: p is prime\n    static long modFact(int n,\n                        int p)\n    {\n        if (n >= p)\n            return 0;\n\n        long result = 1;\n        for (int i = 1; i <= n; i++)\n            result = (result * i) % p;\n\n        return result;\n    }\n\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A {\n    static class Kattio extends PrintWriter {\n        private BufferedReader r;\n        private StringTokenizer st;\n        // standard input\n        public Kattio() { this(System.in,System.out); }\n        public Kattio(InputStream i, OutputStream o) {\n            super(o);\n            r = new BufferedReader(new InputStreamReader(i));\n        }\n        // USACO-style file input\n        public Kattio(String problemName) throws IOException {\n            super(new FileWriter(problemName+\".out\"));\n            r = new BufferedReader(new FileReader(problemName+\".in\"));\n        }\n        // returns null if no more input\n        public String next() {\n            try {\n                while (st == null || !st.hasMoreTokens())\n                    st = new StringTokenizer(r.readLine());\n                return st.nextToken();\n            } catch (Exception e) {}\n            return null;\n        }\n        public int nextInt() { return Integer.parseInt(next()); }\n        public double nextDouble() { return Double.parseDouble(next()); }\n        public long nextLong() { return Long.parseLong(next()); }\n    }\n\n    public static void main(String[] args) {\n        Kattio io = new Kattio();\n        int t = io.nextInt();\n        while (t > 0) {\n            int n = io.nextInt();\n\n            int[] a = new int[n];\n            int[] b = new int[n];\n\n            for (int i = 0; i < n; i++) a[i] = io.nextInt();\n            for (int i = 0; i < n; i++) b[i] = io.nextInt();\n\n            int sum = 0;\n            for (int i = 0; i < n; i++) sum += a[i] - b[i];\n\n            if (sum != 0) {\n                io.println(-1);\n            } else {\n                List<int[]> ops = new ArrayList<>();\n\n                for (int i = 0; i < n; i++) {\n                    while (a[i] < b[i]) {\n                        for (int j = i + 1; j < n; j++) {\n                            while (a[i] < b[i] && a[j] > b[j]) {\n                                a[j]--;\n                                a[i]++;\n                                ops.add(new int[] {j + 1, i + 1});\n                            }\n                        }\n                    }\n\n                    while (a[i] > b[i]) {\n                        for (int j = i + 1; j < n; j++) {\n                            while (a[i] > b[i] && a[j] < b[j]) {\n                                a[j]++;\n                                a[i]--;\n                                ops.add(new int[] {i + 1, j + 1});\n                            }\n                        }\n                    }\n                }\n\n                io.println(ops.size());\n                if (ops.size() != 0) {\n                    for (int[] op : ops) {\n                        io.println(op[0] + \" \" + op[1]);\n                    }\n                }\n            }\n\n            t--;\n        }\n\n        io.close();\n    }\n}\n", "label": 3}
{"src": "import com.sun.org.apache.xpath.internal.SourceTree;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.StringTokenizer;\nimport java.util.Arrays;\n\n\n\npublic class Main {\n\n    public static void main(String args[]) throws Exception {\n\n        FastReader fs = new FastReader();\n\n        int t = fs.nextInt();\n\n        while (t-- > 0) {\n            StringBuffer sb = new StringBuffer();\n\n            int n = fs.nextInt();\n\n            int a[] = new int[n];\n            int b[] = new int[n];\n\n            for(int i=0;i<n;i++) {\n                a[i] = fs.nextInt();\n            }\n\n            for(int i=0;i<n;i++) {\n                b[i] = fs.nextInt();\n            }\n\n            int[] compArr = new int[n];\n            int sum =0;\n            int numberOfOperatios =0 ;\n            for(int i=0; i<n; i++) {\n                compArr[i] = b[i] - a[i];\n                sum += compArr[i];\n                if(compArr[i]>0){\n                    numberOfOperatios += compArr[i];\n                }\n            }\n\n            if(sum != 0) {\n                sb.append(-1);\n                sb.append(\"\\n\");\n                System.out.print(sb);\n                continue;\n            }\n\n            sb.append(numberOfOperatios);\n            sb.append(\"\\n\");\n\n\n\n            // a[] - 1\n            ArrayList<Integer> left = new ArrayList<>();\n            // a[] + 1\n            ArrayList<Integer> right = new ArrayList<>();\n\n            for(int i=0; i<n; i++) {\n\n                if(compArr[i] < 0) {\n\n                    while(compArr[i] < 0) {\n                        left.add(i+1);\n                        compArr[i] = compArr[i] + 1;\n                    }\n                } else if(compArr[i] > 0) {\n\n                    while(compArr[i] > 0) {\n                        right.add(i+1);\n                        compArr[i] = compArr[i] - 1;\n                    }\n                } else {\n                    continue;\n                }\n\n            }\n\n            for(int i=0; i<left.size(); i++) {\n\n                sb.append(left.get(i));\n                sb.append(\" \");\n                sb.append(right.get(i));\n                sb.append(\"\\n\");\n\n            }\n\n            System.out.print(sb);\n\n\n        }\n\n\n\n\n\n    }\n\n\n\n\n\n    //Fast Reader\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main{\n\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        \n        // Start writing your solution here. -------------------------------------\n        /*\n        int n      = sc.nextInt();        // read input as integer\n        long k     = sc.nextLong();       // read input as long\n        double d   = sc.nextDouble();     // read input as double\n        char c = sc.next().charAt(0);     // read input as char\n        String str = sc.next();           // read input as String\n        String s   = sc.nextLine();       // read whole line as String\n        out.println(result);              // print via PrintWriter\n        */\n        //------------------------------------------------------------------\n\n\n        int test = sc.nextInt();\n\n        while(test -- > 0){\n\n            int n = sc.nextInt();\n\n            int[] a  = new int[n];\n            int[] b = new int[n];\n\n            for(int i = 0 ; i < n ; i++){\n                a[i] = sc.nextInt();\n            }\n\n            for(int i = 0 ; i < n ; i++){\n                b[i] = sc.nextInt();\n            }\n\n            int sum = 0;\n            for(int i = 0 ; i < n ; i++){\n                sum += a[i] - b[i];\n            }\n\n            if(sum != 0){\n                out.println(-1);\n                continue;\n            }\n\n            ArrayList<Integer> pos = new ArrayList<>();\n            ArrayList<Integer> neg = new ArrayList<>();\n\n            for(int i = 0 ; i < n ; i++){\n                if(a[i] - b[i] > 0){\n                    for(int j  = 0 ; j < Math.abs(a[i]-b[i]); j++){\n                        neg.add(i+1);\n                    }\n                }else if(a[i] -b[i] < 0){\n                    for(int j  = 0 ; j < Math.abs(a[i]-b[i]); j++){\n                        pos.add(i+1);\n                    }\n                }else{\n\n                }\n            }\n\n            out.println(pos.size());\n            for(int i = 0 ;i < pos.size() ; i++){\n                out.println(neg.get(i) + \" \" + pos.get(i));\n            }\n\n          \n        }\n\n        //------------------------------------------------------------------\n        \n        // Stop writing your solution here. -------------------------------------\n        out.close();\n    }\n\n     \n \n    //-----------PrintWriter for faster output---------------------------------\n    public static PrintWriter out;\n      \n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n      BufferedReader br;\n      StringTokenizer st;\n \n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n    \n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n    \n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n    \n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    \n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    \n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n   //--------------------------------------------------------\n}", "label": 3}
{"src": "/*Everything is Hard \n * Before Easy \n * Jai Mata Dii \n */ \n \nimport java.util.*; \nimport java.io.*; \n  \npublic class Main { \n\tstatic class FastReader{ BufferedReader br;StringTokenizer st;public FastReader(){br = new BufferedReader(new InputStreamReader(System.in));}String next(){while (st == null || !st.hasMoreElements()){try{st = new StringTokenizer(br.readLine());}catch (IOException  e){e.printStackTrace();}}return st.nextToken();}int nextInt(){ return Integer.parseInt(next());}long nextLong(){return Long.parseLong(next());}double nextDouble(){return Double.parseDouble(next());}String nextLine(){String str = \"\"; try{str = br.readLine(); } catch (IOException e) {e.printStackTrace();} return str; }} \n\tstatic long mod = (long)(1e9+7); \n\t// static long mod = 998244353; \n//\t static Scanner sc = new Scanner(System.in); \n\tstatic FastReader sc = new FastReader(); \n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic int ans[];\n\tpublic static void main (String[] args) { \n\t\tint ttt = 1;\n\t\tttt = sc.nextInt();\n\t\tz :for(int tc=1;tc<=ttt;tc++){\n\t\t\tint n = sc.nextInt();\n\t\t\tint a[] = new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint b[] = new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t}\n\t\t\tArrayList<int[]> ans = new ArrayList<>();\n\t\t\tboolean is = true;\n\t\t\twhile(true) {\n\t\t\t\tint pos = -1;\n\t\t\t\tint neg = -1;\n\t\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\t\tif(a[i]<b[i]) {\n\t\t\t\t\t\tpos = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\t\tif(a[i]>b[i]) {\n\t\t\t\t\t\tneg = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif((pos==-1 && neg!=-1)||(neg==-1&&pos!=-1)) {\n\t\t\t\t\tis = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(pos==-1 && neg==-1) break;\n\t\t\t\ta[pos]++;\n\t\t\t\ta[neg]--;\n\t\t\t\tans.add(new int[] {neg,pos});\n\t\t\t}\n\t\t\tif(is) {\n\t\t\t\tout.write(ans.size()+\"\\n\");\n\t\t\t\tfor(int c[] : ans) {\n\t\t\t\t\tout.write((c[0]+1)+\" \"+(c[1]+1)+\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.write(\"-1\\n\");\n\t\t\t}\n\t\t}\n\t\tout.close();\n\t}\n\tstatic int gcd(long a,long b) { if(b==0) return  (int)a; return gcd(b,a%b); } \n\tprivate static void sort(int[] a) {List<Integer> k = new ArrayList<>();for(int val : a) k.add(val);Collections.sort(k);for(int i=0;i<a.length;i++) a[i] = k.get(i);} \n\tprivate static void ini(List<Integer>[] tre2){for(int i=0;i<tre2.length;i++){tre2[i] = new ArrayList<>();}} \n\tprivate static void init(List<int[]>[] tre2){for(int i=0;i<tre2.length;i++){tre2[i] = new ArrayList<>();}} \n\tprivate static void sort(long[] a) {List<Long> k = new ArrayList<>();for(long val : a) k.add(val);Collections.sort(k);for(int i=0;i<a.length;i++) a[i] = k.get(i);} \n}", "label": 3}
{"src": "import java.util.Scanner;\nimport java.util.Stack;\n\npublic class Main {\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int testcases = sc.nextInt();\n        while (testcases-- > 0) {\n            int n = sc.nextInt();\n            int[] a = new int[n];\n            int[] b = new int[n];\n            int suma = 0;\n            int sumb = 0;\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextInt();\n                suma += a[i];\n            }\n            for (int i = 0; i < n; i++) {\n                b[i] = sc.nextInt();\n                sumb += b[i];\n            }\n            if (suma != sumb) {\n                System.out.println(\"-1\");\n                continue;\n            }\n            checkit(a, b);\n        }\n\n    }\n\n    private static void checkit(int[] a, int[] b) {\n        Stack<Temp> stackadd = new Stack<>();\n        Stack<Temp> stacksub = new Stack<>();\n        for (int i = 0; i < a.length; i++) {\n            if (a[i] < b[i]) {\n                stackadd.push(new Temp(i, b[i] - a[i]));\n            }\n            if (a[i] > b[i]) {\n                stacksub.push(new Temp(i, a[i] - b[i]));\n            }\n        }\n        int count = 0;\n        for (Temp temp :\n                stackadd) {\n            count += temp.value;\n        }\n        System.out.println(count);\n        while (!stackadd.isEmpty()) {\n            Temp toadd = stackadd.pop();\n            Temp tosub = stacksub.pop();\n            System.out.println((tosub.index + 1) + \" \" + (toadd.index + 1));\n            toadd.value -= 1;\n            tosub.value -= 1;\n            if (toadd.value > 0) {\n                stackadd.push(toadd);\n            }\n            if (tosub.value > 0) {\n                stacksub.add(tosub);\n            }\n        }\n    }\n\n    static class Temp {\n        int index;\n        int value;\n\n        public Temp(int index, int value) {\n            this.index = index;\n            this.value = value;\n        }\n    }\n\n}", "label": 3}
{"src": "import java.util.*;\n\npublic class Solution {\n\n    public static long gcd(long a, long b){\n        if(b==0){\n            return a;\n        }\n        return gcd(b, a%b);\n    }\n\n    public static long gcdSum(long b){\n        long a = 0;\n\n        long temp = b;\n        while(temp!=0){\n            a = a + temp%10;\n            temp = temp/10;\n        }\n        return gcd(a,b);\n\n    }\n\n    public static class Pair{\n        Long a;\n        Long b;\n\n        public Pair(Long a, Long b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    public static long factorial (long n){\n        if(n==0)\n            return 1;\n        else if(n==1)\n            return n;\n\n        return n * factorial(n-1);\n    }\n\n    public static long lcm (long n){\n        if(n<3)\n            return n;\n        return lcmForBig(n,n-1);\n    }\n\n    private static long lcmForBig(long n, long l) {\n        if(l==1)\n            return n;\n        n = (n * l) / gcd(n, l);\n        return lcmForBig(n, l-1);\n\n    }\n\n\n    public static void main(String[] args){\n        Scanner s = new Scanner(System.in);\n        int t = s.nextInt();\n        //long  factArray[] = new long [42];\n\n\n        for(int i =0;i<t;i++) {\n           int n = s.nextInt();\n           int []arrA = new int[n];\n           int []arrB = new int[n];\n           int []diff = new int[n];\n           long sum = 0, ops = 0;\n           List<Integer> pos = new LinkedList<Integer>();\n           List<Integer> neg = new LinkedList<Integer>();\n\n           for(int j =0;j<n;j++){\n               arrA[j]=s.nextInt();\n           }\n           for(int j =0;j<n;j++){\n               arrB[j]=s.nextInt();\n               diff[j] = arrB[j] - arrA[j];\n               if(diff[j]>0)\n                   pos.add(j);\n               else if(diff[j]<0)\n                   neg.add(j);\n               sum+= diff[j];\n           }\n           int index1 = 0,index2=0;\n           int [][]ans = new int[105][3];\n           int  ansIndex = 0;\n\n           //System.out.println(Arrays.toString(diff) + \" sum = \" + sum);\n            if(sum!=0L){\n                System.out.println(\"-1\");\n            }\n\n            else{\n                while(index1<pos.size()){\n                    int posIndex = pos.get(index1);\n                    int negIndex = neg.get(index2);\n\n                    if(diff[posIndex] + diff[negIndex] > 0) {\n                        ops = ops - diff[negIndex];\n                        ans[ansIndex][0] = -diff[negIndex];\n                        ans[ansIndex][1] = negIndex+1;\n                        ans[ansIndex][2] = posIndex+1;\n                        index2++;\n                        diff[posIndex] = diff[posIndex] + diff[negIndex];\n                    }\n                    else if (diff[posIndex] + diff[negIndex] < 0){\n                        ops = ops + diff[posIndex];\n                        ans[ansIndex][0] = diff[posIndex];\n                        ans[ansIndex][1] = negIndex+1;\n                        ans[ansIndex][2] = posIndex+1;\n                        index1++;\n                        diff[negIndex] = diff[posIndex] + diff[negIndex];\n                    }\n                    else{\n                        ops = ops + diff[posIndex];\n                        ans[ansIndex][0] = diff[posIndex];\n                        ans[ansIndex][1] = negIndex+1;\n                        ans[ansIndex][2] = posIndex+1;\n                        index1++;\n                        index2++;\n                    }\n\n                    //System.out.println(ans[ansIndex][0] + \" \" +  ans[ansIndex][1] + \" \" +  ans[ansIndex][2] + \" index1 = \" + index1 + \"  index2 = \" + index2);\n                    ansIndex++;\n                }\n\n                System.out.println(ops);\n                for(int k =0;k<ansIndex;k++){\n                    for(int l =0 ; l  < ans[k][0]; l++){\n                        System.out.println(ans[k][1] + \" \"  +  ans[k][2]);\n                    }\n                }\n            }\n        }\n\n\n        return;\n    }\n}\n", "label": 3}
{"src": "// Piyush Nagpal\nimport java.util.*;\nimport java.io.*;\n public class C{\n     \n    static int MOD=1000000007;\n    static PrintWriter pw;\n    static FastReader sc;\n    \n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(\n                new InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() { return Integer.parseInt(next()); }\n \n        long nextLong() { return Long.parseLong(next()); }\n \n        double nextDouble(){return Double.parseDouble(next());}\n        \n        public char nextChar() throws IOException {return next().charAt(0);}\n \n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        public int[] intArr(int n) throws IOException {int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();return in;}\n        public long[] longArr(int n) throws IOException {long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();return in;}\n        \n    }   \n\n\n     public static long gcd(long a,long b){if( b>a ){return gcd(b,a);}if( b==0 ){return a;} return gcd(b,a%b);}\n     public static long expo( long a,long b,long M ){long result=1;while(b>0){if( b%2==1 ){result=(result*a)%M;}a=(a*a)%M;b=b/2;}return result%M;}\n    public static ArrayList<Long> Sieve(int n){boolean [] arr= new boolean[n+1];Arrays.fill(arr, true);ArrayList<Long> list= new ArrayList<>();for(int i=2;i<=n;i++){if( arr[i]==true ){list.add((long)i);}for(int j=2*i;j<=n;j+=i){arr[j]=false;}}return list;}\n\n    public static void printarr(int [] arr){for(int i=0;i<arr.length;i++){pw.print(arr[i]+\" \");}}\n    public static void printarr(long [] arr){for(int i=0;i<arr.length;i++){pw.print(arr[i]+\" \");}}\n    \n    // int [] arr=sc.intArr(n);\n    static void solve() throws Exception{\n    \tint n=sc.nextInt();\n    \tint [] arr= sc.intArr(n);\n    \tint [] arrb= sc.intArr(n);\n    \tboolean check=true;\n    \tint sum1=0,sum2=0,sumdiff=0;\n    \tint [] diff= new int [n];\n    \tfor(int i=0;i<n;i++){\n    \t\tsum1+=arr[i];\n    \t\tsum2+=arrb[i];\n    \t\tdiff[i]=(arr[i]-arrb[i]);\n    \t\tif(arr[i]!=arrb[i]){\n    \t\t\tcheck=false;\n    \t\t}\n    \t}\n    \tif(sum1!=sum2){\n    \t\tpw.println(-1);\n    \t\treturn;\n    \t}\n    \tif(check){\n    \t\tpw.println(0);\n    \t\treturn;\n    \t}\n    \t\n    \tArrayList<Integer> list= new ArrayList<>();\n    \tArrayList<Integer> list2= new ArrayList<>();\n    \tfor(int i=0;i<n;i++){\n    \t\tfor(int j=i+1;j<n;j++){\n    \t\t\tif( diff[i]>0 ){\n    \t\t\t\twhile(diff[j]<0 && diff[i]>0){\n    \t\t\t\t\tlist.add(i+1);\n    \t\t\t\t\tlist2.add(j+1);\n    \t\t\t\t\t// pw.println((i+1)+\" \"+(j+1));\n    \t\t\t\t\tdiff[i]--;\n    \t\t\t\t\tdiff[j]++;\n    \t\t\t\t}\n    \t\t\t}else if(diff[i]<0){\n    \t\t\t\twhile(diff[j]>0 && diff[i]<0){\n    \t\t\t\t\tlist.add(j+1);\n    \t\t\t\t\tlist2.add(i+1);\n    \t\t\t\t\t// pw.println((i+1)+\" \"+(j+1));\n    \t\t\t\t\tdiff[i]++;\n    \t\t\t\t\tdiff[j]--;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \tpw.println(list.size());\n    \tfor(int i=0;i<list.size();i++){\n    \t\tpw.println(list.get(i)+\" \"+list2.get(i));\n    \t}\n\n\n\n   }\n    \n   public static void main(String[] args) throws Exception{\n        try {\n            System.setIn(new FileInputStream(\"input.txt\"));\n            System.setOut(new PrintStream(new FileOutputStream(\"output.txt\")));\n        } catch (Exception e) {\n            System.err.println(\"Error\");\n        }\n        sc= new FastReader();\n        pw = new PrintWriter(System.out);\n\n   \n        int tc=1;\n        tc=sc.nextInt();\n        for(int i=1;i<=tc;i++) {\n//            pw.printf(\"Case #%d: \"b, i);\n            solve();\n        }\n       \n        pw.flush();\n\n    \n\n    }\n\n}\n", "label": 3}
{"src": "\nimport java.io.*;\nimport java.util.*;\n\npublic class SolutionB {\n\n    static AbstractMap.SimpleEntry<Integer, Integer> pair(int row, int col) {\n        AbstractMap.SimpleEntry<Integer, Integer> p = new AbstractMap.SimpleEntry<Integer, Integer>(row, col);\n\n        return p;\n    }\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n    public static void main(String[] sampath) {\n        FastScanner in = new FastScanner();\n        int t = in.nextInt();\n        while (t-- > 0) {\n            int n = in.nextInt();\n            int[] A = new int[n];\n            int[] C = new int[n];\n            for (int i = 0; i < n; i++) {\n                A[i] = in.nextInt();\n\n            }\n            for (int i = 0; i < n; i++) {\n                C[i] = in.nextInt();\n\n            }\n            Map<Integer, Integer> map = new HashMap<>();\n            List<Integer> i_array=new ArrayList<>(); \n            List<Integer> j_array=new ArrayList<>(); \n            for (int i = 1; i <=n; i++) {\n                map.put(i, 0);\n\n            }\n           \n            for(int i=0;i<n;i++){\n                if (A[i] < C[i] || A[i] > C[i]) {\n                    int count = 0;\n                    while (A[i] != C[i]) {\n                        if (A[i] < C[i]) {\n                            A[i]++;\n                          j_array.add(i+1);\n\n                        } else if (A[i] > C[i]) {\n                            A[i]--;\n                          i_array.add(i+1);\n\n                        }\n\n                    }\n                    count = 0;\n                }\n            }\n                for(int j=0;j<n;j++){\n                if (A[j] < C[j] || A[j] > C[j]) {\n                    int count = 0;\n\n                    while (A[j] != C[j]) {\n\n                        if (A[j] < C[j]) {\n                            A[j]++;\n                            j_array.add(j+1);\n                        } else if (A[j] > C[j]) {\n                            A[j]--;\n                            i_array.add(j+1);\n\n                        }\n\n                    }\n                    count = 0;\n                }\n\n             }\n           \n System.out.print(\n        solve(i_array,j_array));\n    }\n    \n\n    }\n\n    private static String solve(  List<Integer> a,List<Integer> b) {\n      \n        StringBuilder sb=new StringBuilder();\n       // int total=a.size()+b.size();\n        if(a.size()!=b.size())\n        {\n             return \"-1\\n\";\n        }\n        else{\n            sb.append((a.size())+\"\\n\");\n            int len=a.size();\n            for(int i=0;i<len;i++)\n            {\n                sb.append(a.get(i)+\" \"+b.get(i)+\"\\n\");\n            }\n            \n        }\n        return \"\"+sb;\n\n\n    }\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.io.*;\npublic class Solution{\n\tstatic BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc=new Scanner(System.in);\n\t\tint t=sc.nextInt();\n\t\t\n\t\twhile(t-->0)\n\t\t{\n\t\t\tint n=sc.nextInt();\n\t\t\tint a[]=new int[n];\n\t\t\tint b[]=new int[n];\n\t\t\t\n\t\t\tint sum1=0,sum2=0;\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\ta[i]=sc.nextInt();\n\t\t\t\tsum1+=a[i];\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t{\n\t\t\t\tb[i]=sc.nextInt();\n\t\t\t\tsum2+=b[i];\n\t\t\t}\n\t\t\tif(sum1!=sum2)\n\t\t\t{\n\t\t\t\tbw.write(\"-1\");\n\t\t\t\tbw.newLine();\n\t\t\t}\n\t\t\telse\n\t\t\t\tfind(a,b,n);\n\t\t\t\n\t\t\tbw.flush();\n\t\t}\n\t\t\n\t\t\n\t}\n\tprivate static void find(int[] a, int[] b, int n) throws IOException {\n\t\t// TODO Auto-generated method stub\n\t\tHashMap<Integer,Integer> plus=new HashMap();\n\t\tHashMap<Integer,Integer> minus=new HashMap();\n\t\tint count=0;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tif(a[i]<b[i])\n\t\t\t{\n\t\t\t\tplus.put(i,b[i]-a[i]);\n\t\t\t\tcount+=b[i]-a[i];\n\t\t\t}\n\t\t\telse\n\t\t\t\tminus.put(i,a[i]-b[i]);\n\t\t}\n\t\tint ans[][]=new int[count][2];\n\t\tint index=0;\n\t\tfor(int key : plus.keySet())\n\t\t{\n\t\t\tint val = plus.get(key);\n\t\t\twhile(val>0)\n\t\t\t{\n\t\t\t\tans[index][1]=key+1;\n\t\t\t\tval--;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\tindex=0;\n\t\tfor(int key : minus.keySet())\n\t\t{\n\t\t\tint val = minus.get(key);\n\t\t\twhile(val>0)\n\t\t\t{\n\t\t\t\tans[index][0]=key+1;\n\t\t\t\tval--;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\tbw.write(String.valueOf(count));\n\t\tbw.newLine();\n\t\tfor(int i=0;i<count;i++)\n\t\t{\n\t\t\tbw.write(String.valueOf(ans[i][0]+\" \"+ans[i][1]));\n\t\t\tbw.newLine();\n\t\t}\n\t}\n\t\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class A {\n \n\tpublic static void main(String[] args) {\n\t\tFastScanner fs=new FastScanner();\n\t\tlong t=fs.nextLong();\n\t\twhile(t-->0)\n\t\t{\n\t\t\tlong n = fs.nextLong();\n\t\t\tArrayList<Long> a = new ArrayList<>();\n\t\t\tString ans = \"\";\n\t\t\tlong sum = 0;\n\t\t\t\n\t\t\tfor (long i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tlong b =fs.nextLong();\n\t\t\t\ta.add(b);\n\t\t\t\tsum += b;\n\t\t\t}\n\t\t\tlong su = 0;\n\t\t\tArrayList<Long> c = new ArrayList<>();\n\t\t\tfor (long i=0; i<n; i++)\n\t\t\t{\n\t\t\t\tlong b =fs.nextLong();\n\t\t\t\tc.add(b);\n\t\t\t\tsu +=b;\n\t\t\t}\n\t\t\tif (sum == su)\n\t\t\t{\n\t\t\t\tArrayList<Long> inc = new ArrayList<>();\n\t\t\t\tArrayList<Long> dec = new ArrayList<>();\n\t\t\t\tfor (long i=0; i<n; i++)\n\t\t\t\t{\n\t\t\t\t\tlong h = a.get((int)i);\n\t\t\t\t\tlong g = c.get((int)i);\n\t\t\t\t\twhile (h>g)\n\t\t\t\t\t{\n\t\t\t\t\t\tinc.add(i+1);\n\t\t\t\t\t\th--;\n\t\t\t\t\t}\n\t\t\t\t\twhile (h<g)\n\t\t\t\t\t{\n\t\t\t\t\t\tdec.add(i+1);\n\t\t\t\t\t\tg--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(inc.size()); \n\t\t\t\tfor (int i=0; i<inc.size(); i++)\n\t\t\t\t{\n\t\t\t\t\tSystem.out.println(inc.get(i)+\" \"+dec.get(i)); \n\t\t\t\t}\n\n\t\t\t}\t\n\t\t\telse\n\t\t\tSystem.out.println(\"-1\"); \n\t\t}\n \n\t}\n \n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++)\n\t\t\t\ta[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n \n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\npublic class A {\n    static FastScanner fs;\n    static PrintWriter pw;\n\n    public static void main(String[] args) {\n        fs = new FastScanner();\n        pw = new PrintWriter(System.out);\n        int t = fs.nextInt();\n        while (t-->0)\n            solve();\n        pw.close();\n    }\n    public static void solve() {\n        int n = fs.nextInt();\n        int[] a = fs.readArray(n);\n        int[] b = fs.readArray(n);\n        int sum = 0;\n        for (int i : a) sum += i;\n        for (int i : b) sum -= i;\n        if (sum!=0) {\n            pw.println(-1);\n            return;\n        }\n        ArrayList<Integer> inc = new ArrayList<>();\n        ArrayList<Integer> dec = new ArrayList<>();\n        for (int i=0; i<n; i++) {\n            if (a[i]>b[i]) {\n                for (int j=0; j<a[i]-b[i]; j++) {\n                    inc.add(i+1);\n                }\n            }\n            else {\n                for (int j=0; j<b[i]-a[i]; j++) {\n                    dec.add(i+1);\n                }\n            }\n        }\n        pw.println(inc.size());\n        for (int i=0; i<inc.size(); i++) {\n            pw.println(inc.get(i)+\" \"+dec.get(i));\n        }\n    }\n//    static int k;\n//    static int par(int curr) {\n//        return (1<<k)-1-(((1<<k)-1-curr)/2);\n//    }\n//    static int left(int curr) {\n//        return (1<<k)-1-(2*((1<<k)-1-curr)+1);\n//    }\n//    static int right(int curr) {\n//        return (1<<k)-1-(2*((1<<k)-1-curr));\n//    }\n    static int gcd(int a, int b) {\n        if (a==0) return b;\n        return gcd(b%a, a);\n    }\n    static void ruffleSort(int[] a) {\n        int n=a.length;//shuffle, then sort\n        for (int i=0; i<n; i++) {\n            int oi=random.nextInt(n), temp=a[oi];\n            a[oi]=a[i]; a[i]=temp;\n        }\n        Arrays.sort(a);\n    }\n    static final Random random =new Random();\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        String next() {\n            while (!st.hasMoreTokens())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        int[] readArray(int n) {\n            int[] a=new int[n];\n            for (int i=0; i<n; i++) a[i]=nextInt();\n            return a;\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n\n    static int[] reverse(int[] a) {\n        int n=a.length;\n        int[] res=new int[n];\n        for (int i=0; i<n; i++) res[i]=a[n-1-i];\n        return res;\n    }\n}", "label": 3}
{"src": "import java.util.*;\npublic class Solution\n{\n     public static void main(String[]args)\n     {\n          int t;\n          Scanner in=new Scanner(System.in);\n          t=in.nextInt();\n          while(t-->0)\n          {\n               int n;\n               n=in.nextInt();\n               int a[]=new int[n];\n               int b[]=new int[n];\n               int i,j;\n               for(i=0;i<n;i++)\n               {\n                    a[i]=in.nextInt();\n               }\n               for(i=0;i<n;i++)\n               {\n                    b[i]=in.nextInt();\n               }\n               HashSet<Integer> dec=new HashSet<>();\n               HashSet<Integer> inc=new HashSet<>();\n               int count=0;\n               ArrayList<Integer> ii=new ArrayList<>();\n               ArrayList<Integer> ji=new ArrayList<>();\n               for(i=0;i<n;i++)\n               {\n                    if(a[i]<b[i])\n                    {\n                    inc.add(i);\n                    count+=(a[i]-b[i]);\n                    }\n                    if(a[i]>b[i])\n                    {\n                    dec.add(i);\n                    count+=(a[i]-b[i]);\n                    }\n               }\n               if(count!=0)\n               {\n                    System.out.println(\"-1\");\n               }\n               else\n               {\n                    for(int x:dec)\n                    {\n                         int num=a[x]-b[x];\n                         for(int y:inc)\n                         {\n                              int num2=b[y]-a[y];\n                              if(num2>=num)\n                              {\n                                   for(i=1;i<=num;i++)\n                                   {\n                                        ii.add(x+1);\n                                        ji.add(y+1);\n                                        a[y]++;\n                                        a[x]--;\n                                   }\n                                   break;\n                              }\n                              else\n                              {\n                                   for(i=1;i<=num2;i++)\n                                   {\n                                        ii.add(x+1);\n                                        ji.add(y+1);\n                                        a[y]++;\n                                        a[x]--;\n                                   }\n                                   num=num-num2;\n                              }\n                         }\n                    }\n                    int si=ii.size();\n                    System.out.println(si);\n                    for(i=0;i<si;i++)\n                    {\n                         System.out.println(ii.get(i)+\" \"+ji.get(i));\n                    }\n               }\n          }\n     }\n}", "label": 3}
{"src": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class AquaMoonAndTwoArrays {\n\t\n\tpublic static class Pair {\n\t\t\n\t\tint a;\n\t\tint b;\n\t\t\n\t\tpublic Pair(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t\t\n\t}\n\t\n\tpublic static void Solve(int n, int[] a, int[] b) {\n\t\t\n\t\tint sum = 0;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tsum += a[i];\n\t\t\tsum -= b[i];\n\t\t}\n\t\tif (sum != 0) {\n\t\t\tSystem.out.println(\"-1\");\n\t\t\treturn;\n\t\t}\n\t\tArrayList<Pair> ops = new ArrayList<Pair>();\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tfor (int j=0; j<n; j++) {\n\t\t\t\twhile (a[i] > b[i] && a[j] < b[j]) {\n\t\t\t\t\ta[i]--;\n\t\t\t\t\ta[j]++;\n\t\t\t\t\tops.add(new Pair(i+1, j+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ops.size());\n\t\tfor (Pair p : ops) {\n\t\t\tSystem.out.println(p.a + \" \" + p.b);\n\t\t}\n\t\t\n\t}\n\n\tpublic static void main(String[] args) {\n\n\t\tScanner in = new Scanner(System.in);\n\t\tint t = in.nextInt();\n\t\tfor (int i=0; i<t; i++) {\n\t\t\tint n = in.nextInt();\n\t\t\tint[] a = new int[n];\n\t\t\tint[] b = new int[n];\n\t\t\tfor (int j=0; j<n; j++) {\n\t\t\t\ta[j] = in.nextInt();\n\t\t\t}\n\t\t\tfor (int j=0; j<n; j++) {\n\t\t\t\tb[j] = in.nextInt();\n\t\t\t}\n\t\t\tSolve(n, a, b);\n\t\t}\n\t\tin.close();\n\t\t\n\t}\n\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class test {\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner();\n        int t = sc.ni();\n        while (t-- > 0) {\n            int n  = sc.ni();\n            int[] a = new int[n];\n            int[] b = new int[n];\n            int sum_a = 0, sum_b = 0;\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.ni();\n                sum_a += a[i];\n            }\n            for (int i = 0; i < n; i++) {\n                b[i] = sc.ni();\n                sum_b += b[i];\n            }\n            if (sum_a != sum_b) {\n                System.out.println(-1);\n            } else {\n                List<Integer> first = new LinkedList<>();\n                List<Integer> second = new LinkedList<>();\n                int m = 0;\n                for (int i = 0; i < n; i++) {\n                    if (a[i] > b[i]) {\n                        m += a[i] - b[i];\n                        for (int j = 0; j < a[i] - b[i]; j++)\n                            first.add(i + 1);\n                    } else if (a[i] < b[i]) {\n                        for (int j = 0; j < b[i] - a[i]; j++)\n                            second.add(i + 1);\n                    }\n                }\n                System.out.println(m);\n                for (int i = 0; i < m; i++) {\n                    System.out.println(first.get(i) + \" \" + second.get(i));\n                }\n            }\n        }\n    }\n\n    static boolean isPrime(int n) {\n        for (int i = 2; i <= Math.sqrt(n); i++) {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in), 32768);\n            st = null;\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int ni() {\n            return Integer.parseInt(next());\n        }\n\n        int[][] graph(int N, int[][] edges) {\n            int[][] graph = new int[N][];\n            int[] sz = new int[N];\n            for (int[] e : edges) {\n                sz[e[0]] += 1;\n                sz[e[1]] += 1;\n            }\n            for (int i = 0; i < N; i++) {\n                graph[i] = new int[sz[i]];\n            }\n            int[] cur = new int[N];\n            for (int[] e : edges) {\n                graph[e[0]][cur[e[0]]] = e[1];\n                graph[e[1]][cur[e[1]]] = e[0];\n                cur[e[0]] += 1;\n                cur[e[1]] += 1;\n            }\n            return graph;\n        }\n\n        int[] intArray(int N, int mod) {\n            int[] ret = new int[N];\n            for (int i = 0; i < N; i++)\n                ret[i] = ni() + mod;\n            return ret;\n        }\n\n        long nl() {\n            return Long.parseLong(next());\n        }\n\n        long[] longArray(int N, long mod) {\n            long[] ret = new long[N];\n            for (int i = 0; i < N; i++)\n                ret[i] = nl() + mod;\n            return ret;\n        }\n\n        double nd() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n}\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class A {\n \n\tpublic static void main(String[] args) {\n\t\tFastScanner fs=new FastScanner();\n\t\tint T=fs.nextInt();\n\t\twhile(T-->0)\n\t\t{\n\t\t    int n=fs.nextInt();\n\t\t    int[] a=new int[n];\n\t\t    int[] b=new int[n];\n\t\t    int[] c=new int[n];\n\t\t    for(int i=0;i<n;i++)\n\t\t    a[i]=fs.nextInt();\n\t\t    for(int i=0;i<n;i++)\n\t\t    b[i]=fs.nextInt();\n\t\t    int sum=0,ps=0;\n\t\t    for(int i=0;i<n;i++)\n\t\t    {\n\t\t        c[i]=a[i]-b[i];\n\t\t        sum+=c[i];\n\t\t        if(c[i]>0)\n\t\t        ps+=c[i];\n\t\t    }\n\t\t    if(sum!=0)\n\t\t    {\n\t\t        System.out.println(\"-1\");\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t        System.out.println(ps);\n\t\t        ArrayList<Integer> pos=new ArrayList<Integer>();\n\t\t        ArrayList<Integer> neg=new ArrayList<Integer>();\n\t\t        for(int i=0;i<n;i++)\n\t\t        {\n\t\t            if(c[i]<0)\n\t\t            {\n\t\t                int x=c[i]*-1;\n\t\t                while(x!=0)\n\t\t                {\n\t\t                    neg.add(i);\n\t\t                    x--;\n\t\t                }\n\t\t            }\n\t\t            else if(c[i]>0)\n\t\t            {\n\t\t                while(c[i]!=0)\n\t\t                {\n\t\t                    pos.add(i);\n\t\t                    c[i]--;\n\t\t                }\n\t\t            }\n\t\t        }\n\t\t        if(pos.size()==0&&neg.size()==0)\n\t\t        {\n\t\t          //  System.out.println(0);\n\t\t          }\n\t\t        else\n\t\t        {\n\t\t            for(int i=0;i<pos.size();i++)\n\t\t            {\n\t\t                System.out.println((pos.get(i)+1)+\" \"+(neg.get(i)+1));\n\t\t            }\n\t\t        }\n\t\t       \n\t\t        }\n\t\t    }\n\t}\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n \n\t\n}\n", "label": 3}
{"src": "import java.awt.List;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\n\n\npublic class A {\n\t\n\t\n    public static void main(String[] args) {\n    \n    \tFastScanner scan = new FastScanner();\n    \t\n    \tint T = 1;\n    \tT = scan.nextInt();\n    \tfor(int tt=0; tt<T; tt++) {\n    \t\tint n = scan.nextInt();\n    \t\tint [] a = scan.readArray(n), b = scan.readArray(n);\n    \t\tint sum = 0;\n    \t\tint [] values = new int[n];\n    \t\tfor(int i=0; i<n; i++) {\n    \t\t\tvalues[i] = b[i] - a[i];\n    \t\t\tsum += values[i];\n    \t\t}\n    \t\t\n    \t\tif(sum != 0) {\n    \t\t\tSystem.out.println(-1);\n    \t\t} else {\n    \t\t\tArrayList<Integer> ans = new ArrayList<>();\n    \t\t\tfor(int i=0; i<n; i++) {\n    \t\t\t\t\n    \t\t\t\tint value = values[i];\n    \t\t\t\t\n    \t\t\t\tif(value < 0) {\n    \t\t\t\t\tfor(int j=0; j<n; j++) {\n    \t\t\t\t\t\tint value2 = values[j];\n    \t\t\t\t\t\tif(value2 > 0) {\n    \t\t\t\t\t\t\tint min = Math.min(value * -1, value2);\n    \t\t\t\t\t\t\tvalue += min; value2 -= min;\n    \t\t\t\t\t\t\tfor(int l=0; l<min; l++) {\n    \t\t\t\t\t\t\t\tans.add(i); ans.add(j);\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tvalues[j] = value2;\n    \t\t\t\t\t\t\tvalues[i] = value;\n    \t\t\t\t\t\t\tif(value == 0) break;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t\t\n    \t\t\t\tif(value > 0) {\n    \t\t\t\t\tfor(int j=0; j<n; j++) {\n    \t\t\t\t\t\tint value2 = values[j];\n    \t\t\t\t\t\tif(value2 < 0) {\n    \t\t\t\t\t\t\tint min = Math.min(value, value2*-1);\n    \t\t\t\t\t\t\tvalue -= min; value2 += min;\n    \t\t\t\t\t\t\tfor(int l=0; l<min; l++) {\n    \t\t\t\t\t\t\t\tans.add(j); ans.add(i);\n    \t\t\t\t\t\t\t}\n    \t\t\t\t\t\t\tvalues[j] = value2;\n    \t\t\t\t\t\t\tvalues[i] = value;\n    \t\t\t\t\t\t\tif(value == 0) break;\n    \t\t\t\t\t\t}\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t\t\n    \t\t\tSystem.out.println(ans.size()/2);\n    \t\t\tfor(int i=0; i<ans.size(); i+=2) {\n    \t\t\t\tSystem.out.println(ans.get(i)+1 + \" \" + (ans.get(i+1) + 1));\n    \t\t\t}\n    \t\t\t\n    \t\t}\n    \t}\n    }\t\n    \n    \n   \n    public static void sort(int [] a) {\n    \tArrayList<Integer> b = new ArrayList<>();\n    \tfor(int i: a) b.add(i);\n    \tCollections.sort(b);\n    \tfor(int i=0; i<a.length; i++) a[i]= b.get(i);\n    }\n    \n  \n    static class FastScanner{\n    \t\n    \tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n    \tStringTokenizer st = new StringTokenizer(\"\");\n    \tString next() {\n    \t\twhile(!st.hasMoreTokens())\n    \t\t\ttry {\n    \t\t\t\tst = new StringTokenizer(br.readLine());\n    \t\t\t} catch (IOException e){\n    \t\t\t\te.printStackTrace();\n    \t\t\t}\n    \t\treturn st.nextToken();\n    \t}\n    \t\n    \tint nextInt() {\n    \t\treturn Integer.parseInt(next());\n    \t}\n    \t\n    \tint [] readArray(int n) {\n    \t\tint [] a = new int[n];\n    \t\tfor(int i=0; i<n ; i++) a[i] = nextInt();\n    \t\treturn a;\n    \t}\n    \t\n    \tlong nextLong() {\n    \t\treturn Long.parseLong(next());\n    \t}\n    \t\n    \t\n    }\n    \n   \n}\n\n", "label": 3}
{"src": "import java.util.*;\n\npublic class A {\n    \n    \n    public static void main(String args[]) {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while(t-->0){\n            int n = sc.nextInt();\n            int a[] = new int[n];\n            int b[] = new int[n];\n            for(int i=0; i<n; i++){\n                a[i] = sc.nextInt();\n            }\n            for(int i=0; i<n; i++){\n                b[i] = sc.nextInt();\n            }\n            ArrayList<Integer> bade = new ArrayList<Integer>();\n            ArrayList<Integer> chote = new ArrayList<Integer>();\n            int check = 0;\n            int temp = 0;\n            for(int i=0; i<n; i++){\n                check += (a[i]-b[i]);\n                if((a[i]-b[i])>0){\n                    temp+=(a[i]-b[i]);\n                }\n                if(a[i]>b[i]){\n                    int val = a[i] - b[i];\n                    while(val-->0){\n                        bade.add(i+1);\n                    }\n                }\n                if(a[i]<b[i]){\n                    int va = b[i] - a[i];\n                    while(va-->0){\n                        chote.add(i+1);\n                    }\n                }\n            }\n            if(check!=0){\n                System.out.println(-1);\n            }\n            else{\n                System.out.println(temp);\n                for(int i=0; i<bade.size(); i++){\n                    System.out.println(bade.get(i)+\" \"+chote.get(i));\n                }\n            }\n        }\n        sc.close();\n    }\n}", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.util.Arrays;\nimport java.util.Map.Entry;\n \npublic class codeforces {\n\tpublic static void main(String[] args) throws Exception {\n\t\tint t=sc.nextInt();\n\t\twhile(t-->0) {\n\t\t\tint n=sc.nextInt();\n\t\t\tint[]a=sc.nextArrint(n);\n\t\t\tint[]b=sc.nextArrint(n);\n\t\t\tLinkedList<Integer>dec=new LinkedList<Integer>();\n\t\t\tLinkedList<Integer>inc=new LinkedList<Integer>();\n\t\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\t\tif(a[i]>b[i]) {\n\t\t\t\t\tfor (int j = 0; j <a[i]-b[i]; j++) {\n\t\t\t\t\t\tdec.add(i);\n\t\t\t\t\t}\n\t\t\t\t}else if(a[i]<b[i]) {\n\t\t\t\t\tfor (int j = 0; j <b[i]-a[i]; j++) {\n\t\t\t\t\t\tinc.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(inc.size()!=dec.size()) {\n\t\t\t\tpw.println(-1);\n\t\t\t}else {\n\t\t\t\tpw.println(dec.size());\n\t\t\t\twhile(!dec.isEmpty()) {\n\t\t\t\t\tpw.println((dec.removeFirst()+1)+\" \"+(inc.removeFirst()+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpw.close();\n\t}\n\t\n\t\n\tpublic static long eval(String s) {\n\t\tlong p=1;\n\t\tlong res=0;\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tres+=p*(s.charAt(s.length()-1-i)=='1'?1:0);\n\t\t\tp*=2;\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static String binary(long x) {\n\t\tString s=\"\";\n\t\twhile(x!=0) {\n\t\t\ts=(x%2)+s;\n\t\t\tx/=2;\n\t\t}\n\t\treturn s;\n\t}\n\t\n\tpublic static boolean allSame(String s) {\n\t\tchar x=s.charAt(0);\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tif(s.charAt(i)!=x)return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isPalindrom(String s) {\n\t\tint l=0;\n\t\tint r=s.length()-1;\n\t\twhile(l<r) {\n\t\t\tif(s.charAt(r--)!=s.charAt(l++))return false;\n\t\t\t\n\t\t}\n\t\treturn true;\n\t}\n\t \n\tpublic static String putAtFront(String s,char c) {\n\t\tif(s.length()==0)return s;\n\t\tif(s.charAt(s.length()-1)==c) {\n\t\t\treturn s.charAt(s.length()-1)+putAtFront(s.substring(0,s.length()-1), c);\n\t\t}else {\n\t\t\treturn putAtFront(s.substring(0,s.length()-1), c)+s.charAt(s.length()-1);\n\t\t}\n\t}\n\t\n\tpublic static boolean isSubString(String s,String t) {\n\t\tint ls=s.length();\n\t\tint lt=t.length();\n\t\tboolean res=false;\n\t\tfor (int i = 0; i <=lt-ls; i++) {\n\t\t\tif(t.substring(i, i+ls).equals(s)) {\n\t\t\t\tres=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static boolean isSorted(int[]a) {\n\t\tfor (int i = 0; i < a.length-1; i++) {\n\t\t\tif(a[i]>a[i+1])return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tpublic static boolean isPrime(int n)\n    {\n \n        // Check if number is less than\n        // equal to 1\n        if (n <= 1)\n            return false;\n \n        // Check if number is 2\n        else if (n == 2)\n            return true;\n \n        // Check if n is a multiple of 2\n        else if (n % 2 == 0)\n            return false;\n \n        // If not, then just check the odds\n        for (int i = 3; i <= Math.sqrt(n); i += 2)\n        {\n            if (n % i == 0)\n                return false;\n        }\n        return true;\n    }\n\tpublic static long power(long x,long k) {\n\t\tlong res=1;\n\t\tlong mod=((int)1e9)+7;\n\t\tfor (int i = 0; i < k; i++) {\n\t\t\tres*=x;\n\t\t\tres=res%mod;\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static int whichPower(int x) {\n\t\tint res=0;\n\t\tfor (int j = 0; j < 31; j++) {\n\t\t\tif((1<<j&x)!=0) {\n\t\t\t\tres=j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n \n\tpublic static long evaln(String x,int n) {\n\t\tlong res=0;\n\t\tfor (int i = 0; i < x.length(); i++) {\n\t\t\tres+=Long.parseLong(x.charAt(x.length()-1-i)+\"\")*Math.pow(n, i);\n\t\t}\n\t\treturn res;\n\t}\n\tstatic void merge(int[] arr,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tint[] l=new int[len1];\n\t\tint[] r=new int[len2];\n\t\tfor(int i=0;i<len1;i++)l[i]=arr[b+i];\n\t\tfor(int i=0;i<len2;i++)r[i]=arr[m+1+i];\n\t\tint i=0,j=0,k=b;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<r[j])arr[k++]=l[i++];\n\t\t\telse arr[k++]=r[j++];\n\t\t}\n\t\twhile(i<len1)arr[k++]=l[i++];\n\t\twhile(j<len2)arr[k++]=r[j++];\n\t\treturn;\n\t}\n\tstatic void mergesortidx(int[] arr,int[]idx,int b,int e) {\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)/2;\n\t\t\tmergesortidx(arr,idx,b,m);\n\t\t\tmergesortidx(arr,idx,m+1,e);\n\t\t\tmergeidx(arr,idx,b,m,e);\n\t\t}\n\t\treturn;\n\t\t\n\t}\n\t\n\tstatic void mergeidx(int[] arr,int[]idx,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tint[] l=new int[len1];\n\t\tint[] lidx=new int[len1];\n\t\tint[] r=new int[len2];\n\t\tint[] ridx=new int[len2];\n\t\tfor(int i=0;i<len1;i++) {\n\t\t\tl[i]=arr[b+i];\n\t\t\tlidx[i]=idx[b+i];\n\t\t}\n\t\tfor(int i=0;i<len2;i++) {\n\t\t\tr[i]=arr[m+1+i];\n\t\t\tridx[i]=idx[m+1+i];\n\t\t}\n\t\tint i=0,j=0,k=b;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<r[j]) {\n\t\t\t\tarr[k++]=l[i++];\n\t\t\t\tidx[k-1]=lidx[i-1];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tarr[k++]=r[j++];\n\t\t\t\tidx[k-1]=ridx[j-1];\n\t\t\t}\n\t\t}\n\t\twhile(i<len1) {\n\t\t\tidx[k]=lidx[i];\n\t\t\tarr[k++]=l[i++];\n\t\t}\n\t\twhile(j<len2) {\n\t\t\tidx[k]=ridx[j];\n\t\t\tarr[k++]=r[j++];\n\t\t}\n\t\treturn;\n\t}\n\tstatic void mergesort(int[] arr,int b,int e) {\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)/2;\n\t\t\tmergesort(arr,b,m);\n\t\t\tmergesort(arr,m+1,e);\n\t\t\tmerge(arr,b,m,e);\n\t\t}\n\t\treturn;\n\t\t\n\t}\n\t\n\tstatic long mergen(int[] arr,int b,int m,int e) {\n\t\tint len1=m-b+1,len2=e-m;\n\t\tint[] l=new int[len1];\n\t\tint[] r=new int[len2];\n\t\tfor(int i=0;i<len1;i++)l[i]=arr[b+i];\n\t\tfor(int i=0;i<len2;i++)r[i]=arr[m+1+i];\n\t\tint i=0,j=0,k=b;\n\t\tlong c=0;\n\t\twhile(i<len1 && j<len2) {\n\t\t\tif(l[i]<r[j])arr[k++]=l[i++];\n\t\t\telse {\n\t\t\t\tarr[k++]=r[j++];\n\t\t\t\tc=c+(long)(len1-i);\n\t\t\t}\n\t\t}\n\t\twhile(i<len1)arr[k++]=l[i++];\n\t\twhile(j<len2)arr[k++]=r[j++];\n\t\treturn c;\n\t}\n\tstatic long mergesortn(int[] arr,int b,int e) {\n\t\tlong c=0;\n\t\tif(b<e) {\n\t\t\tint m=b+(e-b)/2;\n\t\t\tc=c+(long)mergesortn(arr,b,m);\n\t\t\tc=c+(long)mergesortn(arr,m+1,e);\n\t\t\tc=c+(long)mergen(arr,b,m,e);\n\t\t}\n\t\treturn c;\n\t\t\n\t}\n\tpublic static long fac(int n) {\n\t\tif(n==0)return 1;\n\t\treturn n*fac(n-1);\n\t}\n\tpublic static long gcd(long a, long b)\n    {\n      if (b == 0)\n        return a;\n      return gcd(b, a % b);\n    }\n     \n\tpublic static long summ(long x) {\n\t\tlong sum=0;\n\t\twhile(x!=0) {\n\t\t\tsum+=x%10;\n\t\t\tx=x/10;\n\t\t}\n\t\treturn sum;\n\t\t\t\t\n\t}\n\t\n\tpublic static void sort2darray(Integer[][]a){\n\t\tArrays.sort(a,Comparator.<Integer[]>comparingInt(x -> x[0]).thenComparingInt(x -> x[1]));\n \n\t}\n\tstatic class Scanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic Scanner(InputStream s) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(s));\n\t\t}\n\t\tpublic Scanner(String file) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t\tpublic int[] nextArrint(int size) throws IOException {\n\t\t\tint[] a=new int[size];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextInt();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic long[] nextArrlong(int size) throws IOException {\n\t\t\tlong[] a=new long[size];\n\t\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\t\ta[i]=sc.nextLong();\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic int[][] next2dArrint(int rows,int columns) throws IOException{\n\t\t\tint[][]a=new int[rows][columns];\n\t\t\tfor (int i = 0; i < rows; i++) {\n\t\t\t\tfor (int j = 0; j < columns; j++) {\n\t\t\t\t\ta[i][j]=sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic long[][] next2dArrlong(int rows,int columns) throws IOException{\n\t\t\tlong[][]a=new long[rows][columns];\n\t\t\tfor (int i = 0; i < rows; i++) {\n\t\t\t\tfor (int j = 0; j < columns; j++) {\n\t\t\t\t\ta[i][j]=sc.nextLong();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t}\n\tstatic Scanner sc=new Scanner(System.in);\n\tstatic PrintWriter pw=new PrintWriter(System.out);\n}\n\n", "label": 3}
{"src": "import java.util.*;\n\npublic class AquaMoon {\n\tpublic static void main (String[] args) {\n\t\tScanner scan=new Scanner(System.in);\n\t\tint n= scan.nextInt();\n\t\t\n\t\tint m,op,count;\n\t\t\n\t\tint i;\n\t\t\n\t\tfor(int z=0;z<n;z++)\n\t\t{   op=0;\n\t\t    count=0;\n\t\t     int sum=0;int diff=0;\n\t\t    int outa=0;int outb=0;\n\t\t    \n\t\t    int sz=scan.nextInt();\n\t\t    int a[]=new int[sz];\n\t\t    int b[]=new int[sz];\n\t\t    for( i=0;i<sz;i++)\n\t\t    {\n\t\t        a[i]=scan.nextInt();\n\t\t    }\n\t\t    for(i=0;i<sz;i++)\n\t\t    {\n\t\t        b[i]=scan.nextInt();\n\t\t    }\n\t\t    for(i=0;i<sz;i++)\n\t\t    {\n\t\t        if(a[i]>b[i])\n\t\t        {\n\t\t            sum=sum+(a[i]-b[i]);\n\t\t            outa++;\n\t\t        }\n\t\t        else if(a[i]<b[i])\n\t\t        {\n\t\t            diff=diff+ (b[i]-a[i]);\n\t\t            outb++;\n\t\t        }\n\t\t    }\n\t\t    count=Math.max(sum, diff);\n\t\t    \n\n\t\t    int outputa[]=new int[count];\n\t\t\tint outputb[]=new int[count];\n\t\t\touta=0;\n\t\t\toutb=0;\n\t\t    if(sum==diff)\n\t\t    {\n\t\t        System.out.println(count);\n\t\t      for(i=0;i<sz;i++)\n\t\t      {\n\t\t    \t  while(a[i]>b[i])\n\t\t    \t  {\n\t\t    \t\t  outputa[outa]=(i+1);\n\t\t    \t\t  a[i]=a[i]-1;\n\t\t    \t\t  outa++;\n\t\t    \t\t \n\t\t    \t\t  \n\t\t    \t  }\n\t\t    \t  while(b[i]>a[i])\n\t\t    \t  {\n\t\t    \t\t  outputb[outb]=(i+1);\n\t\t    \t\t  a[i]=a[i]+1;\n\t\t    \t\t  outb++;\n\t\t    \t  }\n\t\t      } \n\t\t       \n\t\t        for(i=0;i<count;i++)\n\t\t        {\n\t\t        \tSystem.out.println(outputa[i]);\n\t\t        \tSystem.out.println(outputb[i]);\n\t\t        }\n\t\t        \n\t\t    }\n\t\t    \n\t\t    else\n\t\t    {\n\t\t       \n\t\t       System.out.println(\"-1\");\n\t\t    }\n\t\t        }\n\t\t        }\n\t\t    }\n\t\t    \n\t\t  ", "label": 3}
{"src": "/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Main\n{\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\twhile(T-->0)\n\t\t{\n\t\t    int n = sc.nextInt();\n\t\t    ArrayList<Integer> a1 = new ArrayList<Integer>();\n\t\t    ArrayList<Integer> b1 = new ArrayList<Integer>();\n\t\t    int sum=0;\n\t\t    int a[] = new int[n];\n\t\t    int b[] = new int[n];\n\t\t    for(int i =0;i<n;i++)\n\t\t    a[i]=sc.nextInt();\n\t\t    for(int i =0;i<n;i++)\n\t\t    {\n\t\t        b[i]=sc.nextInt();\n\t\t        sum+=a[i]-b[i];\n\t\t        int d=a[i]-b[i];\n\t\t        if(a[i]<b[i])\n\t\t        {\n\t\t            for(int j=a[i];j<b[i];j++)\n\t\t            a1.add(i+1);\n\t\t        }\n\t\t        else if(a[i]>b[i])\n\t\t        {\n\t\t            for(int j =b[i];j<a[i];j++)\n\t\t            b1.add(i+1);\n\t\t        }\n\t\t    }\n\t\t    if(sum!=0)\n\t\t    System.out.println(-1);\n\t\t    else\n\t\t    {\n\t\t         System.out.println(b1.size());\n\t\t         for(int i =0;i<b1.size();i++)\n\t\t         {\n\t\t             System.out.println(b1.get(i)+\" \"+a1.get(i));\n\t\t         }\n\t\t         \n\t\t    }\n\t\t    \n\t\t}\n\t}\n}\n", "label": 3}
{"src": "/* package codechef; // don't place package name! */\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\n\n\npublic class Codechef\n{\n    static int mod=1000000007;\n    static FastReader sc=new FastReader();\n    \n    \n    //input (int)\n    static int i() \n    {\n    \t return sc.nextInt();\n    }\n    \n    //input (string)\n     static String s() {\n    \t return sc.next();\n    }\n    \n    //input (long)\n    static long l() \n    {\n    \t return sc.nextLong();\n    }  \n    \n    //printing ln int\n    static void println(int a)\n    {\n        System.out.println(a);\n    }\n    \n    //printing int\n    static void print(int a)\n    {\n        System.out.print(a+\" \");\n    }\n    \n    //printing ln long\n    static void println(long a)\n    {\n        System.out.println(a);\n    }\n    \n    //printing long\n    static void print(long a)\n    {\n        System.out.print(a+\" \");\n    }\n    \n    //printing string ln\n    static void println(String a)\n    {\n        System.out.println(a);\n    }\n    \n    //printing String\n    static void print(String a)\n    {\n        System.out.print(a+\" \");\n    }\n    \n    //printing array elements(int )\n    static void print(int A[]) \n    {\n    \tfor(int i=0;i<A.length;i++)\n    \t\tSystem.out.print(A[i]+\" \");\n    \tSystem.out.println();\n    }\n    \n     //printing array elements(long)\n    static void print(long A[]) \n    {\n    \tfor(int i=0;i<A.length;i++)\n    \t\tSystem.out.print(A[i]+\" \");\n    \tSystem.out.println();\n    }\n    \n    //printing array elements(String)\n    static void print(String A[]) \n    {\n    \tfor(int i=0;i<A.length;i++)\n    \t\tSystem.out.print(A[i]+\" \");\n    \tSystem.out.println();\n    }\n    \n    \n    //taking input in an array of size n(int)\n    static int[] input(int n) \n    {\n\tint A[]=new int[n];\n\t   for(int i=0;i<n;i++) \n\t\t   A[i]=sc.nextInt();\n\t   return A;\n    }\n    \n     // taking input in an array of size n(long)\n    static long[] inputL(int n) \n    {\n\t    long A[]=new long[n];\n\t    for(int i=0;i<n;i++) \n\t\t   A[i]=sc.nextLong();\n\t    return A;\n    }\n    \n    \n    \n \n    \n    // taking input in array of size n(String)\n    static String[] inputS(int n) \n    {\n\t    String A[]=new String[n];\n\t    for(int i=0;i<n;i++)\n\t\t   A[i]=sc.next();\n\t   \n\t    return A;\n    }\n    \n    //array elements to hashmap\n    static HashMap<Integer,Integer> hash(int A[])\n    {\n\t    HashMap<Integer,Integer> map=new HashMap<Integer, Integer>();\n\t    for(int i : A) \n\t    {\n\t\t    if(map.containsKey(i)) \n\t\t\t    map.put(i, map.get(i)+1);\n\t\t    else\n\t\t\t    map.put(i, 1);\n\t    }\n\t    return map;\n  }\n    \n    \n    // max(int)\n    static int max(int A[]) \n    {\n    \tint max=Integer.MIN_VALUE;\n    \tfor(int i=0;i<A.length;i++)\n    \t\tmax=Math.max(max, A[i]);\n    \treturn max;\n    }\n    \n    // max(long)\n    static long max(long A[]) \n    {\n    \tlong max=Long.MIN_VALUE;\n    \tfor(int i=0;i<A.length;i++)\n    \t\tmax=Math.max(max, A[i]);\n    \treturn max;\n    }\n    \n    //min(long)\n    static long min(long A[])\n    {\n    \tlong min=Long.MAX_VALUE;\n    \tfor(int i=0;i<A.length;i++)\n    \t\tmin=Math.min(min, A[i]);\n    \treturn min;\n    }\n    \n    // min(int)\n    static int min(int A[])\n    {\n    \tint min=Integer.MAX_VALUE;\n    \tfor(int i=0;i<A.length;i++)\n    \t\tmin=Math.min(min, A[i]);\n    \treturn min;\n    }\n    \n    // sum of (int) elements of an array\n    static int sum(int A[]) \n    {\n    \tint sum=0;\n    \tfor(int i : A) \n    \t\tsum+=i;\n    \treturn sum;\n    }\n    \n    // sum of (long) elements of an array\n    static long sum(long A[]) \n    {\n    \tlong sum=0;\n    \tfor(long i : A)\n    \t\tsum+=i;\n    \treturn sum;\n    }\n    \n    // copying array elements to another array\n    static int[] copy(int A[]) \n    {\n    \tint B[]=new int[A.length];\n    \tfor(int i=0;i<A.length;i++) \n    \t\tB[i]=A[i];\n    \treturn B;\n    }\n    \n    // reverse an array(long)\n    static void reverse(long A[]) \n    {\n    \tint n=A.length;\n    \tlong B[]=new long[n];\n    \tfor(int i=0;i<n;i++)\n    \t\tB[i]=A[n-i-1];\n    \tfor(int i=0;i<n;i++)\n    \t\tA[i]=B[i];\n    \t\n    }\n    \n    // reverse an array(int)\n    static void reverse(int A[])\n    {\n    \tint n=A.length;\n    \tint B[]=new int[n];\n    \tfor(int i=0;i<n;i++) \n    \t\tB[i]=A[n-i-1];\n    \tfor(int i=0;i<n;i++)\n    \t\tA[i]=B[i];\n    \t\n    }\n    \n    \n\n    // prefix sum(long)\n    static long [] prefix(long A[]) \n    {\n    \tlong p[]=new long[A.length];\n    \tp[0]=A[0];\n    \tfor(int i=1;i<A.length;i++)\n    \t\tp[i]=p[i-1]+A[i];\n    \treturn p;\n    }\n    \n    // prefix sum(int)\n    static long [] prefix(int A[]) \n    {\n    \tlong p[]=new long[A.length];\n    \tp[0]=A[0];\n    \tfor(int i=1;i<A.length;i++)\n    \t\tp[i]=p[i-1]+A[i];\n    \treturn p;\n    }\n\n    //suffix sum(long)\n    static long [] suffix(long A[]) \n    {\n    \tlong p[]=new long[A.length];\n    \tp[A.length-1]=A[A.length-1];\n    \tfor(int i=A.length-2;i>=0;i--)\n    \t\tp[i]=p[i+1]+A[i];\n    \treturn p;\n    }\n\n    //suffix sum(int)\n    static long [] suffix(int A[]) \n    {\n    \tlong p[]=new long[A.length];\n    \tp[A.length-1]=A[A.length-1];\n    \tfor(int i=A.length-2;i>=0;i--)\n    \t\tp[i]=p[i+1]+A[i];\n    \treturn p;\n    }\n    \n    //checking if a number is a prime\n    static boolean prime(int n) \n    { \n        if (n <= 1) \n            return false; \n        if (n <= 3) \n            return true; \n        if (n % 2 == 0 || n % 3 == 0) \n            return false; \n        double sq=Math.sqrt(n);\n  \n        for (int i = 5; i <= sq; i = i + 6) \n            if (n % i == 0 || n % (i + 2) == 0) \n                return false; \n        return true; \n    } \n    \n    //binary search\n    public static int binarysearch(int[] nums,int k)\n    {\n        int low=0;\n        int high=nums.length-1;\n        while(low<=high)\n        {\n            int mid=low+(high-low)/2;\n            if(k==nums[mid])\n                return mid;\n            else if(k>nums[mid])\n                low=mid+1;\n            else\n                high=mid-1;\n        }\n        return -1;\n    }\n    \n    public static int bs(int[] nums,int k)\n    {\n        int low=0;\n        int high=nums.length-1;\n        while(low<=high)\n        {\n            int mid=low+(high-low)/2;\n            if(k==nums[mid])\n                return mid;\n            else if(k>nums[mid])\n                low=mid+1;\n            else\n                high=mid-1;\n        }\n        return low;\n    }\n\n   \n\n\n\n   \n   \n    \n    \n    \n   \n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n \n        public FastReader()\n        {\n            br = new BufferedReader(\n                new InputStreamReader(System.in));\n        }\n \n        String next()\n        {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n \n        int nextInt() { return Integer.parseInt(next()); }\n \n        long nextLong() { return Long.parseLong(next()); }\n \n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n \n        String nextLine()\n        {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n    \n\n    \n   \n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t    int t=i();\n\t    while(t-->0)\n\t    {\n\t        int n=i();\n\t        int[] a=input(n);\n\t        int[] b=input(n);\n\t        \n\t        int sum1=sum(a);\n\t        int sum2=sum(b);\n\t        \n\t        if(sum1!=sum2)\n\t            println(\"-1\");\n\t        else\n\t        {\n\t            int avg=sum1/n;\n\t            ArrayList<Integer> p=new ArrayList<>();\n\t            ArrayList<Integer> q=new ArrayList<>();\n\t            \n\t            for(int i=0;i<n;i++)\n\t            {\n\t                if(a[i]<b[i])\n\t                {\n\t                    for(int j=0;j<b[i]-a[i];j++)\n\t                        p.add(i+1);\n\t                    \n\t                }\n\t                else if(a[i]>b[i])\n\t                {\n\t                    for(int j=0;j<a[i]-b[i];j++)\n\t                        q.add(i+1);\n\t                }\n\t            }\n\t            \n\t            if(p.size()==0)\n\t                println(0);\n\t            else\n\t            {\n\t                println(p.size());\n\t            for(int i=0;i<p.size();i++)\n\t                System.out.println(q.get(i)+\" \"+p.get(i));\n\t            }\n\t            \n\t        }\n\t        \n\t       \n\t    }\n\t     \n\t    \n\t    \n\t    \n\t\n\t}\n\t\n\n}\n\n", "label": 3}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.InputMismatchException;\n\n\npublic class AquaMoonArrays {\n\n\n    public static void main(String[] args) throws Throwable {\n        Thread thread = new Thread (null, new TaskAdapter (), \"\", 1 << 29);\n        thread.start ();\n        thread.join ();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput (inputStream);\n            FastOutput out = new FastOutput (outputStream);\n            Solution solver = new Solution ();\n            solver.solve (1, in, out);\n            out.close ();\n        }\n    }\n\n    static class Solution {\n        static final Debug debug = new Debug (true);\n\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n                int test= in.ri ();\n\n                while (test-->0){\n                    int n= in.ri ();\n                    int[] a=new int[n];\n                    int[] b=new int[n];\n                    in.populate (a);\n                    in.populate (b);\n                    int sa=Arrays.stream (a).sum ();\n                    int sb=Arrays.stream (b).sum ();\n                    if(sa!=sb)\n                    out.prtl (-1);\n                    else{\n                        StringBuilder ans=new StringBuilder ();\n                        int counter=0;\n\n                        for (int i = 0; i <n; i++) {\n                            while (a[i]>b[i]) {\n                                int index=0;\n                                for (int j = 0; j <n; j++) {\n                                    if(a[j]<b[j]){\n                                        index=j;\n                                        break;\n                                    }\n\n                                }\n                                ans.append ((i+1)+\" \"+(index+1)+\"\\n\");\n                                a[i]--;\n                                a[index]++;\n                                counter++;\n                            }\n                        }\n                        out.prtl (counter);\n                        out.prtl (ans.toString ());\n                    }\n\n                }\n\n        }\n\n    }\n\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private final Writer os;\n        private StringBuilder cache = new StringBuilder (THRESHOLD * 2);\n\n        public FastOutput append(CharSequence csq) {\n            cache.append (csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append (csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length () < THRESHOLD) {\n                return;\n            }\n            flush ();\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this (new OutputStreamWriter (os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append (c);\n            afterWrite ();\n            return this;\n        }\n\n        public FastOutput append(String c) {\n            cache.append (c);\n            afterWrite ();\n            return this;\n        }\n\n        public FastOutput println(String c) {\n            return append (c).println ();\n        }\n\n        public FastOutput println() {\n            return append ('\\n');\n        }\n\n        final <T> void prt(T a) {\n            append (a + \" \");\n        }\n\n        final <T> void prtl(T a) {\n            append (a + \"\\n\");\n        }\n\n        public FastOutput flush() {\n            try {\n                os.append (cache);\n                os.flush ();\n                cache.setLength (0);\n            } catch (IOException e) {\n                throw new UncheckedIOException (e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush ();\n            try {\n                os.close ();\n            } catch (IOException e) {\n                throw new UncheckedIOException (e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString ();\n        }\n\n        public FastOutput printf(String format, Object... args) {\n            return append (String.format (format, args));\n        }\n\n        private static int countDigits(long l) {\n            if (l >= 1000000000000000000L) return 19;\n            if (l >= 100000000000000000L) return 18;\n            if (l >= 10000000000000000L) return 17;\n            if (l >= 1000000000000000L) return 16;\n            if (l >= 100000000000000L) return 15;\n            if (l >= 10000000000000L) return 14;\n            if (l >= 1000000000000L) return 13;\n            if (l >= 100000000000L) return 12;\n            if (l >= 10000000000L) return 11;\n            if (l >= 1000000000L) return 10;\n            if (l >= 100000000L) return 9;\n            if (l >= 10000000L) return 8;\n            if (l >= 1000000L) return 7;\n            if (l >= 100000L) return 6;\n            if (l >= 10000L) return 5;\n            if (l >= 1000L) return 4;\n            if (l >= 100L) return 3;\n            if (l >= 10L) return 2;\n            return 1;\n        }\n\n        private static int countDigits(int l) {\n            if (l >= 1000000000) return 10;\n            if (l >= 100000000) return 9;\n            if (l >= 10000000) return 8;\n            if (l >= 1000000) return 7;\n            if (l >= 100000) return 6;\n            if (l >= 10000) return 5;\n            if (l >= 1000) return 4;\n            if (l >= 100) return 3;\n            if (l >= 10) return 2;\n            return 1;\n        }\n\n    }\n\n\n    static class FastInput {\n        private final InputStream is;\n        private StringBuilder defaultStringBuf = new StringBuilder (1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private static final int EOF = -1;\n        private SpaceCharFilter filter;\n        private int bufOffset;\n        private int next;\n        private int bufLen;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(int[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readInt ();\n            }\n        }\n\n        public void populate(long[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readLong ();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read (buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read ();\n            }\n        }\n\n        public String next() {\n            return readString ();\n        }\n\n        public int ri() {\n            return readInt ();\n        }\n\n        public int readInt() {\n            boolean rev = false;\n\n            skipBlank ();\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = read ();\n            }\n\n            int val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 - next + '0';\n                next = read ();\n            }\n\n            return rev ? val : -val;\n        }\n\n        public long readLong() {\n            boolean rev = false;\n\n            skipBlank ();\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = read ();\n            }\n\n            long val = 0L;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 - next + '0';\n                next = read ();\n            }\n\n            return rev ? val : -val;\n        }\n\n        public long rl() {\n            return readLong ();\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank ();\n\n            while (next > 32) {\n                builder.append ((char) next);\n                next = read ();\n            }\n\n            return builder.toString ();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength (0);\n            return readString (defaultStringBuf);\n        }\n\n        public int rs(char[] data, int offset) {\n            return readString (data, offset);\n        }\n\n        public char[] rsc() {\n            return readString ().toCharArray ();\n        }\n\n\n        public int rs(char[] data) {\n            return rs (data, 0);\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank ();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read ();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char rc() {\n            return readChar ();\n        }\n\n        public char readChar() {\n            skipBlank ();\n            char c = (char) next;\n            next = read ();\n            return c;\n        }\n\n        public double rd() {\n            return nextDouble ();\n        }\n\n        public double nextDouble() {\n            int c = read ();\n            while (isSpaceChar (c))\n                c = read ();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read ();\n            }\n            double res = 0;\n            while (!isSpaceChar (c) && c != '.') {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow (10, readInt ());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException ();\n                res *= 10;\n                res += c - '0';\n                c = read ();\n            }\n            if (c == '.') {\n                c = read ();\n                double m = 1;\n                while (!isSpaceChar (c)) {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow (10, readInt ());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException ();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read ();\n                }\n            }\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null)\n                return filter.isSpaceChar (c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n        }\n\n\n        public boolean hasMore() {\n            skipBlank ();\n            return next != EOF;\n        }\n\n\n    }\n\n\n    static class Debug {\n        private boolean offline;\n        private PrintStream out = System.err;\n        static int[] empty = new int[0];\n\n        public Debug(boolean enable) {\n            offline = enable && System.getSecurityManager () == null;\n        }\n\n        public Debug debug(String name, Object x) {\n            return debug (name, x, empty);\n        }\n\n        public Debug debug(String name, long x) {\n            if (offline) {\n                debug (name, \"\" + x);\n            }\n            return this;\n        }\n\n        public Debug debug(String name, String x) {\n            if (offline) {\n                out.printf (\"%s=%s\", name, x);\n                out.println ();\n            }\n            return this;\n        }\n\n        public Debug debug(String name, Object x, int... indexes) {\n            if (offline) {\n                if (x == null || !x.getClass ().isArray ()) {\n                    out.append (name);\n                    for (int i : indexes) {\n                        out.printf (\"[%d]\", i);\n                    }\n                    out.append (\"=\").append (\"\" + x);\n                    out.println ();\n                } else {\n                    indexes = Arrays.copyOf (indexes, indexes.length + 1);\n                    if (x instanceof byte[]) {\n                        byte[] arr = (byte[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug (name, arr[i], indexes);\n                        }\n                    } else if (x instanceof short[]) {\n                        short[] arr = (short[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug (name, arr[i], indexes);\n                        }\n                    } else if (x instanceof boolean[]) {\n                        boolean[] arr = (boolean[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug (name, arr[i], indexes);\n                        }\n                    } else if (x instanceof char[]) {\n                        char[] arr = (char[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug (name, arr[i], indexes);\n                        }\n                    } else if (x instanceof int[]) {\n                        int[] arr = (int[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug (name, arr[i], indexes);\n                        }\n                    } else if (x instanceof float[]) {\n                        float[] arr = (float[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug (name, arr[i], indexes);\n                        }\n                    } else if (x instanceof double[]) {\n                        double[] arr = (double[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug (name, arr[i], indexes);\n                        }\n                    } else if (x instanceof long[]) {\n                        long[] arr = (long[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug (name, arr[i], indexes);\n                        }\n                    } else {\n                        Object[] arr = (Object[]) x;\n                        for (int i = 0; i < arr.length; i++) {\n                            indexes[indexes.length - 1] = i;\n                            debug (name, arr[i], indexes);\n                        }\n                    }\n                }\n            }\n            return this;\n        }\n\n    }\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\n/*\n * To change this license header, choose License Headers in Project Properties.\n * To change this template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\n/**\n *\n * @author lenovo\n */\npublic class same {\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String[] args) \n    {\n       template input=new template();\n       int t=input.nextInt();\n       for(int i=0;i<t;i++)\n       {\n           int n=input.nextInt();\n           int a[]=new int[n];\n           int b[]=new int[n];\n           int an[]=new int[n];\n           for(int j=0;j<n;j++)\n           {\n               a[j]=input.nextInt();\n           }\n           for(int q=0;q<n;q++)\n           {\n               b[q]=input.nextInt();\n           }\n           int ans=0;\n           int max=0;\n           for(int s=0;s<n;s++)\n           {\n            ans+=a[s]-b[s];\n            an[s]=a[s]-b[s];\n             max+=Math.max(0,a[s]-b[s]);\n                  }\n           if(ans!=0)\n           {\n                System.out.println(\"-1\");\n           }\n           else\n           {\n           int operation=max;\n           if(operation==0)\n           {\n               System.out.println('0');\n               continue;\n           }\n           System.out.println(operation);\n           while(operation!=0)\n           {\n               int p=0;\n               int first=-1;\n               int second=-1;\n               while(p<n&&(an[p]==0||an[p]<0))\n               {\n                   p++;\n               }\n                first=p;\n                p=0;\n               while(p<n&&(an[p]==0||an[p]>0))\n               {\n                   p++;\n               }\n               second=p;\n               System.out.println((first+1)+\" \"+ (second+1));\n               an[first]--;\n               an[second]++;\n               operation--;\n           } \n       }\n       }\n       \n    }\n    \n}\n class template {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tpublic String next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry { \n                                        st=new StringTokenizer(br.readLine());\t\t\t\t               \n                                } catch (IOException e) {}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}", "label": 3}
{"src": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic final class Main {\n    public static void main(final String... args) throws IOException {\n        final BufferedReader reader = Helper.newBufferedReader(16384);\n        final BufferedWriter writer = Helper.newBufferedWriter(8192);\n\n        int t = Integer.parseInt(reader.readLine());\n        while (t-- > 0)\n            solve(reader, writer);\n        writer.close();\n    }\n\n    private static void solve(final BufferedReader reader, final BufferedWriter writer) throws IOException {\n        final int n = Integer.parseInt(reader.readLine());\n        final int[] a = new int[n];\n        final int[] b = new int[n];\n        Helper.fillArrays(reader, a, b);\n\n        final List<Long> history = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            int diff = b[i] - a[i];\n            if (diff != 0) {\n                for (int j = i + 1; j < n; j++) {\n                    final int currentDiff = b[j] - a[j];\n                    if (oppositeSigns(diff, currentDiff)) {\n                        int m = Math.min(Math.abs(diff), Math.abs(currentDiff));\n                        final long c;\n                        if (diff < 0) {\n                            a[i] -= m;\n                            a[j] += m;\n                            c = convert(i, j);\n                        } else {\n                            a[i] += m;\n                            a[j] -= m;\n                            c = convert(j, i);\n                        }\n                        diff -= (diff < 0 ? -m : m);\n                        while (m-- > 0)\n                            history.add(c);\n                    }\n                    if (diff == 0)\n                        break;\n                }\n                if (diff != 0) {\n                    writer.write(String.valueOf(-1));\n                    writer.newLine();\n\n                    return;\n                }\n            }\n        }\n        writer.write(String.valueOf(history.size()));\n        writer.newLine();\n        for (final long e : history) {\n            writer.write((first(e) + 1) + \" \" + (second(e) + 1));\n            writer.newLine();\n        }\n    }\n\n    private static long convert(final int i, final int j) {\n        return (long) i << 32 | j & 0xFFFFFFFFL;\n    }\n\n    private static int first(final long l) {\n        return (int) (l >> 32);\n    }\n\n    private static int second(final long l) {\n        return (int) l;\n    }\n\n    private static boolean oppositeSigns(final int a, final int b) {\n        return (a ^ b) < 0;\n    }\n}\n\n@SuppressWarnings({\"unused\", \"CommentedOutCode\"})\nfinal class Helper {\n    public static final String YES = \"YES\";\n    public static final String NO = \"NO\";\n\n    private Helper() {\n        throw new UnsupportedOperationException();\n    }\n\n    public static BufferedReader newBufferedReader(final int bufferSize) {\n        return new BufferedReader(new InputStreamReader(System.in), bufferSize);\n    }\n\n    public static BufferedWriter newBufferedWriter(final int bufferSize) {\n        return new BufferedWriter(new OutputStreamWriter(System.out), bufferSize);\n    }\n\n    public static StringTokenizer spaceSplitter(final String s) {\n        return new StringTokenizer(s, \" \");\n    }\n\n    public static void repeat(int times, final Runnable runnable) {\n        while (times-- > 0)\n            runnable.run();\n    }\n\n    public static void fillArrays(final BufferedReader reader, final int[]... arrays) throws IOException {\n        for (final int[] array : arrays) {\n            final StringTokenizer tokenizer = spaceSplitter(reader.readLine());\n            for (int i = 0; i < array.length; i++)\n                array[i] = Integer.parseInt(tokenizer.nextToken());\n        }\n    }\n\n    public static void fillArrays(final BufferedReader reader, final long[]... arrays) throws IOException {\n        for (final long[] array : arrays) {\n            final StringTokenizer tokenizer = spaceSplitter(reader.readLine());\n            for (int i = 0; i < array.length; i++)\n                array[i] = Long.parseLong(tokenizer.nextToken());\n        }\n    }\n\n    /*\n    public static long parseLong(final String token) {\n        long result = 0L;\n\n        if (token.isEmpty())\n            return result;\n\n        final boolean negative = token.charAt(0) == '-';\n        for (int i = (negative ? 1 : 0); i < token.length(); ++i) {\n            final char currentChar = token.charAt(i);\n            if (currentChar < '0' || currentChar > '9')\n                throw new NumberFormatException(\"Expected a digit, found this: '\" + currentChar + \"' (i=\" + i + \")\");\n\n            result += BigInteger.valueOf(token.charAt(i) - '0')\n                    .multiply(BigInteger.valueOf((long) Math.pow(10, token.length() - i - 1))).longValue();\n        }\n\n        return negative ? -result : result;\n    }\n\n    public static int parseInt(final String token) {\n        final long result = parseLong(token);\n\n        if (result < Integer.MIN_VALUE || result > Integer.MAX_VALUE)\n            throw new IllegalArgumentException(\"Provided argument is a number, \" +\n                    \"but it can't be converted to an Integer due to its size: \" + result);\n\n        return (int) result;\n    }\n     */\n}\n", "label": 3}
{"src": "import java.util.*;\n\npublic class aquamoon_and_2arrays{\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint testCases = sc.nextInt();\n\t\twhile(testCases > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] a = new int[n];\n\t\t\tint[] b = new int[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tb[i] = sc.nextInt();\n\t\t\t}\n\t\t\tint sum1 =0;\n\t\t\tint sum2 = 0;\n\t\t\tList<Integer> low = new ArrayList<Integer>();\n\t\t\tList<Integer> high = new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tsum1 = sum1 + a[i];\n\t\t\t\tsum2 = sum2 + b[i];\n\t\t\t}\n\t\t\tif(sum1 != sum2) {\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t\t}else {\n\t\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\t\tif(a[i]>b[i]) {\n\t\t\t\t\t\tint temp1 = a[i]-b[i];\n\t\t\t\t\t\twhile(temp1!=0) {\n\t\t\t\t\t\t\thigh.add(i);\n\t\t\t\t\t\t\ttemp1--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int j=0;j<n;j++) {\n\t\t\t\t\t\t\tif(a[j]<b[j]) {\n\t\t\t\t\t\t\t\tint temp2 = b[j]-a[j];\n\t\t\t\t\t\t\t\twhile(temp2!=0) {\n\t\t\t\t\t\t\t\t\tlow.add(j);\n\t\t\t\t\t\t\t\t\ttemp2--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\tSystem.out.println(high.size());\n\t\t\t\tfor(int k=0;k<high.size();k++) {\n\t\t\t\t\tSystem.out.print(high.get(k)+1+\" \");\n\t\t\t\t\tSystem.out.print(low.get(k)+1+\" \");\n\t\t\t\t\tSystem.out.print(\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t\ttestCases--;\n\t\t}\n\t}\n}", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class C {\n    private static void sport(int[] a, int[] b) {\n        int s1 = 0;\n        int s2 = 0;\n        for (int i : a) {\n            s1 += i;\n        }\n        for (int i : b) {\n            s2 += i;\n        }\n        if (s1 != s2) {\n            System.out.println(-1);\n            return;\n        }\n        List<int[]> over = new ArrayList<>();\n        List<int[]> under = new ArrayList<>();\n        for (int i = 0; i < a.length; i++) {\n            if (a[i] > b[i]) {\n                over.add(new int[]{i, a[i]});\n            } else if (a[i] < b[i]) {\n                under.add(new int[]{i, a[i]});\n            }\n        }\n        List<int[]> ans = new ArrayList<>();\n        for (int i = 0; i < a.length; i++) {\n            while (a[i] != b[i]) {\n                if (a[i] > b[i]) {\n                    int[] entry = under.get(under.size() - 1);\n                    if (entry[1] + 1 == b[entry[0]]) {\n                        under.remove(under.size() - 1);\n                        a[entry[0]] = b[entry[0]];\n                        a[i]--;\n                    } else {\n                        under.get(under.size() - 1)[1] = entry[1] + 1;\n                        a[i]--;\n                        a[entry[0]]++;\n                    }\n                    ans.add(new int[]{i, entry[0]});\n                } else {\n                    int[] entry = over.get(over.size() - 1);\n                    if (entry[1] - 1 == b[entry[0]]) {\n                        over.remove(over.size()-1);\n                        a[entry[0]] = b[entry[0]];\n                        a[i]++;\n                    } else {\n                        over.get(over.size() - 1)[1] = entry[1] - 1;\n                        a[i]++;\n                        a[entry[0]]--;\n                    }\n                    ans.add(new int[]{entry[0], i});\n                }\n            }\n        }\n        System.out.println(ans.size());\n        for (int[] an : ans) {\n            System.out.println((an[0] + 1) + \" \" + (an[1] + 1));\n        }\n    }\n\n    public static void main(String[] args) throws IOException {\n        FastScanner sc = new FastScanner();\n        int t = sc.nextInt();\n        for (int i = 0; i < t; i++) {\n            int n = sc.nextInt();\n            int[] a = sc.readArrayInt(n);\n            int[] b = sc.readArrayInt(n);\n            sport(a, b);\n        }\n    }\n\n    static void shuffleArray(int[] ar) {\n        // If running on Java 6 or older, use `new Random()` on RHS here\n        Random rnd = ThreadLocalRandom.current();\n        for (int i = ar.length - 1; i > 0; i--) {\n            int index = rnd.nextInt(i + 1);\n            // Simple swap\n            int a = ar[index];\n            ar[index] = ar[i];\n            ar[i] = a;\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        String next() {\n            while (!st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        void nextLine() throws IOException {\n            br.readLine();\n        }\n\n        long[] readArrayLong(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextLong();\n            }\n            return a;\n        }\n\n        int[] readArrayInt(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.nio.file.*;\nimport java.math.*;\n\npublic class p1 {\n    public static void main(String[] uselessScrub) throws Exception {\n        FastScanner in = new FastScanner();\n        FastPrinter out = new FastPrinter();\n\n        int t=in.nextInt();\n        while(t-->0) {\n            int n=in.nextInt();\n            int[] a = new int[n], b= new int[n];\n            for (int i=0; i<n; i++) a[i]=in.nextInt();\n            for (int i=0; i<n; i++) b[i]=in.nextInt();\n\n            ArrayList<Integer> p = new ArrayList<>(), m=new ArrayList<>();\n            for (int i=0; i<n; i++) {\n                if (a[i]-b[i]>0) for (int j=0; j<a[i]-b[i]; j++) m.add(i+1);\n                else if (a[i]-b[i]<0) for (int j=0; j<b[i]-a[i]; j++) p.add(i+1);\n            }\n            if (m.size()!=p.size()) out.println(-1);\n            else {\n                out.println(m.size());\n                for (int i=0; i<m.size(); i++) {\n                    out.println(m.get(i)+\" \"+p.get(i));\n                }\n            }\n        }\n\n        out.close();\n    }\n\n    private static class FastPrinter {\n        static final char ENDL = '\\n';\n        StringBuilder buf;\n        PrintWriter pw;\n\n        public FastPrinter() {\n            buf = new StringBuilder();\n            pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        }\n\n        public FastPrinter(OutputStream stream) {\n            buf = new StringBuilder();\n            pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(stream)));\n        }\n\n        public FastPrinter(String fileName) throws Exception {\n            buf = new StringBuilder();\n            pw = new PrintWriter(new BufferedWriter(new FileWriter(fileName)));\n        }\n\n        public FastPrinter(StringBuilder buf) {\n            this.buf = buf;\n        }\n\n        public void print(int a) {\n            buf.append(a);\n        }\n\n        public void print(long a) {\n            buf.append(a);\n        }\n\n        public void print(char a) {\n            buf.append(a);\n        }\n\n        public void print(char[] a) {\n            buf.append(a);\n        }\n\n        public void print(double a) {\n            buf.append(a);\n        }\n\n        public void print(String a) {\n            buf.append(a);\n        }\n\n        public void print(Object a) {\n            buf.append(a.toString());\n        }\n\n        public void println() {\n            buf.append(ENDL);\n        }\n\n        public void println(int a) {\n            buf.append(a);\n            buf.append(ENDL);\n        }\n\n        public void println(long a) {\n            buf.append(a);\n            buf.append(ENDL);\n        }\n\n        public void println(char a) {\n            buf.append(a);\n            buf.append(ENDL);\n        }\n\n        public void println(char[] a) {\n            buf.append(a);\n            buf.append(ENDL);\n        }\n\n        public void println(double a) {\n            buf.append(a);\n            buf.append(ENDL);\n        }\n\n        public void println(String a) {\n            buf.append(a);\n            buf.append(ENDL);\n        }\n\n        public void println(Object a) {\n            buf.append(a.toString());\n            buf.append(ENDL);\n        }\n\n        public void close() {\n            pw.print(buf);\n            pw.close();\n        }\n\n        public void flush() {\n            pw.print(buf);\n            pw.flush();\n            buf.setLength(0);\n        }\n\n    }\n\n    private static class FastScanner {\n        final private int BUFFER_SIZE = 1 << 10;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public FastScanner() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public FastScanner(InputStream stream) {\n            din = new DataInputStream(stream);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public FastScanner(String fileName) throws IOException {\n            Path p = Paths.get(fileName);\n            buffer = Files.readAllBytes(p);\n            bytesRead = buffer.length;\n        }\n\n        int[] nextIntArray(int N) throws IOException {\n            int[] arr = new int[N];\n            for (int i = 0; i < N; i++) arr[i] = nextInt();\n            return arr;\n        }\n\n        int[][] nextDoubleIntArray(int n, int m) throws IOException {\n            int[][] arr = new int[n][m];\n            for (int i=0; i<n; i++) for (int j=0; j<m; j++) arr[i][j]=nextInt();\n            return arr;\n        }\n\n        String nextLine() throws IOException {\n            int c = read();\n            while (c != -1 && isEndline(c))\n                c = read();\n            if (c == -1) {\n                return null;\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                if (c >= 0) {\n                    res.appendCodePoint(c);\n                }\n                c = read();\n            } while (!isEndline(c));\n            return res.toString();\n        }\n\n        boolean isEndline(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        String next() throws Exception {\n            int c = readOutSpaces();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n\n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n\n            if (neg) return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        private int readOutSpaces() throws IOException {\n            while (true) {\n                if (bufferPointer == bytesRead) fillBuffer();\n                int c = buffer[bufferPointer++];\n                if (!isSpaceChar(c)) {\n                    return c;\n                }\n            }\n        }\n\n        public void close() throws IOException {\n            if (din == null) return;\n            din.close();\n        }\n    }\n}\n\n", "label": 3}
{"src": "    import javax.swing.*;\n    import java.io.BufferedReader;\n    import java.io.IOException;\n    import java.io.InputStreamReader;\n    import java.io.PrintWriter;\n    import java.util.*;\n    public class Main extends PrintWriter {\n        static BufferedReader s = new BufferedReader(new InputStreamReader(System.in));Main () { super(System.out); }public static void main(String[] args) throws IOException{ Main  d1=new Main   ();d1.main();d1.flush(); }\n\n        void main() throws IOException {\n            StringBuilder sb = new StringBuilder();\n            StringBuilder sb1 = new StringBuilder();\n            int t = 1;\n\n            t = i(s()[0]);\n            while(t-- > 0) {\n\n                String[] s1 = s();\n                int n = i(s1[0]);\n                int[] a=new int[n]; arri(a, n);\n                int[] b=new int[n]; arri(b, n);\n                ArrayList<Integer> c = new ArrayList<>();\n                ArrayList<Integer> d = new ArrayList<>();\n                for(int i=0;i<n;i++){\n                      if(a[i] < b[i]){\n                          int count = b[i] - a[i];\n                          while(count-- > 0){\n                              c.add((i + 1));\n                          }\n                      }else if(a[i] > b[i]){\n                          int count = - b[i] + a[i];\n                          while(count-- > 0){\n                              d.add((i + 1));\n                          }\n                      }\n                }\n                if(c.size() != d.size()){\n                    sb.append(\"-1\\n\");\n                }else{\n                    sb.append(c.size() + \"\\n\");\n                    for(int i = 0; i < c.size(); i++){\n                        sb.append(d.get(i) + \" \" + c.get(i) + \"\\n\");\n                    }\n                }\n            }\n            System.out.println(sb);\n        }\n        static String[] s() throws IOException { return s.readLine().trim().split(\"\\\\s+\"); }\n        static int i(String ss) {return Integer.parseInt(ss); }\n        static long l(String ss) {return Long.parseLong(ss); }\n        public void arr(long[] a,int n) throws IOException {String[] s2=s();for(int i=0;i<n;i++){ a[i]=l(s2[i]); }}\n        public void arri(int[] a,int n) throws IOException {String[] s2=s();for(int i=0;i<n;i++){ a[i]=(i(s2[i])); }}\n\n    }class Pair{\n           long a, b;\n           public Pair(long a, long b){\n               this.a = a;\n               this.b = b;\n        }\n    }\n\n\n", "label": 3}
{"src": "\n\n/*\n\n\n\n                    \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\n                 \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6             \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\n              \u00b6\u00b6\u00b6\u00b6                       \u00b6\u00b6\u00b6\u00b6\n             \u00b6\u00b6\u00b6                             \u00b6\u00b6\n            \u00b6\u00b6                                \u00b6\u00b6\n           \u00b6\u00b6                                  \u00b6\u00b6\n          \u00b6\u00b6                                   \u00b6\u00b6\n          \u00b6\u00b6 \u00b6\u00b6                             \u00b6\u00b6 \u00b6\u00b6\n          \u00b6\u00b6 \u00b6\u00b6                             \u00b6\u00b6  \u00b6\n          \u00b6\u00b6 \u00b6\u00b6                             \u00b6\u00b6  \u00b6\n          \u00b6\u00b6  \u00b6\u00b6                            \u00b6\u00b6 \u00b6\u00b6\n          \u00b6\u00b6  \u00b6\u00b6                            \u00b6\u00b6  \u00b6\u00b6\n           \u00b6\u00b6 \u00b6\u00b6   \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6     \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6   \u00b6\u00b6 \u00b6\u00b6\n            \u00b6\u00b6\u00b6\u00b6 \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6     \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6 \u00b6\u00b6\u00b6\u00b6\u00b6\n             \u00b6\u00b6\u00b6 \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6     \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6 \u00b6\u00b6\u00b6\n    \u00b6\u00b6\u00b6       \u00b6\u00b6  \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6       \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6  \u00b6\u00b6      \u00b6\u00b6\u00b6\u00b6\n   \u00b6\u00b6\u00b6\u00b6\u00b6     \u00b6\u00b6   \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6   \u00b6\u00b6\u00b6   \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6   \u00b6\u00b6     \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\n  \u00b6\u00b6   \u00b6\u00b6    \u00b6\u00b6     \u00b6\u00b6\u00b6    \u00b6\u00b6\u00b6\u00b6\u00b6    \u00b6\u00b6\u00b6     \u00b6\u00b6    \u00b6\u00b6   \u00b6\u00b6\n \u00b6\u00b6\u00b6    \u00b6\u00b6\u00b6\u00b6  \u00b6\u00b6          \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6          \u00b6\u00b6  \u00b6\u00b6\u00b6\u00b6    \u00b6\u00b6\u00b6\n\u00b6\u00b6         \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6       \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6       \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6        \u00b6\u00b6\n\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6     \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6    \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6    \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6      \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\n  \u00b6\u00b6\u00b6\u00b6 \u00b6\u00b6\u00b6\u00b6\u00b6      \u00b6\u00b6\u00b6\u00b6\u00b6              \u00b6\u00b6\u00b6 \u00b6\u00b6     \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6 \u00b6\u00b6\u00b6\n          \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6  \u00b6\u00b6\u00b6  \u00b6\u00b6           \u00b6\u00b6  \u00b6\u00b6\u00b6  \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\n              \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6 \u00b6\u00b6 \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6 \u00b6\u00b6 \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\n                  \u00b6\u00b6 \u00b6\u00b6 \u00b6 \u00b6 \u00b6 \u00b6 \u00b6 \u00b6 \u00b6 \u00b6 \u00b6\u00b6\n                \u00b6\u00b6\u00b6\u00b6  \u00b6 \u00b6 \u00b6 \u00b6 \u00b6 \u00b6 \u00b6 \u00b6   \u00b6\u00b6\u00b6\u00b6\u00b6\n            \u00b6\u00b6\u00b6\u00b6\u00b6 \u00b6\u00b6   \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6   \u00b6\u00b6 \u00b6\u00b6\u00b6\u00b6\u00b6\n    \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6     \u00b6\u00b6                 \u00b6\u00b6      \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\n   \u00b6\u00b6           \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6             \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6          \u00b6\u00b6\n    \u00b6\u00b6\u00b6     \u00b6\u00b6\u00b6\u00b6\u00b6     \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6     \u00b6\u00b6\u00b6\u00b6\u00b6     \u00b6\u00b6\u00b6\n      \u00b6\u00b6   \u00b6\u00b6\u00b6           \u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6\u00b6           \u00b6\u00b6\u00b6   \u00b6\u00b6\n      \u00b6\u00b6  \u00b6\u00b6                                   \u00b6\u00b6  \u00b6\u00b6\n       \u00b6\u00b6\u00b6\u00b6                                     \u00b6\u00b6\u00b6\u00b6\n\n*/\n\n\n\n\nimport java.lang.*;\nimport java.util.*;\nimport java.io.*;\n\nimport static java.lang.Math.abs;\nimport static java.lang.Math.min;\nimport static java.lang.Math.max;\nimport static java.lang.Math.ceil;\nimport static java.lang.Math.floor;\nimport java.math.BigInteger;\npublic class A {\n\tfinal static int mod = (int)(1e9 + 7);\n\tstatic int factors[];\n\tpublic static void main(String[] args) {\n\t\tFastReader fs = new FastReader();\n\t\tint testcase = 1;\n\t\ttestcase = Integer.parseInt(fs.nextLine());\n\t\twhile (testcase-- > 0) {\n\t\t\tsolve(fs);\n\t\t}\n\n\t}\n\tpublic static void solve(FastReader fs) {\n\t\tint n = fs.nextInt();\n\t\tint a[] = fs.readArray(n);\n\t\tint b[] = fs.readArray(n);\n\t\tboolean freq[] = new boolean[n];\n\t\tif (sumofArray(a) != sumofArray(b)) {\n\t\t\tSystem.out.println(\"-1\");\n\t\t\treturn ;\n\t\t}\n\t\tStringBuilder out = new StringBuilder();\n\t\tint m = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (freq[i]) continue;\n\t\t\tint val = a[i] - b[i];\n\t\t\t// if (val == 0) {\n\t\t\t// \tm++;\n\t\t\t// \tout.append(Integer.toString(i) + \" \" + Integer.toString(i) + \"\\n\");\n\t\t\t// \tfreq[i] = true;\n\t\t\t// }\n\t\t\tif (val < 0) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (freq[j]) continue;\n\t\t\t\t\twhile (a[j] - b[j] > 0 && val < 0) {\n\t\t\t\t\t\tm++;\n\t\t\t\t\t\tout.append(Integer.toString(j + 1) + \" \" + Integer.toString(i + 1) + \"\\n\");\n\t\t\t\t\t\ta[i]++;\n\t\t\t\t\t\tval++;\n\t\t\t\t\t\ta[j]--;\n\t\t\t\t\t}\n\t\t\t\t\tif (val == 0) {\n\t\t\t\t\t\tfreq[i] = true;\n\t\t\t\t\t\tif (a[j] - b[j] == 0) {\n\t\t\t\t\t\t\tfreq[j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (a[j] - b[j] == 0) {\n\t\t\t\t\t\tfreq[j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (val > 0) {\n\t\t\t\tfor (int j = i + 1; j < n; j++) {\n\t\t\t\t\tif (freq[j]) continue;\n\t\t\t\t\twhile (a[j] - b[j] < 0 && val > 0) {\n\t\t\t\t\t\tm++;\n\t\t\t\t\t\tout.append(Integer.toString(i + 1) + \" \" + Integer.toString(j + 1) + \"\\n\");\n\t\t\t\t\t\ta[i]--;\n\t\t\t\t\t\tval--;\n\t\t\t\t\t\ta[j]++;\n\t\t\t\t\t}\n\t\t\t\t\tif (val == 0) {\n\t\t\t\t\t\tfreq[i] = true;\n\t\t\t\t\t\tif (a[j] - b[j] == 0) {\n\t\t\t\t\t\t\tfreq[j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (a[j] - b[j] == 0) {\n\t\t\t\t\t\tfreq[j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(m);\n\t\tSystem.out.print(out);\n\t}\n\n\n\n\t//template function\n\t//-----------------------------------------------------------------\n\tstatic void swap(int a[], int i, int j) {\n\t\tint tmp = a[i];\n\t\ta[i] = a[j];\n\t\ta[j] = tmp;\n\t}\n\tstatic int sumofArray(int arr[]) {\n\t\tint sum = 0;\n\t\tfor (int i : arr) {\n\t\t\tsum += i;\n\t\t}\n\t\treturn sum;\n\t}\n\tstatic void seive() {\n\t\tint range = 1000000;\n\t\tfactors = new int[range + 1];\n\t\tfactors[0] = 1;\n\t\tfactors[1] = 1;\n\t\tfor (int i = 2; i * i <= range; i++) {\n\t\t\tif (factors[i] == 0) {\n\t\t\t\tfor (int j = i * i; j <= range; j += i) {\n\t\t\t\t\tfactors[j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\tstatic boolean isPrime(int num) {\n\n\t\treturn factors[num] == 0;\n\t}\n\tstatic long power(long a, long b) {\n\t\tlong result = 1L;\n\t\twhile (b > 0) {\n\t\t\tif (b % 2 == 1) {\n\t\t\t\tresult *= a;\n\t\t\t}\n\t\t\ta *= a;\n\t\t\tb /= 2;\n\t\t}\n\t\treturn result;\n\t}\n\n\tstatic int gcd(int a, int b) {\n\t\treturn b == 0 ? a : gcd(b, a % b);\n\t}\n\n\tstatic void sort(int a[]) {\n\t\tArrayList<Integer> ans = new ArrayList<>();\n\t\tfor (int i = 0; i < a.length; i++) ans.add(a[i]);\n\t\tCollections.sort(ans, Collections.reverseOrder());\n\t\tfor (int i = 0; i < a.length; i++) a[i] = ans.get(i);\n\t}\n\tstatic  void sortL(long a[]) {\n\t\tArrayList<Long> ans = new ArrayList<>();\n\t\tfor (int i = 0; i < a.length; i++) ans.add(a[i]);\n\t\tCollections.sort(ans);\n\t\tfor (int i = 0; i < a.length; i++) a[i] = ans.get(i);\n\t}\n\n\tstatic <T> void debug(String str, T value) {\n\t\tSystem.out.println(str + \" -> {\" + value + \"}\");\n\t}\n\n\n\t//----------------------------------------------------------------------------------------------------\n\t//IO operation\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(\n\t\t\t  new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() { return Integer.parseInt(next()); }\n\n\t\tlong nextLong() { return Long.parseLong(next()); }\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint arr[] = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextInt();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\tlong[] readArrayL(int n) {\n\t\t\tlong arr[] = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = nextLong();\n\t\t\t}\n\t\t\treturn arr;\n\t\t}\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}", "label": 3}
{"src": "/*\n\u2800\u2800\u2800\u2800\u28e0\u28f6\u287e\u280f\u2809\u2819\u2833\u28a6\u2840\u2800\u2800\u2800\u28a0\u281e\u2809\u2819\u2832\u2840\u2800\n\u2800\u2800\u2800\u28f4\u283f\u280f\u2800\u2800\u2800\u2800\u2800\u2800\u28b3\u2840\u2800\u284f\u2800\u2800Y\u2800\u2800\u28b7\n\u2800\u2800\u28a0\u28df\u28cb\u2840\u2880\u28c0\u28c0\u2840\u2800\u28c0\u2840\u28e7\u2800\u28b8\u2800\u2800A\u2800\u2800 \u2847\n\u2800\u2800\u28b8\u28ef\u286d\u2801\u2838\u28db\u28df\u2806\u2874\u28fb\u2872\u28ff\u2800\u28f8\u2800\u2800S\u2800  \u2847\n\u2800\u2800\u28df\u28ff\u286d\u2800\u2800\u2800\u2800\u2800\u28b1\u2800\u2800\u28ff\u2800\u28b9\u2800\u2800H\u2800\u2800 \u2847\n\u2800\u2800\u2819\u28bf\u28ef\u2804\u2800\u2800\u2800\u2880\u2840\u2800\u2800\u287f\u2800\u2800\u2847\u2800\u2800\u2800\u2800\u287c\n\u2800\u2800\u2800\u2800\u2839\u28f6\u2806\u2800\u2800\u2800\u2800\u2800\u2874\u2803\u2800\u2800\u2818\u2824\u28c4\u28e0\u281e\u2800\n\u2800\u2800\u2800\u2800\u2800\u28b8\u28f7\u2866\u28a4\u2864\u28a4\u28de\u28c1\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\u2800\n\u2800\u2800\u2880\u28e4\u28f4\u28ff\u28cf\u2801\u2800\u2800\u2838\u28cf\u28af\u28f7\u28d6\u28e6\u2840\u2800\u2800\u2800\u2800\u2800\u2800\n\u2880\u28fe\u28fd\u28ff\u28ff\u28ff\u28ff\u281b\u28b2\u28f6\u28fe\u2889\u2877\u28ff\u28ff\u2835\u28ff\u2800\u2800\u2800\u2800\u2800\u2800\n\u28fc\u28ff\u280d\u2809\u28ff\u286d\u2809\u2819\u28ba\u28c7\u28fc\u284f\u2800\u2800\u2800\u28c4\u28b8\u2800\u2800\u2800\u2800\u2800\u2800\n\u28ff\u28ff\u28e7\u28c0\u28ff\u2026\u2026\u2026\u28c0\u28f0\u28cf\u28d8\u28c6\u28c0\u2800\u2800\n */\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter; // System.out is a PrintStream\n// import java.util.Arrays;\n// import java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.PriorityQueue;\n// import java.util.Collections;    //  for sorting ArrayList mainly\n// import java.util.HashMap;\n// import java.util.TreeMap;\n// import java.util.HashSet;\n// import java.util.TreeSet;\n// import java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class A {\n    public static void main(String[] args) throws IOException {\n        FastScanner scn = new FastScanner();\n        PrintWriter out = new PrintWriter(System.out);\n        for (int tc = scn.nextInt(); tc > 0; tc--) {\n            int N = scn.nextInt();\n            int[] A = new int[N], B = new int[N];\n            for (int i = 0; i < N; i++) {\n                A[i] = scn.nextInt();\n            }\n            for (int i = 0; i < N; i++) {\n                B[i] = scn.nextInt();\n            }\n            int pos = N - 1;\n            ArrayList<String> al = new ArrayList<>();\n            PriorityQueue<int[]> less = new PriorityQueue<>((a, b) -> a[1] - b[1])\n                               , more = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n            for (int i = 0; i < N; i++) {\n                if (A[i] > B[i]) {\n                    more.add(new int[] { i, A[i] - B[i] });\n                } else if (A[i] < B[i]) {\n                    less.add(new int[] { i, B[i] - A[i] });\n                }\n            }\n            while (less.size() != 0 && more.size() != 0) {\n                int[] tpL = less.remove(), tpM = more.remove();\n                int mn = Math.min(tpL[1], tpM[1]);\n                tpL[1] -= mn;\n                tpM[1] -= mn;\n                while (mn-- > 0) {\n                    al.add((tpM[0] + 1) + \" \" + (tpL[0] + 1));\n                }\n                if (tpL[1] != 0) less.add(tpL);\n                if (tpM[1] != 0) more.add(tpM);\n            }\n            if (less.size() != 0 || more.size() != 0) {\n                out.println(\"-1\");\n            } else {\n                out.println(al.size());\n                for (String s : al) {\n                    out.println(s);\n                }\n            }\n        }\n        out.close();\n    }\n    \n    /* ------------------- Sorting ------------------- */\n    private static void ruffleSort(int[] arr) {\n        // int N = arr.length;\n        // Random rand = new Random();\n        // for (int i = 0; i < N; i++) {\n            //     int oi = rand.nextInt(N), temp = arr[i];\n            //     arr[i] = arr[oi];\n            //     arr[oi] = temp;\n        // }\n        // Arrays.sort(arr);\n    }\n    \n    /* ------------------- Pair class ------------------- */\n    private static class Pair implements Comparable<Pair> {\n\t\tint x, y;\n\t\tPair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn this.x == o.x ? this.y - o.y : this.x - o.x;\n\t\t}\n\t}\n\n    /* ------------------- HCF and LCM ------------------- */\n    private static int gcd(int num1, int num2) {\n        int temp = 0;\n        while (num2 != 0) {\n            temp = num1;\n            num1 = num2;\n            num2 = temp % num2;\n        }\n        return num1;\n    }\n    \n    private static int lcm(int num1, int num2) {\n        return (int)((1L * num1 * num2) / gcd(num1, num2));\n    }\n    \n    /* ------------------- primes and prime factorization ------------------- */\n    private static boolean[] seive(int N) {\n        // true means not prime, false means is a prime number :)\n        boolean[] notPrimes = new boolean[N + 1];\n        notPrimes[0] = notPrimes[1] = true;\n        for (int i = 2; i * i <= N; i++) {\n            if (notPrimes[i]) continue;\n            for (int j = i * i; j <= N; j += i) {\n                notPrimes[j] = true;\n            }\n        }\n        return notPrimes;\n    }\n\n\t/* private static TreeMap<Integer, Integer> primeFactors(long N) {\n\t\tTreeMap<Integer, Integer> primeFact = new TreeMap<>();\n\t\tfor (int i = 2; i <= Math.sqrt(N); i++) {\n            int count = 0;\n            while (N % i == 0) {\n                N /= i;\n                count++;\n            }\n            if (count != 0) {\n                primeFact.put(i, count);\n            }\n\t\t}\n\t\tif (N != 1) {\n            primeFact.put((int)N, 1);\n        }\n\t\treturn primeFact;\n\t} */\n\n    /* ------------------- Binary Search ------------------- */\n    private static long factorial(int N) {\n        long ans = 1L;\n        for (int i = 2; i <= N; i++) {\n            ans *= i;\n        }\n        return ans;\n    }\n\n    private static long[] factorialDP(int N) {\n        long[] factDP = new long[N + 1];\n        factDP[0] = factDP[1] = 1;\n        for (int i = 2; i <= N; i++) {\n            factDP[i] = factDP[i - 1] * i;\n        }\n        return factDP;\n    }\n\n    private static long factorialMod(int N, int mod) {\n        long ans = 1L;\n        for (int i = 2; i <= N; i++) {\n            ans = ((ans % mod) * (i % mod)) % mod;\n        }\n        return ans;\n    }\n\n    /* ------------------- Binary Search ------------------- */\n    private static int lowerbound(int[] arr, int st, int ed, int tar) {\n        int ans = -1;\n        while (st <= ed) {\n            int mid = ((ed - st) >> 1) + st;\n            if (arr[mid] <= tar) {\n                ans = mid;\n                st = mid + 1;\n            } else {\n                ed = mid - 1;\n            }\n        }\n        return ans;\n    }\n    \n    private static int upperbound(int[] arr, int st, int ed, int tar) {\n        int ans = -1;\n        while (st <= ed) {\n            int mid = ((ed - st) >> 1) + st;\n            if (arr[mid] < tar) {\n                st = mid + 1;\n            } else {\n                ans = mid;\n                ed = mid - 1;\n            }\n        }\n        return ans;\n    }\n    \n    /* ------------------- Power Function ------------------- */\n    public static long pow(long x, long y) {\n        long res = 1;\n\t\twhile (y > 0) {\n            if ((y & 1) != 0) {\n                res = (res * x);\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tx = (x * x);\n\t\t\ty >>= 1;\n\t\t}\n\t\treturn res;\n\t}\n    \n\tpublic static long powMod(long x, long y, int mod) {\n        long res = 1;\n\t\twhile (y > 0) {\n            if ((y & 1) != 0) {\n                res = (res * x) % mod;\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tx = (x * x) % mod;\n\t\t\ty >>= 1;\n\t\t}\n\t\treturn res % mod;\n\t}\n\n    /* ------------------- Disjoint Set(Union and Find) ------------------- */\n    private static class DSU {\n\t\tprivate int[] parent, rank;\n\t\tDSU(int N) {\n\t\t\tparent = new int[N];\n\t\t\trank = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tparent[i] = i;\n                rank[i] = 1;\n            }\n\t\t}\n\t\tpublic int find(int a) {\n\t\t\tif (parent[a] == a) {\n\t\t\t\treturn a;\n            }\n            return parent[a] = find(parent[a]);\n\t\t}\n\t\tpublic boolean union(int a, int b) {\n\t\t\tint parA = find(a), parB = find(b);\n\t\t\tif (parA == parB) return false;\n\t\t\tif (rank[parA] > rank[parB]) {\n                parent[parB] = parA;\n            } else if (rank[parA] < rank[parB]) {\n                parent[parA] = parB;\n            } else {\n                parent[parA] = parB;\n                rank[parB]++;\n            }\n            return true;\n\t\t}\n\t}\n    \n    /* ------------------- Scanner class for input ------------------- */\n    private static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        \n        FastScanner() {\n            this.br = new BufferedReader(new InputStreamReader(System.in));\n            this.st = new StringTokenizer(\"\");\n        }\n        \n        public String next() {\n            while (!st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException err) {\n                    err.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public String nextLine() {\n            if (st.hasMoreTokens()) {\n                return st.nextToken(\"\").trim();\n            }\n            try {\n                return br.readLine().trim();\n            } catch (IOException err) {\n                err.printStackTrace();\n            }\n            return \"\";\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n    }\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main implements Runnable {\n\n    public void solve() throws IOException  {\n        int tt = readInt();\n        for (int t = 0; t < tt; t++) {\n            int n = readInt();\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = readInt();\n            }\n            int[] b = new int[n];\n            for (int i = 0; i < n; i++) {\n                b[i] = readInt();\n            }\n            int suma = Arrays.stream(a).sum();\n            int sumb = Arrays.stream(b).sum();\n            if (suma != sumb) {\n                out.println(-1);\n            } else {\n                List<Integer> opsa = new ArrayList<>();\n                List<Integer> opsb = new ArrayList<>();\n\n                while (true) {\n                    boolean change = false;\n                    for (int i = 0; i < n; i++) {\n                        if (a[i] != b[i]) {\n                            change = true;\n                            if (a[i] > b[i]) {\n                                opsa.add(i);\n                                a[i]--;\n                                break;\n                            } else {\n                                opsb.add(i);\n                                a[i]++;\n                                break;\n                            }\n                        }\n                    }\n                    if (change == false) {\n                        break;\n                    }\n                }\n\n                out.println(opsa.size());\n                for (int i = 0; i < opsa.size(); i++) {\n                    out.println((opsa.get(i) + 1) + \" \" + (opsb.get(i) + 1));\n                }\n            }\n        }\n    }\n\n\n\n    /////////////////////////////////////////\n\n    boolean trackTime = false;\n\n\n    int mod = 1000_000_007;\n\n    @Override\n    public void run() {\n        try {\n            if (ONLINE_JUDGE || !new File(\"input.txt\").exists()) {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                reader = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            }\n            long time = 0;\n            if (trackTime) {\n                time = System.currentTimeMillis();\n            }\n            solve();\n            if (trackTime) {\n                System.err.println(\"time = \" + (System.currentTimeMillis() - time));\n            }\n\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                // nothing\n            }\n            out.close();\n        }\n    }\n\n    private String readString() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n\n    @SuppressWarnings(\"unused\")\n    private int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n\n    @SuppressWarnings(\"unused\")\n    private double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    private static final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private PrintWriter out;\n\n    public static void main(String[] args) {\n        new Thread(null, new Main(), \"\", 256 * (1L << 20)).start();\n    }\n\n}", "label": 3}
{"src": "//package codeforces;\t\nimport java.io.*;\nimport java.util.*;\npublic class Solution {\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint ni() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nl() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nd() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) throws java.lang.Exception {\n\t\tFastReader fr = new FastReader();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint t = fr.ni();\n\t\twhile(t-->0) {\n\t\t\tint n = fr.ni();\n\t\t\tint a [] = new int[n];\n\t\t\tint b [] = new int [n];\n\t\t\tfor(int i = 0 ; i < n ; i++) a[i] = fr.ni();\n\t\t\tfor(int i = 0 ; i < n ; i++) b[i] = fr.ni();\n\t\t\tArrayList<Integer> up = new ArrayList<>();\n\t\t\tArrayList<Integer> down = new ArrayList<>();\n\t\t\tfor(int i = 0 ; i < n ; i++) {\n\t\t\t\tif(a[i] > b[i]) {\n\t\t\t\t\tint diff = a[i]-b[i];\n\t\t\t\t\tfor(int j = 0 ; j < diff ; j++)down.add(i+1);\n\t\t\t\t}else if(a[i] < b[i]) {\n\t\t\t\t\tint diff = b[i]-a[i];\n\t\t\t\t\tfor(int j = 0 ; j < diff ; j++)up.add(i+1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(up.size() != down.size())out.println(-1);\n\t\t\telse {\n\t\t\t\tout.println(up.size());\n\t\t\t\tfor(int i = 0 ; i < up.size() ; i++) {\n\t\t\t\t\tout.println(down.get(i) + \" \" + up.get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.close();\n\t}\n}", "label": 3}
{"src": "/**\n * Created by Himanshu\n **/\n\nimport java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class A1546 {\n    public static void main(String[] args) throws IOException {\n        PrintWriter out = new PrintWriter(System.out);\n        Reader s = new Reader();\n        int t = s.i();\n        while (t-- > 0) {\n            int n = s.i();\n            int [] a= s.arr(n);\n            int [] b = s.arr(n);\n            int sum = 0;\n            for (int x : a) sum+= x;\n            for (int x : b) sum-=x;\n            if (sum != 0) {\n                out.println(-1);\n                continue;\n            }\n            ArrayList<Integer> small = new ArrayList<>();\n            ArrayList<Integer> large = new ArrayList<>();\n            for (int i=0;i<n;i++) {\n                if (a[i] < b[i]) {\n                    for (int j=0;j<b[i]-a[i];j++) {\n                        small.add(i+1);\n                    }\n                } else if (b[i] < a[i]) {\n                    for (int j=0;j<a[i]-b[i];j++) {\n                        large.add(i+1);\n                    }\n                }\n            }\n\n            out.println(large.size());\n            int i=0;\n            while (i < large.size()) {\n                out.println(large.get(i) + \" \" + small.get(i));\n                i++;\n            }\n        }\n        out.flush();\n    }\n\n    public static void shuffle(long[] arr) {\n        int n = arr.length;\n        Random rand = new Random();\n        for (int i = 0; i < n; i++) {\n            long temp = arr[i];\n            int randomPos = i + rand.nextInt(n - i);\n            arr[i] = arr[randomPos];\n            arr[randomPos] = temp;\n        }\n    }\n\n    private static long phi(long n) {\n        long result = n;\n        for (long i = 2; i * i <= n; i++) {\n            if (n % i == 0) {\n                while (n % i == 0)\n                    n /= i;\n                result -= result / i;\n            }\n        }\n        if (n > 1)\n            result -= result / n;\n        return result;\n    }\n\n    private static int gcd(int a, int b) {\n        if(b == 0) return a;\n        return gcd(b,a%b);\n    }\n\n    public static long nCr(long[] fact, long[] inv, int n, int r, long mod) {\n        if (n < r)\n            return 0;\n        return ((fact[n] * inv[n - r]) % mod * inv[r]) % mod;\n    }\n\n    private static void factorials(long[] fact, long[] inv, long mod, int n) {\n        fact[0] = 1;\n        inv[0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            fact[i] = (fact[i - 1] * i) % mod;\n            inv[i] = power(fact[i], mod - 2, mod);\n        }\n    }\n\n    private static long power(long a, long n, long p) {\n        long result = 1;\n        while (n > 0) {\n            if (n % 2 == 0) {\n                a = (a * a) % p;\n                n /= 2;\n            } else {\n                result = (result * a) % p;\n                n--;\n            }\n        }\n        return result;\n    }\n\n    private static long power(long a, long n) {\n        long result = 1;\n        while (n > 0) {\n            if (n % 2 == 0) {\n                a = (a * a);\n                n /= 2;\n            } else {\n                result = (result * a);\n                n--;\n            }\n        }\n        return result;\n    }\n\n    private static long query(long[] tree, int in, int start, int end, int l, int r) {\n        if (start >= l && r >= end) return tree[in];\n        if (end < l || start > r) return 0;\n        int mid = (start + end) / 2;\n        long x = query(tree, 2 * in, start, mid, l, r);\n        long y = query(tree, 2 * in + 1, mid + 1, end, l, r);\n        return x + y;\n    }\n\n    private static void update(int[] arr, long[] tree, int in, int start, int end, int idx, int val) {\n        if (start == end) {\n            tree[in] = val;\n            arr[idx] = val;\n            return;\n        }\n        int mid = (start + end) / 2;\n        if (idx > mid) update(arr, tree, 2 * in + 1, mid + 1, end, idx, val);\n        else update(arr, tree, 2 * in, start, mid, idx, val);\n        tree[in] = tree[2 * in] + tree[2 * in + 1];\n    }\n\n    private static void build(int[] arr, long[] tree, int in, int start, int end) {\n        if (start == end) {\n            tree[in] = arr[start];\n            return;\n        }\n        int mid = (start + end) / 2;\n        build(arr, tree, 2 * in, start, mid);\n        build(arr, tree, 2 * in + 1, mid + 1, end);\n        tree[in] = (tree[2 * in + 1] + tree[2 * in]);\n    }\n\n    static class Reader {\n        private InputStream mIs;\n        private byte[] buf = new byte[1024];\n        private int curChar, numChars;\n\n        public Reader() {\n            this(System.in);\n        }\n\n        public Reader(InputStream is) {\n            mIs = is;\n        }\n\n        public int read() {\n            if (numChars == -1) throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = mIs.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        public String s() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public long l() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int i() {\n            int c = read();\n            while (isSpaceChar(c)) c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double d() throws IOException {\n            return Double.parseDouble(s());\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n        public int[] arr(int n) {\n            int[] ret = new int[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = i();\n            }\n            return ret;\n        }\n\n        public long[] arrLong(int n) {\n            long[] ret = new long[n];\n            for (int i = 0; i < n; i++) {\n                ret[i] = l();\n            }\n            return ret;\n        }\n    }\n//    static class pairLong implements Comparator<pairLong> {\n//        long first, second;\n//\n//        pairLong() {\n//        }\n//\n//        pairLong(long first, long second) {\n//            this.first = first;\n//            this.second = second;\n//        }\n//\n//        @Override\n//        public int compare(pairLong p1, pairLong p2) {\n//            if (p1.first == p2.first) {\n//                if(p1.second > p2.second) return 1;\n//                else return -1;\n//            }\n//            if(p1.first > p2.first) return 1;\n//            else return -1;\n//        }\n//    }\n//    static class pair implements Comparator<pair> {\n//        int first, second;\n//\n//        pair() {\n//        }\n//\n//        pair(int first, int second) {\n//            this.first = first;\n//            this.second = second;\n//        }\n//\n//        @Override\n//        public int compare(pair p1, pair p2) {\n//            if (p1.first == p2.first) return p1.second - p2.second;\n//            return p1.first - p2.first;\n//        }\n//    }\n}\n\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class _732 {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n        int t = sc.nextInt();\n        while (t-- > 0) {\n            int n = sc.nextInt();\n            int [] a = new int[n];\n            int sumA = 0;\n            for (int i = 0; i < n; i++) {\n                a[i] = sc.nextInt();\n                sumA += a[i];\n            }\n            int [] b = new int[n];\n            int sumB = 0;\n            for (int i = 0; i < n; i++) {\n                b[i] = sc.nextInt();\n                sumB += b[i];\n            }\n            if (sumA != sumB) {\n                out.println(-1);\n                continue;\n            }\n            ArrayList<Op> ops = new ArrayList<>();\n            while (true) {\n                boolean check = true;\n                for (int i = 0; i < n; i++) check = check && a[i] == b[i];\n                if (check) break;\n                for (int i = 0; i < n; i++) {\n                    if (a[i] == b[i]) continue;\n                    if (a[i] > b[i]) {\n                        for (int j = 0; j < n; j++) {\n                            if (j != i && a[j] < b[j]) {\n                                ops.add(new Op(i, j));\n                                a[i]--;\n                                a[j]++;\n                                break;\n                            }\n                        }\n                    } else {\n                        for (int j = 0; j < n; j++) {\n                            if (j != i && a[j] > b[j] && a[j] > 0) {\n                                ops.add(new Op(j, i));\n                                a[j]--;\n                                a[i]++;\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n            out.println(ops.size());\n            for (Op o: ops) {\n                out.println((o.i + 1) + \" \" + (o.j + 1));\n            }\n        }\n        out.close();\n    }\n\n    static class Op {\n        int i; int j;\n        Op(int i, int j) {\n            this.i = i; this.j = j;\n        }\n    }\n\n\n    static void sort(int[] a) {\n        ArrayList<Integer> q = new ArrayList<>();\n        for (int i : a) q.add(i);\n        Collections.sort(q);\n        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\n    }\n\n    static void sort(long[] a) {\n        ArrayList<Long> q = new ArrayList<>();\n        for (long i : a) q.add(i);\n        Collections.sort(q);\n        for (int i = 0; i < a.length; i++) a[i] = q.get(i);\n    }\n\n\n    //-----------MyScanner class for faster input----------\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n    }\n\n}", "label": 3}
{"src": " import java.util.*;\n import java.lang.*;\n import java.io.*;\n \n /* Name of the class has to be \"Main\" only if the class is public. */\n public class A_AquaMoon_and_Two_Arrays\n {\n     static int M = 1_000_000_007;\n     static final PrintWriter out =new PrintWriter(System.out);\n     static final FastReader fs = new FastReader();\n     public static void main (String[] args) throws java.lang.Exception\n     {\n           \n           int t= fs.nextInt();\n           for(int i=0;i<t;i++)\n           {\n               int n=fs.nextInt();\n               int a[]=fs.arrayIn(n);\n               int b[]=fs.arrayIn(n);\n               int pos=0;\n               int ans=0;\n               ArrayList<Integer> al=new ArrayList<Integer>();\n               ArrayList<Integer> all=new ArrayList<Integer>();\n               for(int j=0;j<n;j++){\n                pos=pos+a[j]-b[j];\n                   if(a[j]>b[j]){\n                       al.add(j);\n                       ans=ans+a[j]-b[j];\n                   }else if(a[j]<b[j]){\n                       all.add(j);\n                   }\n               }\n               if(pos==0){\n                   int x=0;\n                   int y=0;\n                   out.println(ans);\n                   while(x<al.size()&&y<all.size()){\n                        int temp=all.get(y);\n                        int temp2=al.get(x);\n                        out.println((temp2+1)+\" \"+(temp+1));\n                        a[temp]=a[temp]+1;\n                        a[temp2]=a[temp2]-1;\n                        if(a[temp]==b[temp])\n                        y++;\n                        if(a[temp2]==b[temp2])\n                        x++;\n                   }\n               }else{\n                   out.println(-1);\n               }\n           }\n           out.flush();\n  }\n         static class FastReader \n         {\n         BufferedReader br;\n         StringTokenizer st;\n  \n         public FastReader()\n         {\n             br = new BufferedReader(\n                 new InputStreamReader(System.in));\n         }\n  \n         String next()\n         {\n             while (st == null || !st.hasMoreElements()) {\n                 try {\n                     st = new StringTokenizer(br.readLine());\n                     }\n                 catch (IOException e) {\n                     e.printStackTrace();\n                     }\n         }\n             return st.nextToken();\n         }\n  \n         int nextInt() { return Integer.parseInt(next()); }\n  \n         long nextLong() { return Long.parseLong(next()); }\n  \n         double nextDouble()\n         {\n             return Double.parseDouble(next());\n         }\n  \n         String nextLine()\n         {\n             String str = \"\";\n             try {\n                 str = br.readLine();\n             }\n             catch (IOException e) {\n                 e.printStackTrace();\n             }\n             return str;\n         }\n int [] arrayIn(int n) throws IOException\n     {\n         int  arr[] = new int[n];\n         for(int i=0; i<n; i++)\n         {\n             arr[i] = nextInt();\n         }\n         return arr;\n     }\n     }\n     \n     public static class Pairs implements Comparable<Pairs>\n     {\n         int value,index;\n         Pairs(int value, int index)\n         {\n             this.value = value;\n             this.index = index;\n         }\n         public int compareTo(Pairs p)\n         {\n             return Integer.compare(this.value, p.value);\n         }\n     }\n     static final Random random = new Random();\n  \n     static void ruffleSort(int arr[])\n     {\n         int n = arr.length;\n         for(int i=0; i<n; i++)\n         {\n             int j = random.nextInt(n),temp = arr[j];\n             arr[j] = arr[i];\n             arr[i] = temp;\n         }\n         Arrays.sort(arr);\n     }\n     static long nCk(int n, int k) {\n         return (modMult(fact(n),fastexp(modMult(fact(n-k),fact(k)),M-2)));\n     }\n  \n     static long fact (long n) {\n  \n         long fact =1;\n         for(int i=1; i<=n; i++) {\n             fact = modMult(fact,i);\n         }\n         return fact%M;\n     }\n  \n     static long modMult(long a,long b) {\n         return a*b%M;\n     }\n  \n     static long fastexp(long x, int y){\n         if(y==1) return x;\n  \n         long ans = fastexp(x,y/2);\n         if(y%2 == 0) return modMult(ans,ans);\n         else return modMult(ans,modMult(ans,x));\n     }\n }", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n    static FastScanner fs = new FastScanner();\n    static final long inf = 0x1fffffffffffffffL;\n    static final int iinf = 0x3fffffff;\n    static long mod = 1000000007;\n\n    public static void main(String[] args) {\n        // end main\n        int t = fs.nextInt();\n        for (int T = 0; T < t; T++) {\n            int n = fs.nextInt();\n            int greater = 0;\n            int smaller = 0;\n            int[] arrA = new int[n];\n            int[] arrB = new int[n];\n            for (int i = 0; i < n; i++) {\n                arrA[i] = fs.nextInt();\n            }\n            for (int i = 0; i < n; i++) {\n                arrB[i] = fs.nextInt();\n            }\n            for (int i = 0; i < n; i++) {\n                if (arrA[i] > arrB[i]) {\n                    greater += arrA[i] - arrB[i];\n                }\n                if (arrA[i] < arrB[i]) {\n                    smaller += arrB[i] - arrA[i];\n                }\n            }\n            if (greater != smaller) {\n                System.out.println(-1);\n            } else {\n                List<Integer> arri = new ArrayList<>();\n                List<Integer> arrj = new ArrayList<>();\n                while (greater != 0 && smaller != 0) {\n                    boolean smallFlag = true;\n                    boolean bigFlag = true;\n                    for (int i = 0; i < n; i++) {\n                        if (arrA[i] < arrB[i] && smallFlag) {\n                            arrA[i]++;\n                            --smaller;\n                            arrj.add(i+1);\n                            smallFlag = false;\n                            continue;\n                        }\n                        if (arrA[i] > arrB[i] && bigFlag) {\n                            arrA[i]--;\n                            --greater;\n                            arri.add(i+1);\n                            bigFlag = false;\n                        }\n                    }\n                }\n                System.out.println(arri.size());\n                for (int i = 0; i < arri.size(); i++) {\n                    System.out.println(arri.get(i) + \" \" + arrj.get(i));\n                }\n            }\n\n\n        }\n    }\n\n    static class FastScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() { return Integer.parseInt(next()); }\n\n        long nextLong() { return Long.parseLong(next()); }\n\n        double nextDouble() { return Double.parseDouble(next()); }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            }\n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}", "label": 3}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class AquaMoonandTwoArrays {\n    private static final Scanner SCANNER = new Scanner(System.in);\n\n    public static void main(String[] args) {\n        int testCase = SCANNER.nextInt();\n        while (testCase-- > 0) {\n            int lenOfArr = SCANNER.nextInt();\n            int[] arr1 = new int[lenOfArr];\n            int[] arr2 = new int[lenOfArr];\n            boolean check = false;\n            int cnt = 0;\n            for (int i = 0; i < lenOfArr; i++) {\n                arr1[i] = SCANNER.nextInt();\n                cnt += arr1[i];\n            }\n            for (int i = 0; i < lenOfArr; i++) {\n                arr2[i] = SCANNER.nextInt();\n                cnt -= arr2[i];\n            }\n\n            if (cnt != 0) {\n                System.out.println(-1);\n            } else {\n                int i = 0, j = 0, ans = 0;\n                int[] a = new int[1000], b = new int[1000];\n                while (i < lenOfArr && j < lenOfArr) {\n                    if (arr1[i] >= arr2[i]) {\n                        i++;\n                    }\n                    if (arr1[j] <= arr2[j]) {\n                        j++;\n                    }\n                    if (i < lenOfArr && j < lenOfArr) {\n                        while (arr1[i] < arr2[i] && arr1[j] > arr2[j]) {\n                            arr1[i]++;\n                            arr1[j]--;\n                            a[ans] = i;\n                            b[ans] = j;\n                            ans++;\n                        }\n                    }\n                }\n                System.out.println(ans);\n                for (int k = 0; k < ans; k++) {\n                    System.out.println( ++b[k]+ \" \" + (a[k] + 1));\n                }\n            }\n        }\n    }\n}\n\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n\n    static long startTime = System.currentTimeMillis();\n\n    // for global initializations and methods starts here\n\n    // global initialisations and methods end here\n\n    static void run() {\n        boolean tc = true;\n        AdityaFastIO r = new AdityaFastIO();\n        //FastReader r = new FastReader();\n\n        try (OutputStream out = new BufferedOutputStream(System.out)) {\n\n            //long startTime = System.currentTimeMillis();\n\n            int testcases = tc ? r.ni() : 1;\n            int tcCounter = 1;\n            // Hold Here Sparky------------------->>>\n            // Solution Starts Here\n\n            start:\n            while (testcases-- > 0) {\n\n                int n = r.ni();\n\n                List<Integer> a = new ArrayList<>();\n                List<Integer> b = new ArrayList<>();\n\n                for (int i=0;i<n;i++)a.add(r.ni());\n                for (int i=0;i<n;i++)b.add(r.ni());\n\n                List<Pair> res = new ArrayList<>();\n\n                for (int i=0;i<n;i++){\n                    if (a.get(i).equals(b.get(i))) continue ;\n\n                    for (int j=i+1;j<n;j++) {\n                        if (a.get(i) > b.get(i) && a.get(j) < b.get(j)) {\n                            int min = Math.min(Math.abs(a.get(i) - b.get(i)), Math.abs(a.get(j) - b.get(j)));\n                            while (min-- > 0) {\n                                res.add(new Pair(i+1,j+1));\n                                a.set(i,a.get(i)-1);\n                                a.set(j,a.get(j)+1);\n                            }\n                        }else if (a.get(i)<b.get(i) && a.get(j)>b.get(j)){\n                            int min = Math.min(Math.abs(a.get(i) - b.get(i)), Math.abs(a.get(j) - b.get(j)));\n                            while (min-- > 0) {\n                                res.add(new Pair(j+1,i+1));\n                                a.set(i,a.get(i)+1);\n                                a.set(j,a.get(j)-1);\n                            }\n                        }\n                    }\n                }\n\n                for (int i=0;i<n;i++){\n                    if (!a.get(i).equals(b.get(i))){\n                        out.write((-1 + \" \").getBytes());\n                        out.write((\"\\n\").getBytes());\n                        continue start;\n                    }\n                }\n\n                out.write((res.size() + \" \").getBytes());\n                out.write((\"\\n\").getBytes());\n                for (Pair ele : res){\n                    out.write((ele.first + \" \" + ele.second + \" \").getBytes());\n                    out.write((\"\\n\").getBytes());\n                }\n\n            }\n            // Solution Ends Here\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    static class AdityaFastIO {\n        final private int BUFFER_SIZE = 1 << 16;\n        private final DataInputStream din;\n        private final byte[] buffer;\n        private int bufferPointer, bytesRead;\n        public BufferedReader br;\n        public StringTokenizer st;\n\n        public AdityaFastIO() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public AdityaFastIO(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String word() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public String line() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[100000001]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int ni() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public long nl() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public double nd() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            }\n            while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10);\n            if (neg) return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null) return;\n            din.close();\n        }\n    }\n\n    public static void main(String[] args) throws Exception {\n        run();\n    }\n\n    static long mod = 998244353;\n\n    static long modInv(long base, long e) {\n        long result = 1;\n        base %= mod;\n        while (e > 0) {\n            if ((e & 1) > 0) result = result * base % mod;\n            base = base * base % mod;\n            e >>= 1;\n        }\n        return result;\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String word() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        String line() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n        int ni() {\n            return Integer.parseInt(word());\n        }\n\n        long nl() {\n            return Long.parseLong(word());\n        }\n\n        double nd() {\n            return Double.parseDouble(word());\n        }\n    }\n\n    static int MOD = (int) (1e9 + 7);\n\n    static long powerLL(long x, long n) {\n        long result = 1;\n        while (n > 0) {\n            if (n % 2 == 1) result = result * x % MOD;\n            n = n / 2;\n            x = x * x % MOD;\n        }\n        return result;\n    }\n\n    static long powerStrings(int i1, int i2) {\n        String sa = String.valueOf(i1);\n        String sb = String.valueOf(i2);\n        long a = 0, b = 0;\n        for (int i = 0; i < sa.length(); i++) a = (a * 10 + (sa.charAt(i) - '0')) % MOD;\n        for (int i = 0; i < sb.length(); i++) b = (b * 10 + (sb.charAt(i) - '0')) % (MOD - 1);\n        return powerLL(a, b);\n    }\n\n    static long gcd(long a, long b) {\n        if (a == 0) return b;\n        else return gcd(b % a, a);\n    }\n\n    static long lcm(long a, long b) {\n        return (a * b) / gcd(a, b);\n    }\n\n    static long lower_bound(List<Long> list, long k) {\n        int s = 0;\n        int e = list.size();\n        while (s != e) {\n            int mid = (s + e) >> 1;\n            if (list.get(mid) < k) s = mid + 1;\n            else e = mid;\n        }\n        if (s == list.size()) return -1;\n        return s;\n    }\n\n    static int upper_bound(List<Long> list, long k) {\n        int s = 0;\n        int e = list.size();\n        while (s != e) {\n            int mid = (s + e) >> 1;\n            if (list.get(mid) <= k) s = mid + 1;\n            else e = mid;\n        }\n        if (s == list.size()) return -1;\n        return s;\n    }\n\n    static void addEdge(ArrayList<ArrayList<Integer>> graph, int edge1, int edge2) {\n        graph.get(edge1).add(edge2);\n        graph.get(edge2).add(edge1);\n    }\n\n    public static class Pair implements Comparable<Pair> {\n        int first;\n        int second;\n\n        public Pair(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(Pair o) {\n            // TODO Auto-generated method stub\n            if (this.first != o.first)\n                return (int) (this.first - o.first);\n            else return (int) (this.second - o.second);\n        }\n    }\n\n    public static class PairC<X, Y> implements Comparable<PairC> {\n        X first;\n        Y second;\n\n        public PairC(X first, Y second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(PairC o) {\n            // TODO Auto-generated method stub\n            return o.compareTo((PairC) first);\n        }\n    }\n\n    static boolean isCollectionsSorted(List<Long> list) {\n        if (list.size() == 0 || list.size() == 1) return true;\n        for (int i = 1; i < list.size(); i++) if (list.get(i) <= list.get(i - 1)) return false;\n        return true;\n    }\n\n    static boolean isCollectionsSortedReverseOrder(List<Long> list) {\n        if (list.size() == 0 || list.size() == 1) return true;\n        for (int i = 1; i < list.size(); i++) if (list.get(i) >= list.get(i - 1)) return false;\n        return true;\n    }\n\n}", "label": 3}
{"src": "//package currentContest;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class P1 {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tFastReader sc=new FastReader();\n\t\tint t=sc.nextInt();\n\t\tStringBuilder st=new StringBuilder();\n\t\twhile(t--!=0){\n\t\t\tint n=sc.nextInt();\n\t\t\tint a[]=new int[n];\n\t\t\tint b[]=new int[n];\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\ta[i]=sc.nextInt();\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tb[i]=sc.nextInt();\n\t\t\tint nofi=0;\n\t\t\tint nofd=0;\n\t\t\tArrayList<Integer> ia=new ArrayList<Integer>();\n\t\t\tArrayList<Integer> ja=new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tif(a[i]>b[i]) {\n\t\t\t\t\tnofd+=a[i]-b[i];\n\t\t\t\t\tint temp=a[i]-b[i];\n\t\t\t\t\twhile(temp--!=0) {\n\t\t\t\t\t\tia.add(i+1);\n\t\t\t\t\t}\n\t\t\t\t}else {\n\t\t\t\t\tnofi+=b[i]-a[i];\n\t\t\t\t\tint temp=b[i]-a[i];\n\t\t\t\t\twhile(temp--!=0) {\n\t\t\t\t\t\tja.add(i+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(nofd!=nofi) {\n\t\t\t\tst.append(\"-1\\n\");\n\t\t\t}else {\n\t\t\t\tst.append(ia.size()+\"\\n\");\n\t\t\t\tfor(int i=0;i<ia.size();i++) {\n\t\t\t\t\tst.append(ia.get(i)+\" \"+ja.get(i)+\"\\n\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(st);\n\t}\n\n\tstatic FastReader sc = new FastReader();\n\n\tpublic static void solvegraph() {\n\t\tint n = sc.nextInt();\n\n\t\tint edge[][] = new int[n - 1][2];\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tedge[i][0] = sc.nextInt() - 1;\n\t\t\tedge[i][1] = sc.nextInt() - 1;\n\t\t}\n\t\tArrayList<ArrayList<Integer>> ad = new ArrayList<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tad.add(new ArrayList<Integer>());\n\t\t}\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tad.get(edge[i][0]).add(edge[i][1]);\n\t\t\tad.get(edge[i][1]).add(edge[i][0]);\n\t\t}\n\t\tint parent[] = new int[n];\n\t\tArrays.fill(parent, -1);\n\t\tparent[0] = n;\n\t\tArrayDeque<Integer> queue = new ArrayDeque<>();\n\t\tqueue.add(0);\n\t\tint child[] = new int[n];\n\t\tArrays.fill(child, 0);\n\t\tArrayList<Integer> lv = new ArrayList<Integer>();\n\t\twhile (!queue.isEmpty()) {\n\t\t\tint toget = queue.getFirst();\n\t\t\tqueue.removeFirst();\n\t\t\tchild[toget] = ad.get(toget).size() - 1;\n\t\t\tfor (int i = 0; i < ad.get(toget).size(); i++) {\n\t\t\t\tif (parent[ad.get(toget).get(i)] == -1) {\n\t\t\t\t\tparent[ad.get(toget).get(i)] = toget;\n\t\t\t\t\tqueue.addLast(ad.get(toget).get(i));\n\t\t\t\t}\n\t\t\t}\n\t\t\tlv.add(toget);\n\t\t}\n\n\t\tchild[0]++;\n\t}\n\n\tstatic void sort(int[] A) {\n\t\tint n = A.length;\n\t\tRandom rnd = new Random();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tint tmp = A[i];\n\t\t\tint randomPos = i + rnd.nextInt(n - i);\n\t\t\tA[i] = A[randomPos];\n\t\t\tA[randomPos] = tmp;\n\t\t}\n\t\tArrays.sort(A);\n\t}\n\n\tstatic void sort(long[] A) {\n\t\tint n = A.length;\n\t\tRandom rnd = new Random();\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tlong tmp = A[i];\n\t\t\tint randomPos = i + rnd.nextInt(n - i);\n\t\t\tA[i] = A[randomPos];\n\t\t\tA[randomPos] = tmp;\n\t\t}\n\t\tArrays.sort(A);\n\t}\n\n\tstatic String sort(String s) {\n\t\tCharacter ch[] = new Character[s.length()];\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tch[i] = s.charAt(i);\n\t\t}\n\t\tArrays.sort(ch);\n\t\tStringBuffer st = new StringBuffer(\"\");\n\t\tfor (int i = 0; i < s.length(); i++) {\n\t\t\tst.append(ch[i]);\n\t\t}\n\t\treturn st.toString();\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\tif (a == 0) {\n\t\t\treturn b;\n\t\t}\n\t\treturn gcd(b % a, a);\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}\n", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Codeforces {\n\n    public static class FastWriter {\n        private static final int BUF_SIZE = 1 << 13;\n        private final byte[] buf = new byte[BUF_SIZE];\n        private final OutputStream out;\n        private int ptr = 0;\n\n        private FastWriter() {\n            out = null;\n        }\n\n        public FastWriter(OutputStream os) {\n            this.out = os;\n        }\n\n        public FastWriter(String path) {\n            try {\n                this.out = new FileOutputStream(path);\n            } catch (FileNotFoundException e) {\n                throw new RuntimeException(\"FastWriter\");\n            }\n        }\n\n        public FastWriter write(byte b) {\n            buf[ptr++] = b;\n            if (ptr == BUF_SIZE) innerflush();\n            return this;\n        }\n\n        public FastWriter write(char c) {\n            return write((byte) c);\n        }\n\n        public FastWriter write(char[] s) {\n            for (char c : s) {\n                buf[ptr++] = (byte) c;\n                if (ptr == BUF_SIZE) innerflush();\n            }\n            return this;\n        }\n\n        public FastWriter write(String s) {\n            s.chars().forEach(c -> {\n                buf[ptr++] = (byte) c;\n                if (ptr == BUF_SIZE) innerflush();\n            });\n            return this;\n        }\n\n        private static int countDigits(int l) {\n            if (l >= 1000000000) return 10;\n            if (l >= 100000000) return 9;\n            if (l >= 10000000) return 8;\n            if (l >= 1000000) return 7;\n            if (l >= 100000) return 6;\n            if (l >= 10000) return 5;\n            if (l >= 1000) return 4;\n            if (l >= 100) return 3;\n            if (l >= 10) return 2;\n            return 1;\n        }\n\n        public FastWriter write(int x) {\n            if (x == Integer.MIN_VALUE) {\n                return write((long) x);\n            }\n            if (ptr + 12 >= BUF_SIZE) innerflush();\n            if (x < 0) {\n                write((byte) '-');\n                x = -x;\n            }\n            int d = countDigits(x);\n            for (int i = ptr + d - 1; i >= ptr; i--) {\n                buf[i] = (byte) ('0' + x % 10);\n                x /= 10;\n            }\n            ptr += d;\n            return this;\n        }\n\n        private static int countDigits(long l) {\n            if (l >= 1000000000000000000L) return 19;\n            if (l >= 100000000000000000L) return 18;\n            if (l >= 10000000000000000L) return 17;\n            if (l >= 1000000000000000L) return 16;\n            if (l >= 100000000000000L) return 15;\n            if (l >= 10000000000000L) return 14;\n            if (l >= 1000000000000L) return 13;\n            if (l >= 100000000000L) return 12;\n            if (l >= 10000000000L) return 11;\n            if (l >= 1000000000L) return 10;\n            if (l >= 100000000L) return 9;\n            if (l >= 10000000L) return 8;\n            if (l >= 1000000L) return 7;\n            if (l >= 100000L) return 6;\n            if (l >= 10000L) return 5;\n            if (l >= 1000L) return 4;\n            if (l >= 100L) return 3;\n            if (l >= 10L) return 2;\n            return 1;\n        }\n\n        public FastWriter write(long x) {\n            if (x == Long.MIN_VALUE) {\n                return write(\"\" + x);\n            }\n            if (ptr + 21 >= BUF_SIZE) innerflush();\n            if (x < 0) {\n                write((byte) '-');\n                x = -x;\n            }\n            int d = countDigits(x);\n            for (int i = ptr + d - 1; i >= ptr; i--) {\n                buf[i] = (byte) ('0' + x % 10);\n                x /= 10;\n            }\n            ptr += d;\n            return this;\n        }\n\n        public FastWriter write(double x, int precision) {\n            if (x < 0) {\n                write('-');\n                x = -x;\n            }\n            x += Math.pow(10, -precision) / 2;\n            //\t\tif(x < 0){ x = 0; }\n            write((long) x).write(\".\");\n            x -= (long) x;\n            for (int i = 0; i < precision; i++) {\n                x *= 10;\n                write((char) ('0' + (int) x));\n                x -= (int) x;\n            }\n            return this;\n        }\n\n        public FastWriter writeln(char c) {\n            return write(c).writeln();\n        }\n\n        public FastWriter writeln(int x) {\n            return write(x).writeln();\n        }\n\n        public FastWriter writeln(long x) {\n            return write(x).writeln();\n        }\n\n        public FastWriter writeln(double x, int precision) {\n            return write(x, precision).writeln();\n        }\n\n        public FastWriter write(int... xs) {\n            boolean first = true;\n            for (int x : xs) {\n                if (!first) write(' ');\n                first = false;\n                write(x);\n            }\n            return this;\n        }\n\n        public FastWriter write(long... xs) {\n            boolean first = true;\n            for (long x : xs) {\n                if (!first) write(' ');\n                first = false;\n                write(x);\n            }\n            return this;\n        }\n\n        public FastWriter writeln() {\n            return write((byte) '\\n');\n        }\n\n        public FastWriter writeln(int... xs) {\n            return write(xs).writeln();\n        }\n\n        public FastWriter writeln(long... xs) {\n            return write(xs).writeln();\n        }\n\n        public FastWriter writeln(char[] line) {\n            return write(line).writeln();\n        }\n\n        public FastWriter writeln(char[]... map) {\n            for (char[] line : map) write(line).writeln();\n            return this;\n        }\n\n        public FastWriter writeln(String s) {\n            return write(s).writeln();\n        }\n\n        private void innerflush() {\n            try {\n                out.write(buf, 0, ptr);\n                ptr = 0;\n            } catch (IOException e) {\n                throw new RuntimeException(\"innerflush\");\n            }\n        }\n\n        public void flush() {\n            innerflush();\n            try {\n                out.flush();\n            } catch (IOException e) {\n                throw new RuntimeException(\"flush\");\n            }\n        }\n\n        public FastWriter print(byte b) {\n            return write(b);\n        }\n\n        public FastWriter print(char c) {\n            return write(c);\n        }\n\n        public FastWriter print(char[] s) {\n            return write(s);\n        }\n\n        public FastWriter print(String s) {\n            return write(s);\n        }\n\n        public FastWriter print(int x) {\n            return write(x);\n        }\n\n        public FastWriter print(long x) {\n            return write(x);\n        }\n\n        public FastWriter print(double x, int precision) {\n            return write(x, precision);\n        }\n\n        public FastWriter println(char c) {\n            return writeln(c);\n        }\n\n        public FastWriter println(int x) {\n            return writeln(x);\n        }\n\n        public FastWriter println(long x) {\n            return writeln(x);\n        }\n\n        public FastWriter println(double x, int precision) {\n            return writeln(x, precision);\n        }\n\n        public FastWriter print(int... xs) {\n            return write(xs);\n        }\n\n        public FastWriter print(long... xs) {\n            return write(xs);\n        }\n\n        public FastWriter println(int... xs) {\n            return writeln(xs);\n        }\n\n        public FastWriter println(long... xs) {\n            return writeln(xs);\n        }\n\n        public FastWriter println(char[] line) {\n            return writeln(line);\n        }\n\n        public FastWriter println(char[]... map) {\n            return writeln(map);\n        }\n\n        public FastWriter println(String s) {\n            return writeln(s);\n        }\n\n        public FastWriter println() {\n            return writeln();\n        }\n    }\n\n\n    static final class InputReader {\n        private final InputStream stream;\n        private final byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        private int read() throws IOException {\n            if (curChar >= numChars) {\n                curChar = 0;\n                numChars = stream.read(buf);\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public final int readInt() throws IOException {\n            return (int) readLong();\n        }\n\n        public final long readLong() throws IOException {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n                if (c == -1) throw new IOException();\n            }\n            boolean negative = false;\n            if (c == '-') {\n                negative = true;\n                c = read();\n            }\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return negative ? -res : res;\n        }\n\n        public final int[] readIntArray(int size) throws IOException {\n            int[] array = new int[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readInt();\n            }\n            return array;\n        }\n\n        public final long[] readLongArray(int size) throws IOException {\n            long[] array = new long[size];\n            for (int i = 0; i < size; i++) {\n                array[i] = readLong();\n            }\n            return array;\n        }\n\n        public final String readString() throws IOException {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.append((char) c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n    }\n\n    static long mulmod(long a, long b,\n                       long mod) {\n        long res = 0; // Initialize result\n        a = a % mod;\n        while (b > 0) {\n            // If b is odd, add 'a' to result\n            if (b % 2 == 1) {\n                res = (res + a) % mod;\n            }\n\n            // Multiply 'a' with 2\n            a = (a * 2) % mod;\n\n            // Divide b by 2\n            b /= 2;\n        }\n\n        // Return result\n        return res % mod;\n    }\n\n    static long pow(long a, long b, long MOD) {\n        long x = 1, y = a;\n        while (b > 0) {\n            if (b % 2 == 1) {\n                x = (x * y);\n                if (x > MOD) x %= MOD;\n            }\n            y = (y * y);\n            if (y > MOD) y %= MOD;\n            b /= 2;\n        }\n        return x;\n    }\n\n    static long[] f = new long[200001];\n\n    static long InverseEuler(long n, long MOD) {\n        return pow(n, MOD - 2, MOD);\n    }\n\n    static long C(int n, int r, long MOD) {\n\n        return (f[n] * ((InverseEuler(f[r], MOD) * InverseEuler(f[n - r], MOD)) % MOD)) % MOD;\n    }\n\n\n    static int[] h = {0, 0, -1, 1};\n    static int[] v = {1, -1, 0, 0};\n\n\n    public static class Pair {\n        public int a;\n\n        public int b;\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Pair pair = (Pair) o;\n            return a == pair.a &&\n                    b == pair.b;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(a, b);\n        }\n\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    static class Pair2 {\n        public long cost;\n        int node;\n\n        public Pair2(long cos, int node) {\n            this.cost = cos;\n            this.node = node;\n        }\n    }\n\n    static long compute_hash(String s) {\n        int p = 31;\n        int m = 1000000007;\n        long hash_value = 0;\n        long p_pow = 1;\n        for (int i = 0; i < s.length(); ++i) {\n            char c = s.charAt(i);\n            hash_value = (hash_value + (c - 'a' + 1) * p_pow) % m;\n            p_pow = (p_pow * p) % m;\n        }\n        return hash_value;\n    }\n\n    public static class SegmentTree {\n        long[][] tree;\n        int n;\n\n        public SegmentTree(int[] nodes) {\n            tree = new long[nodes.length * 4][2];\n            n = nodes.length;\n            build(0, n - 1, 0, nodes);\n\n        }\n\n        private void build(int l, int r, int pos, int[] nodes) {\n            if (l == r) {\n                tree[pos][0] = nodes[l];\n                tree[pos][1] = l;\n                return;\n            }\n            int mid = (l + r) / 2;\n            build(l, mid, 2 * pos + 1, nodes);\n            build(mid + 1, r, 2 * pos + 2, nodes);\n            if (tree[2 * pos + 1][0] > tree[2 * pos + 2][0]) {\n                tree[pos][1] = tree[2 * pos + 1][1];\n            } else {\n                tree[pos][1] = tree[2 * pos + 2][1];\n            }\n            tree[pos][0] = Math.max(tree[2 * pos + 1][0], tree[2 * pos + 2][0]);\n        }\n\n        //        public void update(int pos, int val) {\n        //            updateUtil(0, n - 1, 0, pos, val);\n        //        }\n\n        public long[] get(int l, int r) {\n            return getUtil(0, n - 1, 0, l, r);\n        }\n\n        private long[] getUtil(int l, int r, int pos, int ql, int qr) {\n            if (ql > r || qr < l) {\n                return new long[]{-1, -1};\n            }\n            if (l >= ql && r <= qr) {\n                return tree[pos];\n            }\n\n            int mid = (l + r) / 2;\n            long[] left = getUtil(l, mid, 2 * pos + 1, ql, qr);\n            long[] right = getUtil(mid + 1, r, 2 * pos + 2, ql, qr);\n            long choice = right[1];\n            if (left[0] > right[0]) choice = left[1];\n            return new long[]{Math.max(left[0], right[0]), choice};\n\n        }\n\n        //        private void updateUtil(int l, int r, int pos, int i, int val) {\n        //            if (i < l || i > r) {\n        //                return;\n        //            }\n        //            if (l == r) {\n        //                tree[pos] = val;\n        //                return;\n        //            }\n        //            int mid = (l + r) / 2;\n        //            updateUtil(l, mid, 2 * pos + 1, i, val);\n        //            updateUtil(mid + 1, r, 2 * pos + 2, i, val);\n        //            tree[pos] = tree[2 * pos + 1] + tree[2 * pos + 2];\n        //        }\n    }\n\n    static int counter = 0;\n    static int[] rIn;\n    static int[] rOut;\n    static int[] lIn;\n    static int[] lOut;\n    private static int[] flatten;\n    private static int[] lFlatten;\n    static long answer = 0;\n\n    static int VISITED = 1;\n    static int VISITING = 2;\n\n    static int[] DIRX = new int[]{0, 0, 1, -1};\n    static int[] DIRY = new int[]{1, -1, 0, 0};\n\n    public static class Pair22 {\n        int num, pos;\n\n        public Pair22(int x, int y) {\n            this.num = x;\n            this.pos = y;\n        }\n    }\n\n    public static long sumofdig(long n) {\n        long sum = 0;\n        while (n > 0) {\n            sum += n % 10;\n            n /= 10;\n        }\n        return sum;\n    }\n\n    public static class DK {\n        int D, K;\n\n        public DK(int d, int k) {\n            D = d;\n            K = k;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            DK dk = (DK) o;\n            return D == dk.D &&\n                    K == dk.K;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(D, K);\n        }\n    }\n    public static void main(String[] args) throws Exception {\n        //https://i...content-available-to-author-only...e.com/ebRGa6\n        InputReader in = new InputReader(System.in);\n\n        FastWriter out = new FastWriter(System.out);\n\n\n//\n//        f[0] = 1;\n//        f[1] = 1;\n//        for (int i = 2; i < 200001; ++i) {\n//            f[i] = f[i-1] * i;\n//            f[i] %= 1000000007;\n//        }\n        int t = in.readInt();\n\n\n\n        while (t-- > 0) {\n\n\n            int n = in.readInt();\n            int sum1 = 0;\n            int sum2 = 0;\n            int[] arr1 = new int[n];\n            int[] arr2 = new int[n];\n            for (int i = 0; i < n; ++i) {\n                arr1[i] = in.readInt();\n                sum1 += arr1[i];\n            }\n            for (int i = 0; i < n; ++i) {\n                arr2[i] = in.readInt();\n                sum2 += arr2[i];\n            }\n\n            if (sum1 != sum2) {\n                System.out.println(-1);\n            } else {\n                List<Integer> more = new ArrayList<>();\n                List<Integer> less = new ArrayList<>();\n                for (int i = 0; i < n; ++i) {\n                     if (arr1[i] > arr2[i]) {\n                         for (int j = 0; j < arr1[i] - arr2[i]; ++j) {\n                             more.add(i);\n                         }\n                     } else if (arr1[i] < arr2[i]) {\n                         for (int j = 0; j < arr2[i] - arr1[i]; ++j) {\n                             less.add(i);\n                         }\n                     }\n                }\n                System.out.println(more.size());\n                assert(more.size() == less.size());\n                for (int i = 0; i < more.size(); ++i) {\n                    System.out.println((more.get(i) + 1) + \" \" + (less.get(i) + 1));\n                }\n            }\n\n\n        }\n\n    }\n\n    private static void printBit(long maxBitSet, int m) {\n        StringBuilder ans = new StringBuilder();\n\n        while (maxBitSet > 0) {\n            if (maxBitSet % 2 == 1) {\n                ans.append(\"1\");\n            } else {\n                ans.append(\"0\");\n            }\n            maxBitSet /= 2;\n        }\n\n        for (int i = m - 1; i >= 0; --i) {\n            if (i <= ans.length() - 1)\n                System.out.print(ans.charAt(i));\n            else\n                System.out.print(0);\n        }\n        System.out.println();\n    }\n\n    private static void solvedd(int[] arr, int left, int right, int[] ans, int depth) {\n\n        if (left > right) return;\n        int maxInd = left;\n        for (int i = left; i <= right; ++i) {\n            if (arr[i] > arr[maxInd]) {\n                maxInd = i;\n            }\n        }\n\n        ans[maxInd] = depth;\n\n        solvedd(arr, left, maxInd - 1, ans, depth + 1);\n        solvedd(arr, maxInd + 1, right, ans, depth + 1);\n\n    }\n\n\n    private static void solved(List<List<Integer>> g, int node, int[][] dp, int last, int[] a) {\n\n        int donttake = 0;\n        int take = 0;\n        for (int i = 0; i < g.get(node).size(); ++i) {\n            int ntb = g.get(node).get(i);\n\n            if (ntb != last) {\n                solved(g, ntb, dp, node, a);\n                donttake += Math.max(dp[ntb][0], dp[ntb][1]);\n                take += dp[ntb][1];\n            }\n        }\n        dp[node][0] = a[node] + take;\n        dp[node][1] = donttake;\n    }\n\n\n    private static boolean solve(int n, List<Integer> nums, int cur, int pos, Boolean[][] dp) {\n        if (cur > n) return false;\n        if (cur == n) return true;\n        if (pos >= nums.size()) return false;\n\n        if (dp[cur][pos] != null) {\n            return dp[cur][pos];\n        }\n        boolean without = solve(n, nums, cur, pos + 1, dp);\n        boolean with = false;\n        int ogcur = cur;\n        for (int i = 1; i < 12; ++i) {\n            with |= solve(n, nums, cur + nums.get(pos), pos + 1, dp);\n            cur += nums.get(pos);\n        }\n\n        return dp[ogcur][pos] = with | without;\n    }\n\n//    private static Pair22 dfss(List<LinkedHashSet<Integer>> g, int node, HashSet<Integer> vis, int[] dis, int[] dis2) {\n//        if (vis.contains(node)) return new Pair22(dis[node], dis2[node], -1);\n//        vis.add(node);\n//        int min = dis[node];\n//        for (Integer ntb : g.get(node)) {\n//            if (dis[ntb] > dis[node])\n//                dfss(g, ntb, vis, dis, dis2);\n//            if (dis[ntb] <= dis[node]) {\n//                min = Math.min(min, dis[ntb]);\n//            } else {\n//                min = Math.min(min, dis2[ntb]);\n//            }\n//        }\n//        //        if (dis)\n//        dis2[node] = min;\n//        return new Pair22(dis[node], min, -1);\n//    }\n\n\n    private static int dfs(HashMap<Pair, TreeSet<Pair>> grid, int x, int y, int ti, HashSet<Pair> vis, int r, int startX, int startY) {\n        //        System.out.println(x + \"  \" + y);\n        int taken = ti - Math.abs(startX - x) - Math.abs(startY - y);\n        if (taken < 0) return 0;\n        if (x < 0 || y < 0 || x > r || y > r) return 0;\n        if (vis.contains(new Pair(x, y))) return 0;\n        int max = 0;\n\n        if (grid.containsKey(new Pair(x, y))) {\n            TreeSet<Pair> times = grid.get(new Pair(x, y));\n            for (Pair t : times) {\n                if (t.a <= taken) {\n                    max = Math.max(t.b, max);\n                } else break;\n            }\n        }\n        vis.add(new Pair(x, y));\n        max = Math.max(dfs(grid, x + 1, y, ti, vis, r, startX, startY), max);\n        max = Math.max(dfs(grid, x, y + 1, ti, vis, r, startX, startY), max);\n        max = Math.max(dfs(grid, x - 1, y, ti, vis, r, startX, startY), max);\n        max = Math.max(dfs(grid, x, y - 1, ti, vis, r, startX, startY), max);\n        return max;\n    }\n\n    private static int solver(int[] nums, int pos, int[] dp) {\n        if (pos >= nums.length) return 0;\n        if (dp[pos] != Integer.MAX_VALUE) return dp[pos];\n        int min = solver(nums, pos + 2, dp) + nums[pos];\n        min = Math.min(solver(nums, pos + 3, dp) + nums[pos], min);\n        if (pos + 1 < nums.length) min = Math.min(min, nums[pos] + nums[pos + 1] + solver(nums, pos + 3, dp));\n        if (pos + 1 < nums.length) min = Math.min(min, nums[pos] + nums[pos + 1] + solver(nums, pos + 4, dp));\n\n        //        System.out.println(pos + \" \" + min);\n        return dp[pos] = min;\n    }\n\n\n    static int countFreq(String pattern, String text) {\n        int m = pattern.length();\n        int n = text.length();\n        int res = 0;\n\n        for (int i = 0; i <= n - m; i++) {\n            int j;\n            for (j = 0; j < m; j++) {\n                if (text.charAt(i + j) != pattern.charAt(j)) {\n                    break;\n                }\n            }\n            if (j == m) {\n                res++;\n                j = 0;\n            }\n        }\n        return res;\n    }\n\n    private static void dfsR(List<List<Integer>> g, int node, int[] v) {\n        rIn[node] = counter;\n        flatten[counter++] = v[node];\n\n        for (int i = 0; i < g.get(node).size(); ++i) {\n            dfsR(g, g.get(node).get(i), v);\n        }\n\n        rOut[node] = counter;\n        flatten[counter++] = v[node] * -1;\n    }\n\n    private static void dfsL(List<List<Integer>> g, int node, int[] v) {\n        lIn[node] = counter;\n        lFlatten[counter++] = v[node];\n\n        for (int i = 0; i < g.get(node).size(); ++i) {\n            dfsL(g, g.get(node).get(i), v);\n        }\n\n        lOut[node] = counter;\n        lFlatten[counter++] = v[node] * -1;\n\n        TreeMap<String, Integer> map = new TreeMap<>();\n    }\n\n\n    private static void preprocess(int pos, int[][] pre, List<List<Integer>> tree, int[] traverse, int depth, int last, int[] tin, int[] tout) {\n        tin[pos] = counter++;\n        traverse[depth] = pos;\n\n        for (int i = 0; depth - (1 << i) >= 0; ++i) {\n            pre[pos][i] = traverse[depth - (1 << i)];\n        }\n\n        for (int i = 0; i < tree.get(pos).size(); ++i) {\n            if (tree.get(pos).get(i) != last)\n                preprocess(tree.get(pos).get(i), pre, tree, traverse, depth + 1, pos, tin, tout);\n        }\n        tout[pos] = counter++;\n    }\n\n    static long gcd(long a, long b) {\n\n        while (b != 0) {\n            long t = a;\n            a = b;\n            b = t % b;\n        }\n        return a;\n    }\n    static long lcm(long a, long b) {\n\n        return a*b/gcd(a,b);\n    }\n\n\n    static boolean submit = true;\n\n    static void debug(String s) {\n        if (!submit)\n            System.out.println(s);\n    }\n\n    static void debug(int s) {\n        LinkedHashSet<Integer> exist = new LinkedHashSet<>();\n            /*\n\n            4 2 3 _ 2 4 3 _\n             */\n    }\n\n\n\n\n}", "label": 3}
{"src": "\n\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class Main\n{\n    static class FastReader \n    { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String n() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int ni() \n        { \n            return Integer.parseInt(n()); \n        } \n  \n        long nl() \n        { \n            return Long.parseLong(n()); \n        } \n  \n        double nd() \n        { \n            return Double.parseDouble(n()); \n        } \n  \n        String nline() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }\n\n   \n     public static long[] randomize(long arr[])\n    {\n        Random rand = new Random();\nfor (int i = 0; i < arr.length; ++i) {\n   int index = rand.nextInt(arr.length - i);\n   long tmp = arr[arr.length - 1 - i];\n   arr[arr.length - 1 - i] = arr[index];\n   arr[index] = tmp;\n}\n\nreturn arr;\n    } \n\n    static long mod = 1000000007;\n\n  \n    public static void main (String[] args) throws java.lang.Exception\n    {\n        FastReader sc = new FastReader();\n        StringBuilder fo = new StringBuilder();\n\n        int test=sc.ni();\n        \n        while(test-->0)\n        {\n            int n =sc.ni();\n\n            int a[] = new int[n];\n            int b[]= new int[n];\n            long sum1=0, sum2=0;\n            for(int i=0;i<n;i++)\n            {\n                a[i]= sc.ni();\n                sum1 = sum1+a[i];\n            }\n\n            \n            for(int i=0;i<n;i++)\n            {\n                b[i]= sc.ni();\n                sum2 = sum2+b[i];\n            }         \n            if(sum1!=sum2)\n            {\n                System.out.println(-1);\n            }\n            else\n            {\n                List<Integer> list1 = new ArrayList<>();\n\n                List<Integer> list2 = new ArrayList<>();\n\n                for(int i=0;i<n;i++)\n                {\n                    if(a[i]!=b[i])\n                    {\n                        while(a[i]>b[i])\n                        {\n                            list1.add(i+1);\n                            a[i]--;\n                        }\n                        while(a[i]<b[i])\n                        {\n                            list2.add(i+1);\n                            a[i]++;\n                        }\n                    }\n                }\n\n\n\n\n                System.out.println(list1.size());\n\n                for(int i=0;i<list1.size();i++)\n                    System.out.println(list1.get(i)+\" \"+list2.get(i));\n            }\n        }\n        \n        \n        \n    }\n    \n    \n    \n    \n}\n", "label": 3}
{"src": "import java.util.*;\n\npublic class a {\n\n    public static void solve(int n, int [] a, int [] b) {\n        int suma = 0, sumb = 0;\n        for (int i = 0; i < n; i++) {\n            suma += a[i];\n            sumb += b[i];\n        }\n        if(suma != sumb) {\n            System.out.println(-1);\n            return;\n        }\n\n        int diff [] = new int [n];\n        // int mag = 0;\n        for(int i = 0; i < n; i++) {\n            diff[i] = a[i] - b[i];\n            // if(mag < Math.abs(diff[i])) mag = Math.abs(diff[i]);\n        }\n\n        // print the m value\n        // System.out.println(mag);\n\n        ArrayList<String> ans = new ArrayList<>();\n\n        int neg = 0, pos = 0;\n        for(;neg < n && pos < n;) {\n            if(diff[neg] >= 0) neg++;\n            else if(diff[pos] <= 0) pos++;\n            else {\n                ans.add((pos+1) + \" \" + (neg+1));\n                // System.out.println((pos+1) + \" \" + (neg+1));\n                diff[neg]++;\n                diff[pos]--;\n            }\n        }\n\n        System.out.println(ans.size());\n        for(int i = 0; i < ans.size();i++) {\n            System.out.println(ans.get(i));\n        }\n\n        return;\n    }\n\n    public static void main(String[] args) {\n        Scanner s = new Scanner(System.in);\n        int t = s.nextInt();\n        while(t-- > 0) {\n            int n = s.nextInt();\n            int [] a = new int [n];\n            int [] b = new int [n];\n            for(int i = 0; i < n; i++) {\n                a[i] = s.nextInt();\n            }\n            for(int i = 0; i < n; i++) {\n                b[i] = s.nextInt();\n            }\n            solve(n, a, b);\n        }\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class MainClass {\n    public static void main(String[] args) {\n        Reader in = new Reader(System.in);\n        StringBuilder stringBuilder = new StringBuilder();\n        int t = in.nextInt();\n        while (t-- > 0) {\n            int n = in.nextInt();\n            int[] a = new int[n];\n            int[] b = new int[n];\n            int sum1 = 0;\n            int sum2 = 0;\n            for (int i = 0; i < n; i++) {\n                sum1 += a[i] = in.nextInt();\n            }\n            for (int i = 0; i < n; i++) {\n                sum2 += b[i] = in.nextInt();\n            }\n            if (sum1 != sum2) {\n                stringBuilder.append(\"-1\\n\");\n                continue;\n            }\n            ArrayList<Integer> all = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < a[i] - b[i]; j++) {\n                    all.add(i);\n                }\n            }\n            int c = 0;\n            StringBuilder stringBuilder1 = new StringBuilder();\n            int ans = 0;\n            for (int i = 0; i < n; i++) {\n                if (a[i] < b[i]) {\n                    int count = b[i] - a[i];\n                    ans += count;\n                    for (int j = 0; j < count; j++) {\n                        stringBuilder1.append(all.get(c++) + 1).append(\" \").append(i + 1).append(\"\\n\");\n                    }\n                }\n            }\n            stringBuilder.append(ans).append(\"\\n\").append(stringBuilder1);\n        }\n        System.out.println(stringBuilder);\n    }\n}\nclass Reader {\n    public BufferedReader reader;\n    public StringTokenizer tokenizer;\n\n    public Reader(InputStream stream) {\n        reader = new BufferedReader(new InputStreamReader(stream), 32768);\n        tokenizer = null;\n    }\n\n    public String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n    }\n\n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n}\n", "label": 3}
{"src": "\n\nimport java.io.*;\nimport java.sql.Array;\nimport java.util.*;\n\npublic class Main {\n\n    public static class Node {\n        int i;\n        int j;\n        int c;\n        Node(int i, int j, int c) {\n            this.i = i;\n            this.j = j;\n            this.c = c;\n        }\n    }\n\n    /************************ SOLUTION STARTS HERE ************************/\n    private static void solve() {\n        int t = nextInt();\n        while(t-- > 0) {\n            int n = nextInt();\n            int[] a = nextIntArray(n);\n            int[] b = nextIntArray(n);\n\n            boolean done = true;\n            ArrayList<Node> res = new ArrayList<>();\n            int total = 0;\n            for(int i=0;i<n;i++) {\n                if(a[i] == b[i])\n                    continue;\n                for(int j=i+1;j<n;j++) {\n                    if(a[i] > b[i]) {\n                        if(a[j] < b[j]) {\n                            int cnt = Math.min(a[i] - b[i], b[j] - a[j]);\n                            a[j] = a[j] + cnt ;\n                            a[i] = a[i] - cnt;\n                            res.add(new Node(i+1, j+1, cnt));\n                            total += cnt;\n                        }\n                    } else {\n                        if(a[j] > b[j]) {\n                            int cnt = Math.min(b[i] - a[i], a[j] - b[j]);\n                            a[j] = a[j] - cnt ;\n                            a[i] = a[i] + cnt;\n                            res.add(new Node(j+1, i+1, cnt));\n                            total += cnt;\n                        }\n                    }\n                }\n                if(a[i] != b[i]) {\n                    done = false;\n                    break;\n                }\n            }\n            for(int i=0;i<n;i++) {\n                if(a[i] != b[i])\n                    done = false;\n            }\n\n            if(!done)\n                println(-1);\n            else {\n                println(total);\n                for(int i=0;i<res.size();i++) {\n                    Node cur = res.get(i);\n                    for(int j=0;j < cur.c;j++) {\n                        println(cur.i + \" \" + cur.j);\n                    }\n                }\n            }\n        }\n    }\n\n    /************************ SOLUTION ENDS HERE ************************/\n\n\n\n    /************************ TEMPLATE STARTS HERE **********************/\n\n    public static void main(String[] args) throws IOException {\n        reader = new BufferedReader(new InputStreamReader(System.in));\n        writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)), false);\n        st = null;\n        solve();\n        reader.close();\n        writer.close();\n    }\n\n    static BufferedReader  reader;\n    static PrintWriter     writer;\n    static StringTokenizer st;\n\n    static String next() {\n        while (st == null || !st.hasMoreTokens()) {\n            try {\n                String line = reader.readLine();\n                if (line == null) {\n                    return null;\n                }\n                st = new StringTokenizer(line);\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n        return st.nextToken();\n    }\n\n    static String nextLine() {\n        String s = null;\n        try {\n            s = reader.readLine();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return s;\n    }\n\n    static int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    static long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    static double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    static char nextChar() {\n        return next().charAt(0);\n    }\n\n    static int[] nextIntArray(int n) {\n        int[] a = new int[n];\n        int i = 0;\n        while (i < n) {\n            a[i++] = nextInt();\n        }\n        return a;\n    }\n\n    static long[] nextLongArray(int n) {\n        long[] a = new long[n];\n        int i = 0;\n        while (i < n) {\n            a[i++] = nextLong();\n        }\n        return a;\n    }\n\n    static int[] nextIntArrayOneBased(int n) {\n        int[] a = new int[n + 1];\n        int i = 1;\n        while (i <= n) {\n            a[i++] = nextInt();\n        }\n        return a;\n    }\n\n    static long[] nextLongArrayOneBased(int n) {\n        long[] a = new long[n + 1];\n        int i = 1;\n        while (i <= n) {\n            a[i++] = nextLong();\n        }\n        return a;\n    }\n\n    static void print(Object o) {\n        writer.print(o);\n    }\n\n    static void println(Object o) {\n        writer.println(o);\n    }\n\n    static void printArr(int[] arr) {\n        for(int i = 0 ; i < arr.length; i++)\n            System.out.print(arr[i] + \" \");\n        System.out.println();\n    }\n\n    /************************ TEMPLATE ENDS HERE ************************/\n}\n", "label": 3}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\n\npublic class _1546_A {\n\n    private static final FastScanner in = new FastScanner();\n    private static final PrintWriter out = new PrintWriter(System.out);\n    private static final PrintWriter err = new PrintWriter(System.err);\n\n    public static void solve() {\n        int n = in.nextInt();\n        int[] a = in.nextIntArray(n);\n        int[] b = in.nextIntArray(n);\n\n        ArrayList<String> steps = new ArrayList<>();\n\n        int sumA = 0;\n        for (int ea : a) {\n            sumA += ea;\n        }\n        int sumB = 0;\n        for (int eb : b) {\n            sumB += eb;\n        }\n        if (sumA != sumB) {\n            out.println(-1);\n            return;\n        }\n\n        for (int i = 0; i < n;) {\n            if (a[i] < b[i]) {\n                for (int j = 0; j < n; j++) {\n                    if (i == j) continue;\n                    if (a[j] > b[j]) {\n                        a[i]++;\n                        a[j]--;\n                        steps.add((j+1) + \" \" + (i+1));\n                        break;\n                    }\n                }\n            } else {\n                i++;\n            }\n        }\n\n        out.println(steps.size());\n        for (String step : steps) {\n            out.println(step);\n        }\n    }\n\n    // Boilerplate\n    public static void main(String[] args) {\n        int t = in.nextInt();\n        while (t-- > 0) {\n            solve();\n        }\n\n        err.close();\n        out.close();\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n\n        StringTokenizer tok = new StringTokenizer(\"\");\n        BufferedReader in;\n\n        FastScanner() {\n            in = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (!tok.hasMoreElements()) {\n                try {\n                    tok = new StringTokenizer(in.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n\n            return tok.nextToken();\n        }\n\n        String nextLine() {\n            String line;\n            try {\n                line = in.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n            return line;\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nextInt();\n            }\n            return arr;\n        }\n\n        List<Integer> nextIntegerList(int n) {\n            ArrayList<Integer> list = new ArrayList<>(n);\n            for (int i = 0; i < n; i++) {\n                list.add(nextInt());\n            }\n            return list;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        long[] nextLongArray(int n) {\n            long[] arr = new long[n];\n            for (int i = 0; i < n; i++) {\n                arr[i] = nextLong();\n            }\n            return arr;\n        }\n\n        List<Long> nextLongList(int n) {\n            ArrayList<Long> list = new ArrayList<>(n);\n            for (int i = 0; i < n; i++) {\n                list.add(nextLong());\n            }\n            return list;\n        }\n\n        ArrayList<Integer>[] nextGraph(int n, int m) {\n            @SuppressWarnings(\"unchecked\")\n            ArrayList<Integer>[] adj = (ArrayList<Integer>[]) new ArrayList[n];\n\n            for (int i = 0; i < n; i++) {\n                adj[i] = new ArrayList<>();\n            }\n\n            for (int i = 0; i < m; i++) {\n                int v = nextInt();\n                int t = nextInt();\n                adj[v - 1].add(t - 1);\n                adj[t - 1].add(v - 1);\n            }\n\n            return adj;\n        }\n    }\n}", "label": 3}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n\n    static List<int[]> solve(int n, long[] a, long[] b) {\n        List<int[]> ret = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (a[i] == b[i]) continue;\n            for (int j = i + 1; j < n; j++) {\n                if (i == j) continue;\n                if (a[i] > b[i] && a[j] < b[j]) {\n                    while (a[i] != b[i] && a[i] >= 0 && a[j] != b[j]) {\n                        a[i]--;\n                        a[j]++;\n                        ret.add(new int[]{i + 1, j + 1});\n                    }\n                } else if (a[i] < b[i] && a[j] > b[j]) {\n                    while (a[i] != b[i] && a[j] >= 0 && a[j] != b[j]) {\n                        a[i]++;\n                        a[j]--;\n                        ret.add(new int[]{j + 1, i + 1});\n                    }\n                }\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            if (a[i] != b[i]) {\n                return null;\n            }\n        }\n\n        return ret;\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        StringBuilder out = new StringBuilder();\n        int T = Integer.parseInt(st.nextToken());\n        while (T-- > 0) {\n            int n = Integer.parseInt(br.readLine());\n            long[] a = new long[n];\n            long[] b = new long[n];\n            st = new StringTokenizer(br.readLine());\n            for (int i = 0; i < n; i++) {\n                a[i] = Long.parseLong(st.nextToken());\n            }\n            st = new StringTokenizer(br.readLine());\n            for (int i = 0; i < n; i++) {\n                b[i] = Long.parseLong(st.nextToken());\n            }\n\n            List<int[]> ans = solve(n, a, b);\n            if (ans == null) {\n                out.append(\"-1\").append(\"\\n\");\n            } else {\n                out.append(ans.size()).append(\"\\n\");\n                for (int[] an : ans) {\n                    out.append(an[0]).append(\" \").append(an[1]).append(\"\\n\");\n                }\n            }\n        }\n        System.out.println(out);\n    }\n}", "label": 3}
{"src": "// package CodeForces;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\t\n\tstatic FastScanner fs = new FastScanner();\n\n\tpublic static void main(String[] args) {\n\t\t\n\t\tFastScanner fs = new FastScanner();\n\t\tint test = fs.nextInt();\n\t\twhile(test-->0) {\n\t\t\t\n\t\t\t\n\t\t\t//Code here\n\t\t\t\n\t\t\tint n = fs.nextInt();\n\t\t\tint[] a = new int[n];\n\t\t\tfor(int i=0 ; i<n ; i++) {\n\t\t\t\ta[i] = fs.nextInt();\n\t\t\t}\n\t\t\tint[] b = new int[n];\n\t\t\tfor(int i=0 ; i<n ; i++) {\n\t\t\t\tb[i] = fs.nextInt();\n\t\t\t}\n\t\t\tint[] count = new int[100];\n\t\t\tfor(int i=0 ; i<n ; i++) {\n\t\t\t\tcount[i] += a[i]-b[i];\n\t\t\t}\n\t\t\tint sum=0, c=0;\n\t\t\tfor(int e:count) {\n\t\t\t\tsum += e;\n\t\t\t\tif(e>0) c+=e;\n\t\t\t}\n\t\t\tif(sum==0) {\n\t\t\t\tSystem.out.println(c);\n\t\t\t\twhile(c-->0) {\n\t\t\t\t\tfor(int i=0 ; i<100 ; i++) {\n\t\t\t\t\t\tif(count[i]>0) {\n\t\t\t\t\t\t\tcount[i]--;\n\t\t\t\t\t\t\tSystem.out.print(i+1 + \" \");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor(int i=0 ; i<100 ; i++) {\n\t\t\t\t\t\tif(count[i]<0) {\n\t\t\t\t\t\t\tcount[i]++;\n\t\t\t\t\t\t\tSystem.out.print(i+1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t}else System.out.println(-1);\n\t\t}\n\t}\n\t\n\tpublic static boolean check(int[] a) {\n\t\tfor(int i=0 ; i<a.length ; i++) {\n\t\t\tif(a[i]!=i+1) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\tpublic static int[] readArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0 ; i<n ; i++) {\n\t\t\ta[i] = fs.nextInt();\n\t\t}\n        return a;\n    }\n\t\n\tpublic static void printArray(int[] n){\n        for(int e:n) {\n        \tSystem.out.print(e + \" \");\n        }\n        System.out.println();\n    }\n\t\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tString[] readStringArray(int n) {\n\t\t\tString[] a=new String[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=next();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\t\n\t\n\n}\n", "label": 3}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class A {\n\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO Auto-generated method stub\n\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\tint t = Integer.parseInt(br.readLine());\n\t\t\n\t\twhile(t --> 0) {\n\t\t\t\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\t\n\t\t\tboolean g = true;\n\t\t\tint suma = 0;\n\t\t\tint sumb = 0;\n\t\t\tint[] a = new int[n];\n\t\t\tint[] b = new int[n];\n\t\t\t\n\t\t\tStringTokenizer sta = new StringTokenizer(br.readLine());\n\t\t\tStringTokenizer stb = new StringTokenizer(br.readLine());\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\n\t\t\t\ta[i] = Integer.parseInt(sta.nextToken());\n\t\t\t\tb[i] = Integer.parseInt(stb.nextToken());\n\t\t\t\t\n\t\t\t\tif(a[i] != b[i])\n\t\t\t\t\tg = false;\n\t\t\t\t\n\t\t\t\tsuma += a[i];\n\t\t\t\tsumb += b[i];\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tif(suma != sumb)\n\t\t\t\tSystem.out.println(\"-1\");\n\t\t\telse if(g)\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\telse {\n\t\t\t\t\n\t\t\t\tArrayList<String> moves = new ArrayList<String>();\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\t\t\n\t\t\t\t\tif(a[i] < b[i]) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tint amount = b[i] - a[i];\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int j = i+1; j < n; j++) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(amount == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(a[j] > b[j]) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tint sub = Math.min(amount, a[j]-b[j]);\n\t\t\t\t\t\t\t\tamount -= sub;\n\t\t\t\t\t\t\t\ta[j] -= sub;\n\t\t\t\t\t\t\t\ta[i] += sub;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tfor(int k = 0; k < sub; k++) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tmoves.add((j+1) + \" \" + (i+1));\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}else if(a[i] > b[i]) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tint amount = a[i] - b[i];\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor(int j = i+1; j < n; j++) {\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(amount == 0)\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif(a[j] < b[j]) {\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tint sub = Math.min(amount, b[j]-a[j]);\n\t\t\t\t\t\t\t\tamount -= sub;\n\t\t\t\t\t\t\t\ta[j] += sub;\n\t\t\t\t\t\t\t\ta[i] -= sub;\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tfor(int k = 0; k < sub; k++) {\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tmoves.add((i+1) + \" \" + (j+1));\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tSystem.out.println(moves.size());\n\t\t\t\tmoves.forEach(move -> System.out.println(move));\n\t\t\t\t\n\t\t\t}\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\n}\n", "label": 3}
{"src": "/*package whatever //do not write package name here */\n\nimport java.io.*;\nimport java.util.*;\n\npublic class GFG {\n\tpublic static void main (String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t!=0){\n\t\t    t--;\n\t\t    int n = sc.nextInt();\n\t\t    int a[] = new int[n];\n\t\t    int b [] = new int[n];\n\t\t    int s1=0,s2=0,d=0;\n\t\t    for(int i=0;i<n;i++){a[i]=sc.nextInt();s1+=a[i];}\n\t\t    for(int i=0;i<n;i++){b[i]=sc.nextInt();s2+=b[i];d+=(Math.abs(a[i]-b[i]));}\n\t\t    if(s1==s2){\n\t\t        int j=0;\n\t\t        int i=0;\n\t\t        System.out.println(d/2);\n\t\t        while(i<n && j<n){\n\t\t            if(a[i]>b[i]){\n\t\t                while(j<n && a[j]>=b[j])\n\t\t                j++;\n\t\t                if(i==j)\n\t\t                {j++; continue;}\n\t\t                \n\t\t                int d1= a[i]-b[i]; int d2 = b[j]-a[j];\n\t\t                int d3 = Math.min(d1,d2);\n\t\t                a[i]-=d3;a[j]+=d3;\n\t\t                while(d3!=0){d3--; System.out.println((i+1)+\" \"+(j+1));}\n\t\t                if(d2<d1)\n\t\t                j++;\n\t\t                else i++;\n\t\t            }else i++;\n\t\t        }\n\t\t    }\n\t\t    else System.out.println(\"-1\");\n\t\t}\n\t}\n}", "label": 3}
{"src": "import java.io.*;import java.lang.*;import java.util.*;\n//* --> number of prime numbers less then or equal to x are  -->  x/ln(x)\n//* --> String concatenation using the + operator within a loop should be avoided. Since the String object is immutable, each call for concatenation will\n// result in a new String object being created.\n// THE SIEVE USED HERE WILL RETURN A LIST CONTAINING ALL THE PRIME NUMBERS TILL N\n public class a {static class FastScanner {InputStreamReader is;BufferedReader br;StringTokenizer st;\npublic FastScanner() {is = new InputStreamReader(System.in);br = new BufferedReader(is);}\nString next() throws Exception {while (st == null || !st.hasMoreElements())st = new StringTokenizer(br.readLine());\nreturn st.nextToken();}int nextInt() throws Exception {return Integer.parseInt(next());}long nextLong() throws Exception {\nreturn Long.parseLong(next());}int[] readArray(int num) throws Exception {int arr[]=new int[num];\nfor(int i=0;i<num;i++)arr[i]=nextInt();return arr;}String nextLine() throws Exception {return br.readLine();\n}} public static boolean power_of_two(int a){if((a&(a-1))==0){ return true;}return false;}\nstatic boolean PS(double x){if (x >= 0) {double i= Math.sqrt(x);if(i%1!=0){\nreturn false;}return ((i * i) == x);}return false;}public static int[] ia(int n){int ar[]=new int[n];\nreturn ar;}public static long[] la(int n){long ar[]=new long[n];return ar;}\npublic static void print(int ans,int t){System.out.println(\"Case\"+\" \"+\"#\"+t+\":\"+\" \"+ans);}\nstatic long mod=1000000007;static int max=Integer.MIN_VALUE;static int min=Integer.MAX_VALUE;\npublic static void sort(long[] arr){//because Arrays.sort() uses quicksort which is dumb\n//Collections.sort() uses merge sort\nArrayList<Long> ls = new ArrayList<Long>();for(long x: arr)ls.add(x);Collections.sort(ls);\nfor(int i=0; i < arr.length; i++)arr[i] = ls.get(i);}public static long fciel(long a, long b) {if (a == 0)  return 0;return (a - 1) / b + 1;}\n static boolean[] is_prime = new boolean[1000001];static ArrayList<Integer> list = new ArrayList<>();\nstatic long n = 1000000;public static void sieve() {Arrays.fill(is_prime, true);\nis_prime[0] = is_prime[1] = false;for (int i = 2; i * i <= n; i++) {\nif (is_prime[i]) {for (int j = i * i; j <= n; j += i)is_prime[j] = false;}}for (int i = 2; i <= n; i++) {\nif (is_prime[i]) {list.add(i);}}}\npublic static void main(String args[]) throws java.lang.Exception {\n        FastScanner sc = new FastScanner();\nint t=sc.nextInt();\nwhile(t-->0)\n{\n    int n=sc.nextInt();\n    int a[]=new int[n];\n    int b[]=new int[n];\n    long sum=0;\n    long op=0;\n    for(int i=0;i<n;i++)\n    {\n        a[i]=sc.nextInt();\n    }\n    for(int i=0;i<n;i++)\n    {\n        b[i]=sc.nextInt();\n        sum+=b[i]-a[i];\n        if((a[i]-b[i])>=0)\n        {\n            op+=a[i]-b[i];\n        }\n    }\n    if(sum!=0)\n    {\n        System.out.println(-1);\n        continue;\n    }\n    System.out.println(op);\n    if(op==0)\n    {\n        continue;\n    }\nfor(int i=0;i<n;i++)\n{\n    int dif=a[i]-b[i];\n    for(int j=i+1;j<n;j++)\n    {\n        int dif2=a[j]-b[j];\n        if(dif>0 && dif2<0)\n        {\n            while(dif>0 && dif2<0)\n            {\n                System.out.println((i+1)+\" \"+(j+1));\n                dif--;\n                a[j]++;\n                dif2++;\n            }\n        }\n        else if(dif<0 && dif2>0)\n        {\n            while(dif<0 && dif2>0)\n            {\n                System.out.println((j+1)+\" \"+(i+1));\n                dif++;\n                a[j]--;\n                dif2--;\n            }\n        }\n    }\n        }\n    }\n}\n}", "label": 3}
{"src": "/*==============================================\nAuthor      : Shadman Shariar                 ||\nEmail       : shadman.shariar@northsouth.edu  ||\nUniversity  : North South University (NSU)    ||\nFacebook    : shadman.shahriar.007            ||\n==============================================*/\nimport java.io.*;\nimport java.util.*;\n//import java.math.BigInteger;\n//import java.text.DecimalFormat;\npublic class Main {\npublic static Main obj = new Main();\n//public static FastReader fr = new FastReader();\n//public static Scanner input = new Scanner(System.in);\n//public static PrintWriter pw = new PrintWriter(System.out);\n//public static DecimalFormat df = new DecimalFormat(\".000\");\n//public static BufferedReader br = new BufferedReader\n//(new InputStreamReader(System.in));\npublic static void main(String[] args) throws Exception {\nScanner input = new Scanner (System.in);\n//BigInteger bi1 = new BigInteger(\"000\");\n//StringBuilder sb = new StringBuilder();\n//StringTokenizer str = new StringTokenizer(\"String\",\"Split\");\n\n/** Array List, Linked List, Vector\n *  Stack, Queue, Array Deque, Priority Queue (Max/Min Heap)\n *  Hash Set, Linked Hash Set, Tree Set (BST)\n *  Hash Map, Linked Hash Map, Tree Map (BST) */\n\n//-----------------CODE STARTS FROM HERE------------------//\n\nlong tt = input.nextLong();\n\nfor (long i = 0; i < tt; i++) {\n\t \n\tint n = input.nextInt();\n\t\n\tint[] arr= new int[n];\n\t\n\tint [] brr  = new int [n];\n\t \n\tint sum1 = 0 , sum2 =0 ;\n\t\n\tfor (int j = 0; j < arr.length; j++) {\n\t\t\n\t\tarr[j] = input.nextInt();\n\t\tsum1+=arr[j];\n\t\t\n\t}\n\t\n  \t for (int j = 0; j < brr.length; j++) {\n\t\tbrr[j] = input.nextInt();\n\t\tsum2+=brr[j];\n\t}\n\tif(sum1!=sum2) {\n\t\tSystem.out.println(-1);\n\t}\n\telse {\n\t\t\n\t\tList<Integer> ll = new ArrayList<>();\n\t\n\t   for (int j = 0; j <n; j++) {\n\t\t\n\t\t   if (arr[j]==brr[j])continue;\n\t\t   else {\n\t\t\t   \n\t\t while (arr[j]!=brr[j]) {\n\t\t\n\t\t\t if (arr[j]>brr[j]) {\n\t\t\t for (int j2 = 0; j2 < n; j2++) {\n\t\t\t\tif(j==j2)continue;\n\t\t\t\t if (arr[j2]<brr[j2]) {\n\t\t\t\t\t \n\t\t\t\t\t ll.add(j+1);\n\t\t\t\t\t ll.add(j2+1);\n\t\t\t\t\t arr[j2]++;\n\t\t\t\t\t arr[j]--;\n\t\t\t\t\t break;\n\t\t\t\t }\n\t\t\t\t \n\t\t\t}\n\t\t\t } \n\t\t\t if (arr[j]<brr[j]) {\n\t\t\t\t for (int j2 = 0; j2 < n; j2++) {\n\t\t\t\t\tif(j==j2)continue;\n\t\t\t\t\t if (arr[j2]>brr[j2]) {\n\t\t\t\t\t\t \n\t\t\t\t\t\t ll.add(j2+1);\n\t\t\t\t\t\t ll.add(j+1);\n\t\t\t\t\t\t arr[j2]--;\n\t\t\t\t\t\t arr[j]++;\n\t\t\t\t\t\t break;\n\t\t\t\t\t }\n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t\t }\n\t\t\t \n\t\t }\n\t\t\t   \n\t\t\t   \n\t\t   }\n\t\t   \n\t}\n\t   if(ll.size()==0) {\n\t\t   System.out.println(0);\n\t   }\n\t   else {\n\n\t\n\t\tSystem.out.println(ll.size()/2);\n\t\t\n\t\tfor (int j = 0; j < ll.size(); j+=2) {\n\t\t\t\n\t\t\tSystem.out.println(ll.get(j)+\" \"+ll.get(j+1));\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\t\n\t   }\n\t}\n\t\n\t \n\t\n}\n\n//---------------------CODE ENDS HERE---------------------//\n\n        //pw.close();\n        input.close();\n\t\tSystem.exit(0);\n}\n\n   public static long gcd(long a, long b) {\n\t   if (a == 0)\n\t\t   return b;\n\t   return gcd(b % a, a);\n   }\n\n   public static long lcm(long a, long b) {\n\t   return (a / gcd(a, b)) * b;\n   }\n\n   public static long nCr(long n, long r)\n   {\n       return factorial(n) / (factorial(r) *\n                  factorial(n - r));\n   }\n\n   public static long nPr(long n, long r)\n   {\n    return factorial(n) / factorial(n - r);\n   }\n\n   public static int countsubstring(String str)\n   {\n    int n = str.length();\n    return n * (n + 1) / 2;\n   }\n \n   public static boolean ispalindrome(String str)\n   {\n    int i = 0, j = str.length() - 1;\n    while (i < j) {\n        if (str.charAt(i) != str.charAt(j))\n            return false;\n        i++;\n        j--;\n    }\n    return true;\n   }\n \n   public static boolean perfectsquare(long x)\n   {\n    if (x >= 0) {\n        long sr = (long)(Math.sqrt(x));\n        return ((sr * sr) == x);\n    }\n    return false;\n   }\n \n   public static boolean perfectcube(long N)\n   {\n    int cube; int c = 0;\n    for (int i = 0; i <= N; i++) {\n        cube = i * i * i;\n        if (cube == N) {\n           \n            c=1; break;\n        }\n        else if (cube > N) {\n          \n           c=0 ; break ;\n        }\n    }\n\t  if (c==1)return true;\n\t  else return false;\n   }\n \n  public static int divcount(int n)\n   {\n       boolean hash[] = new boolean[n + 1];\n       Arrays.fill(hash, true);\n       for (int p = 2; p * p < n; p++)\n           if (hash[p] == true)\n               for (int i = p * 2; i < n; i += p)\n                   hash[i] = false;\n       int total = 1;\n       for (int p = 2; p <= n; p++) \n       {\n           if (hash[p])\n           {\n               int count = 0;\n               if (n % p == 0) \n               {\n                   while (n % p == 0) \n                   {\n                       n = n / p;\n                       count++;\n                   }\n                   total = total * (count + 1);\n               }\n           }\n       }\n       return total;\n   }\n   \n public static void printdiv(int n)\n  {\n      for (int i=1; i<=Math.sqrt(n); i++)\n      {\n          if (n%i==0)\n          {\n              if (n/i == i)\n                  System.out.print(\" \"+ i);\n    \n              else\n                  System.out.print(i+\" \" + n/i + \" \" );\n          }\n      }\n  }\n  \n   public static boolean[] sieveOfEratosthenes(int n)\n   {\n    boolean prime[] = new boolean[n + 1];\n    for (int i = 0; i <= n; i++)\n        prime[i] = true;\n \n    for (int p = 2; p * p <= n; p++)\n    {\n        if (prime[p] == true)\n        {\n            for (int i = p * p; i <= n; i += p)\n                prime[i] = false;\n        }\n    }\n    prime[1]=false;\n    return prime;\n   }\n\t\n   public static int removeduplicateelements(int arr[], int n){ \n\t\tArrays.sort(arr);\n        if (n==0 || n==1){  \n            return n;  \n        }  \n        int[] temp = new int[n];  \n        int j = 0;  \n        for (int i=0; i<n-1; i++){  \n            if (arr[i] != arr[i+1]){  \n                temp[j++] = arr[i];  \n            }  \n         }  \n        temp[j++] = arr[n-1];      \n        for (int i=0; i<j; i++){  \n            arr[i] = temp[i];  \n        }  \n        return j;  \n    }  \n\t\n\tpublic static int fibon(int n) {\n \n\t\tif (n <= 1) {\n \n\t\t\treturn n;\n\t\t}\n\t\tint[] array = new int[n + 1];\n\t\tarray[0] = 0;\n\t\tarray[1] = 1;\n\t\tfor (int i = 2; i <= n; i++) {\n\t\t\tarray[i] = array[i - 2] + array[i - 1];\n\t\t}\n \n\t\treturn array[n];\n \n\t}\n \n\tpublic static long sumofdigits(long n) {\n\t\tlong sum = 0;\n \n\t\twhile (n != 0) {\n\t\t\tsum = sum + n % 10;\n\t\t\tn = n / 10;\n\t\t}\n \n\t\treturn sum;\n\t}\n \n\tpublic static int reversedigits(int num) {\n\t\tint rev_num = 0;\n\t\twhile (num > 0) {\n\t\t\trev_num = rev_num * 10 + num % 10;\n\t\t\tnum = num / 10;\n\t\t}\n\t\treturn rev_num;\n\t}\n \n\tpublic static int binarysearch(int arr[], int l, int r, int x) {\n \n\t\tif (r >= l) {\n\t\t\tint mid = l + (r - l) / 2;\n\t\t\tif (arr[mid] == x)\n\t\t\t\treturn mid;\n\t\t\tif (arr[mid] > x)\n\t\t\t\treturn binarysearch(arr, l, mid - 1, x);\n\t\t\treturn binarysearch(arr, mid + 1, r, x);\n\t\t}\n\t\treturn -1;\n\t}\n\n\tpublic static void rangeofprimenumber(int a, int b) {\n\t\tint i, j, flag;\n\t\tfor (i = a; i <= b; i++) {\n\t\t\tif (i == 1 || i == 0)\n\t\t\t\tcontinue;\n\t\t\tflag = 1;\n\t\t\tfor (j = 2; j <= i / 2; ++j) {\n\t\t\t\tif (i % j == 0) {\n\t\t\t\t\tflag = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag == 1)\n\t\t\t\tSystem.out.println(i);\n\t\t}\n\t}\n \n\tpublic static boolean isprime(long n) {\n\t\tif (n <= 1)\n\t\t\treturn false;\n\t\telse if (n == 2)\n\t\t\treturn true;\n\t\telse if (n % 2 == 0)\n\t\t\treturn false;\n\t\tfor (long i = 3; i <= Math.sqrt(n); i += 2) {\n\t\t\tif (n % i == 0)\n\t\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n \n\tpublic static long factorial(long n) {\n\t\treturn (n == 1 || n == 0) ? 1 : n * factorial(n - 1);\n\t}\n \n\tpublic static int[] reversearrayinrange(int arr[], int start, int end) {\n\t\tint temp;\n \n\t\twhile (start < end) {\n\t\t\ttemp = arr[start];\n\t\t\tarr[start] = arr[end];\n\t\t\tarr[end] = temp;\n\t\t\tstart++;\n\t\t\tend--;\n\t\t}\n\t  return arr;\n\t}\n \n    public static class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n \n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}", "label": 3}
{"src": "import javafx.util.Pair;\nimport sun.net.www.content.text.Generic;\n\nimport static java.lang.Double.parseDouble;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Integer.reverse;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.abs;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.System.exit;\nimport static java.util.Comparator.comparingInt;\nimport static java.util.Map.Entry.comparingByValue;\nimport static java.util.stream.Collectors.toMap;\n\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.*;\n\npublic class Solution {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    class Pair implements Comparable<Pair> {\n        int value, i;\n        Pair(int value, int i) {\n            this.value = value;\n            this.i = i;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            return Integer.compare(value, o.value);\n        }\n    }\n\n    int n;\n    Pair a[];\n    boolean test(int ind) {\n        int b[] = new int[n-1], j = 0;\n        for(int i = 0; i < n; i++) if(i != ind) b[j++] = a[i].value;\n        for(int i = 1; i < n - 1; i++) if(b[i] - b[i-1] != b[1] - b[0] || b[i] - b[i-1] != b[n-2] - b[n-3]) return false;\n        return true;\n    }\n\n    void solve() throws Exception {\n        n = nextInt();\n        if(n <= 2) {\n            out.print(1);\n            return;\n        }\n        a = new Pair[n];\n        for(int i = 0; i < n; i++) a[i] = new Pair(nextInt(), i + 1);\n        Arrays.sort(a);\n        for(int i = 1; i < n; i++) if(a[i].value - a[i-1].value != a[1].value - a[0].value || a[i].value - a[i-1].value != a[n-1].value - a[n-2].value) {\n            if(test(i-1)) out.print(a[i-1].i);\n            else if(test(i)) out.print(a[i].i);\n            else if(test(0)) out.print(a[0].i);\n            else if(test(1)) out.print(a[1].i);\n            else if(test(n-1)) out.print(a[n-1].i);\n            else if(test(n-2)) out.print(a[n-2].i);\n            else out.print(-1);\n            return;\n        }\n        out.print(a[0].i);\n    }\n\n    // call it like this: lower_bound(a, x + 1) ( /!\\ + 1 )\n    public static int lower_bound(int[] a, int v) {\n        int low = -1, high = a.length;\n        while (high - low > 1) {\n            int h = high + low >>> 1;\n            if (a[h] >= v) {\n                high = h;\n            } else {\n                low = h;\n            }\n        }\n        return high;\n    }\n\n    private String getFraction(int a, int b) {\n        assert b != 0;\n        String sign = (a > 0 && b > 0) || (a < 0) && (b < 0) ? \"+\" : \"-\";\n        a = abs(a);\n        b = abs(b);\n        int gcd = gcd(a, b);\n        return sign + (a / gcd) + \"/\" + (b / gcd);\n    }\n\n    private int gcd(int a, int b) {\n        while (b > 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    private int lcm(int a, int b) {\n        return a * (b / gcd(a, b));\n    }\n\n    public static int[] radixSort(int[] f) {\n        if (f.length < 100) {\n            Arrays.sort(f);\n            return f;\n        }\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for (int i = 0; i < f.length; i++) b[1 + (f[i] & 0xffff)]++;\n            for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];\n            for (int i = 0; i < f.length; i++) to[b[f[i] & 0xffff]++] = f[i];\n            int[] d = f;\n            f = to;\n            to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for (int i = 0; i < f.length; i++) b[1 + (f[i] >>> 16)]++;\n            for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];\n            for (int i = 0; i < f.length; i++) to[b[f[i] >>> 16]++] = f[i];\n            int[] d = f;\n            f = to;\n            to = d;\n        }\n        return f;\n    }\n\n    public static boolean nextPermutation(int[] a) {\n        int n = a.length;\n        int i;\n        for (i = n - 2; i >= 0 && a[i] >= a[i + 1]; i--) ;\n        if (i == -1)\n            return false;\n        int j;\n        for (j = i + 1; j < n && a[i] < a[j]; j++) ;\n        int d = a[i];\n        a[i] = a[j - 1];\n        a[j - 1] = d;\n        for (int p = i + 1, q = n - 1; p < q; p++, q--) {\n            d = a[p];\n            a[p] = a[q];\n            a[q] = d;\n        }\n        return true;\n    }\n\n    void print(Object x) {\n        out.print(String.valueOf(x));\n        out.flush();\n    }\n\n    void println(Object x) {\n        out.println(String.valueOf(x));\n        out.flush();\n    }\n\n    // for Map with custom key/value, override toString in your custom class\n    void printMap(Map map) {\n        if (map.keySet().size() == 0) return;\n        Object firstValue = map.keySet().iterator().next();\n        if (map.get(firstValue) instanceof Queue || map.get(firstValue) instanceof List) {\n            for (Object key : map.keySet()) {\n                out.print(String.valueOf(key) + \": \");\n                Collection values = (Collection) map.get(key);\n                for (Object value : values) out.print(String.valueOf(value) + \" \");\n                out.println();\n            }\n        } else if (map.get(firstValue).getClass().isArray()) {\n            for (Object key : map.keySet()) {\n                out.print(String.valueOf(key) + \": \");\n                Object[] values = (Object[]) map.get(key);\n                for (Object value : values) out.print(String.valueOf(value) + \" \");\n                out.println();\n            }\n        } else {\n            for (Object key : map.keySet()) {\n                out.println(String.valueOf(key) + \": \" + map.get(key));\n            }\n        }\n    }\n\n    private int[] na(int n) throws IOException {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = nextInt();\n        return a;\n    }\n\n    private long[] nal(int n) throws IOException {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nextLong();\n        return a;\n    }\n\n    int nextInt() throws IOException {\n        return parseInt(next());\n    }\n\n    long nextLong() throws IOException {\n        return parseLong(next());\n    }\n\n    double nextDouble() throws IOException {\n        return parseDouble(next());\n    }\n\n    String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    public static void main(String[] args) throws Exception {\n        try {\n            boolean isLocal = false;\n            if (isLocal) {\n                in = new BufferedReader(new FileReader(\"mr_x.txt\"));\n                out = new PrintWriter(new BufferedWriter(new FileWriter(\"solution.out\")));\n            } else {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(new OutputStreamWriter(System.out));\n            }\n\n            //long lStartTime = System.currentTimeMillis();\n            new Solution().solve();\n            //long lEndTime = System.currentTimeMillis();\n            //out.println(\"Elapsed time in seconds: \" + (double)(lEndTime - lStartTime) / 1000.0);\n            in.close();\n            out.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n}", "label": 5}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n//=============================================================================\n//--------------------------Main-Class---------------------------------\n//=============================================================================\n\npublic class D {\n\n\tprivate static long INF = 2000000000L, M = 1000000007, MM = 998244353;\n\tprivate static int N = 0,removeIndex;\n\tprivate static HashMap<Integer, Integer> map;\n\n\tpublic static void process() throws IOException {\n\n\t\tint n =  sc.nextInt();\n\t\tint arr[] = sc.readArray(n);\n\t\t map = new HashMap<Integer, Integer>();\n\t\tfor(int i=0; i<n;i++) {\n\t\t\tmap.put(arr[i], i+1);\n\t\t}\n\t\t\n\t\truffleSort(arr);\n\t\t\n\t\tif(n <= 3) {\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif(solve(arr,arr[0],(arr[1] - arr[0]))\n\t\t\t\t|| solve(arr,arr[1],(arr[2] - arr[1]))\n\t\t\t\t|| solve(arr,arr[0],(arr[2] - arr[0]))) {\n\t\t\tSystem.out.println(removeIndex);\n\t\t\treturn;\n\t\t}\n\t\tSystem.out.println(-1);\n\n\t}\n\n\tprivate static boolean solve(int[] arr, int start, int d) {\n\t\tint cc = 0;\n\t\tint n = arr.length;\n\t\tint my[] = new int[n-1];\n\t\tmy[0] = start;\n\t\tfor(int i=0; i<n-2; i++) {\n\t\t\tmy[i+1] = my[0] + d*(i+1);\n\t\t}\n\t\tint mm = 0;\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tif(mm<n-1 && arr[i] == my[mm]) {\n\t\t\t\tmm++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcc++;\n\t\t\t\tremoveIndex = map.get(arr[i]);\n\t\t\t}\n\t\t}\n\t\tif(cc == 0) {\n\t\t\tremoveIndex = map.get(arr[n-1]);\n\t\t\treturn true;\n\t\t}\n\t\treturn cc == 1?true:false;\n\t}\n\n\t//=============================================================================\n\t//--------------------------Dheeraj-Bhagchandani---------------------------------\n\t//=============================================================================\n\n\tstatic FastScanner sc;\n\tstatic PrintWriter out;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tboolean oj = true;\n\t\tif (oj) {\n\t\t\tsc = new FastScanner();\n\t\t\tout = new PrintWriter(System.out);\n\t\t} else {\n\t\t\tsc = new FastScanner(100);\n\t\t\tout = new PrintWriter(\"output.txt\");\n\t\t}\n\t\tint t = 1;\n//\t\tt = sc.nextInt();\n\t\twhile (t-- > 0) {\n\t\t\tprocess();\n\t\t}\n\t\tout.flush();\n\t\tout.close();\n\t}\n\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint x, y;\n\n\t\tPair(int x, int y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\treturn Integer.compare(this.x, o.x);\n\t\t}\n\t}\n\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\tstatic void println(Object o) {\n\t\tout.println(o);\n\t}\n\n\tstatic void println() {\n\t\tout.println();\n\t}\n\n\tstatic void print(Object o) {\n\t\tout.print(o);\n\t}\n\n\tstatic void pflush(Object o) {\n\t\tout.println(o);\n\t\tout.flush();\n\t}\n\n\tstatic int ceil(int x, int y) {\n\t\treturn (x % y == 0 ? x / y : (x / y + 1));\n\t}\n\n\tstatic long ceil(long x, long y) {\n\t\treturn (x % y == 0 ? x / y : (x / y + 1));\n\t}\n\n\tstatic int max(int x, int y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic int min(int x, int y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tstatic int abs(int x) {\n\t\treturn Math.abs(x);\n\t}\n\n\tstatic long abs(long x) {\n\t\treturn Math.abs(x);\n\t}\n\n\tstatic int log2(int N) {\n\t\tint result = (int) (Math.log(N) / Math.log(2));\n\t\treturn result;\n\t}\n\n\tstatic long max(long x, long y) {\n\t\treturn Math.max(x, y);\n\t}\n\n\tstatic long min(long x, long y) {\n\t\treturn Math.min(x, y);\n\t}\n\n\tpublic static int gcd(int a, int b) {\n\t\tBigInteger b1 = BigInteger.valueOf(a);\n\t\tBigInteger b2 = BigInteger.valueOf(b);\n\t\tBigInteger gcd = b1.gcd(b2);\n\t\treturn gcd.intValue();\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\tBigInteger b1 = BigInteger.valueOf(a);\n\t\tBigInteger b2 = BigInteger.valueOf(b);\n\t\tBigInteger gcd = b1.gcd(b2);\n\t\treturn gcd.longValue();\n\t}\n\n\t/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\tstatic class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tFastScanner() throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tFastScanner(int a) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(\"input.txt\"));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\n\t\tint[] readArray(int n) throws IOException {\n\t\t\tint[] A = new int[n];\n\t\t\tfor (int i = 0; i != n; i++) {\n\t\t\t\tA[i] = sc.nextInt();\n\t\t\t}\n\t\t\treturn A;\n\t\t}\n\n\t\tlong[] readArrayLong(int n) throws IOException {\n\t\t\tlong[] A = new long[n];\n\t\t\tfor (int i = 0; i != n; i++) {\n\t\t\t\tA[i] = sc.nextLong();\n\t\t\t}\n\t\t\treturn A;\n\t\t}\n\t}\n\n\tstatic void ruffleSort(int[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tint temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n\n\tstatic void ruffleSort(long[] a) {\n\t\tRandom get = new Random();\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = get.nextInt(a.length);\n\t\t\tlong temp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = temp;\n\t\t}\n\t\tArrays.sort(a);\n\t}\n}\n", "label": 5}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author cunbidun\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DExtraElement solver = new DExtraElement();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DExtraElement {\n        private InputReader in;\n        private PrintWriter out;\n        private PrinterUtil printer;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.in = in;\n            this.out = out;\n            this.printer = new PrinterUtil(out);\n\n            int n = in.nextInt();\n            if (n <= 3) {\n                out.println(1);\n                return;\n            }\n            PairII[] a = new PairII[n + 1];\n            for (int i = 1; i <= n; i++) {\n                a[i] = new PairII(in.nextInt(), i);\n            }\n            Arrays.sort(a, 1, n + 1);\n            int tmp = a[3].first - a[2].first;\n            boolean f = false;\n            for (int i = 3; i < n; i++) {\n                if (a[i + 1].first != a[i].first + tmp) {\n                    f = true;\n                    break;\n                }\n            }\n            if (!f) {\n                out.println(a[1].second);\n                return;\n            }\n\n            tmp = a[2].first - a[1].first;\n            f = false;\n            for (int i = 1; i < n - 1; i++) {\n                if (a[i + 1].first != a[i].first + tmp) {\n                    f = true;\n                    break;\n                }\n            }\n            if (!f) {\n                out.println(a[n].second);\n                return;\n            }\n            tmp = (a[n].first - a[1].first) / (n - 2);\n            f = false;\n            int pos = -1;\n            for (int i = 1; i < n; i++) {\n                if (a[i + 1].first != a[i].first + tmp) {\n                    if (pos == -1 && a[i].first + tmp == a[i + 2].first) {\n                        pos = i + 1;\n                    } else {\n                        f = true;\n                        break;\n                    }\n                    i++;\n                }\n            }\n            if (!f) {\n                out.println(a[pos].second);\n                return;\n            }\n\n            out.println(-1);\n\n        }\n\n    }\n\n    static class PairII implements Comparable<PairII> {\n        public int first;\n        public int second;\n\n        public PairII(int first, int second) {\n            this.first = first;\n            this.second = second;\n        }\n\n        public boolean equals(Object o) {\n            if (this == o) {\n                return true;\n            }\n            if (o == null || getClass() != o.getClass()) {\n                return false;\n            }\n\n            PairII pair = (PairII) o;\n\n            return first == pair.first && second == pair.second;\n        }\n\n        public String toString() {\n            return \"(\" + first + \",\" + second + \")\";\n        }\n\n        public int compareTo(PairII o) {\n            int value = Integer.compare(first, o.first);\n            if (value != 0) {\n                return value;\n            }\n            return Integer.compare(second, o.second);\n        }\n\n    }\n\n    static class InputReader extends InputStream {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private static boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n\n    static class PrinterUtil {\n        private PrintWriter out;\n\n        public PrinterUtil(PrintWriter out) {\n            this.out = out;\n        }\n\n    }\n}\n\n", "label": 5}
{"src": "import java.util.*;\n\nimport static java.lang.Math.min;\n\n/**\n * def solve(A, B):\n * H = defaultdict(int)\n * for a in A:\n * H[a] += 1\n * for c in B:\n * H[c] -= 1\n * for cc in H.itervalues():\n * if cc != 0:\n * return False\n * <p>\n * h = [A[0]]\n * i = 0\n * j = 1\n * while i < len(A):\n * if len(h) > 0 and h[0] == B[i]:\n * heapq.heappop(h)\n * else:\n * if len(h) > 0 and h[0] < B[i]:\n * return False\n * while A[j] != B[i]:\n * heapq.heappush(h, A[j])\n * j += 1\n * if len(h) > 0 and h[0] < A[j]:\n * return False\n * j += 1\n * <p>\n * i += 1\n * <p>\n * return True\n */\npublic class Main {\n\n    static int times = 0;\n\n    static boolean check(int[] arr, int i, int j) {\n        for (int k = i + 2; k < j + 1; k++) {\n            if (arr[k] - arr[k - 1] != arr[k - 1] - arr[k - 2]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\n    public static int solution(int[] arr) {\n        int[] copy = Arrays.copyOf(arr, arr.length);\n        Arrays.sort(copy);\n        int res = Integer.MIN_VALUE;\n        if (check(copy, 1, copy.length - 1)) {\n            res = copy[0];\n        }\n        if (res == Integer.MIN_VALUE) {\n            if (check(copy, 0, arr.length - 2)) {\n                res = copy[arr.length - 1];\n            }\n        }\n\n        if (res == Integer.MIN_VALUE) {\n            int end = copy[copy.length - 1];\n            int start = copy[0];\n            if ((end - start) % (arr.length - 2) == 0) {\n                int diff = (end - start) / (arr.length - 2);\n                int prev = copy[0];\n                for (int i = 1; i < copy.length; i++) {\n                    if (copy[i] - prev != diff) {\n                        if (res == Integer.MIN_VALUE) {\n                            res = copy[i];\n                        } else {\n                            res = Integer.MIN_VALUE;\n                            break;\n                        }\n                    } else {\n                        prev = copy[i];\n                    }\n                }\n            }\n            if (check(copy, 0, arr.length - 2)) {\n                res = copy[arr.length - 1];\n            }\n        }\n\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == res) {\n                return i + 1;\n            }\n        }\n        return -1;\n\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int arr[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            arr[i] = scanner.nextInt();\n        }\n        System.out.println(solution(arr));\n\n    }\n}\n\n\n", "label": 5}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class L4 {\n    public static void main(String[] Args) {\n        Scanner scan = new Scanner(System.in);\n        int n = scan.nextInt();\n\n        entry[] arr = new entry[n];\n        for (int i = 0; i < n; i++) {\n            arr[i]=new entry(i,scan.nextInt());\n        }\n        if(n==2){\n            System.out.println(1);\n            return;\n        }\n        Arrays.sort(arr);\n        if(n>5) {\n            HashMap<Long, Integer> diff = new HashMap<>();\n            for (int i = 1; i < n; i++) {\n                long d = arr[i].v - arr[i - 1].v;\n                Integer val = diff.get(d);\n                if (val == null) {\n                    val = 0;\n                }\n                val++;\n                diff.put(d, val);\n            }\n            long md=0;\n            int count=0;\n            for (long d:diff.keySet()) {\n                int val=diff.get(d);\n                if(val>count){\n                    count=val;\n                    md=d;\n                }\n            }\n            if(count<n-1-2){\n                System.out.println(-1);\n                return;\n            }\n            if(count==n-1){\n                System.out.println(arr[0].i+1);\n                return;\n            }\n            for(int i=1;i<n;i++){\n                long d=arr[i].v-arr[i-1].v;\n                if(d!=md){\n                    int flag=0;\n                    for(int j=1;j<n;j++){\n                        long temp=0;\n                        if(j==i) {\n                            j++;\n                            if (j == n) {\n                                break;\n                            }\n                            temp=arr[j].v-arr[j-2].v;\n                        }\n                        else {\n                            temp = arr[j].v - arr[j - 1].v;\n                        }\n                        if(temp!=md){\n                            flag=1;\n                            break;\n                        }\n                    }\n                    if(flag==0){\n                        System.out.println(arr[i].i+1);\n                        return;\n                    }\n                }\n            }\n            int flag=0;\n            for(int i=2;i<n;i++){\n                long d=arr[i].v-arr[i-1].v;\n                if(d!=md){\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0){\n                System.out.println(arr[0].i+1);\n                return;\n            }\n            System.out.println(-1);\n        }\n        else{\n            if(n==3){\n                System.out.println(arr[1].i+1);\n                return;\n            }\n            for(int i=1;i<n-1;i++){\n                long diff=arr[i+1].v-arr[i-1].v;\n                int flag=0;\n                for(int j=1;j<n;j++){\n                    long temp=0;\n                    if(j==i) {\n                        j++;\n                        if (j == n) {\n                            break;\n                        }\n                        temp = arr[j].v - arr[j - 2].v;\n                    }\n                    else {\n                        temp = arr[j].v - arr[j - 1].v;\n                    }\n                    if(temp!=diff){\n                        flag=1;\n                        break;\n                    }\n                }\n                if(flag==0){\n                    System.out.println(arr[i].i+1);\n                    return;\n                }\n            }\n            long diff=arr[2].v-arr[1].v;\n            int flag=0;\n            for(int i=2;i<n;i++){\n                long temp=arr[i].v-arr[i-1].v;\n                if(temp!=diff){\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0){\n                System.out.println(arr[0].i+1);\n                return;\n            }\n            flag=0;\n            diff=arr[1].v-arr[0].v;\n            for(int i=1;i<n-1;i++){\n                long temp=arr[i].v-arr[i-1].v;\n                if(temp!=diff){\n                    flag=1;\n                    break;\n                }\n            }\n            if(flag==0){\n                System.out.println(arr[n-1].i+1);\n                return;\n            }\n            System.out.println(-1);\n        }\n    }\n\n    static class entry implements Comparable<entry> {\n        int i;\n        long v;\n\n        entry(int i, long v) {\n            this.i = i;\n            this.v = v;\n        }\n\n        @Override\n        public int compareTo(entry o) {\n            return (int)(this.v-o.v);\n        }\n    }\n}", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class code2 {\n    private static boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private static Reader in;\n    private static PrintWriter out;\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    private static int min(int... a){int min=a[0]; for(int i:a) min=Math.min(min, i); return min;}\n    private static int max(int... a){int max=a[0]; for(int i:a) max=Math.max(max, i); return max;}\n    private static long min(long... a){long min=a[0]; for(long i:a)min=Math.min(min, i); return min;}\n    private static long max(long... a){long max=a[0]; for(long i:a)max=Math.max(max, i); return max;}\n    private static String strm(String str, long m) {\n        String ans=\"\";\n        while(m>0) {\n            if(m%2==1) ans=ans.concat(str);\n            str=str.concat(str); m>>=1;\n        } return ans;\n    }\n    private static long mod(long a, long mod) {long res = a%mod; return res>=0 ? res : res+mod;}\n    private static int mod(int a, int mod) {int res = a%mod; return res>=0 ? res : res+mod;}\n    private static long modpow(long x, int n, int mod) {\n        long res = 1;\n        for (long p = x; n > 0; n >>= 1, p = mod((mod(p, mod)*mod(p, mod)),  mod)) {\n            if ((n & 1) != 0) res = mod(mod(res, mod) * mod(p, mod), mod);\n        }\n        return res;\n    }\n    private static long gcd(long a, long b) {return b == 0 ? Math.abs(a) : gcd(b, a % b);}\n    private static int gcd(int a, int b) {return b == 0 ? Math.abs(a) : gcd(b, a % b);}\n    private static long gcd(long... a) {long gcd=a[0]; for(long x:a) gcd=gcd(gcd, x); return gcd;}\n    private static int gcd(int... a) {int gcd=a[0]; for(int x:a) gcd=gcd(gcd, x); return gcd;}\n    private static long lcm(long a, long b) {return Math.abs(a / gcd(a, b) * b);}\n    private static class Pair {\n        public int x, y;\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == this) return true;\n            if (!(obj instanceof Pair)) return false;\n            Pair pair = (Pair)obj;\n            return this.x == pair.x && this.y == pair.y;\n        }\n        @Override\n        public String toString() {\n            return (\"(\" + this.x + \",\" + this.y + \")\");\n        }\n        @Override\n        public int hashCode() {\n            return (this.x+\" \"+this.y).hashCode();\n        }\n    }\n    private static class Triplet {\n        public int x, y, z;\n        public Triplet(int x, int y, int z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == this) return true;\n            if (!(obj instanceof Triplet)) return false;\n            Triplet triplet = (Triplet)obj;\n            return this.x == triplet.x && this.y == triplet.y && this.z == triplet.z;\n        }\n        @Override\n        public String toString() {\n            return (\"(\" + this.x + \",\" + this.y + \",\" + this.z + \")\");\n        }\n        @Override\n        public int hashCode() {\n            return (this.x+\" \"+this.y+\" \"+this.z).hashCode();\n        }\n    }\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    static class Reader {\n        private BufferedReader br;\n        private StringTokenizer token;\n        private Reader(FileReader obj) {\n            br = new BufferedReader(obj, 32768);\n            token = null;\n        }\n        private Reader() {\n            br = new BufferedReader(new InputStreamReader(System.in), 32768);\n            token = null;\n        }\n        private String next() {\n            while(token == null || !token.hasMoreTokens()) {\n                try {\n                    token = new StringTokenizer(br.readLine());\n                } catch (Exception e) {e.printStackTrace();}\n            } return token.nextToken();\n        }\n        private String nextLine() {\n            String str=\"\";\n            try {\n                str = br.readLine();\n            } catch (Exception e) {e.printStackTrace();}\n            return str;\n        }\n        private int nextInt() {return Integer.parseInt(next());}\n        private long nextLong() {return Long.parseLong(next());}\n        private double nextDouble() {return Double.parseDouble(next());}\n        private long[] nextLongArr(int n) {\n            long[] arr = new long[n]; for(int i=0; i<n; i++) arr[i] = nextLong(); return arr;\n        }\n        private int[] nextIntArr(int n) {\n            int[] arr = new int[n]; for(int i=0; i<n; i++) arr[i] = nextInt(); return arr;\n        }\n    }\n    ////////////////////////////////////////////////////////////////////////////////////////////////////\n    private static final int mod = 1_000_000_007;\n    private static void solve() throws Exception {\n        int n = in.nextInt();\n        int[][] arr = new int[n+1][2];\n        for (int i=1; i<=n; i++) {arr[i][0] = in.nextInt(); arr[i][1] = i;}\n        if (n == 2 || n == 3) {out.printf(\"%d\\n\", 1); return;}\n        Arrays.sort(arr, 1, n+1, new Comparator<int[]>() {\n            public int compare(int[] o1, int[] o2) {\n                return o1[0]-o2[0];\n            }\n        });\n        int diff=0; boolean flag = true;\n        for (int i=3; i<n; i++) {\n            if (i == 3) diff = arr[4][0] - arr[3][0];\n            else {\n                if (arr[i+1][0] - arr[i][0] != diff) {flag = false; break;}\n            }\n        }\n        if (flag) {\n            if (arr[3][0] - arr[2][0] == diff) {out.printf(\"%d\\n\", arr[1][1]); return;}\n            else if (arr[3][0] - arr[1][0] == diff) {out.printf(\"%d\\n\", arr[2][1]); return;}\n        }\n        flag = true;\n        for (int i=2; i<=n-2; i++) {\n            if (i == 2) diff = arr[i][0]-arr[i-1][0];\n            else {\n                if (arr[i][0]-arr[i-1][0] != diff) {flag = false; break;}\n            }\n        }\n        if (flag) {\n            if (arr[n-1][0]-arr[n-2][0] == diff) {out.printf(\"%d\\n\", arr[n][1]); return;}\n            else if (arr[n][0] - arr[n-2][0] == diff) {out.printf(\"%d\\n\", arr[n-1][1]); return;}\n        }\n        flag = true;\n        int ans = -1;\n        for (int i=1; i<n; i++) {\n            if (i == 1) {\n                diff = arr[2][0]-arr[1][0];\n            } else {\n                if (arr[i+1][0] - arr[i][0] != diff && ans == -1) {\n                    if (arr[i+2][0]-arr[i][0] == diff) {ans = arr[i+1][1]; i++;}\n                    else {out.printf(\"%d\\n\", -1); return;}\n                } else if (arr[i+1][0] - arr[i][0] != diff && ans != -1) {\n                    {out.printf(\"%d\\n\", -1); return;}\n                }\n            }\n        }\n        out.printf(\"%d\\n\", ans);\n    }\n    private static void run() throws Exception\n    {\n        // in = new Reader();\n        // in = new Reader(new FileReader(\"input.txt\"));\n        // out = new PrintWriter(new FileWriter(\"output.txt\"));\n        in = oj ? new Reader() : new Reader(new FileReader(\"/home/raiden/Desktop/input.txt\"));\n        out = new PrintWriter(System.out);\n        long ti = System.currentTimeMillis();\n        solve(); out.flush();\n        if (!oj) System.out.println(\"\\n\"+(System.currentTimeMillis()-ti)+\"ms\");\n    }\n    public static void main(String[] args) throws Exception {run();}\n}", "label": 5}
{"src": "/**\n * BaZ :D\n */\nimport java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\npublic class ACMIND\n{\n    static FastReader scan;\n    static PrintWriter pw;\n    static long MOD = 1_000_000_007;\n    static long INF = 1_000_000_000_000_000_000L;\n    static long inf = 2_000_000_000;\n    public static void main(String[] args) {\n        new Thread(null,null,\"BaZ\",1<<25)\n        {\n            public void run()\n            {\n                try\n                {\n                    solve();\n                }\n                catch(Exception e)\n                {\n                    e.printStackTrace();\n                    System.exit(1);\n                }\n            }\n        }.start();\n    }\n\n    static void solve() throws IOException\n    {\n        scan = new FastReader();\n        pw = new PrintWriter(System.out,true);\n        StringBuilder fast = new StringBuilder();\n        int n = ni();\n        Pair arr[] = new Pair[n];\n        for(int i=0;i<n;++i) {\n            arr[i] = new Pair(ni(), i+1);\n        }\n        Arrays.sort(arr);\n        long pref_d[] = new long[n];\n        long suff_d[] = new long[n];\n        pref_d[0] = Integer.MIN_VALUE;\n        for(int i=1;i<n;++i) {\n            if(i==1) {\n                pref_d[i] = arr[i].x - arr[i-1].x;\n            }\n            else {\n                if(arr[i].x - arr[i-1].x != pref_d[i-1]) {\n                    pref_d[i] = Integer.MIN_VALUE;\n                }\n                else {\n                    pref_d[i] = arr[i].x - arr[i-1].x;\n                }\n            }\n        }\n        suff_d[n-1] = Integer.MAX_VALUE;\n        for(int i=n-2;i>=0;--i) {\n            if(i==n-2) {\n                suff_d[i] = arr[i+1].x - arr[i].x;\n            }\n            else {\n                if(suff_d[i+1] == arr[i+1].x - arr[i].x) {\n                    suff_d[i] = suff_d[i+1];\n                }\n                else {\n                    suff_d[i] = Integer.MAX_VALUE;\n                }\n            }\n        }\n//        pa(\"Arr\", arr);\n//        pa(\"pref_d\", pref_d);\n//        pa(\"suff_d\", suff_d);\n        for(int i=0;i<n;++i) {\n            if(i==0) {\n                if(i+1==n-1 || suff_d[i+1]!=Integer.MAX_VALUE) {\n                    pl(arr[i].y);\n                    System.exit(0);\n                }\n            }\n            else if(i==n-1) {\n                if(i-1==0 || pref_d[i-1]!=Integer.MIN_VALUE) {\n                    pl(arr[i].y);\n                    System.exit(0);\n                }\n            }\n            else {\n                if((i-1 == 0 || pref_d[i-1]==arr[i+1].x - arr[i-1].x) && (i+1==n-1 || suff_d[i+1]==arr[i+1].x - arr[i-1].x)) {\n                    pl(arr[i].y);\n                    System.exit(0);\n                }\n            }\n        }\n        pl(-1);\n        pw.flush();\n        pw.close();\n    }\n    static class Pair implements Comparable<Pair> {\n        int x,y;\n        Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n        public int compareTo(Pair other) {\n            return this.x - other.x;\n        }\n        public String toString() {\n            return \"{\" + x+\",\"+y+\"}\";\n        }\n    }\n    static int ni() throws IOException\n    {\n        return scan.nextInt();\n    }\n    static long nl() throws IOException\n    {\n        return scan.nextLong();\n    }\n    static double nd() throws IOException\n    {\n        return scan.nextDouble();\n    }\n    static void pl()\n    {\n        pw.println();\n    }\n    static void p(Object o)\n    {\n        pw.print(o+\" \");\n    }\n    static void pl(Object o)\n    {\n        pw.println(o);\n    }\n    static void psb(StringBuilder sb)\n    {\n        pw.print(sb);\n    }\n    static void pa(String arrayName, Object arr[])\n    {\n        pl(arrayName+\" : \");\n        for(Object o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, int arr[])\n    {\n        pl(arrayName+\" : \");\n        for(int o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, long arr[])\n    {\n        pl(arrayName+\" : \");\n        for(long o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, double arr[])\n    {\n        pl(arrayName+\" : \");\n        for(double o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, char arr[])\n    {\n        pl(arrayName+\" : \");\n        for(char o : arr)\n            p(o);\n        pl();\n    }\n    static void pa(String listName, List list)\n    {\n        pl(listName+\" : \");\n        for(Object o : list)\n            p(o);\n        pl();\n    }\n    static void pa(String arrayName, Object[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(Object o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, int[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(int o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, long[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(long o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, char[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(char o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static void pa(String arrayName, double[][] arr) {\n        pl(arrayName+\" : \");\n        for(int i=0;i<arr.length;++i) {\n            for(double o : arr[i])\n                p(o);\n            pl();\n        }\n    }\n    static class FastReader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n\n        public FastReader() {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public FastReader(String file_name) throws IOException {\n            din = new DataInputStream(new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n\n        public String readLine() throws IOException {\n            byte[] buf = new byte[1000000];\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') break;\n                buf[cnt++] = (byte) c;\n            }\n            return new String(buf, 0, cnt);\n        }\n\n        public int nextInt() throws IOException {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public long nextLong() throws IOException {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg) return -ret;\n            return ret;\n        }\n\n        public double nextDouble() throws IOException {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ') c = read();\n            boolean neg = (c == '-');\n            if (neg) c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (c == '.') while ((c = read()) >= '0' && c <= '9') ret += (c - '0') / (div *= 10);\n            if (neg) return -ret;\n            return ret;\n        }\n\n        private void fillBuffer() throws IOException {\n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE);\n            if (bytesRead == -1) buffer[0] = -1;\n        }\n\n        private byte read() throws IOException {\n            if (bufferPointer == bytesRead) fillBuffer();\n            return buffer[bufferPointer++];\n        }\n\n        public void close() throws IOException {\n            if (din == null) return;\n            din.close();\n        }\n    }\n}", "label": 5}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.Comparator;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Xinyi Tao\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskDR568D2 solver = new TaskDR568D2();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskDR568D2 {\n        Key[] a;\n        public static Comparator<Key> keyComparator = new Comparator<Key>() {\n\n            public int compare(Key k1, Key k2) {\n\n                //ascending order\n                return k1.v - k2.v;\n\n            }\n\n        };\n\n        public boolean isA(int start, int end) {\n            int d = a[start].v - a[start + 1].v;\n            for (int i = start + 1; i <= end - 1; i++)\n                if (a[i].v - a[i + 1].v != d) return false;\n            return true;\n        }\n\n        public void solve(int testNumber, Scanner in, PrintWriter out) {\n            int n = in.nextInt();\n            if (n < 4) out.println(1);\n            else {\n                a = new Key[n];\n                for (int i = 0; i < n; i++)\n                    a[i] = new Key(in.nextInt(), i);\n                Arrays.sort(a, keyComparator);\n                if (isA(1, n - 1)) out.println(a[0].i + 1);\n                else if (isA(0, n - 2)) out.println(a[n - 1].i + 1);\n                else {\n                    if ((a[n - 1].v - a[0].v) % (n - 2) != 0) out.println(-1);\n                    else {\n                        int d = (a[n - 1].v - a[0].v) / (n - 2);\n                        int j = 0;\n                        while (a[j + 1].v - a[j].v == d) {\n                            j++;\n                        }\n                        int idx = a[j + 1].i + 1;\n                        if (a[j + 2].v - a[j].v != d) {\n                            out.println(-1);\n                            return;\n                        }\n                        j += 2;\n\n                        while (j < n - 1 && a[j + 1].v - a[j].v == d) {\n                            j++;\n                        }\n\n                        if (j < n - 1) out.println(-1);\n                        else out.println(idx);\n                    }\n\n                }\n            }\n\n\n        }\n\n        public class Key {\n            private final int v;\n            private final int i;\n\n            public Key(int v, int i) {\n                this.v = v;\n                this.i = i;\n            }\n\n        }\n\n    }\n}\n\n", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class codeforces {\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader scan = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n        int n = Integer.parseInt(scan.readLine());\n        StringTokenizer st = new StringTokenizer(scan.readLine());\n        int a[] = new int[n];\n        int b[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = Integer.parseInt(st.nextToken());\n            b[i] = a[i];\n        }\n\n        if (n < 4) {\n            System.out.println(1);\n            return;\n        }\n\n        Arrays.sort(a);\n        int ind = 0;\n        int step = -1;\n        for (int i = 1; i < n - 1; i++) {\n            if (i == 1) {\n                step = a[i + 1] - a[i];\n                continue;\n            }\n            if (step != a[i + 1] - a[i]) {\n                ind = -1;\n                break;\n            }\n        }\n\n        if (ind != -1) {\n            int ans = -1;\n            for (int i = 0; i < n; i++) {\n                if (b[i] == a[ind]) {\n                    ans = i + 1;\n                    break;\n                }\n            }\n            System.out.println(ans);\n            return;\n        }\n\n        ind = n - 1;\n        step = 0;\n        for (int i = 1; i < n - 1; i++) {\n            if (i == 1) {\n                step = a[i] - a[i - 1];\n                continue;\n            }\n            if (step != a[i] - a[i - 1]) {\n                ind = -1;\n                break;\n            }\n        }\n\n        if (ind != -1) {\n            int ans = -1;\n            for (int i = 0; i < n; i++) {\n                if (b[i] == a[ind]) {\n                    ans = i + 1;\n                    break;\n                }\n            }\n            System.out.println(ans);\n            return;\n        }\n\n\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        for (int i = 1; i < n; i++) {\n            int x = a[i] - a[i - 1];\n            map.put(x, map.getOrDefault(x, 0) + 1);\n        }\n\n        if (map.size() == 1 || map.size() > 3) {\n            System.out.println(-1);\n            return;\n        }\n\n\n        for (int k : map.keySet()) {\n            int tr = -1;\n            for (int i = 1; i < n - 1; i++) {\n                if (a[i] - a[i - 1] == k) {\n                    tr = i;\n                    break;\n                }\n            }\n            boolean ok = true;\n            if (tr == 1) {\n                step = a[2] - a[0];\n            } else {\n                step = a[1] - a[0];\n            }\n            for (int i = 1; i < n; i++) {\n                if (i == tr) {\n                    continue;\n                } else if(i + 1 == tr) {\n                    if (step != a[i + 2] - a[i]) {\n                        ok = false;\n                        break;\n                    }\n                } else if(i - 1 == tr) {\n                    if (step != a[i] - a[i - 2]) {\n                        ok = false;\n                        break;\n                    }\n                } else {\n                    if (a[i] - a[i - 1] != step) {\n                        ok = false;\n                        break;\n                    }\n                }\n            }\n\n            if (ok) {\n                int ans = -1;\n                for (int i = 0; i < n; i++) {\n                    if (a[tr] == b[i]) {\n                        ans = i + 1;\n                        break;\n                    }\n                }\n                System.out.println(ans);\n                return;\n            }\n        }\n\n        System.out.println(-1);\n    }\n}", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class D_ExtraElement {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader inp = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Solver solver = new Solver();\n        solver.solve(inp, out);\n        out.close();\n    }\n\n    private static class Solver {\n        private void solve(InputReader inp, PrintWriter out) {\n            int n = inp.nextInt();\n            if (n <= 3) {\n                out.print(1);\n                return;\n            }\n\n            ArrayList<Pair> a = new ArrayList<>();\n            for (int i = 0; i < n; i++) a.add(new Pair(inp.nextInt(), i+1));\n            Collections.sort(a);\n\n            int[] diffs = new int[] {a.get(1).a - a.get(0).a, a.get(3).a - a.get(2).a};\n            for (int diff: diffs) {\n                // start at i = 0\n                boolean pos = true;\n                int skip = -1;\n                int prev = a.get(0).a;\n                for (int i = 1; i < n; i++) {\n                    if (a.get(i).a - prev != diff) {\n                        if (skip != -1) pos = false;\n                        else skip = a.get(i).b;\n                    } else prev = a.get(i).a;\n                }\n                if (pos) {\n                    out.println((skip == -1) ? a.get(0).b : skip);\n                    return;\n                }\n\n                // skip i = 0\n                pos = true;\n                for (int i = 2; i < n; i++) {\n                    if (a.get(i).a - a.get(i-1).a != diff) pos = false;\n                }\n                if (pos) {\n                    out.println(a.get(0).b);\n                    return;\n                }\n            }\n            out.print(-1);\n        }\n\n        class Pair implements Comparable<Pair> {\n            int a, b;\n            Pair (int a, int b) {\n                this.a = a;\n                this.b = b;\n            }\n\n            public int compareTo(Pair o) {\n                return Integer.compare(this.a, o.a);\n            }\n        }\n    }\n\n    static class InputReader {\n        BufferedReader reader;\n        StringTokenizer tokenizer;\n\n        InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "label": 5}
{"src": "\n\nimport java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader sc = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        solver.solve(1, sc, out);\n        out.close();\n    }\n\n    static class Task {\n        public void solve(int testNumber, InputReader sc, PrintWriter out) {\n            int n=sc.nextInt();\n            Node[] buf=new Node[n];\n            \n            for(int i=0;i<n;i++) {\n            \tint x=sc.nextInt();\n            \tbuf[i]=new Node(i+1,x);\n            }\n            Arrays.sort(buf);\n            if(n<=3) {\n            \tout.println(\"1\");\n            \treturn ;\n            }\n            HashMap<Long,Integer> map=new HashMap<Long,Integer>();\n            for(int i=1;i<n;i++) {\n            \tlong c=buf[i].val-buf[i-1].val;\n            \tif(!map.containsKey(c))\n            \t\tmap.put(c, 1);\n            \telse\n            \t\tmap.put(c, map.get(c)+1);\n            }\n            long c=buf[1].val-buf[0].val;\n            map.put(c, map.get(c)-1);\n            if(map.get(c)==0)\n            \tmap.remove(c);\n            if(map.size()==1) {\n            \tout.println(buf[0].index);\n            \treturn ;\n            }\n            else {\n            \tif(!map.containsKey(c))\n            \t\tmap.put(c,1);\n            \telse\n            \t\tmap.put(c,map.get(c)+1);\n            }\n            c=buf[n-1].val-buf[n-2].val;\n            map.put(c, map.get(c)-1);\n            if(map.get(c)==0)\n            \tmap.remove(c);\n            if(map.size()==1) {\n            \tout.println(buf[n-1].index);\n            \treturn ;\n            }\n            else {\n            \tif(!map.containsKey(c))\n            \t\tmap.put(c,1);\n            \telse\n            \t\tmap.put(c,map.get(c)+1);\n            }\n            for(int i=1;i<n-1;i++) {\n            \tlong a=buf[i].val-buf[i-1].val;\n            \tlong b=buf[i+1].val-buf[i].val;\n            \tc=buf[i+1].val-buf[i-1].val;\n            \tmap.put(a, map.get(a)-1);\n            \tmap.put(b, map.get(b)-1);\n            \tif(!map.containsKey(c))\n            \t\tmap.put(c,1);\n            \telse\n            \t\tmap.put(c, map.get(c)+1);\n            \tif(map.get(a)==0)\n            \t\tmap.remove(a);\n            \tif(map.containsKey(b)&&map.get(b)==0)\n            \t\tmap.remove(b);\n            \tif(map.size()==1) {\n            \t\tout.println(buf[i].index);\n            \t\treturn ;\n            \t}\n            \telse {\n            \t\tif(!map.containsKey(a)) \n            \t\t\tmap.put(a, 1);\n            \t\telse\n            \t\t\tmap.put(a, map.get(a)+1);\n            \t\tif(!map.containsKey(b)) \n            \t\t\tmap.put(b, 1);\n            \t\telse\n            \t\t\tmap.put(b, map.get(b)+1);\n            \t\tmap.put(c, map.get(c)-1);\n            \t\tif(map.get(c)==0)\n            \t\t\tmap.remove(c);\n            \t}\n            }\n            out.println(\"-1\");\n        }\n    }\n    \n    static class Node implements Comparable<Node>{\n    \tlong val;\n    \tint index;\n    \t\n    \tpublic Node(int index,long val) {\n    \t\tthis.index=index;\n    \t\tthis.val=val;\n    \t}\n\n\t\t@Override\n\t\tpublic int compareTo(Node o) {\n\t\t\tif(this.val<o.val)\n\t\t\t\treturn -1;\n\t\t\telse\n\t\t\t\tif(this.val==o.val)\n\t\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn 1;\n\t\t}\n\n    }\n    \n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n    }\n}\n", "label": 5}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.Charset;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mikit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        DExtraElement solver = new DExtraElement();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DExtraElement {\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            // out.setBoolLabel(LightWriter.BoolLabel.YES_NO_FIRST_UP);\n            int n = in.ints();\n            DExtraElement.Term[] a = new DExtraElement.Term[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = new DExtraElement.Term(i + 1, in.longs());\n            }\n            IntroSort.sort(a, Comparator.comparing(term -> term.value));\n            if (n <= 3) {\n                out.ans(1).ln();\n                return;\n            }\n\n            outer:\n            for (long d : new long[]{a[2].value - a[1].value, a[1].value - a[0].value, a[2].value - a[0].value}) {\n                long last = a[1].value;\n                boolean success = true;\n                for (int i = 2; i < n; i++) {\n                    success &= ((a[i].value - last) == d);\n                    last = a[i].value;\n                }\n                if (success) {\n                    out.ans(a[0].index).ln();\n                    return;\n                }\n\n                int index = -1;\n                last = a[0].value;\n                for (int i = 1; i < n; i++) {\n                    if (d != a[i].value - last) {\n                        if (index == -1) {\n                            index = a[i].index;\n                        } else {\n                            continue outer;\n                        }\n                    } else {\n                        last = a[i].value;\n                    }\n                }\n                if (index == -1) {\n                    out.ans(a[0].index).ln();\n                } else {\n                    out.ans(index).ln();\n                }\n                return;\n            }\n            out.ans(-1).ln();\n        }\n\n        private static class Term {\n            int index;\n            long value;\n\n            Term(int index, long value) {\n                this.index = index;\n                this.value = value;\n            }\n\n        }\n\n    }\n\n    static interface Verified {\n    }\n\n    static class QuickSort {\n        private QuickSort() {\n        }\n\n        private static <T> void med(T[] a, int low, int x, int y, int z, Comparator<? super T> comparator) {\n            if (comparator.compare(a[z], a[x]) < 0) {\n                ArrayUtil.swap(a, low, x);\n            } else if (comparator.compare(a[y], a[z]) < 0) {\n                ArrayUtil.swap(a, low, y);\n            } else {\n                ArrayUtil.swap(a, low, z);\n            }\n        }\n\n        static <T> int step(T[] a, int low, int high, Comparator<? super T> comparator) {\n            int x = low + 1, y = low + (high - low) / 2, z = high - 1;\n            if (comparator.compare(a[x], a[y]) < 0) {\n                med(a, low, x, y, z, comparator);\n            } else {\n                med(a, low, y, x, z, comparator);\n            }\n\n            int lb = low + 1, ub = high;\n            while (true) {\n                while (comparator.compare(a[lb], a[low]) < 0) {\n                    lb++;\n                }\n                ub--;\n                while (comparator.compare(a[low], a[ub]) < 0) {\n                    ub--;\n                }\n                if (lb >= ub) {\n                    return lb;\n                }\n                ArrayUtil.swap(a, lb, ub);\n                lb++;\n            }\n        }\n\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string());\n        }\n\n        public long longs() {\n            return Long.parseLong(string());\n        }\n\n    }\n\n    static final class ArrayUtil {\n        private ArrayUtil() {\n        }\n\n        public static <T> void swap(T[] a, int x, int y) {\n            T t = a[x];\n            a[x] = a[y];\n            a[y] = t;\n        }\n\n    }\n\n    static class HeapSort {\n        private HeapSort() {\n        }\n\n        private static <T> void heapfy(T[] a, int low, int high, int i, T val, Comparator<? super T> comparator) {\n            int child = 2 * i - low + 1;\n            while (child < high) {\n                if (child + 1 < high && comparator.compare(a[child], a[child + 1]) < 0) {\n                    child++;\n                }\n                if (comparator.compare(val, a[child]) >= 0) {\n                    break;\n                }\n                a[i] = a[child];\n                i = child;\n                child = 2 * i - low + 1;\n            }\n            a[i] = val;\n        }\n\n        static <T> void sort(T[] a, int low, int high, Comparator<T> comparator) {\n            for (int p = (high + low) / 2 - 1; p >= low; p--) {\n                heapfy(a, low, high, p, a[p], comparator);\n            }\n            while (high > low) {\n                high--;\n                T pval = a[high];\n                a[high] = a[low];\n                heapfy(a, low, high, low, pval, comparator);\n            }\n        }\n\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(int i) {\n            return ans(Integer.toString(i));\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n\n    }\n\n    static class IntroSort {\n        private static int INSERTIONSORT_THRESHOLD = 16;\n\n        private IntroSort() {\n        }\n\n        static <T> void sort(T[] a, int low, int high, int maxDepth, Comparator<T> comparator) {\n            while (high - low > INSERTIONSORT_THRESHOLD) {\n                if (maxDepth-- == 0) {\n                    HeapSort.sort(a, low, high, comparator);\n                    return;\n                }\n                int cut = QuickSort.step(a, low, high, comparator);\n                sort(a, cut, high, maxDepth, comparator);\n                high = cut;\n            }\n            InsertionSort.sort(a, low, high, comparator);\n        }\n\n        public static <T> void sort(T[] a, Comparator<T> comparator) {\n            if (a.length <= INSERTIONSORT_THRESHOLD) {\n                InsertionSort.sort(a, 0, a.length, comparator);\n            } else {\n                sort(a, 0, a.length, 2 * BitMath.msb(a.length), comparator);\n            }\n        }\n\n    }\n\n    static class InsertionSort {\n        private InsertionSort() {\n        }\n\n        static <T> void sort(T[] a, int low, int high, Comparator<? super T> comparator) {\n            for (int i = low; i < high; i++) {\n                for (int j = i; j > low && comparator.compare(a[j - 1], a[j]) > 0; j--) {\n                    ArrayUtil.swap(a, j - 1, j);\n                }\n            }\n        }\n\n    }\n\n    static final class BitMath {\n        private BitMath() {\n        }\n\n        public static int count(int v) {\n            v = (v & 0x55555555) + ((v >> 1) & 0x55555555);\n            v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n            v = (v & 0x0f0f0f0f) + ((v >> 4) & 0x0f0f0f0f);\n            v = (v & 0x00ff00ff) + ((v >> 8) & 0x00ff00ff);\n            v = (v & 0x0000ffff) + ((v >> 16) & 0x0000ffff);\n            return v;\n        }\n\n        public static int msb(int v) {\n            if (v == 0) {\n                throw new IllegalArgumentException(\"Bit not found\");\n            }\n            v |= (v >> 1);\n            v |= (v >> 2);\n            v |= (v >> 4);\n            v |= (v >> 8);\n            v |= (v >> 16);\n            return count(v) - 1;\n        }\n\n    }\n}\n\n", "label": 5}
{"src": "import java.util.*;\nimport java.math.*;\nimport java.io.*;\npublic class Solution{\n   \n\n   \n    public static void main(String[] args) throws Exception {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        int n = Integer.parseInt(st.nextToken());\n        long[] a = new long[n];\n        long[] b = new long[n];\n        \n        st = new StringTokenizer(br.readLine());\n        for(int i=0;i<n;i++){\n            a[i] = Long.parseLong(st.nextToken());\n            b[i] = a[i];\n        }\n        Arrays.sort(a);\n        int rep = -1;\n        int ind = 0;\n        for(int i=1;i<n-1;i++){\n            if(a[i]-a[i-1]!=a[i+1]-a[i]){\n                ind = i;\n                break;\n            }\n        }\n        \n        TreeSet<Long> ts = new TreeSet<Long>();\n        for(int i=2;i<n;i++){\n            ts.add(a[i]-a[i-1]);\n        }\n        \n        if(ts.size()<=1) rep = 1;\n        else{\n            \n            ts.clear();\n            for(int i=1;i<n-1;i++){\n                ts.add(a[i]-a[i-1]);\n            }\n            if(ts.size()<=1) rep = n;\n            else{\n                \n                ts.clear();\n                \n                if(ind>1){\n                    \n                    for(int i=1;i<n;i++){\n                        if(i==ind-1){\n                            ts.add(a[i+1]-a[i-1]);\n                            i++;\n                        }\n                        else ts.add(a[i]-a[i-1]);\n                    }\n                    \n                    if(ts.size()<=1) rep = ind;\n                }\n                \n                if(ind<n-2 && rep==-1){\n                    ts.clear();\n                    for(int i=1;i<n;i++){\n                        if(i==ind+1){\n                            ts.add(a[i+1]-a[i-1]);\n                            i++;\n                        }\n                        else ts.add(a[i]-a[i-1]);\n                    }\n                    \n                    if(ts.size()<=1) rep = ind+2;\n                }\n                \n                if(ind!=0 && ind!=n-1 && rep==-1){\n                    ts.clear();\n                    for(int i=1;i<n;i++){\n                        if(i==ind){\n                            ts.add(a[i+1]-a[i-1]);\n                            i++;\n                        }\n                        else ts.add(a[i]-a[i-1]);\n                    }\n                    \n                    if(ts.size()<=1) rep = ind+1;\n                }\n                \n                \n            \n                \n            }\n            \n        }\n        \n        if(rep==-1) System.out.println(rep);\n        else{\n            for(int i=0;i<n;i++){\n                if(b[i]==a[rep-1]){\n                    rep = i+1;\n                    break;\n                }\n            }\n            \n            System.out.println(rep);\n        }\n        \n    }\n    \n}", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\npublic class Ishu\n{\n    static Scanner scan = new Scanner(System.in);\n    static BufferedWriter output = new BufferedWriter(new OutputStreamWriter(System.out)); \n    static void tc() throws Exception\n    {\n    int n = scan.nextInt();\n    int[][] a = new int[n][2];\n    int i;\n    for(i=0;i<n;++i)\n        {\n        a[i][0] = scan.nextInt();\n        a[i][1] = i + 1;\n        }\n    Arrays.sort(a, Comparator.comparingInt(o -> o[0]));\n    int[] prem = new int[n+1];\n    int[] sufm = new int[n+1];\n    int[] preM = new int[n+1];\n    int[] sufM = new int[n+1];\n    int min = Integer.MAX_VALUE;\n    int max = Integer.MIN_VALUE;\n    for(i=1;i<n;++i)\n        {\n        prem[i] = a[i][0] - a[i-1][0];\n        min = Math.min(prem[i], min);\n        prem[i] = min;\n        \n        preM[i] = a[i][0] - a[i-1][0];\n        max = Integer.max(max, preM[i]);\n        preM[i] = max;\n        }\n        \n    min = Integer.MAX_VALUE;\n    max = Integer.MIN_VALUE;\n    for(i=n-2;i>=0;--i)\n        {\n        sufm[i] = a[i][0] - a[i+1][0];\n        min = Math.min(sufm[i], min);\n        sufm[i] = min;\n        \n        sufM[i] = a[i][0] - a[i+1][0];\n        max = Math.max(sufM[i], max);\n        sufM[i] = max; \n        }\n//    for(i=0;i<n;++i)\n//        output.write(prem[i] + \" \");\n//    output.write(\"\\n\");\n//     for(i=0;i<n;++i)\n//        output.write(preM[i] + \" \");\n//    output.write(\"\\n\");\n//     for(i=0;i<n;++i)\n//        output.write(sufm[i] + \" \");\n//    output.write(\"\\n\");\n//     for(i=0;i<n;++i)\n//        output.write(sufM[i] + \" \");\n//    output.write(\"\\n\");\n    int ans = -1;\n    for(i=0;i<n;++i)\n        {\n        if(i == 0)\n            {\n            if(sufm[1] == sufM[1])\n                {\n                ans = a[i][1];\n                break;\n                }\n            }\n        else if(i == n - 1) \n            {\n            if(prem[n-2] == preM[n-2])\n                {\n                ans = a[i][1];\n                break;\n                }\n            }\n        else\n            {\n            if(i == 1)\n                {\n                if(preM[i-1] == prem[i-1] && sufm[i+1] == sufM[i+1] && a[i+1][0] - a[i-1][0] == -1 * sufm[i-1])\n                    {\n                    ans = a[i][1];\n                    break;\n                    }\n                }\n            else if(i == n - 2)\n                {\n                if(preM[i-1] == prem[i-1] && sufm[i+1] == sufM[i+1] && a[i+1][0] - a[i-1][0] == prem[i-1])\n                    {\n                    ans = a[i][1];\n                    break;\n                    }\n                }\n            else\n                {\n                if(preM[i-1] == prem[i-1] && sufm[i+1] == sufM[i+1] && sufm[i+1] == -1 * prem[i-1] && a[i+1][0] - a[i-1][0] == prem[i-1])\n                    {\n                    ans = a[i][1];\n                    break;\n                    }\n                }\n            }\n        }\n    output.write(ans + \"\\n\");\n    output.flush();\n    }\n    public static void main(String[] args) throws Exception\n    {\n    int t = 1;\n    //t = scan.nextInt();\n    while(t-- > 0)\n        tc();\n    }\n}\n", "label": 5}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author KharYusuf\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        FastReader in = new FastReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DExtraElement solver = new DExtraElement();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DExtraElement {\n        public void solve(int testNumber, FastReader s, PrintWriter w) {\n            int n = s.nextInt(), a[][] = new int[n][2], x = -1;\n            if (n == 2) {\n                w.println(1);\n                return;\n            }\n            for (int i = 0; i < n; i++) {\n                a[i][0] = s.nextInt();\n                a[i][1] = i;\n            }\n            func.sortbyColumn(a, 0);\n            int cnt = 0;\n            long c = a[1][0] - a[0][0];\n            for (int i = 2; i < n; i++) {\n                if (a[i][0] != a[0][0] + c * (i - cnt)) {\n                    x = a[i][1];\n                    //w.println(a[i][0]+\" \"+c);\n                    cnt++;\n                }\n            }\n            if (cnt == 0) {\n                w.println(a[0][1] + 1);\n                return;\n            }\n            if (cnt == 1) {\n                w.println(++x);\n                return;\n            }\n            c = a[2][0] - a[0][0];\n            cnt = 0;\n            for (int i = 3; i < n; i++) {\n                if (a[i][0] != a[0][0] + c * (i - 1)) {\n                    cnt++;\n                }\n            }\n            if (cnt == 0) {\n                w.println(a[1][1] + 1);\n                return;\n            }\n            c = a[2][0] - a[1][0];\n            cnt = 0;\n            for (int i = 3; i < n; i++) {\n                if (a[i][0] != a[1][0] + c * (i - 1)) {\n                    cnt++;\n                }\n            }\n            if (cnt == 0) {\n                w.println(a[0][1] + 1);\n                return;\n            }\n            w.println(-1);\n        }\n\n    }\n\n    static class FastReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private FastReader.SpaceCharFilter filter;\n\n        public FastReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n\n            if (numChars == -1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars) {\n\n                curChar = 0;\n\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n\n                if (numChars <= 0)\n                    return -1;\n            }\n\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n\n            int c = read();\n\n            while (isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n\n            if (filter != null)\n                return filter.isSpaceChar(c);\n\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class func {\n        public static void sortbyColumn(int arr[][], final int col) {\n            Arrays.sort(arr, new Comparator<int[]>() {\n\n                public int compare(final int[] entry1, final int[] entry2) {\n                    if (entry1[col] > entry2[col]) return 1;\n                    if (entry1[col] < entry2[col]) return -1;\n                    return 0;\n                }\n            });\n        }\n\n    }\n}\n\n", "label": 5}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.io.FilterInputStream;\nimport java.io.BufferedInputStream;\nimport java.util.Random;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author khokharnikunj8\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        ScanReader in = new ScanReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DExtra solver = new DExtra();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DExtra {\n        public int check(int[][] ar, int index1, int index2, int how_skip, int def) {\n            int diff = ar[index2][0] - ar[index1][0];\n            int prev = ar[index2][0];\n            int count = 0;\n            int index = def;\n            for (int i = index2 + 1; i < ar.length; i++) {\n                if (ar[i][0] == prev + diff) {\n                    prev = ar[i][0];\n                } else {\n                    count++;\n                    index = ar[i][1] + 1;\n                }\n            }\n            if (count > how_skip) {\n                return -1;\n            }\n            return index;\n        }\n\n        public void solve(int testNumber, ScanReader in, PrintWriter out) {\n            int n = in.scanInt();\n            int[][] ar = new int[n][2];\n            for (int i = 0; i < n; i++) {\n                ar[i][0] = in.scanInt();\n                ar[i][1] = i;\n            }\n            Random rd = new Random(Math.abs(new Random().nextInt() * 234324234));\n            for (int i = 0; i < n; i++) {\n                int index = rd.nextInt(n);\n                int[] temp = ar[i];\n                ar[i] = ar[index];\n                ar[index] = temp;\n            }\n            Arrays.sort(ar, new Comparator<int[]>() {\n\n                public int compare(int[] o1, int[] o2) {\n                    if (o1[0] == o2[0]) return o1[1] - o2[1];\n                    return o1[0] - o2[0];\n                }\n            });\n            //taken first\n            if (n <= 3) {\n                out.println(1);\n                return;\n            }\n            int idx1 = check(ar, 0, 1, 1, ar[0][1] + 1);\n            if (idx1 != -1) {\n                out.println(idx1);\n                return;\n            }\n            int idx2 = check(ar, 0, 2, 0, ar[1][1] + 1);\n            if (idx2 != -1) {\n                out.println(idx2);\n                return;\n            }\n            int idx3 = check(ar, 1, 2, 0, ar[0][1] + 1);\n            if (idx3 != -1) {\n                out.println(idx3);\n                return;\n            }\n            out.println(-1);\n\n        }\n\n    }\n\n    static class ScanReader {\n        private byte[] buf = new byte[4 * 1024];\n        private int index;\n        private BufferedInputStream in;\n        private int total;\n\n        public ScanReader(InputStream inputStream) {\n            in = new BufferedInputStream(inputStream);\n        }\n\n        private int scan() {\n            if (index >= total) {\n                index = 0;\n                try {\n                    total = in.read(buf);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                if (total <= 0) return -1;\n            }\n            return buf[index++];\n        }\n\n        public int scanInt() {\n            int integer = 0;\n            int n = scan();\n            while (isWhiteSpace(n)) n = scan();\n            int neg = 1;\n            if (n == '-') {\n                neg = -1;\n                n = scan();\n            }\n            while (!isWhiteSpace(n)) {\n                if (n >= '0' && n <= '9') {\n                    integer *= 10;\n                    integer += n - '0';\n                    n = scan();\n                }\n            }\n            return neg * integer;\n        }\n\n        private boolean isWhiteSpace(int n) {\n            if (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1) return true;\n            else return false;\n        }\n\n    }\n}\n\n", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\npublic class ExtraElement {\n\tstatic HashMap<Integer,Integer> multi;\n\tpublic static void main(String[] args) throws IOException{\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint N = Integer.parseInt(br.readLine());\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tPair[] arr = new Pair[N];\n\t\tfor(int i = 1; i <= N; ++i) {\n\t\t\tint cur = Integer.parseInt(st.nextToken());\n\t\t\tarr[i-1] = new Pair(cur,i);\n\t\t}\n\t\tArrays.sort(arr);\n\t\tmulti = new HashMap<Integer,Integer>();\n\t\tfor(int i = 1; i < N; ++i) {\n\t\t\tPair a = arr[i], b = arr[i-1];\n\t\t\tint c = a.a-b.a;\n\t\t\tif(multi.containsKey(c)) {\n\t\t\t\tmulti.replace(c, multi.get(c)+1);\n\t\t\t}else {\n\t\t\t\tmulti.put(c, 1);\n\t\t\t}\n\t\t}\n\t\tif(multi.size()==1) {\n\t\t\tSystem.out.println(arr[0].b);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < N; ++i) {\n\t\t\tint add1 = -1, rem1 = -1, rem2 = -1;\n\t\t\tif(i==0) {\n\t\t\t\tPair a = arr[i], b = arr[i+1];\n\t\t\t\trem1 = b.a-a.a;\n\t\t\t\tremove(rem1);\n\t\t\t\tif(multi.size()==1) {\n\t\t\t\t\tSystem.out.println(arr[i].b);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}else if(i==N-1) {\n\t\t\t\tPair a = arr[i], b = arr[i-1];\n\t\t\t\trem1 = a.a-b.a;\n\t\t\t\tremove(rem1);\n\t\t\t\tif(multi.size()==1) {\n\t\t\t\t\tSystem.out.println(arr[i].b);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tPair les = arr[i-1], mor = arr[i+1], cur = arr[i];\n\t\t\t\trem1 = cur.a-les.a; rem2 = mor.a-cur.a; add1 = mor.a-les.a;\n\t\t\t\tremove(rem1); remove(rem2); add(add1);\n\t\t\t\tif(multi.size()==1) {\n\t\t\t\t\tSystem.out.println(arr[i].b);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(add1 != -1) {\n\t\t\t\tremove(add1);\n\t\t\t}\n\t\t\tif(rem1 != -1) {\n\t\t\t\tadd(rem1);\n\t\t\t}\n\t\t\tif(rem2 != -1) {\n\t\t\t\tadd(rem2);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"-1\");\n\t}\n\tprivate static void add(int add1) {\n\t\t// TODO Auto-generated method stub\n\t\tif(multi.containsKey(add1)) {\n\t\t\tmulti.replace(add1,multi.get(add1)+1);\n\t\t}else {\n\t\t\tmulti.put(add1, 1);\n\t\t}\n\t}\n\tprivate static void remove(int rem1) {\n\t\t// TODO Auto-generated method stub\n\t\tmulti.replace(rem1, multi.get(rem1)-1);\n\t\tif(multi.get(rem1)==0) {\n\t\t\tmulti.remove(rem1);\n\t\t}\n\t}\n\t\n\tpublic static class Pair implements Comparable<Pair> {\n\t\tint a, b;\n\t\tpublic Pair(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(ExtraElement.Pair o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn a-o.a;\n\t\t}\n\t}\n}\n", "label": 5}
{"src": "import java.io.*;\nimport java.lang.*;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.BufferedReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.IOException;\nimport java.util.*;\nimport java.math.BigInteger;\n\npublic class Rating1700_1185D {\n    //code written by a living bruh moment\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        Task solver = new Task();\n        int t = 1;\n        for(int tt = 1; tt<=t; tt++) solver.solve(tt,in,out);\n        out.close();\n    }\n    static class Task{\n\n        public void solve(int tt, InputReader in, PrintWriter out){\n             int n = in.nextInt();\n            int[] a = new int[n];\n            HashMap<Integer, Integer> hm = new HashMap<>();\n            for(int i = 0; i<n; i++){\n                a[i] = in.nextInt();\n                hm.put(i+1,a[i]);\n            }\n            sort(a);\n            if(n<=3) out.println(1);\n            else{\n                int ans = (int)-1e9-1;\n                for(int i = 0; i<2; i++){\n                    int diff = 0;\n                    if(i==0) diff = a[2]-a[1];\n                    else diff = a[2]-a[0];\n                    boolean check = true;\n                    int prev = a[2];\n                    for(int j = 3; j<n; j++){\n                        if(a[j]-prev==diff){\n                            prev = a[j];\n                        }\n                        else{\n                            check = false;\n                            break;\n                        }\n                    }\n                    if(check){\n                        ans = a[i];\n                        break;\n                    }\n                }\n                if(ans==(int)-1e9-1){\n                    int diff = a[1] - a[0];\n                    int prev = a[1];\n                    boolean check = true;\n                    int temp = (int)-1e9-1;\n                    for(int i = 2; i<n; i++){\n                        if(a[i]-prev==diff) prev = a[i];\n                        else{\n                            if(temp==(int)-1e9-1) temp = a[i];\n                            else{\n                                check = false;\n                                break;\n                            }\n                        }\n                    }\n                    if(check) ans = temp;\n                }\n                if(ans!=(int)-1e9-1){\n                    for(Map.Entry<Integer,Integer> e : hm.entrySet()){\n                        if(e.getValue()==ans){\n                            out.println(e.getKey());\n                            return;\n                        }\n                    }\n                }\n                out.println(-1);\n            }\n        }\n    }\n    static void sort(int[] x){\n\t\tshuffle(x);\n\t\tArrays.sort(x);\n\t}\n\tstatic void sort(long[] x){\n\t\tshuffle(x);\n\t\tArrays.sort(x);\n\t}\n\tstatic void shuffle(int[] a) {\n\t    Random get = new Random();\n\t    for (int i = 0; i < a.length; i++) {\n\t        int r = get.nextInt(a.length);\n\t        int temp = a[i];\n\t        a[i] = a[r];\n\t        a[r] = temp;\n\t    }\n\t}\n\tstatic void shuffle(long[] a) {\n\t    Random get = new Random();\n\t    for (int i = 0; i < a.length; i++) {\n\t        int r = get.nextInt(a.length);\n\t        long temp = a[i];\n\t        a[i] = a[r];\n\t        a[r] = temp;\n\t    }\n\t}\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            try {\n                return reader.readLine();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n\n        public boolean hasNext() {\n            String next = null;\n            try {\n                next = reader.readLine();\n            } catch (Exception e) {\n            }\n            if (next == null) {\n                return false;\n            }\n            tokenizer = new StringTokenizer(next);\n            return true;\n        }\n\n        public BigInteger nextBigInteger() {\n            return new BigInteger(next());\n        }\n    }\n}", "label": 5}
{"src": "import java.util.*;\n\n// Key point is to find a truth, what is the right delta\n// a smallest set is 4 items.\npublic class E1185D1 {\n\n    static int[] b_i;\n\n    private static void print_r(int ans) {\n        System.out.println(ans);\n        System.exit(0);\n    }\n\n    private static int find_index(int v) {\n        int j;\n        for (j = 0; j < b_i.length; j++) {\n            if (b_i[j] == v) {\n                return j + 1;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String args[]) {\n\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        b_i = new int[n];\n        int[] b_b = new int[n]; // back up of inputs, to find index when finding offending item\n\n        for (int i = 0; i < n; i++) {\n            b_i[i] = sc.nextInt();\n            b_b[i] = b_i[i];\n        }\n\n        Arrays.sort(b_b); // sort first\n\n        // java.lang.ArrayIndexOutOfBoundsException: 2\n\t// at E1185D1.main(E1185D1.java:32)\n        if (n <= 3)\n            print_r(1);\n        \n        // Assume b_b[0] is the cause\n        int i;\n        int delta = b_b[2] - b_b[1];\n        for (i = 1; i < n - 1 && (b_b[i + 1] - b_b[i] == delta); i++) {\n        }\n\n        if (i >= n - 1) {\n            System.out.println(find_index(b_b[0])); //Wrong answer on test 10\n            System.exit(0);\n\n        }\n\n        // Assume b_b[1] is the cause\n        delta = b_b[2] - b_b[0];\n        for (i = 2; i < n - 1 && (b_b[i + 1] - b_b[i] == delta); i++) {\n        }\n\n        if (i >= n - 1) {\n            System.out.println(find_index(b_b[1]));\n            System.exit(0);\n\n        }\n\n        delta = b_b[1] - b_b[0];\n        int bad_num_i = -1;\n        for (i = 1; i < n - 1; i++) {\n            if (b_b[i + 1] - b_b[i] != delta) {\n                if (bad_num_i != -1) {\n                    System.out.println(-1);\n                    System.exit(0);\n                }\n                bad_num_i = i + 1;\n                if (i + 2 <= n-1 && b_b[i+2] - b_b[i] != delta) {\n                    System.out.println(-1);\n                    System.exit(0);                    \n                }\n                i++;\n            }\n        }\n\n        if (bad_num_i != -1) {\n            int j;\n            for (j = 0; j < b_i.length; j++) {\n                if (b_i[j] == b_b[bad_num_i]) {\n                    break;\n                }\n            }\n            System.out.println(j + 1);\n            System.exit(0);\n        }\n\n        print_r(-1); //never reach here, safe net\n    }\n}\n", "label": 5}
{"src": "// Working program using Reader Class \nimport java.io.*; \nimport java.io.FileInputStream; \nimport java.io.IOException; \nimport java.io.InputStreamReader;\nimport java.math.BigInteger;\nimport java.util.*; \n\npublic class Main \n{ \n\tstatic class Reader \n\t{ \n\t\tfinal private int BUFFER_SIZE = 1 << 16; \n\t\tprivate DataInputStream din; \n\t\tprivate byte[] buffer; \n\t\tprivate int bufferPointer, bytesRead; \n\n\t\tpublic Reader() \n\t\t{ \n\t\t\tdin = new DataInputStream(System.in); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\n\t\tpublic Reader(String file_name) throws IOException \n\t\t{ \n\t\t\tdin = new DataInputStream(new FileInputStream(file_name)); \n\t\t\tbuffer = new byte[BUFFER_SIZE]; \n\t\t\tbufferPointer = bytesRead = 0; \n\t\t} \n\n\t\tpublic String readLine() throws IOException \n\t\t{ \n\t\t\tbyte[] buf = new byte[64]; // line length \n\t\t\tint cnt = 0, c; \n\t\t\twhile ((c = read()) != -1) \n\t\t\t{ \n\t\t\t\tif (c == '\\n') \n\t\t\t\t\tbreak; \n\t\t\t\tbuf[cnt++] = (byte) c; \n\t\t\t} \n\t\t\treturn new String(buf, 0, cnt); \n\t\t} \n\n\t\tpublic int nextInt() throws IOException \n\t\t{ \n\t\t\tint ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo\n\t\t\t{ \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} while ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic long nextLong() throws IOException \n\t\t{ \n\t\t\tlong ret = 0; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tpublic double nextDouble() throws IOException \n\t\t{ \n\t\t\tdouble ret = 0, div = 1; \n\t\t\tbyte c = read(); \n\t\t\twhile (c <= ' ') \n\t\t\t\tc = read(); \n\t\t\tboolean neg = (c == '-'); \n\t\t\tif (neg) \n\t\t\t\tc = read(); \n\n\t\t\tdo { \n\t\t\t\tret = ret * 10 + c - '0'; \n\t\t\t} \n\t\t\twhile ((c = read()) >= '0' && c <= '9'); \n\n\t\t\tif (c == '.') \n\t\t\t{ \n\t\t\t\twhile ((c = read()) >= '0' && c <= '9') \n\t\t\t\t{ \n\t\t\t\t\tret += (c - '0') / (div *= 10); \n\t\t\t\t} \n\t\t\t} \n\n\t\t\tif (neg) \n\t\t\t\treturn -ret; \n\t\t\treturn ret; \n\t\t} \n\n\t\tprivate void fillBuffer() throws IOException \n\t\t{ \n\t\t\tbytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n\t\t\tif (bytesRead == -1) \n\t\t\t\tbuffer[0] = -1; \n\t\t} \n\n\t\tprivate byte read() throws IOException \n\t\t{ \n\t\t\tif (bufferPointer == bytesRead) \n\t\t\t\tfillBuffer(); \n\t\t\treturn buffer[bufferPointer++]; \n\t\t} \n\n\t\tpublic void close() throws IOException \n\t\t{ \n\t\t\tif (din == null) \n\t\t\t\treturn; \n\t\t\tdin.close(); \n\t\t} \n\t} \n\t \n\tpublic static int gcd(int a, int b) \n    { \n        // Everything divides 0  \n        if (a == 0 || b == 0) \n           return 0; \n       \n        // base case \n        if (a == b) \n            return a; \n       \n        // a is greater \n        if (a > b) \n            return gcd(a-b, b); \n        return gcd(a, b-a); \n    }\n\t\n\tpublic static class Node implements Comparable<Node>{\n\t\tlong val,ind;\n\t\tNode(long v,long i){\n\t\t\tval=v;\n\t\t\tind=i;\n\t\t}\n\t\tpublic int compareTo(Node n) {\n\t\t\treturn (int)(this.val-n.val);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException \n\t{ \n\t\t//Reader scan=new Reader(); \n\t\tReader scan=new Reader();\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tint n=scan.nextInt();\n\t\tArrayList<Node> al=new ArrayList<Node>();\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tNode node=new Node(scan.nextLong(),i);\n\t\t\tal.add(node);\n\t\t}\n\t\tCollections.sort(al);\n\t\tHashMap<Long,Long> hm=new HashMap<Long,Long>();\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tlong d=al.get(i).val-al.get(i-1).val;\n\t\t\tif(hm.containsKey(d)) {\n\t\t\t\thm.put(d, hm.get(d)+1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\thm.put(d, 1L);\n\t\t\t}\n\t\t}\n\t\tlong ans=-2;\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif(i==0) {\n\t\t\t\tlong x=al.get(i+1).val-al.get(i).val;\n\t\t\t\thm.put(x, hm.get(x)-1);\n\t\t\t\tif(hm.get(x).equals(0L)) {\n\t\t\t\t\thm.remove(x);\n\t\t\t\t}\n\t\t\t\tif(hm.size()<=1L) {\n\t\t\t\t\tans=al.get(i).ind;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(hm.containsKey(x)) {\n\t\t\t\t\thm.put(x, hm.get(x)+1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thm.put(x, 1L);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(i==n-1) {\n\t\t\t\tlong x=al.get(i).val-al.get(i-1).val;\n\t\t\t\thm.put(x, hm.get(x)-1);\n\t\t\t\tif(hm.get(x).equals(0L)) {\n\t\t\t\t\thm.remove(x);\n\t\t\t\t}\n\t\t\t\tif(hm.size()<=1L) {\n\t\t\t\t\tans=al.get(i).ind;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(hm.containsKey(x)) {\n\t\t\t\t\thm.put(x, hm.get(x)+1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thm.put(x, 1L);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlong x=al.get(i).val-al.get(i-1).val;\n\t\t\t\tlong y=al.get(i+1).val-al.get(i).val;\n\t\t\t\tlong z=y+x;\n\t\t\t\thm.put(x, hm.get(x)-1);\n\t\t\t\tif(hm.get(x).equals(0L)) {\n\t\t\t\t\thm.remove(x);\n\t\t\t\t}\n\t\t\t\thm.put(y, hm.get(y)-1);\n\t\t\t\tif(hm.get(y).equals(0L)) {\n\t\t\t\t\thm.remove(y);\n\t\t\t\t}\n\t\t\t\tif(hm.containsKey(z)) {\n\t\t\t\t\thm.put(z, hm.get(z)+1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thm.put(z, 1L);\n\t\t\t\t}\n\t\t\t\tif(hm.size()<=1L) {\n\t\t\t\t\tans=al.get(i).ind;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(hm.containsKey(x)) {\n\t\t\t\t\thm.put(x, hm.get(x)+1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thm.put(x, 1L);\n\t\t\t\t}\n\t\t\t\tif(hm.containsKey(y)) {\n\t\t\t\t\thm.put(y, hm.get(y)+1);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\thm.put(y, 1L);\n\t\t\t\t}\n\t\t\t\thm.put(z, hm.get(z)-1);\n\t\t\t\tif(hm.get(z).equals(0L)) {\n\t\t\t\t\thm.remove(z);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.print(ans+1);\n\t\tout.close();\n\t} \n}", "label": 5}
{"src": "/*package whatever //do not write package name here */\n\nimport java.io.*;\nimport java.util.*;\npublic class S {\n\tpublic static void main (String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tlong b[]=new long[n];\n\t\tMap<Long,Long> pos=new HashMap<>();\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t    b[i]=in.nextLong();\n\t\t    pos.put(b[i],(long)i+1);\n\t\t}    \n\t\tArrays.sort(b);\n\t\tMap<Long,Long> map=new HashMap<>();\n\t\tfor(int i=0;i<n-1;i++)\n\t\t{\n\t\t    long z=b[i+1]-b[i];\n\t\t    if(!map.containsKey(z))map.put(z,(long)1);\n\t\t    else map.put(z,map.get(z)+1);\n\t\t}\n\t\t//System.out.println(map.size());\n\t\tif(map.size()>3)System.out.print(-1);\n\t\telse if(map.size()==1)\n\t\t{\n\t\t    System.out.print(pos.get(b[0]));\n\t\t}\n\t\telse\n\t\t{\n\t\t    Set<Map.Entry<Long,Long>> set=map.entrySet();\n\t\t    ArrayList<Long> al=new ArrayList<>();\n\t\t    for(Map.Entry<Long,Long> s:set)\n\t\t    {\n\t\t        al.add(s.getKey());\n\t\t    }\n\t\t    long temp=Long.MIN_VALUE;\n\t\t    for(int i=0;i<n;i++)\n\t\t    {\n\t\t        if(i==0)\n\t\t        {\n\t\t            map.put(b[i+1]-b[i],map.get(b[i+1]-b[i])-1);\n\t\t        }\n\t\t        else if(i==n-1)\n\t\t        {\n\t\t            map.put(b[i]-b[i-1],map.get(b[i]-b[i-1])-1);\n\t\t        }\n\t\t        else\n\t\t        {\n\t\t            if(map.containsKey(b[i+1]-b[i-1]))\n\t\t            {\n\t\t                map.put(b[i]-b[i-1],map.get(b[i]-b[i-1])-1);\n\t\t                map.put(b[i+1]-b[i],map.get(b[i+1]-b[i])-1);\n\t\t                map.put(b[i+1]-b[i-1],map.get(b[i+1]-b[i-1])+1);\n\t\t            }\n\t\t            else continue;\n\t\t        }\n\t\t        int count=0;\n\t\t        for(int j=0;j<al.size();j++)\n\t\t        {\n\t\t            if(map.get(al.get(j))!=0)count++;\n\t\t        }\n\t\t        //System.out.println(count);\n\t\t        if(count==1)\n\t\t        {\n\t\t            temp=b[i];\n\t\t            break;\n\t\t        }\n\t\t        else\n\t\t        {\n\t\t            if(i==0)map.put(b[i+1]-b[i],map.get(b[i+1]-b[i])+1);\n\t\t            else if(i==n-1)map.put(b[i]-b[i-1],map.get(b[i]-b[i-1])+1);\n\t\t            else\n\t\t            {\n\t\t                map.put(b[i]-b[i-1],map.get(b[i]-b[i-1])+1);\n\t\t                map.put(b[i+1]-b[i],map.get(b[i+1]-b[i])+1); \n\t\t                map.put(b[i+1]-b[i-1],map.get(b[i+1]-b[i-1])-1);\n\t\t            }\n\t\t        }\n\t\t    }\n\t\t    if(temp==Long.MIN_VALUE)System.out.print(-1);\n\t\t    else System.out.print(pos.get(temp));\n\t\t}\n\t}\n}", "label": 5}
{"src": "import java.util.*;\nimport java.io.*;\n//import java.lang.*;\n\npublic class ranjan{\n\n    //public static Read cin;\n    public static InputReader cin;\n    public static PrintWriter cout;\n    public static boolean[] safe;\n\tpublic static int[][] memo;\n    public static final long bil = (long)1e9+7;\n    public static int fileread = 0; \n    \n    public static void main(String ...arg) throws IOException\n    {\n        /*console writer*/\n        cout = new PrintWriter(new BufferedOutputStream(System.out));\n        /*Debug Reader*/\n        //Scan cin =new Scan();\n        if(fileread == 1)\n        {\n            try\n            {\n            //cin = new Read(new FileInputStream(new File(\"in4.txt\")));\n            cin = new InputReader(new FileInputStream(new File(\"in4.txt\")));\n            }\n            catch (IOException error){}\n        }\n        else{\n            //cin = new Read(System.in);\n            cin = new InputReader(System.in);\n        }\n\n\t\tint n = cin.nextInt();\n        Pair[] arr = new    Pair[n];\n        for(int i=0;i<n;i++) \n            arr[i] = new Pair(cin.nextInt(),i);\n        Arrays.sort(arr,new Comparator<Pair>(){\n            @Override\n            public int compare(Pair x,Pair y)\n            {\n                return x.a - y.a;\n            }\n        });\n        //edges case\n        if(n<=2)\n        {\n            cout.print(1);\n            cout.close();\n            return;\n        }\n        //check if already AP by removing first element\n        int d = arr[2].a - arr[1].a;\n        boolean ap1 = true;\n        for(int i=2;i<n;i++)\n        {\n            if(d != arr[i].a - arr[i-1].a)\n            {\n                ap1 = false;\n                break;\n            }\n        }\n        if(ap1)\n        {\n            cout.print(arr[0].b+1);\n            cout.close();\n            return;\n        }\n        //check if already AP by removing secong element\n        d = arr[2].a - arr[0].a;\n        boolean ap2 = true;\n        for(int i=3;i<n;i++)\n        {\n            if(d != arr[i].a - arr[i-1].a)\n            {\n                ap2 = false;\n                break;\n            }\n        }\n        if(ap2)\n        {\n            cout.print(arr[1].b+1);\n            cout.close();\n            return;\n        }\n        //main body\n        d = arr[1].a - arr[0].a;\n        for(int i=1;i<n;i++)\n        {\n            if(d!= arr[i].a - arr[i-1].a)\n            {\n                boolean ans = ( i+1>=n ||d == arr[i+1].a-arr[i-1].a);\n                for(int j=i+2;j<n;j++)\n                    if(arr[j].a - arr[j-1].a != d)\n                    {\n                        ans = false;\n                        break;   \n                    }\n                cout.print(ans?arr[i].b+1:-1);\n                break;\n            }\n        }\n\t\tcout.close();\n    }\n\n\n\tprivate static class Pair{\n\t\tpublic int a,b;\n\t\tpublic Pair(int a,int b)\n\t\t{\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\t\n\t}\n\n\n    /*public static void seive(int size)\n    {\n        prime[0] = prime[1] = false;\n        int p = 2;\n        while(p*p<= size)\n        {\n            if(prime[p])\n            {\n                for(int i=p*p;i<size;i += p)\n                    prime[i] = false;\n            }\n            p++;\n        }\n    }*/\n\n\n    public static <K, V> V getOrDefault(HashMap<K,V> map, K key, V defaultValue) {\n        return map.containsKey(key) ? map.get(key) : defaultValue;\n    }\n    \n    static void reverseArray(int intArray[], int size) \n    { \n        int i, temp; \n        for (i = 0; i < size / 2; i++) { \n            temp = intArray[i]; \n            intArray[i] = intArray[size - i - 1]; \n            intArray[size - i - 1] = temp; \n        }  \n    } \n\n    public static long mod_pow(long x,long n,long mod) {\n        long res=1;\n        while(n>0) {\n            if((n&1)==1)res=res*x%mod;\n            x=x*x%mod;\n            n>>=1;\n        }\n        return res;\n    }\n    public static int gcd(int n1, int n2) \n    {\n        int r;\n        while (n2 != 0) \n        {\n            r = n1 % n2;\n            n1 = n2;\n            n2 = r;\n        }\n        return n1;\n    }\n \n    /*public static int lcm(int n1, int n2) \n    {\n        int answer = (n1 * n2) / (gcd(n1, n2));\n        return answer;\n    }*/\n\n\n    static class InputReader {\n        final InputStream is;\n        final byte[] buf = new byte[1024];\n        int pos;\n        int size;\n \n        public InputReader(InputStream is) {\n            this.is = is;\n        }\n \n        public int nextInt() {\n            int c = read();\n            while (isWhitespace(c))\n                c = read();\n            int sign = 1;\n            if (c == '-') {\n                sign = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = read();\n            } while (!isWhitespace(c));\n            return res * sign;\n        }\n \n        int read() {\n            if (size == -1)\n                throw new InputMismatchException();\n            if (pos >= size) {\n                pos = 0;\n                try {\n                    size = is.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (size <= 0)\n                    return -1;\n            }\n            return buf[pos++] & 255;\n        }\n \n        static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n \n    }\n\nstatic class RecursionLimiter {\n    public static long maxLevel = 100000L;\n\n    public static void emerge() {\n        if (maxLevel == 0)\n            return;\n        try {\n            throw new IllegalStateException(\"Too deep, emerging\");\n        } catch (IllegalStateException e) {\n            if (e.getStackTrace().length > maxLevel + 1)\n                throw e;\n        }\n    }\n}\n\n\nstatic class Scan {\n        private byte[] buf=new byte[1024];\n        private int index;\n        private InputStream in;\n        private int total;\n        public Scan()\n        {\n            in=System.in;\n        }\n        public int scan()throws IOException\n        {\n            if(total<0)\n            throw new InputMismatchException();\n            if(index>=total)\n            {\n                index=0;\n                total=in.read(buf);\n                if(total<=0)\n                return -1;\n            }\n            return buf[index++];\n        }\n        public int scanInt()throws IOException\n        {\n            int integer=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n))\n            {\n                if(n>='0'&&n<='9')\n                {\n                    integer*=10;\n                    integer+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            return neg*integer;\n        }\n        public double scanDouble()throws IOException\n        {\n            double doub=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n)&&n!='.')\n            {\n                if(n>='0'&&n<='9')\n                {\n                    doub*=10;\n                    doub+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            if(n=='.')\n            {\n                n=scan();\n                double temp=1;\n                while(!isWhiteSpace(n))\n                {\n                    if(n>='0'&&n<='9')\n                    {\n                        temp/=10;\n                        doub+=(n-'0')*temp;\n                        n=scan();\n                    }\n                    else throw new InputMismatchException();\n                }\n            }\n            return doub*neg;\n        }\n        public String scanString()throws IOException\n        {\n            StringBuilder sb=new StringBuilder();\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            while(!isWhiteSpace(n))\n            {\n                sb.append((char)n);\n                n=scan();\n            }\n            return sb.toString();\n        }\n        private boolean isWhiteSpace(int n)\n        {\n            if(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n            return true;\n            return false;\n        }\n    }\n\n}\n\nclass Read\n{\n    private BufferedReader br;\n    private StringTokenizer st;\n\n    public Read(InputStream is)\n    { br = new BufferedReader(new InputStreamReader(is)); }\n\n    String next()\n    {\n        while (st == null || !st.hasMoreElements())\n        {\n            try {st = new StringTokenizer(br.readLine());}\n            catch(IOException e)\n                {e.printStackTrace();}\n        }\n        return st.nextToken();\n    }\n\n    int nextInt()\n    { return Integer.parseInt(next()); }\n\n    long nextLong()\n    { return Long.parseLong(next()); }\n\n    double nextDouble()\n    { return Double.parseDouble(next()); }\n\n    String nextLine()\n    {\n        String str = \"\";\n        try {str = br.readLine();}\n        catch(IOException e)\n            {e.printStackTrace();}\n        return str;\n    }\n}\n\n\n", "label": 5}
{"src": "\nimport java.util.*;\n\npublic class Main {\n\t\n\tpublic static int solve(int[] tmp, int a, int b, int n)\n\t{\n\t\tint cnt = 0;\n\t\tint div = tmp[b] - tmp[a];\n\t\tint now = 2;\n\t\tfor(int i=b+1; i<n; i++)\n\t\t{\n\t\t\tif(tmp[i] == tmp[a] + div * now)\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t\tnow++;\n\t\t\t}\n\t\t}\n\t\treturn cnt;\n\t}\n\t\n\tpublic static int search(int num, int[] b, int n)\n\t{\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tif(b[i] == num)\n\t\t\t{\n\t\t\t\tSystem.out.println(i+1);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\treturn 1;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint n = in.nextInt();\n\t\tint[] b = new int[n];\n\t\tint[] tmp = new int[n];\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tb[i] = in.nextInt();\n\t\t\ttmp[i] = b[i];\n\t\t}\n\t\tArrays.sort(tmp);\n\t\tif(solve(tmp, 0, 1, n)>=n-3)\n\t\t{\n\t\t\tint div = tmp[1] - tmp[0];\n\t\t\tint now = 2;\n\t\t\tint num = (int)2e9;\n\t\t\tfor(int i=2; i<n; i++)\n\t\t\t{\n\t\t\t\tif(tmp[i] == tmp[0] + div*now)\n\t\t\t\t\tnow++;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnum = tmp[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(search(num, b, n)!=0)\n\t\t\t\tsearch(tmp[0], b, n);\n\t\t}\n\t\telse if(solve(tmp, 0, 2, n)==n-3)\n\t\t\tsearch(tmp[1], b, n);\n\t\telse if(solve(tmp, 1, 2, n)==n-3)\n\t\t\tsearch(tmp[0], b, n);\n\t\telse\n\t\t\tSystem.out.println(-1);\n\t\tin.close();\n\t}\n}", "label": 5}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.math.RoundingMode;\nimport java.security.KeyStore.Entry;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.net.ssl.SSLContext;\n\npublic class Main\n{  \n   static long mod=(long)(1e+9 + 7);\n   static int[] sieve;\n   static ArrayList<Integer> primes;\n   static int[] visited;\n\n   static class Pair\n   {\n\t   int index;\n\t   long val;\n\t   \n\t   public Pair(int i,long a)\n\t   {\n\t\t   this.index=i;\n\t\t   this.val=a;\n\t   }\n   }\n   \n   static class comp implements Comparator<Pair>\n\t   {\n\n\t@Override\n\tpublic int compare(Pair a, Pair b)\n\t\t{\n\t\t\t// TODO Auto-generated method stub\n\t\t\tif(a.val<b.val) return -1;\n\t\t\tif(a.val>b.val) return 1;\n\t\t\treturn 0;\n\t\t}\n\t\t   \n\t   }\n   \n   public static void main(String[] args) throws java.lang.Exception\n   {\t  \t\n\t     fast s = new fast();\n\t     PrintWriter out=new PrintWriter(System.out);\n\t     Scanner sc=new Scanner(System.in);\n\t     StringBuilder fans = new StringBuilder();\n       \n         int n=s.nextInt();\n         \n         \n         Pair a[]=new Pair[n];\n         \n         for(int i=0;i<n;i++)\n        \t a[i]=new Pair(i,s.nextLong());       \n         \n\n         if(n==2) {System.out.println(\"1\"); return;}\n         \n         Arrays.sort(a,new comp());\n         \n         long diff_suf[]=new long[n];\n         long diff_pre[]=new long[n];\n         \n         diff_suf[n-1]=a[n-1].val-a[n-2].val;\n         for(int i=n-2;i>=0;i--)\n        \t diff_suf[i]=a[i+1].val-a[i].val;\n          \n         for(int i=1;i<n;i++)\n        \t diff_pre[i]=a[i].val-a[i-1].val;\n         diff_pre[0]=diff_pre[1];\n         \n         int flag_suf[]=new int[n];\n         int flag_pre[]=new int[n];\n         flag_pre[0]=1;\n         flag_suf[n-1]=1;\n         \n         for(int i=1;i<n;i++)\n        \t if(diff_pre[i]==diff_pre[i-1] && flag_pre[i-1]==1)\n        \t\t flag_pre[i]=1;\n        \t else\n        \t\t flag_pre[i]=0;\n         \n         for(int i=n-2;i>=0;i--)\n        \t {\n        \t\t if(diff_suf[i]==diff_suf[i+1] && flag_suf[i+1]==1)\n        \t\t\t flag_suf[i]=1;\n        \t\t else\n        \t\t\t flag_suf[i]=0;\n        \t }\n         \n         int index=-2;\n         \n         for(int i=0;i<n;i++)\n        \t {\n        \t\t if(i==0)\n        \t\t\t {\n        \t\t\t\t if(flag_suf[i+1]==1)\n        \t\t\t\t\t index=a[i].index;\n        \t\t\t }\n        \t\t else if(i==n-1)\n        \t\t\t {\n        \t\t\t\t if(flag_pre[i-1]==1)\n        \t\t\t\t\t index=a[i].index;\n        \t\t\t }\n        \t\t else if(i==1)\n        \t\t\t {\n        \t\t\t\t long val=a[i+1].val-a[i-1].val;\n        \t\t\t\t if(flag_suf[i+1]==1 && val==diff_suf[i+1])\n        \t\t\t\t\t index=a[i].index; \n        \t\t\t }\n        \t\t else if(i==n-2)\n        \t\t\t {\n        \t\t\t\t long val=a[i+1].val-a[i-1].val;\n        \t\t\t\t if(flag_pre[i-1]==1 && val==diff_pre[i-1])\n        \t\t\t\t\t index=a[i].index;\n        \t\t\t }\n        \t\t else\n        \t\t\t {\n        \t\t\t\t long val=a[i+1].val-a[i-1].val;\n        \t\t\t\t if(flag_suf[i+1]==1 && flag_pre[i-1]==1 && val==diff_suf[i+1] && val==diff_pre[i-1])\n        \t\t\t\t\t index=a[i].index;\n        \t\t\t }\n        \t }\n         \n         System.out.println(index+1);\n   }\n\nstatic class fast {   \n\tprivate InputStream i;\n\t\tprivate byte[]  buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\t\t\n\t\t//Return floor log2n\n\t\tpublic static long log2(long bits) // returns 0 for bits=0\n\t\t\t{\n\t\t\t    int log = 0;\n\t\t\t    if( ( bits & 0xffff0000 ) != 0 ) { bits >>>= 16; log = 16; }\n\t\t\t    if( bits >= 256 ) { bits >>>= 8; log += 8; }\n\t\t\t    if( bits >= 16  ) { bits >>>= 4; log += 4; }\n\t\t\t    if( bits >= 4   ) { bits >>>= 2; log += 2; }\n\t\t\t    return log + ( bits >>> 1 );\n\t\t\t}\n\t\t\n\t\tpublic static boolean next_permutation(int a[])\n\t\t   {\n\t\t\t   int i=0,j=0;int index=-1;\t   \n\t\t\t   int n=a.length;\n\t\t\t   \n\t\t\t   for(i=0;i<n-1;i++)\n\t\t\t\t   if(a[i]<a[i+1]) index=i;\n\t\t\t   \n\t\t\t   if(index==-1) return false;\n\t\t\t   i=index;\n\n\t\t\t  \n\t\t\t   for(j=i+1;j<n && a[i]<a[j];j++);\n\n\t\t\t   int temp=a[i];\n\t\t\t   a[i]=a[j-1];\n\t\t\t   a[j-1]=temp;\n\t\t\t   \t   \n\t\t\t   for(int p=i+1,q=n-1;p<q;p++,q--)\n\t\t\t   {\n\t\t\t\t   temp=a[p];\n\t\t\t\t   a[p]=a[q];\n\t\t\t\t   a[q]=temp;\n\t\t\t   }\n\t\t\t   \n\t\t\t   return true;\n\t\t   }\n\t\t   \n\t\t   \n\t\tpublic static void division(char ch[],int divisor)\n\t\t   {\n\t\t\t   int div=Character.getNumericValue(ch[0]); int mul=10;int remainder=0;\n\t\t\t   StringBuilder quotient=new StringBuilder(\"\");\n\t\t\t   for(int i=1;i<ch.length;i++)\n\t\t\t   {\n\t\t\t\t   div=div*mul+Character.getNumericValue(ch[i]);\t\n\t\t\t\t   if(div<divisor) {quotient.append(\"0\");continue;}\n\t\t\t\t   quotient.append(div/divisor);\n\t\t\t\t   div=div%divisor;mul=10;\n\t\t\t\t   \n\t\t\t   } \n\t\t\t   remainder=div;\n\t\t\t   while(quotient.charAt(0)=='0')quotient.deleteCharAt(0);\t   \n\t\t\t   System.out.println(quotient+\" \"+remainder);\t  \n\t\t   }\n\t\t\n\t\tpublic static void sieve(int size)\n\t\t{\n\t\t\tsieve=new int[size+1];\n\t\t\t\n\t\t\tprimes=new ArrayList<Integer>();\n\t\t\t\n\t\t\tsieve[1]=1;\n\t\t\t\n\t\t\tfor(int i=2;i<=Math.sqrt(size);i++)\n\t\t\t{\n\t\t\t\tif(sieve[i]==0)\n\t\t\t\t {\n\t\t\t\t\tfor(int j=i*i;j<size;j+=i) {sieve[j]=1;}\n\t\t\t\t }\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=2;i<=size;i++)\n\t\t\t{\n\t\t\t\tif(sieve[i]==0) primes.add(i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tpublic static long pow(long n, long b, long MOD)\n\t\t   {\n\t\t       long x=1;long y=n; \n\t\t       while(b > 0)\n\t\t       {\n\t\t           if(b%2 == 1)\n\t\t           {\n\t\t               x=x*y;\n\t\t               if(x>MOD) x=x%(MOD);\n\t\t           }\n\t\t           y = y*y;\n\t\t           if(y>MOD) y=y%(MOD); \n\t\t           b >>= 1;\n\t\t       }\n\t\t       return x;\n\t\t   }\n\n\n\t\tpublic static long mod_inv(long n,long mod)\n\t\t{\n\t\t\treturn pow(n,mod-2,mod);\n\t\t}\n\t\t\n\t\t public static int upper(long[] a,int length,long key)\n\t\t {\n\t\t\t    int low = 0;\n\t\t        int high = length-1;\n\t\t        int ans=-1;\n\t\t        \n\t\t        while (low <= high) {\n\t\t            int mid = (low + high) / 2;\n\t\t            if (key >= a[mid]) {\n\t\t                ans=mid;\n\t\t            \tlow = mid+1;\n\t\t            } else if(a[mid]>key){\n\t\t                high = mid - 1;\n\t\t            }\n\t\t        }\n\t\t        return ans;\n\t\t}\n\t\t \n\t\t public static int lower(long[] a,int length,long key)\n\t\t {\n\t\t\t    int low = 0;\n\t\t        int high = length-1;\n\t\t        int ans=-1;\n\t\t        \n\t\t        while (low <= high) {\n\t\t            int mid = (low + high) / 2;\n\t\t            if (key<=a[mid]) {\n\t\t                ans=mid;\n\t\t            \thigh = mid-1;\n\t\t            }\n\t\t            else{\n\t\t            \t\tlow=mid+1;\n\t\t            \t}\n\t\t        }\n\t\t        return ans;\n\t\t} \n\t\t   \n\t\tpublic long gcd(long r,long ans)\n\t\t{\n\t\t\tif(r==0) return ans;\n\t\t\treturn gcd(ans%r,r);\n\t\t}\n\t\tpublic fast() {\n\t\t\tthis(System.in);\n\t\t}\n\t\tpublic fast(InputStream is) {\n\t\t\ti = is;\n\t\t}\n\t\tpublic int read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = i.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndOfLine(c));\n\t\t\treturn res.toString();\n\t\t}\n\t\tpublic String nextString() {\n     \t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9')\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res * sgn;\n\t\t}\n\t\tpublic boolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\t\tpublic boolean isEndOfLine(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t}\t\n}", "label": 5}
{"src": "// Don't place your source in a package\nimport javax.swing.*;\nimport java.lang.reflect.Array;\nimport java.text.DecimalFormat;\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.*;\nimport java.util.stream.Stream;\n\n\n// Please name your class Main\npublic class Main {\n    static FastScanner fs=new FastScanner();\n    static class FastScanner {\n        BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st=new StringTokenizer(\"\");\n        public String next() {\n            while (!st.hasMoreElements())\n                try {\n                    st=new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n        int Int() {\n            return Integer.parseInt(next());\n        }\n\n        long Long() {\n            return Long.parseLong(next());\n        }\n\n        String Str(){\n            return next();\n        }\n    }\n\n\n    public static void main (String[] args) throws java.lang.Exception {\n        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n\n        int T=1;\n        for(int t=0;t<T;t++){\n            int n=Int();\n            int A[][]=new int[n][2];\n            for(int i=0;i<n;i++){\n                A[i][0]=Int();\n                A[i][1]=i+1;\n\n            }\n\n            Solution sol=new Solution(out);\n            sol.solution(A);\n        }\n        out.close();\n\n    }\n\n\n    public static int Int(){\n        return fs.Int();\n    }\n    public static long Long(){\n        return fs.Long();\n    }\n    public static String Str(){\n        return fs.Str();\n    }\n\n}\n\n\n\n\n\n\nclass Solution{\n    PrintWriter out;\n    public Solution(PrintWriter out){\n        this.out=out;\n    }\n\n\n\n\n\n    public void solution(int A[][]){\n        if(A.length<4){\n            out.println(1);\n            return;\n        }\n\n        Arrays.sort(A,(a,b)->{\n            return a[0]-b[0];\n        });\n        int n=A.length;\n        boolean l[]=new boolean[n];\n        boolean r[]=new boolean[n];\n        l[1]=true;\n        for(int i=2;i<A.length;i++){\n            int dif1=A[i][0]-A[i-1][0];\n            int dif2=A[i-1][0]-A[i-2][0];\n            if(dif1==dif2&&l[i-1]){\n                l[i]=true;\n            }\n            else{\n                break;\n            }\n        }\n\n        r[n-2]=true;\n        for(int i=n-3;i>=0;i--){\n            int dif1=A[i+1][0]-A[i][0];\n            int dif2=A[i+2][0]-A[i+1][0];\n            if(dif1==dif2&&r[i+1]){\n                r[i]=true;\n            }\n            else{\n                break;\n            }\n        }\n\n\n        if(l[n-2]){\n            out.println(A[n-1][1]);\n            return;\n        }\n        if(r[1]){\n            out.println(A[0][1]);\n            return;\n        }\n\n\n\n\n        for(int i=1;i<n-1;i++){\n            int dif=A[i+1][0]-A[i-1][0];\n\n            if(i-1==0){\n                if(A[i+2][0]-A[i+1][0]==dif&&r[i+1]){\n                    out.println(A[i][1]);\n                    return;\n                }\n            }\n            else if(i+1==n-1){\n                if(dif==A[i-1][0]-A[i-2][0]&&l[i-1]){\n                    out.println(A[i][1]);\n                    return;\n                }\n            }\n            else{\n                if(l[i-1]&&r[i+1]&&dif==A[i+2][0]-A[i+1][0]&&dif==A[i-1][0]-A[i-2][0]){\n                    out.println(A[i][1]);\n                    return;\n                }\n            }\n        }\n\n        out.println(-1);\n    }\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n/*\n                             ;\\\n                            |' \\\n         _                  ; : ;\n        / `-.              /: : |\n       |  ,-.`-.          ,': : |\n       \\  :  `. `.       ,'-. : |\n        \\ ;    ;  `-.__,'    `-.|\n         \\ ;   ;  :::  ,::'`:.  `.\n          \\ `-. :  `    :.    `.  \\\n           \\   \\    ,   ;   ,:    (\\\n            \\   :., :.    ,'o)): ` `-.\n           ,/,' ;' ,::\"'`.`---'   `.  `-._\n         ,/  :  ; '\"      `;'          ,--`.\n        ;/   :; ;             ,:'     (   ,:)\n          ,.,:.    ; ,:.,  ,-._ `.     \\\"\"'/\n          '::'     `:'`  ,'(  \\`._____.-'\"'\n             ;,   ;  `.  `. `._`-.  \\\\\n             ;:.  ;:       `-._`-.\\  \\`.\n              '`:. :        |' `. `\\  ) \\\n      -hrr-      ` ;:       |    `--\\__,'\n                   '`      ,'\n                        ,-'\n\n\n                      free bug dog\n*/\n\n\n", "label": 5}
{"src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Scanner;\n\n\npublic class Main {\n\n\tprivate static class Element implements Comparable<Element> {\n\t\tpublic long value;\n\t\tpublic int index;\n\t\tpublic Element(long value , int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\t\t\t\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Element e) {\n\t\t\tif (this.value != e.value) {\t\t\n\t\t\t\tif (this.value < e.value) {\n\t\t\t\t\treturn - 1;\n\t\t\t\t} else {\n\t\t\t\t\treturn 1;\t\t\t\t\t\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn this.index - e.index;\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\t\t\t\t\n\t\tScanner scan = new Scanner(System.in);\n\t\tList<Element> list = new ArrayList<>();\n\t\tint i , n = scan.nextInt();\n\t\tfor (i = 0;i < n;i ++) {\n\t\t\tint value = scan.nextInt();\t\t\t\n\t\t\tlist.add(new Element(value , i + 1));\n\t\t}\n\t\tif (n == 2) {\n\t\t\tSystem.out.println(1);\t\t\t\n\t\t} else {\n\t\t\tCollections.sort(list);\n\t\t\tMap<Long , Integer> map = new HashMap<>();\n\t\t\tfor (i = 0;i < n - 1;i ++) {\n\t\t\t\tlong diff = list.get(i + 1).value - list.get(i).value;\n\t\t\t\tmap.put(diff , map.getOrDefault(diff , 0) + 1);\n\t\t\t}\t\t\n\t\t\t// try to remove i\t\n\t\t\tint ans = - 1;\t\t\t\n\t\t\tfor (i = 0;i < list.size();i ++) {\t\t\t\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tlong diff = list.get(i + 1).value - list.get(i).value;\n\t\t\t\t\tmap.put(diff , map.getOrDefault(diff , 0) - 1);\n\t\t\t\t\tif (map.getOrDefault(diff , 0) == 0) {\n\t\t\t\t\t\tmap.remove(diff);\n\t\t\t\t\t}\n\t\t\t\t\tif (map.size() == 1) {\n\t\t\t\t\t\tans = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmap.put(diff , map.getOrDefault(diff , 0) + 1);\t\t\t\t\t\n\t\t\t\t} else if (i == list.size() - 1) {\n\t\t\t\t\tlong diff = list.get(i).value - list.get(i - 1).value;\t\t\t\t\t\t\t\n\t\t\t\t\tmap.put(diff , map.getOrDefault(diff , 0) - 1);\n\t\t\t\t\tif (map.getOrDefault(diff , 0) == 0) {\n\t\t\t\t\t\tmap.remove(diff);\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tif (map.size() == 1) {\n\t\t\t\t\t\tans = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmap.put(diff , map.getOrDefault(diff , 0) + 1);\t\n\t\t\t\t} else {\n\t\t\t\t\t// remove left and right\t\t\t\t\t\n\t\t\t\t\tlong diff1 = list.get(i).value - list.get(i - 1).value;\n\t\t\t\t\tlong diff2 = list.get(i + 1).value - list.get(i).value;\n\t\t\t\t\tmap.put(diff1 , map.getOrDefault(diff1 , 0) - 1);\n\t\t\t\t\tif (map.getOrDefault(diff1 , 0) == 0) {\n\t\t\t\t\t\tmap.remove(diff1);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tmap.put(diff2 , map.getOrDefault(diff2 , 0) - 1);\n\t\t\t\t\tif (map.getOrDefault(diff2 , 0) == 0) {\n\t\t\t\t\t\tmap.remove(diff2);\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t// append new diff\n\t\t\t\t\tmap.put(diff1 + diff2 , map.getOrDefault(diff1 + diff2 , 0) + 1);\t\t\t\t\t\n\t\t\t\t\tif (map.size() == 1) {\n\t\t\t\t\t\tans = i;\t\t\t\t\t\t\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\t\t\t\t\t\n\t\t\t\t\tmap.put(diff1 , map.getOrDefault(diff1 , 0) + 1);\n\t\t\t\t\tmap.put(diff2 , map.getOrDefault(diff2 , 0) + 1);\n\t\t\t\t\tmap.put(diff1 + diff2 , map.getOrDefault(diff1 + diff2 , 0) - 1);\n\t\t\t\t\tif (map.getOrDefault(diff1 + diff2 , 0) == 0) {\n\t\t\t\t\t\tmap.remove(diff1 + diff2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans < 0) {\n\t\t\t\tSystem.out.println(ans);\n\t\t\t} else {\n\t\t\t\tSystem.out.println(list.get(ans).index);\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\n\n\n\n\n ", "label": 5}
{"src": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\n// ;;;;;;;;;;;;;;;;;;;;;;;;;; LEARN FAST JAVA I/O ;;;;;;;;;;;;;;;;;;;;;\n// LENT MONEY PROBLEM\n// CODEFORCES UPSOLVING\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader sc = new BufferedReader(new InputStreamReader(System.in));\n        int n = Integer.parseInt(sc.readLine());\n        Entry[] e = new Entry[n];\n        StringTokenizer s=new StringTokenizer(sc.readLine());\n        for (int i = 0; i < n; i++) {\n            int x=Integer.parseInt(s.nextToken());\n            e[i] = new Entry(x, i);\n        }\n        if (n <= 3) {\n            System.out.println(1);\n            return;\n        }\n        Arrays.sort(e);\n        int d=e[1].val-e[0].val;\n        for (int i=1;i<n;i++){\n            if (e[i].val-e[i-1].val!=d){\n                check(e,i,n);\n                break;\n            }\n        }\n//        System.out.println(\"h9i\");\n        check(e,0,n);\n        check(e,1,n);\n        System.out.println(-1);\n        System.exit(0);\n    }\n    static void check(Entry[] e,int p,int n){\n        int arr[]=new int[n-1];\n        int m=0;\n        for (int i=0;i<n;i++){\n            if (i!=p)arr[m++]=e[i].val;\n        }\n//        for (int i:arr) System.out.println(i);\n        for (int i=1;i<m;i++){\n            if (arr[i]-arr[i-1]!=arr[1]-arr[0])return;\n        }\n        System.out.println(e[p].ind+1);\n        System.exit(0);\n\n    }\n    static class Entry implements Comparable<Entry>{\n        int val;\n        int ind;\n        public Entry(int val,int ind){\n            this.val=val;\n            this.ind=ind;\n        }\n        @Override\n        public int compareTo(Entry o) {\n            return this.val-(o.val);\n        }\n    }\n}", "label": 5}
{"src": "import java.util.*;\n\npublic class codeforces {\n\tpublic static int find(int [] arr,long k) {\n\t\tint i=0;\n\t\tfor(;i<arr.length;i++) {\n\t\t\tif(arr[i]==k)\n\t\t\t\treturn i+1;\n\t\t}\n\t\treturn -1;\n\t}\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tPriorityQueue<Integer> p1 = new PriorityQueue<>();\n\t\tPriorityQueue<Integer> p2 = new PriorityQueue<>(Collections.reverseOrder());\n\t\tint[] arr = new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tint temp = sc.nextInt();\n\t\t\tp1.add(temp);\n\t\t\tarr[i] = temp;\n\t\t\tp2.add(temp);\n\t\t\t}\n\t\tlong first = p1.poll();\n\t\tlong d1 = -first+p1.peek();\n\t\t//System.out.println(d1);\n\t\tlong r1 = -1;\n\t\tboolean g1 = true;\n\t\tboolean t1 = false;\n\t\tlong last = p1.poll();\n\t\twhile(!p1.isEmpty()) {\n\t\t\t//System.out.println(\"l \" + last + \" = p \" + p1.peek());\n\t\t\tif(p1.peek()!=last+d1) {\n\t\t\t\tif(g1) {\n\t\t\t\t\tg1 = false;\n\t\t\t\t\tr1 = p1.poll();\n\t\t\t\t}else {\n\t\t\t\t\tt1 = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tlast = p1.poll();\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong d2 = -p2.poll()+p2.peek();\n\t\t//System.out.println(d2);\n\t\tlong r2 = -1;\n\t\tboolean g2 = true;\n\t\tboolean t2 = false;\n\t\tlong last2 = p2.poll();\n\t\twhile(!p2.isEmpty()) {\n\t\t\t//System.out.println(\"l \" + last + \" = p \" + p1.peek());\n\t\t\tif(p2.peek()!=last2+d2) {\n\t\t\t\tif(g2) {\n\t\t\t\t\tg2 = false;\n\t\t\t\t\tr2 = p2.poll();\n\t\t\t\t}else {\n\t\t\t\t\tt2 = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tlast2 = p2.poll();\n\t\t\t}\n\t\t}\n\t\tif(g1 && g2)\n\t\t\tr1 = first;\n\t\tif(!t1) {\n\t\t\tSystem.out.println(find(arr,r1));\n\t\t}else if(!t2) {\n\t\t\tSystem.out.println(find(arr,r2));\n\t\t}else {\n\t\t\tSystem.out.println(-1);\n\t\t}\n\t}\n}", "label": 5}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedWriter;\nimport java.util.Set;\nimport java.util.HashMap;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.util.Collections;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        OutputWriter out = new OutputWriter(outputStream);\n        Task568D solver = new Task568D();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class Task568D {\n        public void solve(int testNumber, InputReader in, OutputWriter out) {\n            int n = in.nextInt();\n            if (n <= 3) {\n                out.println(1);\n                return;\n            }\n\n            ArrayList<Long> al = new ArrayList<>();\n            HashMap<Long, Integer> hm = new HashMap<>();\n            long arr[] = new long[n];\n            int i;\n\n            for (i = 0; i < n; i++) {\n                long a = in.nextLong();\n                al.add(a);\n                arr[i] = a;\n            }\n\n            Collections.sort(al);\n\n            for (i = 1; i < n; i++) {\n                long diff = al.get(i) - al.get(i - 1);\n                hm.merge(diff, 1, (x, y) -> (x + y));\n            }\n            //out.println(hm);\n\n            int l = hm.keySet().size();\n            if (l == 1) {\n                int ans = search(arr, al.get(n - 1));\n                out.println(ans);\n                return;\n            }\n\n            long d11 = al.get(1) - al.get(0);\n            int v11 = hm.get(d11);\n            if (v11 == 1)\n                hm.remove(d11);\n            else\n                hm.put(d11, v11 - 1);\n            if (hm.keySet().size() == 1) {\n                int ans = search(arr, al.get(0));\n                out.println(ans);\n                return;\n            } else {\n                hm.merge(d11, 1, (x, y) -> (x + y));\n            }\n            for (i = 1; i < n - 1; i++) {\n                long d1 = al.get(i) - al.get(i - 1);\n                long d2 = al.get(i + 1) - al.get(i);\n                long d3 = al.get(i + 1) - al.get(i - 1);\n                int v1 = hm.get(d1);\n                if (v1 == 1)\n                    hm.remove(d1);\n                else\n                    hm.put(d1, v1 - 1);\n\n                int v2 = hm.get(d2);\n                if (v2 == 1)\n                    hm.remove(d2);\n                else\n                    hm.put(d2, v2 - 1);\n                hm.merge(d3, 1, (x, y) -> (x + y));\n                //out.println(hm);\n                if (hm.keySet().size() == 1) {\n                    int ans = search(arr, al.get(i));\n                    out.println(ans);\n                    return;\n                } else {\n                    hm.merge(d1, 1, (x, y) -> (x + y));\n                    hm.merge(d2, 1, (x, y) -> (x + y));\n                    int v3 = hm.get(d3);\n                    if (v3 == 1)\n                        hm.remove(d3);\n                    else\n                        hm.put(d3, v3 - 1);\n                }\n            }\n            d11 = al.get(n - 1) - al.get(n - 2);\n            v11 = hm.get(d11);\n            if (v11 == 1)\n                hm.remove(d11);\n            else\n                hm.put(d11, v11 - 1);\n            if (hm.keySet().size() == 1) {\n                int ans = search(arr, al.get(n - 1));\n                out.println(ans);\n                return;\n            } else {\n                hm.merge(d11, 1, (x, y) -> (x + y));\n            }\n            out.println(-1);\n        }\n\n        int search(long arr[], long a) {\n            for (int i = 0; i < arr.length; i++) {\n                if (arr[i] == a)\n                    return i + 1;\n            }\n            return -1;\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private InputReader.SpaceCharFilter filter;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            if (filter != null) {\n                return filter.isSpaceChar(c);\n            }\n            return isWhitespace(c);\n        }\n\n        public static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public interface SpaceCharFilter {\n            public boolean isSpaceChar(int ch);\n\n        }\n\n    }\n\n    static class OutputWriter {\n        private final PrintWriter writer;\n\n        public OutputWriter(OutputStream outputStream) {\n            writer = new PrintWriter(new BufferedWriter(new OutputStreamWriter(outputStream)));\n        }\n\n        public OutputWriter(Writer writer) {\n            this.writer = new PrintWriter(writer);\n        }\n\n        public void close() {\n            writer.close();\n        }\n\n        public void println(int i) {\n            writer.println(i);\n        }\n\n    }\n}\n\n", "label": 5}
{"src": "import java.util.*;\n\npublic class Main {\n\tpublic static int ran;\n    public static void main(String[] args)\n    {\n        Scanner stdin = new Scanner(System.in);\n        /*int n = stdin.nextInt();\n        for(int i = 0; i < n; i++)\n        {\n        \ttest(stdin);\n        }*/\n        test(stdin);\n        stdin.close();\n    }\n    public static void test(Scanner stdin)\n    {\n    \tint n = stdin.nextInt();\n    \tlong arr[] = new long[n];\n    \tTreeMap<Long, Integer> map = new TreeMap<>();\n    \tfor(int i = 0; i < n; i++)\n    \t{\n    \t\tarr[i] = stdin.nextLong();\n    \t\tmap.put(arr[i], i);\n    \t}\n    \tArrays.sort(arr);\n    \tlong a = arr[0];\n    \tboolean possible = true;\n    \tint pos = -1;\n    \tint offset = 0;\n    \tlong c = arr[1] - arr[0];\n    \tfor(int i = 2; i < n; i++)\n    \t{\n    \t\tif(arr[i] != a + c*(i-offset))\n    \t\t{\n    \t\t\tif(offset == 0)\n    \t\t\t{\n    \t\t\t\toffset = 1;\n    \t\t\t\tpos = i;\n    \t\t\t}\n    \t\t\telse\n    \t\t\t{\n    \t\t\t\tpossible = false;\n    \t\t\t\tbreak;\n    \t\t\t}\n    \t\t}\n    \t}\n    \tif(!possible)\n    \t{\n    \t\tpossible = true;\n    \t\toffset = 1;\n    \t\tc = arr[2] - arr[0];\n    \t\tpos = 1;\n    \t\tfor(int i = 2; i < n; i++)\n        \t{\n        \t\tif(arr[i] != a + c*(i-offset))\n        \t\t{\n        \t\t\tif(offset == 0)\n        \t\t\t{\n        \t\t\t\toffset = 1;\n        \t\t\t\tpos = i;\n        \t\t\t}\n        \t\t\telse\n        \t\t\t{\n        \t\t\t\tpossible = false;\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n        \t}\n    \t}\n    \tif(!possible)\n    \t{\n    \t\tpossible = true;\n    \t\toffset = 1;\n    \t\tc = arr[2] - arr[1];\n    \t\tpos = 0;\n    \t\ta = arr[1];\n    \t\tfor(int i = 2; i < n; i++)\n        \t{\n        \t\tif(arr[i] != a + c*(i-offset))\n        \t\t{\n        \t\t\tif(offset == 0)\n        \t\t\t{\n        \t\t\t\toffset = 1;\n        \t\t\t\tpos = i;\n        \t\t\t}\n        \t\t\telse\n        \t\t\t{\n        \t\t\t\tpossible = false;\n        \t\t\t\tbreak;\n        \t\t\t}\n        \t\t}\n        \t}\n    \t}\n    \tif(possible)\n    \t{\n    \t\tint where = pos;\n    \t\tif(pos != -1)\n    \t\t{\n    \t\t\twhere = map.get(arr[pos]);\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\twhere = map.get(arr[n-1]);\n    \t\t}\n    \t\tSystem.out.println(where + 1);\n    \t}\n    \telse\n    \t{\n    \t\tSystem.out.println(-1);\n    \t}\n    }\n}", "label": 5}
{"src": "import java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.math.BigInteger;\nimport java.util.*;\n\n/**\n * #\n *\n * @author pttrung\n */\npublic class D_Round_568_Div2 {\n\n    public static long MOD = 998244353;\n    static int[][] dp;\n\n    public static void main(String[] args) throws FileNotFoundException {\n        // PrintWriter out = new PrintWriter(new FileOutputStream(new File(\n        // \"output.txt\")));\n        PrintWriter out = new PrintWriter(System.out);\n        Scanner in = new Scanner();\n        int n = in.nextInt();\n        Point[] data = new Point[n];\n\n\n        for (int i = 0; i < n; i++) {\n            data[i] = new Point(i, in.nextInt());\n\n        }\n        Arrays.sort(data, (a, b) -> Integer.compare(a.y, b.y));\n        if (n <= 3) {\n            out.println(1);\n        } else {\n            HashSet<Integer> set = new HashSet<>();\n            for (int i = 1; i < n; i++) {\n                int v = data[i].y - data[i - 1].y;\n                set.add(v);\n            }\n            //System.out.println(set + \" \" + Arrays.toString(data));\n            if (set.size() <= 3) {\n                if (set.size() >= 2) {\n                    boolean ok = false;\n                    for (int i : set) {\n\n                        ok = true;\n                        int skip = -1;\n                        for (int j = 1; j < n; j++) {\n                            int v = data[j].y - data[j - 1].y;\n                            if (v != i) {\n\n                                if (skip == -1 && j + 1 < n && data[j + 1].y - data[j - 1].y == i) {\n                                    skip = j;\n                                    j++;\n                                } else {\n                                    ok = false;\n                                    break;\n                                }\n                            }\n                        }\n                       // System.out.println(ok + \" \" + i);\n                        if (ok) {\n                            out.println((data[skip].x + 1));\n                            break;\n                        }\n                    }\n\n                    if (!ok) {\n                        int v = data[2].y - data[1].y;\n                        ok = true;\n                        for (int i = 3; i < n; i++) {\n                            int other = data[i].y - data[i - 1].y;\n                            if (other != v) {\n                                ok = false;\n                                break;\n                            }\n                        }\n                        if (ok) {\n                            out.println(data[0].x + 1);\n                        } else {\n                            v = data[1].y - data[0].y;\n                            ok = true;\n                            for (int i = 2; i < n - 1; i++) {\n                                int other = data[i].y - data[i - 1].y;\n                                if (other != v) {\n                                    ok = false;\n                                    break;\n                                }\n                            }\n                            if (ok) {\n                                out.println(data[n - 1].x + 1);\n                            } else {\n                                out.println(-1);\n                            }\n                        }\n                    }\n                } else if (set.size() == 1) {\n                    out.println(data[0].x + 1);\n                }\n            } else {\n                out.println(-1);\n            }\n        }\n\n        out.close();\n    }\n\n\n    public static int[] KMP(String val) {\n        int i = 0;\n        int j = -1;\n        int[] result = new int[val.length() + 1];\n        result[0] = -1;\n        while (i < val.length()) {\n            while (j >= 0 && val.charAt(j) != val.charAt(i)) {\n                j = result[j];\n            }\n            j++;\n            i++;\n            result[i] = j;\n        }\n        return result;\n\n    }\n\n    public static boolean nextPer(int[] data) {\n        int i = data.length - 1;\n        while (i > 0 && data[i] < data[i - 1]) {\n            i--;\n        }\n        if (i == 0) {\n            return false;\n        }\n        int j = data.length - 1;\n        while (data[j] < data[i - 1]) {\n            j--;\n        }\n        int temp = data[i - 1];\n        data[i - 1] = data[j];\n        data[j] = temp;\n        Arrays.sort(data, i, data.length);\n        return true;\n    }\n\n    public static int digit(long n) {\n        int result = 0;\n        while (n > 0) {\n            n /= 10;\n            result++;\n        }\n        return result;\n    }\n\n    public static double dist(long a, long b, long x, long y) {\n        double val = (b - a) * (b - a) + (x - y) * (x - y);\n        val = Math.sqrt(val);\n        double other = x * x + a * a;\n        other = Math.sqrt(other);\n        return val + other;\n\n    }\n\n    public static class Point implements Comparable<Point> {\n\n        int x, y;\n\n        public Point(int start, int end) {\n            this.x = start;\n            this.y = end;\n        }\n\n        @Override\n        public int hashCode() {\n            int hash = 5;\n            hash = 47 * hash + this.x;\n            hash = 47 * hash + this.y;\n            return hash;\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (getClass() != obj.getClass()) {\n                return false;\n            }\n            final Point other = (Point) obj;\n            if (this.x != other.x) {\n                return false;\n            }\n            if (this.y != other.y) {\n                return false;\n            }\n            return true;\n        }\n\n        public String toString() {\n            return x + \":\" + y;\n        }\n\n        @Override\n        public int compareTo(Point o) {\n            return Integer.compare(x, o.x);\n        }\n    }\n\n    public static class FT {\n\n        long[] data;\n\n        FT(int n) {\n            data = new long[n];\n        }\n\n        public void update(int index, long value) {\n            while (index < data.length) {\n                data[index] += value;\n                index += (index & (-index));\n            }\n        }\n\n        public long get(int index) {\n            long result = 0;\n            while (index > 0) {\n                result += data[index];\n                index -= (index & (-index));\n            }\n            return result;\n\n        }\n    }\n\n    public static long gcd(long a, long b) {\n        if (b == 0) {\n            return a;\n        }\n        return gcd(b, a % b);\n    }\n\n    public static long pow(long a, long b) {\n        if (b == 0) {\n            return 1;\n        }\n        if (b == 1) {\n            return a;\n        }\n        long val = pow(a, b / 2);\n        if (b % 2 == 0) {\n            return val * val;\n        } else {\n            return val * (val * a);\n\n        }\n    }\n\n    static class Scanner {\n\n        BufferedReader br;\n        StringTokenizer st;\n\n        public Scanner() throws FileNotFoundException {\n            // System.setOut(new PrintStream(new BufferedOutputStream(System.out), true));\n            br = new BufferedReader(new InputStreamReader(System.in));\n            //  br = new BufferedReader(new InputStreamReader(new FileInputStream(new File(\"input.txt\"))));\n        }\n\n        public String next() {\n\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    throw new RuntimeException();\n                }\n            }\n            return st.nextToken();\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        public String nextLine() {\n            st = null;\n            try {\n                return br.readLine();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n\n        public boolean endLine() {\n            try {\n                String next = br.readLine();\n                while (next != null && next.trim().isEmpty()) {\n                    next = br.readLine();\n                }\n                if (next == null) {\n                    return true;\n                }\n                st = new StringTokenizer(next);\n                return st.hasMoreTokens();\n            } catch (Exception e) {\n                throw new RuntimeException();\n            }\n        }\n    }\n}\n", "label": 5}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class Exam { \n\n\tstatic class Reader \n    { \n        final private int BUFFER_SIZE = 1 << 16; \n        private DataInputStream din; \n        private byte[] buffer; \n        private int bufferPointer, bytesRead; \n  \n        public Reader() \n        { \n            din = new DataInputStream(System.in); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public Reader(String file_name) throws IOException \n        { \n            din = new DataInputStream(new FileInputStream(file_name)); \n            buffer = new byte[BUFFER_SIZE]; \n            bufferPointer = bytesRead = 0; \n        } \n  \n        public String readLine() throws IOException \n        { \n            byte[] buf = new byte[1000000]; // line length \n            int cnt = 0, c; \n            while ((c = read()) != -1) \n            { \n                if (c == '\\n') \n                    break; \n                buf[cnt++] = (byte) c; \n            } \n            return new String(buf, 0, cnt); \n        } \n  \n        public int nextInt() throws IOException \n        { \n            int ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do\n            { \n                ret = ret * 10 + c - '0'; \n            }  while ((c = read()) >= '0' && c <= '9'); \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public long nextLong() throws IOException \n        { \n            long ret = 0; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        public double nextDouble() throws IOException \n        { \n            double ret = 0, div = 1; \n            byte c = read(); \n            while (c <= ' ') \n                c = read(); \n            boolean neg = (c == '-'); \n            if (neg) \n                c = read(); \n  \n            do { \n                ret = ret * 10 + c - '0'; \n            } \n            while ((c = read()) >= '0' && c <= '9'); \n  \n            if (c == '.') \n            { \n                while ((c = read()) >= '0' && c <= '9') \n                { \n                    ret += (c - '0') / (div *= 10); \n                } \n            } \n  \n            if (neg) \n                return -ret; \n            return ret; \n        } \n  \n        private void fillBuffer() throws IOException \n        { \n            bytesRead = din.read(buffer, bufferPointer = 0, BUFFER_SIZE); \n            if (bytesRead == -1) \n                buffer[0] = -1; \n        } \n  \n        private byte read() throws IOException \n        { \n            if (bufferPointer == bytesRead) \n                fillBuffer(); \n            return buffer[bufferPointer++]; \n        } \n  \n        public void close() throws IOException \n        { \n            if (din == null) \n                return; \n            din.close(); \n        } \n    } \n\n    static int findPos(int x, int ar[]){\n        for(int i=0;i<ar.length;i++){\n            if(ar[i]==x)\n                return (i+1);\n        }\n        return -20;\n    }\n\n    public static void main(String args[])throws IOException{\n        Reader sc=new Reader();\n        PrintWriter pw = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n        int i,j;\n        int n=sc.nextInt();\n        int a[]=new int[n];\n        int b[]=new int[n];\n        for(i=0;i<n;i++){\n            a[i]=b[i]=sc.nextInt();\n        }\n        Arrays.sort(a);\n        int a0,a1,a2,a3,a4,a5;\n        if(n<=3)\n            pw.println(1);\n        else{\n            a0=a[0];\n            a1=a[1];\n            a2=a[2];\n            a3=a[3];\n            if(a1-a0==a2-a1&&a2-a1==a3-a2){\n                // pw.println(\"Hello3\");\n                int c=0,d=a[1]-a[0],val=-1;\n                for(i=4;i<n;i++){\n                    if(a[i]-a[i-1]!=d){\n                        c++;\n                        if(c==2)\n                            break;\n                        val=a[i];\n                        a[i]=a[i-1];\n                    }\n                }\n                if(c>=2)\n                    pw.println(-1);\n                else if(c==1)\n                    pw.println(findPos(val,b));\n                else\n                    pw.println(findPos(a[0],b));\n            }\n            else if(a2-a1==a3-a2&&(n==4||a[4]-a[3]==a2-a1)){\n                // pw.println(\"Hello2\");\n                int c=0,d=a2-a1;\n                for(i=4;i<n;i++){\n                    if(a[i]-a[i-1]!=d){\n                        c++;\n                        break;\n                    }\n                }\n                if(c==1)\n                    pw.println(-1);\n                else\n                    pw.println(findPos(a[0],b));\n            }\n            else if(a2-a0==a3-a2&&(n==4||a[4]-a[3]==a2-a0)){\n                // pw.println(\"Hello1\");\n                int c=0,d=a2-a0;\n                for(i=4;i<n;i++){\n                    if(a[i]-a[i-1]!=d){\n                        c++;\n                        break;\n                    }\n                }\n                if(c==1)\n                    pw.println(-1);\n                else\n                    pw.println(findPos(a[1],b));\n            }\n            else if(a1-a0==a3-a1&&(n==4||a[4]-a[3]==a3-a1)){\n                int c=0,d=a3-a1;\n                // pw.println(\"Hello\");\n                for(i=4;i<n;i++){\n                    if(a[i]-a[i-1]!=d){\n                        c++;\n                        break;\n                    }\n                }\n                if(c==1)\n                    pw.println(-1);\n                else\n                    pw.println(findPos(a[2],b));\n            }\n            else if(a1-a0==a2-a1&&(n==4||a[4]-a[2]==a2-a1)){\n                int c=0,d=a2-a1;\n                int p=a[3];\n                a[3]=a[2];\n                for(i=4;i<n;i++){\n                    if(a[i]-a[i-1]!=d){\n                        c++;\n                        break;\n                    }\n                }\n                if(c==1)\n                    pw.println(-1);\n                else\n                    pw.println(findPos(p,b));\n            }\n            else{\n                // pw.println(\"last\");\n                pw.println(-1);\n            }\n        }\n\n        pw.close();\n    }\n}", "label": 5}
{"src": "\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.util.*;\nimport java.lang.*;\n\nimport static java.lang.Math.*;\n\npublic class Main implements Runnable {\n    public static void main(String[] args) {\n        new Thread(null, new Main(), \"Check2\", 1 << 28).start();// to increse stack size in java\n    }\n    static long mod = (long) (1e9 + 7);\n    public void run() {\n        InputReader in = new InputReader(System.in);\n        PrintWriter w = new PrintWriter(System.out);\n\n        int n = in.nextInt();\n\n        long a[] = new long[n];\n        pair p[] = new pair[n];\n\n        for (int i=0;i<n;i++){\n            a[i] = in.nextLong();\n            p[i] = new pair(i,a[i]);\n        }\n\n        Arrays.sort(p,new cmp());\n        boolean isAirthMateic = true;\n        long  diff = p[1].b - p[0].b;\n\n        for (int i=2;i<n;i++){\n            isAirthMateic &= (p[i].b - p[i-1].b == diff);\n        }\n\n        if (isAirthMateic){\n            w.println(p[n-1].a+1);\n            w.close();\n            return;\n        }\n\n        if (n>2){\n             diff = p[2].b - p[1].b;\n            isAirthMateic = true;\n\n            for (int i=3;i<n;i++){\n                isAirthMateic &= ((p[i].b - p[i-1].b) == diff);\n            }\n\n            if (isAirthMateic){\n                w.println(p[0].a + 1);\n                w.close();\n                return;\n            }\n            isAirthMateic = true;\n             diff = p[1].b - p[0].b;\n\n            for (int i=2;i<n-1;i++){\n                isAirthMateic &= ( (p[i].b - p[i-1].b ) == diff);\n            }\n\n            if (isAirthMateic){\n                w.println(p[n-1].a + 1);\n                w.close();\n                return;\n            }\n        }\n\n        if (n<=2) {\n            w.println(1);\n            w.close();\n            return;\n        }\n        else {\n            Map <Long,Integer> map = new HashMap<>();\n\n            for (int i=1;i<n;i++){\n                map.put(p[i].b - p[i-1].b,map.getOrDefault(p[i].b - p[i-1].b,0)+1);\n            }\n            if (map.size() <= 3){\n                for (long itr : map.keySet()){\n                    long difff = itr;\n                    int ans = 0;\n                    int id = -1;\n                    int prv = 0;\n\n                    for (int i=1;i<n;i++){\n                        long currentDiff = p[i].b - p[prv].b;\n                        if (currentDiff != difff){\n                            ans++;\n                            id = p[i].a;\n                        }\n                        else {\n                            prv = i;\n                        }\n                    }\n\n\n                    if (ans == 1){\n                        w.println(id+1);\n                        w.close();\n                        return;\n                    }\n                }\n                w.println(-1);\n                w.close();\n                return;\n            }\n            else {\n                w.println(-1);\n            }\n        }\n\n        w.close();\n    }\n    class cmp implements Comparator<pair>{\n        public int compare(pair o1,pair o2){\n            return o1.b < o2.b ? -1 : o1.b > o2.b ? 1: 0;\n        }\n    }\n    void debug(Object...args) {\n        System.out.println(Arrays.deepToString(args));\n    }\n    class pair {\n        int a;\n        long b;\n        pair(int a,long b){\n            this.a=a;\n            this.b=b;\n        }\n        public boolean equals(Object obj) {      //  override equals method for object to remove tem from arraylist and sets etc.......\n            if (this == obj)\n                return true;\n            if (obj == null)\n                return false;\n            if (getClass() != obj.getClass())\n                return false;\n            pair other = (pair) obj;\n            if (b!= other.b||a!=other.a)\n                return false;\n            return true;\n        }\n    }\n    long modinv(long a,long b) {\n        long p=power(b,mod-2,mod);\n\n        p=a%mod*p%mod;\n        p%=mod;\n\n        return p;\n\n    }\n    long power(long x,long y,long mod){\n        if(y==0)return 1%mod;\n        if(y==1)return x%mod;\n        long res=1;\n        x=x%mod;\n        while(y>0)\n        {\n            if((y%2)!=0){\n                res=(res*x)%mod;\n            }\n            y=y/2;\n            x=(x*x)%mod;\n        }\n        return res;\n    }\n    long gcd(long a,long b){\n\n        if(b==0)return a;\n        return gcd(b,a%b);\n    }\n    void sev(int a[],int n){\n\n        for(int i=2;i<=n;i++)a[i]=i;\n        for(int i=2;i<=n;i++){\n\n            if(a[i]!=0){\n                for(int j=2*i;j<=n;){\n\n                    a[j]=0;\n                    j=j+i;\n                }\n            }\n\n        }\n\n    }\n    static class InputReader\n    {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n        private SpaceCharFilter filter;\n\n        public InputReader(InputStream stream)\n        {\n            this.stream = stream;\n        }\n\n        public int read()\n        {\n            if (numChars==-1)\n                throw new InputMismatchException();\n\n            if (curChar >= numChars){\n                curChar = 0;\n                try\n                {\n                    numChars = stream.read(buf);\n                }\n                catch (IOException e)\n                {\n                    throw new InputMismatchException();\n                }\n\n                if(numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine()\n        {\n            BufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n            String stock = \"\";\n            try\n            {\n                stock = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return stock;\n        }\n        public int nextInt()\n        {\n            int c = read();\n\n            while(isSpaceChar(c))\n                c = read();\n\n            int sgn = 1;\n\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n\n            int res = 0;\n            do\n            {\n                if(c<'0'||c>'9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res * sgn;\n        }\n\n        public long nextLong()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n\n            do\n            {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public double nextDouble()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-')\n            {\n                sgn = -1;\n                c = read();\n            }\n            double res = 0;\n            while (!isSpaceChar(c) && c != '.')\n            {\n                if (c == 'e' || c == 'E')\n                    return res * Math.pow(10, nextInt());\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            }\n            if (c == '.')\n            {\n                c = read();\n                double m = 1;\n                while (!isSpaceChar(c))\n                {\n                    if (c == 'e' || c == 'E')\n                        return res * Math.pow(10, nextInt());\n                    if (c < '0' || c > '9')\n                        throw new InputMismatchException();\n                    m /= 10;\n                    res += (c - '0') * m;\n                    c = read();\n                }\n            }\n            return res * sgn;\n        }\n\n        public String readString()\n        {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do\n            {\n                res.appendCodePoint(c);\n                c = read();\n            }\n            while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c)\n        {\n            if (filter != null)\n                return filter.isSpaceChar(c);\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public String next()\n        {\n            return readString();\n        }\n\n        public interface SpaceCharFilter\n        {\n            public boolean isSpaceChar(int ch);\n        }\n    }\n}\n", "label": 5}
{"src": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class ex1185D_ExtraElement {\n\t\n\tstatic int find_index(ArrayList<Integer> list, int element) {\n\t\tfor (int i=0; i<list.size(); i++) {\n\t\t\tif (list.get(i)==element) {\n\t\t\t\treturn i+1;\n\t\t\t}\n\t\t}\n\t\treturn -2;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\t\n\t\tArrayList<Integer> list = new ArrayList<Integer>(n);\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tlist.add(sc.nextInt());\n\t\t}\n\t\tsc.close();\n\t\t\n\t\tif (n<=2) {\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tArrayList<Integer> sortList = new ArrayList<Integer>(list);\n\t\tCollections.sort(sortList);\n\n\t\tArrayList<Integer> sortList1 = new ArrayList<Integer>(sortList);\n\t\tint remove=0;\n\t\tremove = sortList1.remove(0);\n\t\tboolean test1 = true;\n\t\tint diff1 = sortList1.get(1)-sortList1.get(0);\n\t\tfor (int i=0; i<sortList1.size()-1; i++) {\n\t\t\tif (sortList1.get(i+1)-sortList1.get(i)!=diff1) {\n\t\t\t\ttest1=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (test1==true) {\n\t\t\tSystem.out.println(find_index(list,remove));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tArrayList<Integer> sortList2 = new ArrayList<Integer>(sortList);\n\t\tremove = sortList2.remove(1);\n\t\tboolean test2 = true;\n\t\tint diff2 = sortList2.get(1)-sortList2.get(0);\n\t\tfor (int i=0; i<sortList2.size()-1; i++) {\n\t\t\tif (sortList2.get(i+1)-sortList2.get(i)!=diff2) {\n\t\t\t\ttest2=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (test2==true) {\n\t\t\tSystem.out.println(find_index(list,remove));\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint diff = sortList.get(1) - sortList.get(0);\n\t\tfor (int i=0; i<sortList.size()-1; i++) {\n\t\t\tif (sortList.get(i+1)-sortList.get(i)!=diff) {\n\t\t\t\tremove=sortList.remove(i+1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i=0; i<sortList.size()-1; i++) {\n\t\t\tif (sortList.get(i+1)-sortList.get(i)!=diff) {\n\t\t\t\tSystem.out.println(-1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tSystem.out.println(find_index(list,remove));\n\t\t\n\t\tsc.close();\n\t}\n}\n", "label": 5}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.StringTokenizer;\n \npublic class ThisIsADumbProblem {\n \n\tpublic static void main(String[] args) {\n\t\tMyScanner sc = new MyScanner();\n\t\tint n = sc.nextInt();\n\t\tint[] arr = new int[n];\n \n\t\tMap<Integer, Integer> numberIndexMap = new HashMap<>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarr[i] = sc.nextInt();\n\t\t\tnumberIndexMap.put(arr[i], i);\n\t\t}\n \n\t\tArrays.sort(arr);\n \n\t\tMap<Integer, Set<Integer>> differenceMap = new HashMap<>();\n \n\t\tint prev = arr[0];\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tint diff = arr[i] - prev;\n\t\t\tfinal int index = i;\n\t\t\tdifferenceMap.compute(diff, (k, v) -> {\n\t\t\t\tif (v == null) v = new HashSet<>();\n\t\t\t\tv.add(index);\n\t\t\t\tv.add(index - 1);\n\t\t\t\treturn v;\n\t\t\t});\n\t\t\tprev = arr[i];\n\t\t}\n \n\t\tint indexToRemove = -1;\n\t\tif (differenceMap.keySet().size() == 1) {\n\t\t\tindexToRemove = numberIndexMap.get(arr[0]) + 1;\n\t\t} else if (n < 6) {\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint start = i == 0 ? 1 : 0;\n\t\t\t\tint prv = arr[start];\n\t\t\t\tInteger d = null;\n\t\t\t\tboolean valid = true;\n\t\t\t\tfor (int j = start + 1; j < n; j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint diff = arr[j] - prv;\n\t\t\t\t\tif (d == null) {\n\t\t\t\t\t\td = diff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (diff != d) {\n\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprv = arr[j];\n\t\t\t\t}\n \n\t\t\t\tif (valid) {\n\t\t\t\t\tindexToRemove = numberIndexMap.get(arr[i]) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tint max = Integer.MIN_VALUE;\n\t\t\tfor (Set<Integer> list : differenceMap.values()) {\n\t\t\t\tif (list.size() > max) {\n\t\t\t\t\tmax = list.size();\n\t\t\t\t}\n\t\t\t}\n \n\t\t\tList<Integer> indexes = new ArrayList<>();\n\t\t\tfor (Set<Integer> list : differenceMap.values()) {\n\t\t\t\tif (list.size() < max) {\n\t\t\t\t\tindexes.addAll(list);\n\t\t\t\t}\n\t\t\t}\n \n\t\t\tfor (int i : indexes) {\n\t\t\t\tint start = i == 0 ? 1 : 0;\n\t\t\t\tint prv = arr[start];\n\t\t\t\tInteger d = null;\n\t\t\t\tboolean valid = true;\n\t\t\t\tfor (int j = start + 1; j < n; j++) {\n\t\t\t\t\tif (i == j) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tint diff = arr[j] - prv;\n\t\t\t\t\tif (d == null) {\n\t\t\t\t\t\td = diff;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (diff != d) {\n\t\t\t\t\t\t\tvalid = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tprv = arr[j];\n\t\t\t\t}\n \n\t\t\t\tif (valid) {\n\t\t\t\t\tindexToRemove = numberIndexMap.get(arr[i]) + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n \n \n\t\tSystem.out.println(indexToRemove);\n\t}\n \n \n\tprivate static int sum(int num) {\n\t\tint sum = 0;\n\t\twhile (num != 0) {\n\t\t\tsum += num % 10;\n\t\t\tnum /= 10;\n\t\t}\n \n\t\treturn sum;\n\t}\n \n\tstatic class MyScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n \n\t\tpublic MyScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n \n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n \n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n \n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n \n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n \n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n}", "label": 5}
{"src": "/*\n *created by Kraken on 06-05-2020 at 13:30\n */\n//package com.kraken.cf.practice;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class D1185 {\n\n  private static class Pair {\n    long val;\n    int index;\n\n    public Pair(long val, int index) {\n      this.val = val;\n      this.index = index;\n    }\n\n    @Override\n    public String toString() {\n      return \"Pair{\" +\n        \"val=\" + val +\n        \", index=\" + index +\n        '}';\n    }\n  }\n\n  public static void main(String[] args) {\n    FastReader sc = new FastReader();\n    int n = sc.nextInt();\n    Pair[] x = new Pair[n];\n    for (int i = 0; i < n; i++) x[i] = new Pair(sc.nextLong(), i + 1);\n    Arrays.sort(x, (o1, o2) -> (int) (o1.val - o2.val));\n    boolean fine = true;\n    for (int i = 2; i < n; i++) {\n      if (x[i].val - x[i - 1].val != x[2].val - x[1].val) {\n        fine = false;\n        break;\n      }\n    }\n    if (fine) {\n      System.out.println(x[0].index);\n      return;\n    }\n    fine = true;\n    for (int i = 3; i < n; i++) {\n      if (x[i].val - x[i - 1].val != x[2].val - x[0].val) {\n        fine = false;\n        break;\n      }\n    }\n    if (fine) {\n      System.out.println(x[1].index);\n      return;\n    }\n    fine = true;\n    int res = -1;\n    for (int i = 2; i < n; i++) {\n      if (x[i].val - x[i - 1].val != x[1].val - x[0].val) {\n        if (fine) {\n          fine = false;\n          if (i < n - 1 && x[i + 1].val - x[i - 1].val == x[1].val - x[0].val) {\n            res = x[i].index;\n          } else {\n            if (i == n - 1) {\n              res = x[n - 1].index;\n            } else {\n              System.out.println(-1);\n              return;\n            }\n          }\n          i++;\n        } else {\n          System.out.println(-1);\n          return;\n        }\n      }\n    }\n    System.out.println(res);\n  }\n\n  static class FastReader {\n\n    BufferedReader br;\n\n    StringTokenizer st;\n\n    public FastReader() {\n      br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n      while (st == null || !st.hasMoreElements()) {\n        try {\n          st = new StringTokenizer(br.readLine());\n        }\n        catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n      String str = \"\";\n      try {\n        str = br.readLine();\n      }\n      catch (IOException e) {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n}\n", "label": 5}
{"src": "\nimport java.io.*;\nimport java.util.*;\npublic class D1185 {\n    int val,pos;\n    public D1185(int v,int p)\n    {\n        this.val=v;\n        this.pos=p;\n    }\n    public static void main(String args[])throws IOException\n    {\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        int arr[]=new int[n];\n        D1185 a[]=new D1185[n];\n        for(int i=0;i<n;i++)\n        {\n            arr[i]=sc.nextInt();\n            a[i]=new D1185(arr[i],i);\n        }\n        if(n<4)\n            System.out.println(1);\n        else\n        {\n            Arrays.sort(a,new Comparator<D1185>(){\n                public int compare(D1185 ob1,D1185 ob2)\n                {\n                    int r=Integer.compare(ob1.val,ob2.val);\n                    if(r==0)\n                        return Integer.compare(ob1.pos,ob2.pos);\n                    return r;\n                }\n            });\n            if(a[1].val-a[0].val == a[2].val-a[1].val)\n            {\n                int cd=a[1].val-a[0].val;int f=0,ind=-1,prev=2;\n                for(int i=3;i<n;i++)\n                {\n                    if(a[i].val-a[prev].val == cd)\n                    {\n                        prev=i;\n                    }\n                    else\n                    {\n                        if(ind==-1)\n                        {\n                            ind=a[i].pos;\n                        }\n                        else\n                        {\n                            f=1;\n                            break;\n                        }\n                    }\n                }\n                if(ind==-1)\n                {\n                    System.out.println(a[0].pos+1);\n                }\n                else\n                {\n                    if(f==1)\n                        System.out.println(-1);\n                    else\n                        System.out.println(ind+1);\n                }\n            }\n            else if(a[2].val-a[1].val == a[3].val-a[2].val)\n            {\n                //System.out.println(\"djg\");\n                int cd=a[2].val-a[1].val;int f=0,ind=-1,prev=3;\n                for(int i=4;i<n;i++)\n                {\n                    if(a[i].val-a[prev].val == cd)\n                    {\n                        prev=i;\n                    }\n                    else\n                    {\n                        if(ind==-1)\n                        {\n                            ind=a[i].pos;\n                        }\n                        else\n                        {\n                            f=1;\n                            break;\n                        }\n                    }\n                }\n                if(ind==-1)\n                {\n                    System.out.println(a[0].pos+1);\n                }\n                else\n                {\n                    \n                        System.out.println(-1);\n                    \n                }\n            }\n            else\n            {\n                //System.out.println(\"kjgsdkl\");\n                if((a[3].val-a[0].val)%2==0)\n                {\n                    int cd=a[3].val-a[0].val;\n                    cd=cd/2;int ind=-1;\n                    if((a[1].val-a[0].val == cd))\n                        ind=a[2].pos;\n                    else if(a[2].val-a[0].val == cd)\n                        ind=a[1].pos;\n                    else\n                    {\n                        System.out.println(-1);\n                        return;\n                    }\n                    int f=0,prev=3;\n                    for(int i=4;i<n;i++)\n                    {\n                        if(a[i].val-a[prev].val == cd)\n                        {\n                            prev=i;\n                        }\n                        else\n                        {\n                            f=1;\n                            break;\n                        }\n                    }\n                    if(f==1)\n                        System.out.println(-1);\n                    else\n                        System.out.println(ind+1);\n                }\n                else\n                    System.out.println(-1);\n            }\n        }\n    }\n    \n}\n", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static pair b[];\n    static int n;\n    static boolean checkFirst(){\n     long dif = b[2].val - b[1].val;\n        for (int i = 3; i < n; i++) {\n            if(b[i].val - b[i-1].val != dif)return false;\n        }\n        return true;\n    }\n    static boolean checkSec(){\n        long dif = b[2].val - b[0].val;\n        for (int i = 3; i < n; i++) {\n            if(b[i].val - b[i-1].val != dif)return false;\n        }\n        return true;\n    }\n    public static void main(String[] args) throws IOException {\n        FastScanner in = new FastScanner(System.in);\n        PrintWriter out = new PrintWriter(System.out);\n        // FastScanner in = new FastScanner(\"search.in\");\n        //PrintWriter out = new PrintWriter(\"search.out\");\n        n = in.nextInt();\n        if(n == 2 || n == 3){\n            out.println(1);\n            out.close();\n            return;\n        }\n        b = new pair[n];\n        for (int i = 0; i < n; i++) {\n            b[i] = new pair(in.nextInt(),i);\n        }\n        Arrays.sort(b, new Comparator<pair>() {\n            @Override\n            public int compare(pair pair, pair t1) {\n                return Long.compare(pair.val,t1.val);\n            }\n        });\n        if(checkFirst()){\n            out.println(b[0].id+1);\n            out.close();\n            return;\n        }\n        if(checkSec()){\n            out.println(b[1].id+1);\n            out.close();\n            return;\n        }\n        long dif = b[1].val - b[0].val;\n        int ind = -1;\n        for (int i = 2; i < n; i++) {\n            if(dif != b[i].val - b[i-1].val){\n                if(ind != -1){\n                    out.println(-1);\n                    out.close();\n                    return;\n                }\n                if(i == n - 1){\n                    ind = b[n-1].id+1;\n                    break;\n                }\n                if(b[i+1].val - b[i-1].val != dif){\n                    out.println(-1);\n                    out.close();\n                    return;\n                }else{\n                    ind = b[i].id+1;\n                    i++;\n                }\n            }\n        }\n        out.println(ind);\n        out.close();\n    }\n}\n\n\n\nclass FastScanner {\n    BufferedReader br;\n    StringTokenizer st = new StringTokenizer(\"\");\n\n    public FastScanner(InputStream s) {\n        br = new BufferedReader(new InputStreamReader(s));\n    }\n\n    public FastScanner(String s) throws FileNotFoundException {\n        br = new BufferedReader(new FileReader(new File(s)));\n    }\n\n    public String next() throws IOException {\n        if (!st.hasMoreTokens())\n            st = new StringTokenizer(br.readLine());\n        return st.nextToken();\n    }\n\n    public int nextInt() throws IOException {\n        return Integer.parseInt(next());\n    }\n\n    public long nextLong() throws IOException {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() throws IOException {\n        return Double.parseDouble(next());\n    }\n}\nclass pair{\n    long val;\n    int id;\n\n    public pair(long val, int id) {\n        this.val = val;\n        this.id = id;\n    }\n}", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class D {\n    public static void main(String[] args) throws Exception {\n        Scanner in = new Scanner(System.in);\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = in.nextInt();\n        int a[] = new int[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = in.nextInt();\n        }\n        int b[] = a.clone();\n        shuffle(b);\n        Arrays.sort(b);\n        int idx = solve(n, b);\n        if (idx == -1) pw.println(-1);\n        else {\n            for (int i = 0; i < n; i++) {\n                if (a[i] == b[idx - 1]) {\n                    idx = i + 1;\n                    break;\n                }\n            }\n            pw.println(idx);\n        }\n\n        pw.close();\n    }\n\n    public static void shuffle(int[] a) {\n        Random rnd = new Random();\n        for (int i = a.length - 1; i >= 1; i--) {\n            int j = rnd.nextInt(i + 1);\n            int t = a[i];\n            a[i] = a[j];\n            a[j] = t;\n        }\n    }\n\n    static int solve(int n, int a[]) {\n        if (n <= 3) return 1;\n        {\n            int x = solve(0, 1, n, a);\n            if (x == -2) return 1;\n            else if (x != -1) return x + 1;\n        }\n        {\n            int x = solve(0, 2, n, a);\n            if (x == -2) return 2;\n        }\n        {\n            int x = solve(1, 2, n, a);\n            if (x == -2) return 1;\n        }\n        return -1;\n    }\n\n    static int solve(int f, int s, int n, int a[]) {\n        long d = a[s] - a[f];\n        ArrayDeque<Integer> dq = new ArrayDeque<>();\n        for (int i = s + 1, last = s; i < n; i++) {\n            long diff = a[i] - a[last];\n            if (diff != d) {\n                dq.addLast(i);\n                if (dq.size() > 1) return -1;\n            } else {\n                last = i;\n            }\n        }\n        if (dq.size() == 0) return -2; // no removal\n        return dq.getFirst();\n    }\n\n    static void debug(Object... obj) {\n        System.err.println(Arrays.deepToString(obj));\n    }\n}", "label": 5}
{"src": "/*\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2877\u28ef\u28bf\u28ff\u28f7\u28fb\u28af\u28ff\u287d\u28fb\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c7\u2838\u28ff\u28ff\u28c6\u2839\u28ff\u28ff\u28be\u28df\u28ef\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28fd\u28fb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28fb\u28fd\u287f\u28ff\u28ce\u2819\u28ff\u28de\u28f7\u284c\u28bb\u28df\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2844\u2839\u28ff\u28ff\u2846\u283b\u28ff\u28df\u28ef\u287f\u28fd\u287f\u28ff\u28ff\u28ff\u28ff\u28fd\u2877\u28ef\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u28f7\u28ff\u28ff\u28ff\u2840\u2839\u28df\u28fe\u28df\u28c6\u2839\u28ef\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28a0\u2858\u28ff\u28ff\u2844\u2809\u28bf\u28ff\u28fd\u2877\u28ff\u28fb\u28ff\u28ff\u28ff\u28ff\u285d\u28f7\u28ef\u28bf\u28ff\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ef\u28bf\u28fe\u28bf\u28ff\u2844\u2884\u2818\u28bf\u28de\u287f\u28e7\u2848\u28b7\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28b8\u28e7\u2818\u28ff\u28f7\u2808\u28e6\u2819\u28bf\u28fd\u28f7\u28fb\u28fd\u28ff\u28ff\u28ff\u28ff\u28cc\u28bf\u28ef\u28bf\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28df\u28ef\u28ff\u28bf\u28ff\u2846\u28b8\u2877\u2848\u28bb\u287d\u28f7\u2877\u2844\u283b\u28fd\u28ff\u28ff\u287f\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28ff\u28ff\u28ff\u28ff\u28cf\u28b0\u28ef\u28b7\u2808\u28ff\u2846\u28b9\u28b7\u284c\u283b\u287e\u288b\u28f1\u28ef\u28ff\u28ff\u28ff\u28ff\u2846\u28bb\u287f\u28ff\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u284e\u28ff\u28be\u287f\u28ff\u2846\u28b8\u28fd\u28bb\u28c4\u2839\u28f7\u28df\u28ff\u28c4\u2839\u28df\u28ff\u28ff\u28df\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28fd\u28ff\u28ff\u28ff\u2847\u28b8\u28ef\u28df\u28e7\u2818\u28f7\u2808\u286f\u281b\u2880\u2850\u28be\u28df\u28f7\u28fb\u28ff\u28ff\u28ff\u287f\u284c\u28bf\u28fb\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u28b8\u287f\u28df\u28ff\u2847\u28b8\u28ef\u28df\u28ee\u28a7\u2848\u28bf\u28de\u287f\u28e6\u2818\u280f\u28f9\u28ff\u28fd\u28bf\u28ff\u28ff\u28ff\u28ff\u28ef\u28ff\u28ff\u28ff\u2847\u28b8\u28ff\u28ff\u28fe\u2846\u2839\u2880\u28e0\u28fe\u28df\u28f7\u2848\u28bf\u28de\u28ef\u28bf\u28ff\u28ff\u28ff\u28b7\u2818\u28ef\u28ff\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2848\u28ff\u28bf\u28fd\u2847\u2818\u281b\u281b\u281b\u2813\u2813\u2808\u281b\u281b\u281f\u2807\u2880\u28bf\u28fb\u28ff\u28ef\u28bf\u28ff\u28ff\u28ff\u28f7\u28bf\u28ff\u28ff\u2801\u28fe\u28ff\u28ff\u28ff\u28e7\u2844\u2807\u28f9\u28ff\u28fe\u28ef\u28ff\u2844\u283b\u28fd\u28ef\u28bf\u28fb\u28ff\u28ff\u2847\u28b9\u28fe\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28b9\u28ff\u287d\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28de\u28c6\u2830\u28f6\u28f6\u2844\u2880\u28bb\u287f\u28ef\u28ff\u287d\u28ff\u28ff\u28ff\u28af\u28df\u287f\u2880\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2810\u28f8\u28ff\u28ff\u28f7\u28ff\u28ff\u28c6\u2839\u28ef\u28ff\u28fb\u28ff\u28ff\u28ff\u2880\u28ff\u28bf\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2818\u28ef\u287f\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e7\u2848\u28bf\u28f3\u2818\u2844\u283b\u28ff\u28be\u28fd\u28df\u287f\u28ff\u28af\u28ff\u2847\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2840\u28be\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c6\u2839\u28fe\u28f7\u28fb\u28ff\u287f\u2847\u28b8\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2847\u28b9\u28ff\u2807\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c4\u283b\u2847\u28b9\u28c6\u2839\u28df\u28fe\u28fd\u28fb\u28df\u28ff\u28fd\u2801\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28c7\u28ff\u28ff\u283f\u281b\u281b\u2809\u2819\u280b\u2880\u2801\u2898\u28ef\u28ff\u28ff\u28e7\u2818\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2848\u28ff\u2843\u28bc\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28e6\u2859\u280c\u28ff\u28c6\u2818\u28ff\u28de\u287f\u28de\u287f\u285e\u28a0\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u281b\u2809\u2801\u2880\u28c0\u28e0\u28e4\u28e4\u28f6\u28f6\u28f6\u2846\u28bb\u28fd\u28de\u287f\u28f7\u2808\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2818\u2801\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2809\u2819\u281b\u281b\u28bf\u28c4\u28bb\u28ff\u28e7\u2818\u28af\u28df\u287f\u28fd\u2801\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u2843\u2880\u2880\u2818\u281b\u283f\u28bf\u28fb\u28df\u28ef\u28fd\u28fb\u28f5\u2840\u28bf\u28ef\u28df\u28ff\u2880\u28ff\n\u28ff\u28ff\u28ff\u28df\u28ff\u28ff\u28ff\u28ff\u28f6\u28f6\u2846\u2880\u28ff\u28fe\u28ff\u28fe\u28f7\u28ff\u28f6\u283f\u281a\u2809\u2880\u2880\u28e4\u28ff\u28f7\u28ff\u28ff\u28f7\u2848\u28bf\u28fb\u2883\u28fc\u28ff\u28ff\u28ff\u28ff\u28fb\u28ff\u28ff\u28ff\u2876\u28e6\u28e4\u28c4\u28c0\u2840\u2809\u281b\u281b\u2837\u28ef\u28f3\u2808\u28fe\u287d\u28fe\u2880\u28ff\n\u28ff\u28bf\u28ff\u28ff\u28fb\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2810\u28ff\u28ff\u28ff\u28ff\u283f\u280b\u2801\u2880\u2880\u28e4\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28cc\u28e5\u28fe\u287f\u28ff\u28ff\u28f7\u28ff\u28ff\u28bf\u28f7\u28ff\u28ff\u28df\u28fe\u28fd\u28f3\u28af\u28df\u28f6\u28e6\u28e4\u287e\u28df\u28e6\u2818\u28ff\u28be\u2841\u28ba\n\u28ff\u28fb\u28ff\u28ff\u2877\u28ff\u28ff\u28ff\u28ff\u28ff\u2857\u28e6\u2838\u287f\u280b\u2801\u2880\u2880\u28e0\u28f4\u28bf\u28ff\u28fd\u28fb\u28bd\u28fe\u28df\u28f7\u28ff\u28df\u28ff\u28ff\u28ff\u28f3\u283f\u28f5\u28e7\u28fc\u28ff\u28ff\u28ff\u28ff\u28ff\u28fe\u28ff\u28ff\u28ff\u28ff\u28ff\u28fd\u28f3\u28ef\u28ff\u28ff\u28ff\u28fd\u2880\u28b7\u28fb\u2804\u2818\n\u28ff\u28b7\u28fb\u28ff\u28ff\u28f7\u28fb\u28ff\u28ff\u28ff\u2877\u281b\u28c1\u2880\u28c0\u28e4\u28f6\u28ff\u28db\u287f\u28ff\u28ee\u28fd\u287b\u28ff\u28ee\u28fd\u28fb\u28af\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ef\u2880\u28b8\u28ff\u2880\u2846\n\u2838\u28df\u28ef\u28ff\u28ff\u28f7\u28bf\u28fd\u28ff\u28ff\u28f7\u28ff\u28f7\u28c6\u2839\u28ff\u28f6\u28ef\u283f\u28ff\u28f6\u28df\u28fb\u28bf\u28f7\u28fd\u28fb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2880\u28ef\u28df\u2880\u2847\n\u28c7\u2839\u28df\u28fe\u28fb\u28ff\u28ff\u28be\u287d\u28ff\u28ff\u28ff\u28ff\u28ff\u28c6\u28b9\u28f6\u28ff\u28fb\u28f7\u28ef\u28df\u28ff\u28ff\u28fd\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2880\u287f\u2847\u28b8\u2847\n\u28ff\u28c6\u2839\u28f7\u287b\u28fd\u28ff\u28ef\u28bf\u28fd\u28fb\u28ff\u28ff\u28ff\u28ff\u28c6\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281b\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2807\u28b8\u28ff\u2807\u28fc\u2847\n\u2859\u283e\u28c6\u2839\u28ff\u28e6\u281b\u28ff\u28af\u28f7\u28bf\u287d\u28ff\u28ff\u28ff\u28ff\u28c6\u283b\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u2803\u280e\u28b8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u280f\u2880\u28ff\u28fe\u28e3\u287f\u2847\n\u28ff\u28f7\u284c\u28a6\u2819\u28ff\u28ff\u28cc\u283b\u28fd\u28af\u28ff\u28fd\u28fb\u28ff\u28ff\u28ff\u28e7\u2829\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u284f\u28b0\u28a3\u2818\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u2803\u2880\u2880\u28bf\u28de\u28f7\u28bf\u2847\n\u28ff\u28fd\u28c6\u2839\u28e7\u2818\u28ff\u28ff\u2877\u28cc\u2819\u28b7\u28ef\u2877\u28df\u28ff\u28ff\u28ff\u28f7\u2840\u2879\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28c8\u2803\u28f8\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281f\u2880\u28f4\u2867\u2880\u2838\u28ff\u287d\u28ff\u2880\n\u28bb\u28fd\u28ff\u2844\u28bb\u28f7\u2848\u28bf\u28ff\u28ff\u28a7\u2880\u2819\u28bf\u28fb\u287e\u28fd\u28fb\u28ff\u28ff\u28c4\u280c\u28bf\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u281b\u2881\u28f0\u28fe\u28df\u287f\u2880\u2844\u28bf\u28df\u28ff\u2880\n\u2844\u28bf\u28ff\u28f7\u2880\u2839\u28df\u28c6\u283b\u28ff\u28ff\u28c6\u2880\u28c0\u2809\u283b\u28ff\u287d\u28ef\u28ff\u28ff\u28f7\u28c8\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u2880\u28e0\u2818\u28ef\u28f7\u28ff\u285f\u2880\u2886\u2838\u28ff\u285f\u28b8\n\u28f7\u2848\u28bf\u28ff\u28c7\u28b1\u2858\u28bf\u28f7\u28ec\u28d9\u283f\u28e7\u2818\u28c6\u2880\u2808\u283b\u28f7\u28df\u28fe\u28bf\u28ff\u28c6\u2839\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u287f\u280b\u28e0\u285e\u28a1\u28ff\u2880\u28ff\u28ff\u28ff\u2807\u2844\u28b8\u2844\u28bb\u2847\u28fc\n\u28ff\u28f7\u2848\u28bf\u28ff\u2846\u28a3\u2840\u2819\u28be\u28df\u28ff\u28ff\u28f7\u2848\u2802\u2818\u28e6\u2848\u283f\u28ef\u28ff\u28be\u28ff\u28c6\u2819\u283b\u283f\u283f\u283f\u283f\u287f\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u283f\u281b\u288b\u28e0\u28fe\u285f\u28a0\u28ff\u28ff\u2880\u28ff\u28ff\u285f\u28a0\u28ff\u2888\u28e7\u2818\u28a0\u28ff\n\u28ff\u28ff\u28ff\u28c4\u283b\u28ff\u2844\u28b3\u2844\u2886\u2859\u283e\u28fd\u28ff\u28ff\u28c6\u2840\u28b9\u2877\u28c4\u2819\u28bf\u28ff\u287e\u28ff\u28c6\u2880\u2840\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u2880\u28c0\u28e0\u28f4\u287f\u28ef\u280f\u28e0\u28ff\u28ff\u284f\u28b8\u28ff\u287f\u2881\u28ff\u28ff\u2880\u28ff\u2806\u28b8\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28e6\u2859\u28ff\u28c6\u28bb\u284c\u28bf\u28f6\u28a4\u28c9\u28d9\u28ff\u28f7\u2840\u2819\u283d\u2837\u2804\u2839\u28ff\u28df\u28ff\u28c6\u2899\u28cb\u28e4\u28e4\u28e4\u28c4\u28c0\u2880\u2880\u2880\u2880\u28fe\u28ff\u28df\u2877\u28ef\u287f\u2883\u28fc\u28ff\u28ff\u28ff\u2807\u28fc\u285f\u28e1\u28ff\u28ff\u28ff\u2880\u287f\u28a0\u2808\u28ff\n\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28ee\u28ff\u28ff\u28ff\u284c\u2801\u28a4\u28e4\u28e4\u28e4\u28ec\u28ed\u28f4\u28f6\u28f6\u28f6\u28c6\u2808\u28bb\u28ff\u28ff\u28c6\u28bb\u28ff\u28ff\u28ff\u28ff\u28ff\u28ff\u28f7\u28f6\u28e4\u28cc\u28c9\u2858\u281b\u283b\u2836\u28ff\u28ff\u28ff\u28ff\u285f\u28f0\u28eb\u28f4\u28ff\u28ff\u28ff\u28ff\u2804\u28f7\u28ff\u28ff\u28ff\n*/\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class b {\n\t\n\t\n\tpublic static void main(String[] args) throws Exception {\n\n\t      Scanner s=new Scanner(System.in);\n\t      long v=0,x=0;\n\t      int n=s.nextInt();\n\t      pair[] arr=new pair[n];\n\t      for(int i=0;i<n;i++) {\n\t    \t  \n\t    \t   long a=s.nextLong();\n\t    \t   if(i==0) {\n\t    \t\t   v=a;\n\t    \t   }\n\t    \t   if(i==1) {\n\t    \t\t   x=a;\n\t    \t   }\n\t    \t   pair ob=new pair(a,i+1);\n\t    \t   arr[i]=ob;\n\t      }\n\t      \n\t      Arrays.sort(arr,new comp());\n\t      if(arr.length<=3) {\n\t    \t  System.out.println(1);\n\t      }else {\n\t    \t  int e=0;\n\t    \t  int f=0;\n\t    \t  int g=0;\n\t    \t  int in=arr[0].in;\n\t\t    \t int in2=arr[1].in;\n\t\t    \t int in3=arr[0].in;\n\t    \t long d=arr[1].val-arr[0].val;\n\t    \t \n\t    \t long curr=arr[1].val;\n\t    \t int flag=0;\n\t    \t int be=0;\n\t    \t for(int i=2;i<n;i++) {\n\t    \t\t if(flag==0) {\n\t    \t\t curr=curr+d;\n\t    \t\t \n\t    \t\t }\n\t    \t\t\n\t    \t\t if(arr[i].val!=curr&&flag==0&&be==0) {\n\t    \t\t\t flag=1;\n\t    \t\t\t in=arr[i].in;\n\t    \t\t\t be=1;\n\t    \t\t\t \n\t    \t\t }else if(arr[i].val!=curr&&be==1){\n\t    \t\t\t\n\t    \t\t\t g=1;\n\t    \t\t\t break;\n\t    \t\t }else if(arr[i].val==curr) {\n\t    \t\t\t flag=0;\n\t    \t\t }\n\t    \t }\n\t    \t  \n\t    \t d=arr[2].val-arr[0].val;\n\t    \t curr=arr[2].val;\n\t    \t \n\t    \t for(int i=3;i<n;i++) {\n\t    \t\t curr=curr+d;\n\t    \t\t if(arr[i].val!=curr) {\n\t    \t\t\t f=1;\n\t    \t\t\t break;\n\t    \t\t }\n\t    \t }\n\t    \t \n\t    \t \n\t    \t d=arr[2].val-arr[1].val;\n\t    \t curr=arr[2].val;\n\t    \t \n\t    \t for(int i=3;i<n;i++) {\n\t    \t\t \n\t    \t\t curr=curr+d;\n\t    \t\t if(arr[i].val!=curr) {\n\t    \t\t\n\t    \t\t\t e=1;\n\t    \t\t\t break;\n\t    \t\t }\n\t    \t }\n\t    \t\n\t    \t \n\t    \t if(g==0) {\n\t    \t\t\n\t    \t\t System.out.println(in);\n\t    \t\t \n\t    \t }else if(f==0) {\n\t    \t\t System.out.println(in2);\n\t    \t }else if(e==0) {\n\t    \t\t System.out.println(in3);\n\t    \t }else {\n\t    \t\t System.out.println(-1);\n\t    \t }\n\t    \t \n\t    \t  \n\t      }\n\t     \n\t      \n\t}\n}\n\nclass pair{\n\tlong val;\n\tint in;\n\tpublic pair(long val,int in) {\n\t\tthis.val=val;\n\t\tthis.in=in;\n\t}\n}\n\nclass comp implements Comparator<pair>{\n\tpublic int compare(pair h, pair j) {\n\t\t\n\t\tif(h.val<j.val) {\n\t\t\treturn -1;\n\t\t}else if(h.val==j.val) {\n\t\t\treturn 0;\n\t\t}else {\n\t\t\treturn 1;\n\t\t}\n\t\t\n\t\t\n\t}\n}", "label": 5}
{"src": "import java.util.Scanner;\nimport java.util.Arrays;\npublic class D_568{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint[] A = new int[n];\n\t\tint[] D = new int[n];\n\t\tint ans = -1;\n\t\tfor (int i =0 ; i<n ; i++){\n\t\t\tA[i] = sc.nextInt();\n\t\t\tD[i] = A[i];\n\t\t}\n\t\tArrays.sort(A);\n\t\tint c = A[1] - A[0];\n\t\tint res = -1; int counter = 0;boolean cond = false;\n\t\tfor (int i = 1 ; i<n-2 ;i++)\n\t\t\tif((A[i] - A[i-1])!= A[i+1] - A[i])\n\t\t\t{\n\t\t\t\tcond = true;\n\t\t\t\tif ( A[i+2] - A[i+1]== A[i+1] - A[i-1]  && res!=i)\n\t\t\t\t{\n\t\t\t\t\tres = i;\n\t\t\t\t\tc = A[i+2] - A[i+1];\n\t\t\t\t}\n\t\t\t\telse if ( A[i+2] - A[i]== A[i] - A[i-1] && res!=i+1)\n\t\t\t\t{\n\t\t\t\t\tres = i+1;\n\t\t\t\t\tc = A[i+2] - A[i];\n\t\t\t\t}\n\t\t\t\telse if ( A[i+2] - A[i+1]== A[i+1] - A[i] && res!=i-1)\n\t\t\t\t{\n\t\t\t\t\tres = i-1;\n\t\t\t\t\tc = A[i+1] - A[i];\n\t\t\t\t}\n\t\t\t\t// else res = i;\n\t\t\t}\n\t\tif  (A[n-1] - A[n-2]!=c && res==-1){\n\t\t\t\tres = n-1;\n\t\t}\n\n\t\t\tint first = res==0?A[1]:A[0];\n\t\t\t// System.out.println(c + \" \" + first + \" \" + A[res]) ;\n\t\t\tfor (int i = 0 ; i < n ; i++){\n\t\t\t\tint expexted = 0;\n\t\t\t\tif (res!=-1 && i >res)\n\t\t\t\t\texpexted = first + c * i - c;\n\t\t\t\telse if (res==-1 || i < res)\n\t\t\t\t\texpexted = first + c * i;\n\t\t\t\tif (A[i]!= expexted)\n\t\t\t\t{\n\t\t\t\t\tcounter++;\n\t\t\t\t\tif (counter>1)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (counter==1)\n\t\t\t{\n\t\t\t\tfor (int i = 0 ; i <n ;i++)\n\t\t\t\t{\n\t\t\t\t\tif (D[i]==A[res])\n\t\t\t\t\t{\n\t\t\t\t\t\tans = i+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (counter == 0)\n\t\t\t{\n\t\t\t\tfor (int i =0 ; i<n ;i++)\n\t\t\t\t\tif (D[i] == A[0])\n\t\t\t\t\t{\n\t\t\t\t\t\tans = i+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\n", "label": 5}
{"src": "import javafx.util.Pair;\nimport sun.net.www.content.text.Generic;\n\nimport static java.lang.Double.parseDouble;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Integer.reverse;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.abs;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.System.exit;\nimport static java.util.Comparator.comparingInt;\nimport static java.util.Map.Entry.comparingByValue;\nimport static java.util.stream.Collectors.toMap;\n\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.*;\n\npublic class Solution {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    class Pair implements Comparable<Pair> {\n        int value, i;\n        Pair(int value, int i) {\n            this.value = value;\n            this.i = i;\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            return Integer.compare(value, o.value);\n        }\n    }\n\n    int n;\n    Pair a[];\n    boolean test(int ind) {\n        int b[] = new int[n-1], j = 0;\n        for(int i = 0; i < n; i++) if(i != ind) b[j++] = a[i].value;\n        for(int i = 1; i < n - 1; i++) if(b[i] - b[i-1] != b[1] - b[0] || b[i] - b[i-1] != b[n-2] - b[n-3]) return false;\n        return true;\n    }\n\n    void solve() throws Exception {\n        n = nextInt();\n        if(n <= 2) {\n            out.print(1);\n            return;\n        }\n        a = new Pair[n];\n        for(int i = 0; i < n; i++) a[i] = new Pair(nextInt(), i + 1);\n        int mx = Integer.MIN_VALUE, ans = 1;\n        for(int i = 0; i < n; i++) if(a[i].value > mx) { ans = i + 1; mx = a[i].value; }\n        Arrays.sort(a);\n        for(int i = 1; i < n; i++) if(a[i].value - a[i-1].value != a[1].value - a[0].value || a[i].value - a[i-1].value != a[n-1].value - a[n-2].value) {\n            if(test(i-1)) out.print(a[i-1].i);\n            else if(test(i)) out.print(a[i].i);\n            else if(test(0)) out.print(a[0].i);\n            else if(test(1)) out.print(a[1].i);\n            else if(test(n-1)) out.print(a[n-1].i);\n            else if(test(n-2)) out.print(a[n-2].i);\n            else out.print(-1);\n            return;\n        }\n        out.print(ans);\n    }\n\n    // call it like this: lower_bound(a, x + 1) ( /!\\ + 1 )\n    public static int lower_bound(int[] a, int v) {\n        int low = -1, high = a.length;\n        while (high - low > 1) {\n            int h = high + low >>> 1;\n            if (a[h] >= v) {\n                high = h;\n            } else {\n                low = h;\n            }\n        }\n        return high;\n    }\n\n    private String getFraction(int a, int b) {\n        assert b != 0;\n        String sign = (a > 0 && b > 0) || (a < 0) && (b < 0) ? \"+\" : \"-\";\n        a = abs(a);\n        b = abs(b);\n        int gcd = gcd(a, b);\n        return sign + (a / gcd) + \"/\" + (b / gcd);\n    }\n\n    private int gcd(int a, int b) {\n        while (b > 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    private int lcm(int a, int b) {\n        return a * (b / gcd(a, b));\n    }\n\n    public static int[] radixSort(int[] f) {\n        if (f.length < 100) {\n            Arrays.sort(f);\n            return f;\n        }\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for (int i = 0; i < f.length; i++) b[1 + (f[i] & 0xffff)]++;\n            for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];\n            for (int i = 0; i < f.length; i++) to[b[f[i] & 0xffff]++] = f[i];\n            int[] d = f;\n            f = to;\n            to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for (int i = 0; i < f.length; i++) b[1 + (f[i] >>> 16)]++;\n            for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];\n            for (int i = 0; i < f.length; i++) to[b[f[i] >>> 16]++] = f[i];\n            int[] d = f;\n            f = to;\n            to = d;\n        }\n        return f;\n    }\n\n    public static boolean nextPermutation(int[] a) {\n        int n = a.length;\n        int i;\n        for (i = n - 2; i >= 0 && a[i] >= a[i + 1]; i--) ;\n        if (i == -1)\n            return false;\n        int j;\n        for (j = i + 1; j < n && a[i] < a[j]; j++) ;\n        int d = a[i];\n        a[i] = a[j - 1];\n        a[j - 1] = d;\n        for (int p = i + 1, q = n - 1; p < q; p++, q--) {\n            d = a[p];\n            a[p] = a[q];\n            a[q] = d;\n        }\n        return true;\n    }\n\n    void print(Object x) {\n        out.print(String.valueOf(x));\n        out.flush();\n    }\n\n    void println(Object x) {\n        out.println(String.valueOf(x));\n        out.flush();\n    }\n\n    // for Map with custom key/value, override toString in your custom class\n    void printMap(Map map) {\n        if (map.keySet().size() == 0) return;\n        Object firstValue = map.keySet().iterator().next();\n        if (map.get(firstValue) instanceof Queue || map.get(firstValue) instanceof List) {\n            for (Object key : map.keySet()) {\n                out.print(String.valueOf(key) + \": \");\n                Collection values = (Collection) map.get(key);\n                for (Object value : values) out.print(String.valueOf(value) + \" \");\n                out.println();\n            }\n        } else if (map.get(firstValue).getClass().isArray()) {\n            for (Object key : map.keySet()) {\n                out.print(String.valueOf(key) + \": \");\n                Object[] values = (Object[]) map.get(key);\n                for (Object value : values) out.print(String.valueOf(value) + \" \");\n                out.println();\n            }\n        } else {\n            for (Object key : map.keySet()) {\n                out.println(String.valueOf(key) + \": \" + map.get(key));\n            }\n        }\n    }\n\n    private int[] na(int n) throws IOException {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = nextInt();\n        return a;\n    }\n\n    private long[] nal(int n) throws IOException {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nextLong();\n        return a;\n    }\n\n    int nextInt() throws IOException {\n        return parseInt(next());\n    }\n\n    long nextLong() throws IOException {\n        return parseLong(next());\n    }\n\n    double nextDouble() throws IOException {\n        return parseDouble(next());\n    }\n\n    String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    public static void main(String[] args) throws Exception {\n        try {\n            boolean isLocal = false;\n            if (isLocal) {\n                in = new BufferedReader(new FileReader(\"mr_x.txt\"));\n                out = new PrintWriter(new BufferedWriter(new FileWriter(\"solution.out\")));\n            } else {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(new OutputStreamWriter(System.out));\n            }\n\n            //long lStartTime = System.currentTimeMillis();\n            new Solution().solve();\n            //long lEndTime = System.currentTimeMillis();\n            //out.println(\"Elapsed time in seconds: \" + (double)(lEndTime - lStartTime) / 1000.0);\n            in.close();\n            out.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n}", "label": 5}
{"src": "//package cf568d2;\nimport java.util.*;\npublic class D {\n    public static void main(String[]args){\n        Scanner sc=new Scanner(System.in);\n        int n=sc.nextInt();\n        Integer[]a=new Integer[n];\n        HashMap<Integer,Integer>rlkup=new HashMap<Integer,Integer>();\n        for(int i=0;i<n;i++) {\n            a[i] = sc.nextInt();\n            rlkup.put(a[i],i+1);\n        }\n        Arrays.sort(a);\n        HashMap<Integer,Integer>dels=new HashMap<Integer,Integer>();\n        for(int i=1;i<n;i++){\n            int d=a[i]-a[i-1];\n            dels.put(d,dels.containsKey(d)?dels.get(d)+1:1);\n        }\n        int delta=-1;\n        int ct=0;\n        for(int d:dels.keySet())\n            if(dels.get(d)>ct||(dels.get(d)==ct&&d>delta)){\n                delta=d;\n                ct=dels.get(d);\n            }\n        if(ct==n-1)\n            System.out.println(rlkup.get(a[0]));\n        else if(ct==n-2){\n            if(a[1]-a[0]!=delta)\n                System.out.println(rlkup.get(a[0]));\n            else if(a[n-1]-a[n-2]!=delta)\n                System.out.println(rlkup.get(a[n-1]));\n            else if(delta!=0&&dels.containsKey(0)){\n                int i=1;\n                while(a[i]!=a[i-1])\n                    i++;\n                System.out.println(rlkup.get(a[i]));\n            }else\n                System.out.println(-1);\n        }else if(ct==n-3&&(delta==0||!dels.containsKey(0))){\n            int i=1;\n            while(a[i]-a[i-1]==delta)\n                i++;\n            if(a[i+1]-a[i-1]==delta)\n                System.out.println(rlkup.get(a[i]));\n            else\n                System.out.println(-1);\n        }else\n            System.out.println(-1);\n    }\n}\n", "label": 5}
{"src": "import java.util.*;\nimport java.io.*;\npublic class CF1185D {\n    static int n;\n    public static void main(String[] args) throws IOException{\n        BufferedReader file = new BufferedReader(new InputStreamReader(System.in));\n        n = Integer.parseInt(file.readLine());\n        StringTokenizer st = new StringTokenizer(file.readLine());\n        int[][] arr = new int[n][2];\n        for (int i=0; i<n; i++){\n            arr[i] = new int[] {Integer.parseInt(st.nextToken()), i+1};\n        }\n        Arrays.sort(arr, (a, b) -> a[0]-b[0]);\n        int[] d = new int[n-1];\n        for (int i=1; i<n; i++){\n            d[i-1] = arr[i][0]-arr[i-1][0];\n        }\n        // let's check if all the diff equal in the first place\n        boolean good = true;\n        for (int i=2; i<n-1; i++){\n            if (d[i] != d[1]){\n                good = false;\n                break;\n            }\n        }\n        if (good){\n            // if all diff equal in the first place, then we can just remove the first elem\n            System.out.println(arr[0][1]);\n            return;\n        }\n        // if we get here, than we know there must be a \"bad element\" that has a different diff than the first. We want to locate where\n        // that bad elem is. But first, we need to know which is the correct diff. This is a boolean situation, becuase there can't be\n        // 2 correct diffs. We will just check whether the first diff (between index 0-1) is the correct one. How do we check? What if we remove the second\n        // element, we could have the diff of index 0-2. Then, if every other val in the d[] is == diff of 0-2,  that means we have found the\n        // correct elemnt to remove, which is the second elem. Else, if there are other differences, that means the second elem must not be the answer.\n        // Although we can still output -1. we are sure that the difference between 0-1 is correct. (Since elem 2 is not the ans);\n        good = true;\n        for (int i=2; i<n-1; i++){\n            if (arr[2][0]-arr[0][0] != d[i]){\n                good = false;\n                break;\n            }\n        }\n        if (good){\n            // All other differences equal to 0-2 (removing second elem)\n            System.out.println(arr[1][1]);\n            return;\n        }\n        boolean f = false;\n        int ans = 0;\n        for (int i=1; i<n-1; i++){\n            if (d[i] == d[0]){\n                continue;\n            }\n            if (f){\n                // we already had a bad elem\n                System.out.println(-1);\n                return;\n            }else{\n                if (i == n-2){\n                    // we don't have an elem to delete anymore, but everything before it is good. So, just remove the last\n                    System.out.println(arr[n-1][1]);\n                    return;\n                }\n                // try to remove the i+1 term and go to i+2\n                if (arr[i+2][0]-arr[i][0] == d[0]){\n                    f = true;\n                    ans = arr[i+1][1];\n                    i++; // we skipped an elem, no point to check that\n                }else{\n                    // no solution\n                    System.out.println(-1);\n                    return;\n                }\n            }\n        }\n        if (f){\n            // found ans\n            System.out.println(ans);\n        }else{\n            // no ans found, but didn't return -1, that means we can return the last elem\n            System.out.println(arr[n-1][1]);\n        }\n    }\n}", "label": 5}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Vaibhav Pulastya\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DExtraElement solver = new DExtraElement();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DExtraElement {\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            node[] b = new node[n];\n\n            if (n == 2) {\n                out.println(1);\n                return;\n            }\n\n            for (int i = 1; i <= n; i++) {\n                b[i - 1] = new node(in.nextInt(), i);\n            }\n\n            Arrays.sort(b, new Comparator<node>() {\n\n                public int compare(node o1, node o2) {\n                    return Long.compare(o1.val, o2.val);\n                }\n            });\n\n            long d1 = b[1].val - b[0].val;\n            int toRem = -1;\n            boolean ok = true;\n            for (int i = 2; i < n; i++) {\n                long diff = b[i].val - b[i - 1].val;\n                if (diff != d1) {\n                    if (toRem != -1) {\n                        ok = false;\n                        break;\n                    } else if (i == n - 1) {\n                        toRem = i;\n                    } else if (b[i + 1].val - b[i].val == d1 && b[i].val - b[i - 2].val == d1) {\n                        toRem = i - 1;\n                        i++;\n                    } else if (b[i + 1].val - b[i - 1].val == d1) {\n                        toRem = i;\n                        i++;\n                    } else {\n                        ok = false;\n                        break;\n                    }\n                }\n            }\n\n            if (toRem != -1 && ok) {\n                out.println(b[toRem].ind);\n                return;\n            }\n\n            d1 = b[2].val - b[0].val;\n            ok = true;\n            for (int i = 3; i < n; i++) {\n                long diff = b[i].val - b[i - 1].val;\n                if (diff != d1) {\n                    ok = false;\n                    break;\n                }\n            }\n            if (ok) {\n                out.println(b[1].ind);\n                return;\n            }\n\n            d1 = b[2].val - b[1].val;\n            ok = true;\n            for (int i = 3; i < n; i++) {\n                long diff = b[i].val - b[i - 1].val;\n                if (diff != d1) {\n                    ok = false;\n                    break;\n                }\n            }\n\n            if (ok) {\n                out.println(b[0].ind);\n            } else {\n                out.println(-1);\n            }\n\n        }\n\n        class node {\n            long val;\n            int ind;\n\n            node(long v, int idx) {\n                val = v;\n                ind = idx;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "label": 5}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class extraelement {\n    public static void main(String[] args) throws IOException {\n        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));\n        int N = Integer.parseInt(f.readLine());\n        ArrayList<int[]> arr = new ArrayList<>(N);\n        StringTokenizer st = new StringTokenizer(f.readLine());\n        for (int i = 1; i <= N; i++) {\n            arr.add(new int[]{Integer.parseInt(st.nextToken()), i});\n        }\n        Collections.sort(arr, new Comparator<int[]>() {\n            @Override\n            public int compare(int[] ints, int[] t1) {\n                return Integer.compare(ints[0], t1[0]);\n            }\n        });\n        HashMap<Integer, Integer> differences = new HashMap<>();\n        for (int i = 0; i < N-1; i++) {\n            differences.putIfAbsent(arr.get(i+1)[0] - arr.get(i)[0], 0);\n            differences.replace(arr.get(i+1)[0] - arr.get(i)[0], differences.get(arr.get(i+1)[0] - arr.get(i)[0])+1);\n            if (differences.size() > 3) {\n                System.out.println(-1);\n                System.exit(0);\n            }\n        }\n        if (differences.size() == 1) {\n            System.out.println(arr.get(0)[1]);\n        }\n        else {\n            if (differences.size() == 2) {\n                int firstRemove = arr.get(1)[0] - arr.get(0)[0];\n                if (differences.get(firstRemove) == 1) {\n                    System.out.println(arr.get(0)[1]);\n                    System.exit(0);\n                }\n                else if (differences.get(arr.get(N-1)[0] - arr.get(N-2)[0]) == 1) {\n                    System.out.println(arr.get(N-1)[1]);\n                    System.exit(0);\n                }\n                for (int val : differences.keySet()) {\n                    if (val == 0 && differences.get(val) == 1) {\n                        for (int i = 0; i < N; i++) {\n                            if (arr.get(i+1)[0] - arr.get(i)[0] == 0) {\n                                System.out.println(arr.get(i)[1]);\n                                System.exit(0);\n                            }\n                        }\n                    }\n                }\n            }\n            for (int i = 1; i < N - 1; i++) {\n                int firstdif = arr.get(i + 1)[0] - arr.get(i)[0];\n                int secondif = arr.get(i)[0] - arr.get(i - 1)[0];\n                if (differences.get(firstdif) <= 2 && differences.get(secondif) <= 2) {\n                    int otherValue = 0;\n                    for (int val : differences.keySet()) {\n                        if (val != firstdif && val != secondif) {\n                            otherValue = val;\n                        }\n                    }\n                    if (firstdif + secondif == otherValue) {\n                        differences.replace(firstdif, differences.get(firstdif) - 1);\n                        differences.replace(secondif, differences.get(secondif) - 1);\n                        int countChange = 0;\n                        if (differences.get(firstdif) == 0) {\n                            countChange++;\n                        }\n                        if (differences.get(secondif) == 0) {\n                            countChange++;\n                        }\n                        if (differences.size() - countChange <= 1) {\n                            System.out.println(arr.get(i)[1]);\n                            System.exit(0);\n                        } else {\n                            System.out.println(-1);\n                            System.exit(0);\n                        }\n                    }\n                }\n//                else {\n//                    i++;\n//                }\n            }\n            System.out.println(-1);\n        }\n    }\n}\n", "label": 5}
{"src": "//package test_1185D;\n\nimport java.util.*;\n\npublic class test_1185d5 {\n    public  static  void main(String[] args){\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int j = 0, i =0 , k =0, z =0, delta =0, delta1 = 0;\n        Set<Integer> TestList = new TreeSet<>();\n        Integer number = -1;\n        int[] b = new int[n];\n        Map<Integer, Integer> myKeays = new HashMap<Integer,Integer>();\n        ArrayList<Integer> b_sort = new ArrayList<Integer>(n);\n        for ( i=0; i< n; i++){\n            b[i] = sc.nextInt();\n            b_sort.add(b[i]);\n        }\n        Collections.sort(b_sort);\n        // \u0438\u0449\u0435\u043c \u0443\u0437\u043b\u044b \u0432 \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438\n        TestList.add(0);\n        for (i=0; i< n-2; i++){\n            if(b_sort.get(i+1) - b_sort.get(i) != b_sort.get(i+2) - b_sort.get(i+1)){\n                TestList.add(i);\n                TestList.add(i+1);\n                TestList.add(i+2);\n            }\n        }\n\n        // \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0435\u043c \u0433\u0438\u043f\u043e\u0442\u0438\u0437\u0443 \u043e\u0431 \u044d\u043b\u0435\u043c\u0435\u043d\u0442\u0435 \u043d\u0435 \u0432\u043a\u043b\u044e\u0447\u0435\u043d\u043d\u044b\u043c \u0432 \u0430\u0440\u0438\u0444\u043c\u0438\u0442\u0438\u0447\u0435\u0441\u043a\u0443\u044e \u043f\u043e\u0441\u043b\u0435\u0434\u043e\u0432\u0430\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c\n        for(i =0; i<n-1;i++){\n            delta = b_sort.get(i+1) - b_sort.get(i);\n\n            number = myKeays.get(delta);\n            myKeays.put(delta, number == null? 1: number + 1);\n\n//                number = myKeays.getOrDefault(delta, myDefault);\n//                if (number == myDefault){\n//                    myKeays.put(delta,1);\n//                }else{\n//                    myKeays.replace(delta,++number);\n//                }\n//                // \u0442\u0435\u0441\u0442\u0438\u0440\u0443\u0435\u043c \u043d\u0430 \u043e\u0442\u0441\u0443\u0442\u0432\u0438\u0435 \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u0447\u0435\u0441\u043a\u043e\u0439 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0438\u0438\n        }\n        k  = 0;\n        if(myKeays.size() > 1){\n            for (Map.Entry<Integer,Integer> e: myKeays.entrySet()  ) {\n                if (e.getValue() >= 3){\n                    k++;\n                    if(k >= 2){\n                        System.out.println(-1);\n                        System.exit(0);\n                    }\n                }\n\n            }\n        }else{\n            //            System.out.println(1);\n            //            System.exit(0);\n\n        }\n\n\n\n        for (Integer aItem: TestList){\n            i = (int) aItem;\n            z = -1;\n            ArrayList<Integer>  arr = new ArrayList<Integer>(b_sort);\n            arr.remove(i);\n            delta = 0;\n            if(arr.size() >= 2){\n                delta = arr.get(1) - arr.get(0);\n\n            }\n            k = arr.size() - 1;\n            if(arr.get(0) + k * delta == arr.get(k) ) {\n                myKeays.put(delta,1);\n                for (k = 1; k < arr.size(); k++) {\n                    delta1 = arr.get(k) - arr.get(k - 1);\n                    //number = myKeays.get(delta1);\n                    if (delta != delta1) {\n                        break;\n                    }\n\n                }\n            }\n            if (k == arr.size()){\n                z = i;\n                break;\n            }\n        }\n        // \u0438\u0449\u0435\u043c \u044d\u043b\u0435\u043c\u0435\u043d\u0442\n        if(z >= 0){\n            for(i =0; i<n; i++){\n                if(b[i] == b_sort.get(z)){\n                    z = i +1;\n                    break;\n                }\n            }\n        }\n        System.out.println(z);\n    }\n\n}\n", "label": 5}
{"src": "\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.util.*;\n\npublic class CFContest {\n    public static void main(String[] args) throws Exception {\n        boolean local = System.getProperty(\"ONLINE_JUDGE\") == null;\n        boolean async = false;\n\n        Charset charset = Charset.forName(\"ascii\");\n\n        FastIO io = local ? new FastIO(new FileInputStream(\"D:\\\\DATABASE\\\\TESTCASE\\\\Code.in\"), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, \"dalt\", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(\"\\n\\n--memory -- \\n\" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + \"M\");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e9 + 2;\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            //bruteForce();\n            solve();\n        }\n\n        int n;\n        int[][] data;\n\n        public void solve() {\n            n = io.readInt();\n            data = new int[n + 1][2];\n            for (int i = 1; i <= n; i++) {\n                data[i][0] = io.readInt();\n                data[i][1] = i;\n            }\n            Arrays.sort(data, 1, n + 1, (a, b) -> a[0] - b[0]);\n            if (n == 2) {\n                io.cache.append(1);\n                return;\n            }\n\n            int max = Math.max(test(data[2][0] - data[1][0]), test(data[3][0] - data[2][0]));\n            max = Math.max(max, test(data[3][0] - data[1][0]));\n            if (max == -1) {\n                io.cache.append(-1);\n            } else {\n                io.cache.append(data[max][1]);\n            }\n        }\n\n        public int test(int k) {\n            int chance = 1;\n            int index = -1;\n            for (int i = 2; i <= n; i++) {\n                if (data[i][0] - data[i - 1][0] != k) {\n                    if (chance == 0) {\n                        return -1;\n                    }\n                    chance--;\n                    if (i == 2) {\n                        if (data[3][0] - data[1][0] == k) {\n                            index = 2;\n                            i++;\n                        } else {\n                            index = 1;\n                        }\n                    } else {\n                        index = i;\n                        if (i == n) {\n                            continue;\n                        } else if (i + 1 <= n && data[i + 1][0] - data[i - 1][0] == k) {\n                            i++;\n                        } else {\n                            return -1;\n                        }\n                    }\n                }\n            }\n            if (index == -1) {\n                return 1;\n            }\n            return index;\n        }\n    }\n\n    public static class Randomized {\n        static Random random = new Random();\n\n        public static double nextDouble(double min, double max) {\n            return random.nextDouble() * (max - min) + min;\n        }\n\n        public static void randomizedArray(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static void randomizedArray(long[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                long tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static void randomizedArray(double[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                double tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static void randomizedArray(float[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                float tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static <T> void randomizedArray(T[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                T tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n    }\n\n\n    public static class Splay implements Cloneable {\n        public static final Splay NIL = new Splay();\n\n        static {\n            NIL.left = NIL;\n            NIL.right = NIL;\n            NIL.father = NIL;\n            NIL.size = 0;\n            NIL.key = Integer.MIN_VALUE;\n            NIL.sum = 0;\n        }\n\n        Splay left = NIL;\n        Splay right = NIL;\n        Splay father = NIL;\n        int size = 1;\n        int key;\n        long sum;\n\n        public static void splay(Splay x) {\n            if (x == NIL) {\n                return;\n            }\n            Splay y, z;\n            while ((y = x.father) != NIL) {\n                if ((z = y.father) == NIL) {\n                    y.pushDown();\n                    x.pushDown();\n                    if (x == y.left) {\n                        zig(x);\n                    } else {\n                        zag(x);\n                    }\n                } else {\n                    z.pushDown();\n                    y.pushDown();\n                    x.pushDown();\n                    if (x == y.left) {\n                        if (y == z.left) {\n                            zig(y);\n                            zig(x);\n                        } else {\n                            zig(x);\n                            zag(x);\n                        }\n                    } else {\n                        if (y == z.left) {\n                            zag(x);\n                            zig(x);\n                        } else {\n                            zag(y);\n                            zag(x);\n                        }\n                    }\n                }\n            }\n\n            x.pushDown();\n            x.pushUp();\n        }\n\n        public static void zig(Splay x) {\n            Splay y = x.father;\n            Splay z = y.father;\n            Splay b = x.right;\n\n            y.setLeft(b);\n            x.setRight(y);\n            z.changeChild(y, x);\n\n            y.pushUp();\n        }\n\n        public static void zag(Splay x) {\n            Splay y = x.father;\n            Splay z = y.father;\n            Splay b = x.left;\n\n            y.setRight(b);\n            x.setLeft(y);\n            z.changeChild(y, x);\n\n            y.pushUp();\n        }\n\n        public void setLeft(Splay x) {\n            left = x;\n            x.father = this;\n        }\n\n        public void setRight(Splay x) {\n            right = x;\n            x.father = this;\n        }\n\n        public void changeChild(Splay y, Splay x) {\n            if (left == y) {\n                setLeft(x);\n            } else {\n                setRight(x);\n            }\n        }\n\n        public void pushUp() {\n            if (this == NIL) {\n                return;\n            }\n            size = left.size + right.size + 1;\n            sum = left.sum + right.sum + key;\n        }\n\n        public void pushDown() {\n        }\n\n        public static int toArray(Splay root, int[] data, int offset) {\n            if (root == NIL) {\n                return offset;\n            }\n            offset = toArray(root.left, data, offset);\n            data[offset++] = root.key;\n            offset = toArray(root.right, data, offset);\n            return offset;\n        }\n\n        public static void toString(Splay root, StringBuilder builder) {\n            if (root == NIL) {\n                return;\n            }\n            root.pushDown();\n            toString(root.left, builder);\n            builder.append(root.key).append(',');\n            toString(root.right, builder);\n        }\n\n        public Splay clone() {\n            try {\n                return (Splay) super.clone();\n            } catch (CloneNotSupportedException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public static Splay cloneTree(Splay splay) {\n            if (splay == NIL) {\n                return NIL;\n            }\n            splay = splay.clone();\n            splay.left = cloneTree(splay.left);\n            splay.right = cloneTree(splay.right);\n            return splay;\n        }\n\n        public static Splay add(Splay root, Splay node) {\n            if (root == NIL) {\n                return node;\n            }\n            Splay p = root;\n            while (root != NIL) {\n                p = root;\n                root.pushDown();\n                if (root.key < node.key) {\n                    root = root.right;\n                } else {\n                    root = root.left;\n                }\n            }\n\n            if (p.key < node.key) {\n                p.setRight(node);\n            } else {\n                p.setLeft(node);\n            }\n            p.pushUp();\n            splay(node);\n            return node;\n        }\n\n        /**\n         * Make the node with the minimum key as the root of tree\n         */\n        public static Splay selectMinAsRoot(Splay root) {\n            if (root == NIL) {\n                return root;\n            }\n            root.pushDown();\n            while (root.left != NIL) {\n                root = root.left;\n                root.pushDown();\n            }\n            splay(root);\n            return root;\n        }\n\n        /**\n         * Make the node with the maximum key as the root of tree\n         */\n        public static Splay selectMaxAsRoot(Splay root) {\n            if (root == NIL) {\n                return root;\n            }\n            root.pushDown();\n            while (root.right != NIL) {\n                root = root.right;\n                root.pushDown();\n            }\n            splay(root);\n            return root;\n        }\n\n        /**\n         * delete root of tree, then merge remain nodes into a new tree, and return the new root\n         */\n        public static Splay deleteRoot(Splay root) {\n            root.pushDown();\n            Splay left = splitLeft(root);\n            Splay right = splitRight(root);\n            return merge(left, right);\n        }\n\n        /**\n         * detach the left subtree from root and return the root of left subtree\n         */\n        public static Splay splitLeft(Splay root) {\n            root.pushDown();\n            Splay left = root.left;\n            left.father = NIL;\n            root.setLeft(NIL);\n            root.pushUp();\n            return left;\n        }\n\n        /**\n         * detach the right subtree from root and return the root of right subtree\n         */\n        public static Splay splitRight(Splay root) {\n            root.pushDown();\n            Splay right = root.right;\n            right.father = NIL;\n            root.setRight(NIL);\n            root.pushUp();\n            return right;\n        }\n\n\n        public static Splay merge(Splay a, Splay b) {\n            if (a == NIL) {\n                return b;\n            }\n            if (b == NIL) {\n                return a;\n            }\n            a = selectMaxAsRoot(a);\n            a.setRight(b);\n            a.pushUp();\n            return a;\n        }\n\n        public static Splay selectKthAsRoot(Splay root, int k) {\n            if (root == NIL) {\n                return NIL;\n            }\n            Splay trace = root;\n            Splay father = NIL;\n            while (trace != NIL) {\n                father = trace;\n                trace.pushDown();\n                if (trace.left.size >= k) {\n                    trace = trace.left;\n                } else {\n                    k -= trace.left.size + 1;\n                    if (k == 0) {\n                        break;\n                    } else {\n                        trace = trace.right;\n                    }\n                }\n            }\n            splay(father);\n            return father;\n        }\n\n        public static Splay selectKeyAsRoot(Splay root, int k) {\n            if (root == NIL) {\n                return NIL;\n            }\n            Splay trace = root;\n            Splay father = NIL;\n            Splay find = NIL;\n            while (trace != NIL) {\n                father = trace;\n                trace.pushDown();\n                if (trace.key > k) {\n                    trace = trace.left;\n                } else {\n                    if (trace.key == k) {\n                        find = trace;\n                        trace = trace.left;\n                    } else {\n                        trace = trace.right;\n                    }\n                }\n            }\n\n            splay(father);\n            if (find != NIL) {\n                splay(find);\n                return find;\n            }\n            return father;\n        }\n\n        public static Splay bruteForceMerge(Splay a, Splay b) {\n            if (a == NIL) {\n                return b;\n            } else if (b == NIL) {\n                return a;\n            }\n            if (a.size < b.size) {\n                Splay tmp = a;\n                a = b;\n                b = tmp;\n            }\n\n            a = selectMaxAsRoot(a);\n            int k = a.key;\n            while (b != NIL) {\n                b = selectMinAsRoot(b);\n                if (b.key >= k) {\n                    break;\n                }\n                Splay kickedOut = b;\n                b = deleteRoot(b);\n                a = add(a, kickedOut);\n            }\n            return merge(a, b);\n        }\n\n        public static Splay[] split(Splay root, int key) {\n            if (root == NIL) {\n                return new Splay[]{NIL, NIL};\n            }\n            Splay p = root;\n            while (root != NIL) {\n                p = root;\n                root.pushDown();\n                if (root.key > key) {\n                    root = root.left;\n                } else {\n                    root = root.right;\n                }\n            }\n\n            splay(p);\n            if (p.key <= key) {\n                return new Splay[]{p, splitRight(p)};\n            } else {\n                return new Splay[]{splitLeft(p), p};\n            }\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder builder = new StringBuilder().append(key).append(\":\");\n            toString(cloneTree(this), builder);\n            return builder.toString();\n        }\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder();\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(\"ascii\"));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() {\n            try {\n                os.write(cache.toString().getBytes(charset));\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + \" = \");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n}", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\nimport java.lang.reflect.Array;\n\npublic class D {\n    static final int MOD = 1000000007; // 1e9 + 7\n    static final boolean AUTO_FLUSH = false; // slow if true\n    // int = num(); // long = ll();\n    // string = next(); // a string line = line();\n    // ---------------------------------- \\\n    Pair[] arr;\n    void main() throws Exception {\n        int n = num();\n        arr = new Pair[n];\n        // boolean yes = false;\n        for (int i = 0; i < n; i++) {\n            arr[i] = Pair.of(num(), i);\n            // if (i == 0 && arr[0].a == 9610870)\n            //     yes = true;\n        }\n        // if (yes) {\n        //     outln(arr[177522-1].a);\n        //     return;\n        // }\n        Arrays.sort(arr);\n        if (arr.length <= 3) {\n            outln(1);\n            return;\n        }\n        int[] ar = new int[] {sel(1, 2), sel(2, 3), sel(0, 1), sel(0, 2), sel(1, 3)};\n        HashMap<Integer, Integer> map = new HashMap<>();\n        for (int i : ar)\n            map.put(i, map.get(i) == null ? 1 : map.get(i)+1);\n        int sel = -1;\n        for (int i : ar) {\n            if (map.get(i) > 1) {\n                sel = i;\n                break;\n            }\n        }\n        if (sel == -1) {\n            outln(-1);\n            return;\n        }\n        int ans = -2;\n        for (int i = 1; i < n; i++) {\n            if (sel(i-(i-1 == ans ? 2 : 1), i) != sel) {\n                if (ans == -2) {\n                    ans = i == 1 && sel(1, 2) == sel ? 0 : i;\n                } else {\n                    ans = -1;\n                    break;\n                }\n            }\n        }\n        // if (yes) {\n        //     outln(sel);\n        //     return;\n        // }\n        if (ans >= 0)\n            ans = arr[ans].b+1;\n        outln(ans == -2 ? arr[0].b+1 : ans);\n    }\n    int sel(int a, int b) {\n        return arr[b].a-arr[a].a;\n    }\n    // ---------------------------------- \\\n    //#region\n    public static void main(String[] args) throws Exception {\n        new Thread(null, () -> {\n            try {\n                if (!ONLINE_JUDGE)\n                    startTime();\n                new D().main();\n                boolean endsWithEnter = TO_BE_PRINTED.length() == 0 || TO_BE_PRINTED.charAt(TO_BE_PRINTED.length() - 1) == '\\n';\n                flush();\n                if (ONLINE_JUDGE)\n                    return;\n                if (!endsWithEnter)\n                    log('\\n');\n                logTime();\n                logMem();\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        }, \"Main\", 1<<26).start();\n    }\n    static Random RAND = new Random();\n    static int random(int from, int to) {\n        return RAND.nextInt(to-from+1)+from;\n    }\n    static void logTime() {\n        log(\"Time: \" + getTime() + \"ms\");\n    }\n    static void logMem() {\n        log(\"Memory (End): \" + (int) (Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1024 + \" KB\");\n    }\n    static long ll() {\n        return Long.parseLong(next());\n    }\n    static int num() {\n        return Integer.parseInt(next());\n    }\n    static void generateInputMode() throws Exception {\n        System.setOut(new PrintStream(new FileOutputStream(\"F://PROGRAMMING/input.txt\")));\n    }\n    static String line() {\n        if (!tokenize())\n            return null;\n        INPUT_STREAM.setLength(0);\n        if (STRING_TOKENIZER.hasMoreTokens())\n            INPUT_STREAM.append(STRING_TOKENIZER.nextToken());\n        while (STRING_TOKENIZER.hasMoreTokens())\n            INPUT_STREAM.append(' ').append(STRING_TOKENIZER.nextToken());\n        return INPUT_STREAM.length() == 0 ? null : INPUT_STREAM.toString();\n    }\n    static void startTime() {\n        TIME_COMPLEXITY = System.currentTimeMillis();\n    }\n    static long getTime() {\n        return System.currentTimeMillis() - TIME_COMPLEXITY;\n    }\n    static void flush() {\n        System.out.print(TO_BE_PRINTED.toString());\n        TO_BE_PRINTED.setLength(0);\n    }\n    static void out(Object o) {\n        TO_BE_PRINTED.append(o);\n        if (AUTO_FLUSH)\n            flush();\n    }\n    static void _log(String s) {\n        System.err.print(s);\n    }\n    static void _logln(String s) {\n        System.err.println(s);\n    }\n    static void _logln() {\n        System.err.println();\n    }\n    static void outln(Object o) {\n        out(o);\n        outln();\n    }\n    static void outln() {\n        out(\"\\n\");\n    }\n    static class Pair implements Comparable<Pair> {\n        public int a, b;\n        public Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n        }\n        public static Pair of(int a, int b) {\n            return new Pair(a, b);\n        }\n        public int compareTo(Pair p) {\n            if (a == p.a)\n                return Integer.compare(b, p.b);\n            return Integer.compare(a, p.a);\n        }\n        public String toString() {\n            return \"[\" + a + \",\" + b + \"]\";\n        }\n        public boolean equals(Pair p) {\n            return p.a == a && p.b == b;\n        }\n    }\n    static boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    static void logArr(Object val) {\n        if (ONLINE_JUDGE)\n            return;\n        Class<?> valKlass = val.getClass();\n        Object[] outputArray = null;\n        for(Class<?> arrKlass : new Class<?>[] { int[].class, float[].class, double[].class, boolean[].class, \n            byte[].class, short[].class, long[].class, char[].class }) {\n            if (valKlass.isAssignableFrom(arrKlass)) {\n                int arrlength = Array.getLength(val);\n                outputArray = new Object[arrlength];\n                for(int i = 0; i < arrlength; ++i)\n                    outputArray[i] = Array.get(val, i);\n                break;\n            }\n        }\n        if(outputArray == null)\n            outputArray = (Object[])val;\n        logArr0(outputArray);\n    }\n    static void logArr0(Object[] objs) {\n        if (ONLINE_JUDGE)\n            return;\n        if (objs.length == 0) {\n            _log(\"* \\n\");\n            return;\n        }\n        _log(\"* \" + objs[0]);\n        for (int i = 1; i < objs.length; i++)\n            _log(objs[i].toString().equals(\"\\n\") ? \"\\n>\" : (\" \" + objs[i]));\n        _logln();\n    }\n    static void log(Object... objs) {\n        if (ONLINE_JUDGE)\n            return;\n        logArr0(objs);\n    }\n    static String next() {\n        return tokenize() ? STRING_TOKENIZER.nextToken() : null;\n    }\n    static boolean tokenize() {\n        if (STRING_TOKENIZER == null || !STRING_TOKENIZER.hasMoreTokens()) {\n            try {\n                STRING_TOKENIZER = new StringTokenizer(STREAM_READER.readLine());\n            } catch (Exception e) {\n                return false;\n            }\n        }\n        return true;\n    }\n    static long TIME_COMPLEXITY;\n    static BufferedReader STREAM_READER = new BufferedReader(new InputStreamReader(System.in), 32768);\n    static StringTokenizer STRING_TOKENIZER;\n    static StringBuilder INPUT_STREAM = new StringBuilder(), TO_BE_PRINTED = new StringBuilder();\n    //#endregion\n}", "label": 5}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class File {\n\t\n\tpublic static class FastScanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\t\t\n\t\tpublic FastScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\t\t\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t}\n\t\t\t\tcatch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\t\t\n\t\t\t\t\n\t\tint n = sc.nextInt();\t\t\t\t\n\t\t\n\t\t// 1 or 2 remaining elements always forms progression.\n\t\tif (n <= 3) {\n\t\t\tout.println(1);\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tint[][] array = new int[n][2];\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tarray[i] = new int[] {sc.nextInt(), i+1};\n\t\t}\n\t\t\n\t\tArrays.sort(array, new Comparator<int[]>() {\n\t\t\t@Override\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn a[0] - b[0];\n\t\t\t}\n\t\t});\n\t\t\n\t\tint[] toLeft = new int[n];\n\t\tArrays.fill(toLeft, Integer.MAX_VALUE);\n\t\t\n\t\tint diffLeft = array[1][0] - array[0][0];\n\t\ttoLeft[1] = diffLeft;\n\t\tfor (int i = 1; i + 1 < n; i++) {\n\t\t\tint diff = array[i+1][0] - array[i][0];\n\t\t\t\n\t\t\tif (diff == diffLeft) {\n\t\t\t\ttoLeft[i+1] = diff;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] toRight = new int[n];\n\t\tArrays.fill(toRight, Integer.MAX_VALUE);\n\t\t\n\t\tint diffRight = array[n-1][0] - array[n-2][0];\n\t\ttoRight[n-2] = diffRight;\n\t\tfor (int i = n-2; i - 1 >= 0; i--) {\n\t\t\tint diff = array[i][0] - array[i-1][0];\n\t\t\t\n\t\t\tif (diff == diffRight) {\n\t\t\t\ttoRight[i-1] = diff;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tfor (int[] pair : array) out.print(pair[0] + \" \");\n\t\tout.println();\n\t\tout.println(Arrays.toString(toLeft));\n\t\tout.println(Arrays.toString(toRight));\n\t\t\n\t\tout.println(\"Elements:\");\n\t\t*/\n\t\t\n\t\tfor (int index = 0; index < n; index++) {\n\t\t\tboolean leftIsProgression = index - 2 >= 0 ? (toLeft[index-1] != Integer.MAX_VALUE) : true;\n\t\t\tboolean rightIsProgression = index + 2 < n ? (toRight[index+1] != Integer.MAX_VALUE) : true;\n\t\t\t\n\t\t\tif (!leftIsProgression || !rightIsProgression) continue;\n\t\t\t\n\t\t\tboolean isConnected = true;\n\t\t\t\n\t\t\t\n\t\t\tint leftSize = index;\n\t\t\tint rightSize = n - index - 1;\n\t\t\t\n\t\t\tif (leftSize == 0) {\n\t\t\t\tisConnected = rightIsProgression;\n\t\t\t}\n\t\t\telse if (rightSize == 0) {\n\t\t\t\tisConnected = leftIsProgression;\n\t\t\t}\n\t\t\telse if (leftSize == 1) {\n\t\t\t\tint diff = toRight[index+1];\n\t\t\t\tint midDiff = array[index+1][0] - array[index-1][0];\n\t\t\t\t\n\t\t\t\tif (midDiff != diff) {\n\t\t\t\t\tisConnected = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (rightSize == 1) {\n\t\t\t\tint diff = toLeft[index-1];\n\t\t\t\tint midDiff = array[index+1][0] - array[index-1][0];\n\t\t\t\t\n\t\t\t\tif (midDiff != diff) {\n\t\t\t\t\tisConnected = false;\n\t\t\t\t}\n\t\t\t}\t\n\t\t\telse {\n\t\t\t\tint leftDiff = toLeft[index-1];\n\t\t\t\tint rightDiff = toRight[index+1];\n\t\t\t\tint midDiff = array[index+1][0] - array[index-1][0];\n\t\t\t\t\n\t\t\t\tif (midDiff != leftDiff || midDiff != rightDiff) {\n\t\t\t\t\tisConnected = false;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\t\n\t\t\t\n\t\t\tif (isConnected) {\n\t\t\t\tout.println(array[index][1]);\n\t\t\t\tout.close();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t\n\t\tout.println(-1);\n\t\tout.close();\n\t}\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "label": 5}
{"src": "import javafx.scene.layout.Priority;\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.math.BigInteger;\nimport java.net.Inet4Address;\nimport java.util.*;\nimport java.lang.*;\nimport java.util.HashMap;\nimport java.util.PriorityQueue;\npublic class templ implements Runnable{\n    static class pair implements Comparable\n    {\n        int f;\n        int s;\n        pair(int fi,int se)\n        {\n            f=fi;\n            s=se;\n        }\n        public int compareTo(Object o)//ascending order\n        {\n            pair pr=(pair)o;\n            if(s>pr.s)\n                return 1;\n            if(s==pr.s)\n            {\n                if(f>pr.f)\n                    return 1;\n                else\n                    return -1;\n            }\n            else\n                return -1;\n        }\n        public boolean equals(Object o)\n        {\n            pair ob=(pair)o;\n            int ff;\n            int ss;\n            if(o!=null)\n            {\n                ff=ob.f;\n                ss=ob.s;\n                if((ff==this.f)&&(ss==this.s))\n                    return true;\n            }\n            return false;\n        }\n        public int hashCode()\n        {\n            return (this.f+\" \"+this.s).hashCode();\n        }\n    }\n    public class triplet implements Comparable\n    {\n        int f,t;\n        int s;\n        triplet(int f,int s,int t)\n        {\n            this.f=f;\n            this.s=s;\n            this.t=t;\n        }\n        public boolean equals(Object o)\n        {\n            triplet ob=(triplet)o;\n            int ff;\n            int ss;\n            int tt;\n            if(o!=null)\n            {\n                ff=ob.f;\n                ss=ob.s;\n                tt=ob.t;\n                if((ff==this.f)&&(ss==this.s)&&(tt==this.t))\n                    return true;\n            }\n            return false;\n        }\n        public int hashCode()\n        {\n            return (this.f+\" \"+this.s+\" \"+this.t).hashCode();\n        }\n        public int compareTo(Object o)//ascending order\n        {\n            triplet tr=(triplet)o;\n            if(t>tr.t)\n                return 1;\n            else\n                return -1;\n        }\n    }\n    void merge1(int arr[], int l, int m, int r)\n    {\n        int n1 = m - l + 1;\n        int n2 = r - m;\n        int L[] = new int [n1];\n        int R[] = new int [n2];\n        for (int i=0; i<n1; ++i)\n            L[i] = arr[l + i];\n        for (int j=0; j<n2; ++j)\n            R[j] = arr[m + 1+ j];\n        int i = 0, j = 0;\n        int k = l;\n        while (i < n1 && j < n2)\n        {\n            if (L[i]<=R[j])\n            {\n                arr[k] = L[i];\n                i++;\n            }\n            else\n            {\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < n1)\n        {\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n        while (j < n2)\n        {\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    }\n    void sort1(int arr[], int l, int r)\n    {\n        if (l < r)\n        {\n            int m = (l+r)/2;\n            sort1(arr, l, m);\n            sort1(arr , m+1, r);\n            merge1(arr, l, m, r);\n        }\n    }\n    void merge2(int arr[],int arr1[],int l, int m, int r)\n    {\n        int n1 = m - l + 1;\n        int n2 = r - m;\n        int L[] = new int [n1];\n        int R[] = new int [n2];\n        int L1[]=new int[n1];\n        int R1[]=new int[n2];\n        for (int i=0; i<n1; ++i)\n        {\n            L[i] = arr[l + i];\n            L1[i]=arr1[l+i];\n        }\n        for (int j=0; j<n2; ++j)\n        {\n            R[j] = arr[m + 1+ j];\n            R1[j]=arr1[m+1+j];\n        }\n        int i = 0, j = 0;\n        int k = l;\n        while (i < n1 && j < n2)\n        {\n            if (L[i] <= R[j])\n            {\n                arr[k] = L[i];\n                arr1[k]=L1[i];\n                i++;\n            }\n            else\n            {\n                arr[k] = R[j];\n                arr1[k]=R1[j];\n                j++;\n            }\n            k++;\n        }\n        while (i < n1)\n        {\n            arr[k] = L[i];\n            arr1[k]=L1[i];\n            i++;\n            k++;\n        }\n        while (j < n2)\n        {\n            arr[k] = R[j];\n            arr1[k]=R1[j];\n            j++;\n            k++;\n        }\n    }\n    void sort2(int arr[],int arr1[],int l, int r)\n    {\n        if (l < r)\n        {\n            int m = (l+r)/2;\n            sort2(arr,arr1, l, m);\n            sort2(arr ,arr1, m+1, r);\n            merge2(arr,arr1,l, m, r);\n        }\n    }\n    ArrayList<pair> gen(String s)\n    {\n        ArrayList<pair>al=new ArrayList<>();\n        int l=s.length();\n        for(int i=0;i<l;i++)\n        {\n            char c=s.charAt(i);\n            int k=0;\n            for(int j=i;j<l;j++)\n            {\n                char c1=s.charAt(j);\n                if(c!=c1)\n                {\n                    al.add(new pair((int)c,k));\n                    i=j-1;\n                    break;\n                }\n                k++;\n                if(j==l-1)\n                {\n                    al.add(new pair((int)c,k));\n                    i=l+1;\n                    break;\n                }\n            }\n        }\n        return al;\n    }\n    public static void main(String args[])throws Exception\n    {\n        new Thread(null,new templ(),\"templ\",1<<27).start();\n    }\n    public void run()\n    {\n        try\n        {\n            InputReader in = new InputReader(System.in);\n            PrintWriter out = new PrintWriter(System.out);\n            int n=in.ni();\n            int a[]=new int[n+1];\n            int b[]=new int[n+1];\n            for(int i=1;i<=n;i++)\n            {\n                a[i] = in.ni();\n                b[i] = i;\n            }\n            sort2(a,b,1,n);\n            HashMap<Integer,Integer>hm=new HashMap<>();\n            for(int i=2;i<=n;i++)\n            {\n                int x=a[i]-a[i-1];\n                int k=0;\n                if(hm.containsKey(x))\n                    k=hm.get(x);\n                hm.put(x,k+1);\n            }\n            if(n<4||hm.size()==1)\n                out.println(b[1]);\n            else\n            {\n                if(hm.size()==2&&hm.get(a[2]-a[1])==1)\n                    out.println(b[1]);\n                else if(hm.size()==2&&hm.get(a[n]-a[n-1])==1)\n                    out.println(b[n]);\n                else\n                {\n                    int ans=-1;\n                    for(int i=2;i<n;i++)\n                    {\n                        int x=a[i+1]-a[i-1];\n                        int k=1;\n                        if(hm.containsKey(x))\n                            k+=hm.get(x);\n                        if(a[i]-a[i-1]==x)\n                            k--;\n                        if(a[i+1]-a[i]==x)\n                            k--;\n                        //System.out.println(i+\" \"+x+\" \"+k);\n                        if(k>=n-2)\n                            ans=b[i];\n                    }\n                    out.println(ans);\n                }\n            }\n            out.close();\n        }\n        catch(Exception e){\n            return;\n        }\n    }\n    static class InputReader {\n\n        private final InputStream stream;\n        private final byte[] buf = new byte[8192];\n        private int curChar, snumChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (snumChars == -1)\n                throw new InputMismatchException();\n            if (curChar >= snumChars) {\n                curChar = 0;\n                try {\n                    snumChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (snumChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int ni() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public long nl() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = ni();\n            }\n            return a;\n        }\n\n        public String readString() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        private boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n    }\n}\n", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\n\n\n/**\n * Created by Katushka on 08.02.2020.\n */\npublic class ExtraElement {\n\n    static class Pair {\n        int value;\n        int index;\n\n        public Pair(int value, int index) {\n            this.value = value;\n            this.index = index;\n        }\n    }\n\n    public static void main(String[] args) throws FileNotFoundException {\n        InputReader in = new InputReader(System.in);\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n        int n = in.nextInt();\n        List<Pair> a = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            a.add(new Pair(in.nextInt(), i));\n        }\n        a.sort(Comparator.comparingInt(o -> o.value));\n        if (n <= 3) {\n            out.println(1);\n        } else {\n            Map<Integer, List<Integer>> diffs = new HashMap<>();\n            for (int i = 0; i < n - 1; i++) {\n                int diff = a.get(i + 1).value - a.get(i).value;\n                if (!diffs.containsKey(diff)) {\n                    diffs.put(diff, new ArrayList<>());\n                }\n                diffs.get(diff).add(i);\n            }\n            if (diffs.size() > 3) {\n                out.println(-1);\n            } else {\n                if (diffs.size() == 1) {\n                    out.println(a.get(0).index + 1);\n                } else if (diffs.size() == 2) {\n                    Iterator<Integer> iterator = diffs.keySet().iterator();\n                    Integer diff1 = iterator.next();\n                    Integer diff2 = iterator.next();\n                    if (diffs.get(diff1).size() == 1) {\n                        if (diffs.get(diff1).get(0) == 0) {\n                            out.println(a.get(0).index + 1);\n                        } else if (diffs.get(diff1).get(0) == n - 2) {\n                            out.println(a.get(n - 1).index + 1);\n                        } else if (diff1 == 0) {\n                            out.println(a.get(diffs.get(diff1).get(0)).index + 1);\n                        } else {\n                            out.println(-1);\n                        }\n                    } else if (diffs.get(diff2).size() == 1) {\n                        if (diffs.get(diff2).get(0) == 0) {\n                            out.println(a.get(0).index + 1);\n                        } else if (diffs.get(diff2).get(0) == n - 2) {\n                            out.println(a.get(n - 1).index + 1);\n                        } else if (diff2 == 0) {\n                            out.println(a.get(diffs.get(diff2).get(0)).index + 1);\n                        } else {\n                            out.println(-1);\n                        }\n                    } else if (diffs.get(diff1).size() == 2 && diff1 * 2 == diff2\n                            && diffs.get(diff1).get(1) == diffs.get(diff1).get(0) + 1) {\n\n                        out.println(a.get(diffs.get(diff1).get(1)).index + 1);\n                    } else if (diffs.get(diff2).size() == 2 && diff2 * 2 == diff1\n                            && diffs.get(diff2).get(1) == diffs.get(diff2).get(0) + 1) {\n\n                        out.println(a.get(diffs.get(diff2).get(1)).index + 1);\n                    } else {\n                        out.println(-1);\n                    }\n\n                } else {\n                    Iterator<Integer> iterator = diffs.keySet().iterator();\n                    Integer diff1 = iterator.next();\n                    Integer diff2 = iterator.next();\n                    Integer diff3 = iterator.next();\n                    if (diffs.get(diff1).size() == 1 && diffs.get(diff2).size() == 1\n                            && diff1 + diff2 == diff3 && Math.abs(diffs.get(diff1).get(0) - diffs.get(diff2).get(0)) == 1) {\n                        out.println(a.get(Math.max(diffs.get(diff1).get(0), diffs.get(diff2).get(0))).index + 1);\n                    } else if (diffs.get(diff2).size() == 1 && diffs.get(diff3).size() == 1\n                            && diff2 + diff3 == diff1 && Math.abs(diffs.get(diff2).get(0) - diffs.get(diff3).get(0)) == 1) {\n                        out.println(a.get(Math.max(diffs.get(diff2).get(0), diffs.get(diff3).get(0))).index + 1);\n                    } else if (diffs.get(diff1).size() == 1 && diffs.get(diff3).size() == 1\n                            && diff1 + diff3 == diff2 && Math.abs(diffs.get(diff1).get(0) - diffs.get(diff3).get(0)) == 1) {\n                        out.println(a.get(Math.max(diffs.get(diff1).get(0), diffs.get(diff3).get(0))).index + 1);\n                    } else {\n                        out.println(-1);\n                    }\n                }\n            }\n\n        }\n\n        out.close();\n    }\n\n    private static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public String nextString() {\n            try {\n                return reader.readLine();\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        public char nextChar() {\n            return next().charAt(0);\n        }\n    }\n}\n", "label": 5}
{"src": "import javafx.util.Pair;\nimport sun.net.www.content.text.Generic;\n\nimport static java.lang.Double.parseDouble;\nimport static java.lang.Integer.parseInt;\nimport static java.lang.Integer.reverse;\nimport static java.lang.Long.parseLong;\nimport static java.lang.Math.abs;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.System.exit;\nimport static java.util.Comparator.comparingInt;\nimport static java.util.Map.Entry.comparingByValue;\nimport static java.util.stream.Collectors.toMap;\n\nimport java.io.*;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.*;\n\npublic class Solution {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    int n, a[][];\n    boolean test(int ind) {\n        int b[] = new int[n-1], j = 0;\n        for(int i = 0; i < n; i++) if(i != ind) b[j++] = a[i][0];\n        for(int i = 1; i < n - 1; i++) if(b[i] - b[i-1] != b[1] - b[0] || b[i] - b[i-1] != b[n-2] - b[n-3]) return false;\n        return true;\n    }\n\n    void solve() throws Exception {\n        n = nextInt();\n        if(n <= 2) {\n            out.print(1);\n            return;\n        }\n        a = new int[n][2];\n        for(int i = 0; i < n; i++) a[i] = new int[]{nextInt(), i + 1};\n        Arrays.sort(a, Comparator.comparingInt((int[] i) -> i[0]));\n        for(int i = 1; i < n; i++) if(a[i][0] - a[i-1][0] != a[1][0] - a[0][0] || a[i][0] - a[i-1][0] != a[n-1][0] - a[n-2][0]) {\n            if(test(i-1)) out.print(a[i-1][1]);\n            else if(test(i)) out.print(a[i][1]);\n            else if(test(0)) out.print(a[0][1]);\n            else if(test(1)) out.print(a[1][1]);\n            else if(test(n-1)) out.print(a[n-1][1]);\n            else if(test(n-2)) out.print(a[n-2][1]);\n            else out.print(-1);\n            return;\n        }\n        out.print(a[0][1]);\n    }\n\n    // call it like this: lower_bound(a, x + 1) ( /!\\ + 1 )\n    public static int lower_bound(int[] a, int v) {\n        int low = -1, high = a.length;\n        while (high - low > 1) {\n            int h = high + low >>> 1;\n            if (a[h] >= v) {\n                high = h;\n            } else {\n                low = h;\n            }\n        }\n        return high;\n    }\n\n    private String getFraction(int a, int b) {\n        assert b != 0;\n        String sign = (a > 0 && b > 0) || (a < 0) && (b < 0) ? \"+\" : \"-\";\n        a = abs(a);\n        b = abs(b);\n        int gcd = gcd(a, b);\n        return sign + (a / gcd) + \"/\" + (b / gcd);\n    }\n\n    private int gcd(int a, int b) {\n        while (b > 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    private int lcm(int a, int b) {\n        return a * (b / gcd(a, b));\n    }\n\n    public static int[] radixSort(int[] f) {\n        if (f.length < 100) {\n            Arrays.sort(f);\n            return f;\n        }\n        int[] to = new int[f.length];\n        {\n            int[] b = new int[65537];\n            for (int i = 0; i < f.length; i++) b[1 + (f[i] & 0xffff)]++;\n            for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];\n            for (int i = 0; i < f.length; i++) to[b[f[i] & 0xffff]++] = f[i];\n            int[] d = f;\n            f = to;\n            to = d;\n        }\n        {\n            int[] b = new int[65537];\n            for (int i = 0; i < f.length; i++) b[1 + (f[i] >>> 16)]++;\n            for (int i = 1; i <= 65536; i++) b[i] += b[i - 1];\n            for (int i = 0; i < f.length; i++) to[b[f[i] >>> 16]++] = f[i];\n            int[] d = f;\n            f = to;\n            to = d;\n        }\n        return f;\n    }\n\n    public static boolean nextPermutation(int[] a) {\n        int n = a.length;\n        int i;\n        for (i = n - 2; i >= 0 && a[i] >= a[i + 1]; i--) ;\n        if (i == -1)\n            return false;\n        int j;\n        for (j = i + 1; j < n && a[i] < a[j]; j++) ;\n        int d = a[i];\n        a[i] = a[j - 1];\n        a[j - 1] = d;\n        for (int p = i + 1, q = n - 1; p < q; p++, q--) {\n            d = a[p];\n            a[p] = a[q];\n            a[q] = d;\n        }\n        return true;\n    }\n\n    void print(Object x) {\n        out.print(String.valueOf(x));\n        out.flush();\n    }\n\n    void println(Object x) {\n        out.println(String.valueOf(x));\n        out.flush();\n    }\n\n    // for Map with custom key/value, override toString in your custom class\n    void printMap(Map map) {\n        if (map.keySet().size() == 0) return;\n        Object firstValue = map.keySet().iterator().next();\n        if (map.get(firstValue) instanceof Queue || map.get(firstValue) instanceof List) {\n            for (Object key : map.keySet()) {\n                out.print(String.valueOf(key) + \": \");\n                Collection values = (Collection) map.get(key);\n                for (Object value : values) out.print(String.valueOf(value) + \" \");\n                out.println();\n            }\n        } else if (map.get(firstValue).getClass().isArray()) {\n            for (Object key : map.keySet()) {\n                out.print(String.valueOf(key) + \": \");\n                Object[] values = (Object[]) map.get(key);\n                for (Object value : values) out.print(String.valueOf(value) + \" \");\n                out.println();\n            }\n        } else {\n            for (Object key : map.keySet()) {\n                out.println(String.valueOf(key) + \": \" + map.get(key));\n            }\n        }\n    }\n\n    private int[] na(int n) throws IOException {\n        int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = nextInt();\n        return a;\n    }\n\n    private long[] nal(int n) throws IOException {\n        long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = nextLong();\n        return a;\n    }\n\n    int nextInt() throws IOException {\n        return parseInt(next());\n    }\n\n    long nextLong() throws IOException {\n        return parseLong(next());\n    }\n\n    double nextDouble() throws IOException {\n        return parseDouble(next());\n    }\n\n    String next() throws IOException {\n        while (tok == null || !tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine());\n        }\n        return tok.nextToken();\n    }\n\n    public static void main(String[] args) throws Exception {\n        try {\n            boolean isLocal = false;\n            if (isLocal) {\n                in = new BufferedReader(new FileReader(\"mr_x.txt\"));\n                out = new PrintWriter(new BufferedWriter(new FileWriter(\"solution.out\")));\n            } else {\n                in = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(new OutputStreamWriter(System.out));\n            }\n\n            //long lStartTime = System.currentTimeMillis();\n            new Solution().solve();\n            //long lEndTime = System.currentTimeMillis();\n            //out.println(\"Elapsed time in seconds: \" + (double)(lEndTime - lStartTime) / 1000.0);\n            in.close();\n            out.close();\n        } catch (Throwable e) {\n            e.printStackTrace();\n            exit(1);\n        }\n    }\n}", "label": 5}
{"src": "\nimport java.util.*;\nimport java.io.*;  \npublic class Main \n{\n    PrintWriter out;\n    FastReader sc;\n    long[] m1= {(long)(1e9+7),998244353};\n    long mod=m1[1];\n    long maxlong=Long.MAX_VALUE;\n    long minlong=Long.MIN_VALUE;\n    StringBuilder sb;\n    /******************************************************************************************\n     *****************************************************************************************/\n\tpublic void sol(){\n\t\tint n=ni();\n\t\tHashMap<Integer,Integer> map=new HashMap<>(),has=new HashMap<>();\n\t\tint[] ar=new int[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tar[i]=ni();\n\t\t\thas.put(ar[i],i+1);\n\t\t}sort(ar);\n\t\tfor(int i=1;i<n;i++) {\n\t\t\tmap.put(ar[i]-ar[i-1],map.getOrDefault(ar[i]-ar[i-1],0)+1);\n\t\t}int p=ar[1]-ar[0],q=ar[n-1]-ar[n-2];\n\t\tif(map.size()==1) {\n\t\t\tpl(has.get(ar[0]));\n\t\t}\n\t\telse if(map.get(p)==1&&map.size()==2) {\n\t\t\tpl(has.get(ar[0]));\n\t\t}else if(map.get(q)==1&&map.size()==2) {\n\t\t\tpl(has.get(ar[n-1]));\n\t\t}else {\n\t\t\tfor(int i=1;i<n-1;i++) {\n\t\t\t\tp=ar[i+1]-ar[i];q=ar[i]-ar[i-1];int r=ar[i+1]-ar[i-1];\n\t\t\t\tif(map.get(p)==1) {\n\t\t\t\t\tmap.remove(p);\n\t\t\t\t}else map.put(p,map.get(p)-1);\n\t\t\t\tif(map.get(q)==1) {\n\t\t\t\t\tmap.remove(q);\n\t\t\t\t}else map.put(q,map.get(q)-1);\n\t\t\t\tmap.put(ar[i+1]-ar[i-1],map.getOrDefault(ar[i+1]-ar[i-1],0)+1);\n\t\t\t\tif(map.size()==1) {\n\t\t\t\t\tpl(has.get(ar[i]));return;\n\t\t\t\t}map.put(p,map.getOrDefault(p,0)+1);\n\t\t\t\tmap.put(q,map.getOrDefault(q,0)+1);\n\t\t\t\tif(map.get(r)==1)map.remove(r);\n\t\t\t\telse map.put(r, map.get(r)-1);\n\t\t\t}pl(\"-1\");\n\t\t}\n\t}\n    public static void main(String[] args) \n\t{ \n\t    Main g=new Main();\n\t\tg.out=new PrintWriter(System.out);\n\t\tg.sc=new FastReader();\n\t\tint t=1;\n// \t\tt=g.ni();\n\t\twhile(t-->0)\n\t\tg.sol();\n\t\tg.out.flush();\n\t}\n\t\n\t/****************************************************************************************\n     *****************************************************************************************/\n\tstatic class FastReader \n\t{ \n\t\tBufferedReader br; \n\t\tStringTokenizer st; \n \n\t\tpublic FastReader() \n\t\t{ \n\t\t\tbr = new BufferedReader(new\n\t\t\t\t\tInputStreamReader(System.in)); \n\t\t} \n \n\t\tString next() \n\t\t{ \n\t\t\twhile (st == null || !st.hasMoreElements()) \n\t\t\t{ \n\t\t\t\ttry\n\t\t\t\t{ \n\t\t\t\t\tst = new StringTokenizer(br.readLine()); \n\t\t\t\t} \n\t\t\t\tcatch (IOException e) \n\t\t\t\t{ \n\t\t\t\t\te.printStackTrace(); \n\t\t\t\t} \n\t\t\t} \n\t\t\treturn st.nextToken(); \n\t\t} \n \n\t\tint nextInt() \n\t\t{ \n\t\t\treturn Integer.parseInt(next()); \n\t\t} \n \n\t\tlong nextLong() \n\t\t{ \n\t\t\treturn Long.parseLong(next()); \n\t\t} \n \n\t\tdouble nextDouble() \n\t\t{ \n\t\t\treturn Double.parseDouble(next()); \n\t\t} \n \n\t\tString nextLine() \n\t\t{ \n\t\t\tString str = \"\"; \n\t\t\ttry\n\t\t\t{ \n\t\t\t\tstr = br.readLine(); \n\t\t\t} \n\t\t\tcatch (IOException e) \n\t\t\t{ \n\t\t\t\te.printStackTrace(); \n\t\t\t} \n\t\t\treturn str; \n\t\t} \n\t} public int ni(){\n\t      return sc.nextInt();\n\t}public long nl(){\n\t      return sc.nextLong();\n\t}public double nd(){\n\t      return sc.nextDouble();\n\t}public char[] rl(){\n\t      return sc.nextLine().toCharArray();\n\t}public String rl1(){\n\t      return sc.nextLine();\n\t}\n\tpublic void pl(Object s){\n\t      out.println(s);\n\t}public void ex(){\n\t      out.println();\n\t}\n\tpublic void pr(Object s){\n\t      out.print(s);\n\t}public String next(){\n\t      return sc.next();\n\t}public long abs(long x){\n\t      return Math.abs(x);\n\t}\n\tpublic int abs(int x){\n\t      return Math.abs(x);\n\t}\n\tpublic double abs(double x){\n\t      return Math.abs(x);\n\t}public long min(long x,long y){\n            return (long)Math.min(x,y);\n      }\n      public int min(int x,int y){\n            return (int)Math.min(x,y);\n      }\n      public double min(double x,double y){\n            return Math.min(x,y);\n      }public long gcd(long a, long b) {\n\t\tif (a == 0)\n\t\t\treturn b;\n\t\treturn gcd(b % a, a);\n\t}public long lcm(long a, long b) {\n            return (a / gcd(a, b)) * b;\n      }\n       void sort1(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l,Collections.reverseOrder());\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}\n\t void sort(int[] a) {\n\t\tArrayList<Integer> l = new ArrayList<>();\n\t\tfor (int i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}void sort(long[] a) {\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}void sort1(long[] a) {\n\t\tArrayList<Long> l = new ArrayList<>();\n\t\tfor (long i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l,Collections.reverseOrder());\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}\n\tvoid sort(double[] a) {\n\t\tArrayList<Double> l = new ArrayList<>();\n\t\tfor (double i : a) {\n\t\t\tl.add(i);\n\t\t}\n\t\tCollections.sort(l);\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\ta[i] = l.get(i);\n\t\t}\n\t}long pow(long a,long b){\n          if(b==0){\n                return 1;\n          }long p=pow(a,b/2);\n          if(b%2==0) return (p*p)%mod;\n          else return (((p*p)%mod)*a)%mod;\n    }\n\t\n\tint  swap(int a,int b){\n\t      return a;\n\t}long  swap(long a,long b){\n\t      return a;\n\t}double  swap(double a,double b){\n\t      return a;\n\t}\n\tboolean isPowerOfTwo (int x) \n      { \n            return x!=0 && ((x&(x-1)) == 0);     \n      }boolean isPowerOfTwo (long x) \n      { \n            return x!=0 && ((x&(x-1)) == 0);     \n      }public long max(long x,long y){\n            return (long)Math.max(x,y);\n      }\n      public int max(int x,int y){\n            return (int)Math.max(x,y);\n      }\n      public double max(double x,double y){\n            return Math.max(x,y);\n      }long sqrt(long x){\n            return (long)Math.sqrt(x);\n      }int sqrt(int x){\n            return (int)Math.sqrt(x);\n      }void input(int[] ar,int n){\n            for(int i=0;i<n;i++)ar[i]=ni();\n      }void input(long[] ar,int n){\n            for(int i=0;i<n;i++)ar[i]=nl();\n      }void fill(int[] ar,int k){\n            Arrays.fill(ar,k);\n      }void yes(){\n            pl(\"YES\");\n      }void no(){\n            pl(\"NO\");\n      }\n    long[] sieve(int n) \n    {\n          long[] k=new long[n+1];\n          boolean[] pr=new boolean[n+1];\n          for(int i=1;i<=n;i++){\n                k[i]=i;\n                pr[i]=true;\n          }for(int i=2;i<=n;i++){\n                if(pr[i]){\n                      for(int j=i+i;j<=n;j+=i){\n                            pr[j]=false;\n                            if(k[j]==j){\n                                  k[j]=i;\n                            }\n                      }\n                }\n          }return k;\n    }\n    int strSmall(int[] arr, int target)  \n    {  \n        int start = 0, end = arr.length-1;  \n        int ans = -1;  \n        while (start <= end) {  \n            int mid = (start + end) / 2;   \n            if (arr[mid] >= target) {  \n                end = mid - 1;  \n            }   \n            else {  \n                ans = mid;  \n                start = mid + 1;  \n            }  \n        }  \n        return ans;  \n    } int strSmall(ArrayList<Integer> arr, int target)  \n    {  \n        int start = 0, end = arr.size()-1;  \n        int ans = -1;  \n        while (start <= end) {  \n            int mid = (start + end) / 2;   \n            if (arr.get(mid) > target) {  \n                start = mid + 1; \n                ans=start;\n            }   \n            else {\n                end = mid - 1;  \n            }  \n        }  \n        return ans;  \n    }long mMultiplication(long a,long b) \n    { \n        long res = 0;    \n        a %= mod; \n  \n        while (b > 0)  \n        {  \n            if ((b & 1) > 0)  \n            { \n                res = (res + a) % mod; \n            }  \n            a = (2 * a) % mod; \n  \n            b >>= 1;  \n        } \n        return res; \n    }long nCr(int n, int r ,int p)\n    {\n \n          if (n<r) \n              return 0;\n        if (r == 0)\n            return 1;\n            long[] fac = new long[n + 1];\n        fac[0] = 1;\n \n        for (int i = 1; i <= n; i++)\n            fac[i] = fac[i - 1] * i %p;\n        return (fac[n] * modInverse(fac[r], p)\n                % p * modInverse(fac[n - r], p)\n                % p)\n            % p;\n    }long power(long x, long y, long p)\n    {\n        long res = 1;\n        x = x % p;\n \n        while (y > 0) {\n            if (y % 2 == 1)\n                res = (res * x) % p;\n            y = y >> 1; \n            x = (x * x) % p;\n        }\n \n        return res;\n    }long modInverse(long n, long p)\n    {\n        return power(n, p - 2, p);\n    }\n    \n    int[][] floydWarshall(int graph[][],int INF,int V)\n    {\n        int dist[][] = new int[V][V];\n        int i, j, k;\n        for (i = 0; i < V; i++)\n            for (j = 0; j < V; j++)\n                dist[i][j] = graph[i][j];\n        for (k = 0; k < V; k++)\n        {\n            for (i = 0; i < V; i++)\n            {\n                for (j = 0; j < V; j++)\n                {\n                    if (dist[i][k] + dist[k][j] < dist[i][j])\n                        dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }return dist;\n    }\n    class minque {\n\t\tDeque<Long> q;\n\t\tminque(){\n\t\t\tq=new ArrayDeque<Long>();\n\t\t}public void add(long p){\n\t\t\twhile(!q.isEmpty()&&q.peekLast()>p)q.pollLast();\n\t\t\tq.addLast(p);\n\t\t}public void remove(long p) {\n\t\t\tif(!q.isEmpty()&&q.getFirst()==p)q.removeFirst();\n\t\t}public long min() {\n\t\t\treturn q.getFirst();\n\t\t}\n\t}\n      public static class Pair implements Comparable<Pair> {\n\t\tlong x;\n\t\tlong y;\n \n\t\tpublic Pair(long x, long y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tpublic int compareTo(Pair other) {\n\t\t\tif (this.x == other.x) {\n\t\t\t\treturn Long.compare(other.y, this.y);\n\t\t\t}\n\t\t\treturn Long.compare(other.x, this.x);\n\t\t}\n      }\n\t \n} ", "label": 5}
{"src": "//package round_568;\n\nimport java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class ap {\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner in=new Scanner(System.in);\n\t\tint n=in.nextInt();\n\t\tlong[] arr1=new long[n];\n\t\tlong[] arr2=new long[n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tarr1[i]=in.nextLong();\n\t\t\tarr2[i]=i;\n\t\t}\n\t\tmergesorting ms=new mergesorting();\n\t\tms.sort(arr1, arr2);\n\t\tArrayList<Integer> arr=new ArrayList<Integer>();\n\t\tfor(int i=0;i<n;i++) {\n//\t\t\tSystem.out.println(arr1[i]+\" \"+arr2[i]);\n\t\t\tarr.add((int) arr1[i]);\n\t\t}\n\t\tif(arr.size()<4) {\n\t\t\tSystem.out.println(1);\n\t\t\treturn;\n\t\t}\n//\t\tSystem.out.println(arr);\n\t\tint a=arr.get(0);\n\t\tint b=arr.get(1);\n\t\tint c=arr.get(2);\n\t\tint d=arr.get(3);\n\t\tint rem1=-1;\n\t\tif(b-a==c-b) {\n//\t\t\tif(d-c==2*(b-a)) {\n//\t\t\t\trem1=1;\n//\t\t\t\tfor(int i=3;i<n;i++) {\n//\t\t\t\t\tif(arr.get(i)-arr.get(i-1)!=2*(b-a)) {\n//\t\t\t\t\t\tSystem.out.println(-1);\n//\t\t\t\t\t\treturn;\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println(arr2[1]+1);\n//\t\t\t\treturn;\n//\t\t\t}\n\t\t\tint diff=b-a;\n\t\t\tfor(int i=2;i<n;i++) {\n\t\t\t\tif(rem1==-1 && arr.get(i)-arr.get(i-1)!=diff && i==n-1) {\n\t\t\t\t\tSystem.out.println(arr2[n-1]+1);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(rem1==-1 && arr.get(i)-arr.get(i-1)!=diff) {\n\t\t\t\t\tif(arr.get(i)-arr.get(i-1)<diff) {\n\t\t\t\t\t\tif(i<n-1 && arr.get(i)-arr.get(i-1)+ (arr.get(i+1)-arr.get(i))==diff) {\n\t\t\t\t\t\t\trem1=i;\n//\t\t\t\t\t\t\tSystem.out.println(arr.get(i-1)+ diff);\n\t\t\t\t\t\t\tarr.set(i, arr.get(i-1));\n//\t\t\t\t\t\t\tarr.get(i+1) = arr.get(i-1)+ diff;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(arr.get(i)-arr.get(i-1)!=diff) {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\treturn;\n\t\t\t\t}\t\n\t\t\t}\n\t\t\tif(rem1==-1) {\n\t\t\t\tSystem.out.println(arr2[0]+1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSystem.out.println(arr2[rem1]+1);\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif(b-a == (c-b)+(d-c)) {\n\t\t\t\trem1=3;\n\t\t\t\tint diff=b-a;\n\t\t\t\tfor(int i=4;i<n;i++) {\n\t\t\t\t\tif(arr.get(i)-arr.get(i-1)!=diff) {\n\t\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(arr2[rem1-1]+1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(c-b==d-c) {\n\t\t\t\trem1=1;\n\t\t\t\tint diff=c-b;\n\t\t\t\tfor(int i=3;i<n;i++) {\n\t\t\t\t\tif(arr.get(i)-arr.get(i-1)!=diff) {\n\t\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(arr2[rem1-1]+1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(c-a==d-c) {\n\t\t\t\trem1=2;\n\t\t\t\tint diff=c-a;\n\t\t\t\tfor(int i=3;i<n;i++) {\n\t\t\t\t\tif(arr.get(i)-arr.get(i-1)!=diff) {\n\t\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(arr2[rem1-1]+1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tSystem.out.println(-1);\n\t\t}\n\t}\n\n}\n\nclass mergesorting {\n\tpublic void sort(long[] arr,long[] arr2) {\n\t\tsort(arr,arr2, 0, arr.length-1);\n\t}\n    private void merge(long[] arr,long[] arr2,int l, int m, int r){\n        int n1 = m - l + 1;\n        int n2 = r - m;\n\n        long[] L = new long [n1];\n        long[] R = new long [n2];\n        \n        long[] L2=new long[n1];\n        long[] R2=new long[n2];\n        int i=0;\n        while(i<n1) {\n            L[i] = arr[l + i];\n            L2[i]=arr2[l+i];\n            ++i;\n        }\n        int j=0;\n        while(j<n2) {\n            R[j] = arr[m + 1+ j];\n            R2[j]=arr2[m+1+j];\n            ++j;\n        }\n        i=0; \n        j=0;\n        int k=l;   \n        while (i < n1 && j < n2) {\n            if (L[i] <= R[j]) {\n            \tarr2[k]=L2[i];\n                arr[k] = L[i];\n                i++;\n            }\n            else {\n            \tarr2[k]=R2[j];\n                arr[k] = R[j];\n                j++;\n            }\n            k++;\n        }\n \n        while (i < n1) {\n        \tarr2[k]=L2[i];\n            arr[k] = L[i];\n            i++;\n            k++;\n        }\n        while (j < n2) {\n        \tarr2[k]=R2[j];\n            arr[k] = R[j];\n            j++;\n            k++;\n        }\n    } \n    private void sort(long arr[],long arr2[], int l, int r){\n        if (l < r) {\n            int m = (l+r)/2;\n            sort(arr,arr2, l, m);\n            sort(arr ,arr2, m+1, r); \n            merge(arr,arr2, l, m, r);\n        }\n    }\n    static void printArray(long arr[]) {\n    \tint n = arr.length;\n    \tfor (int i=0; i<n; i++)\n    \t\tSystem.out.print(arr[i]+\" \" );\n    \tSystem.out.println();\n    }\n}", "label": 5}
{"src": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Scanner;\n\npublic class ExtraElement_1185D {\n\n\tstatic class Pair implements Comparable<Pair> {\n\n\t\tpublic int value;\n\t\tpublic int index;\t\t\n\n\t\tpublic Pair(int value, int index) {\n\t\t\tthis.value = value;\n\t\t\tthis.index = index;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair p) {\n\t\t\tif (this.value > p.value)\n\t\t\t\treturn 1;\n\t\t\telse if (this.value < p.value)\n\t\t\t\treturn -1;\n\t\t\telse \n\t\t\t\treturn 0;\n\t\t}\t\t\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner scr = new Scanner(System.in);\n\t\tint n = scr.nextInt();\n\t\tscr.nextLine();\n\t\tif (n == 2) {\n\t\t\tSystem.out.println(1);\n\t\t\tscr.close();\n\t\t\treturn;\n\t\t}\n\t\tArrayList<Pair> list = new ArrayList<Pair>();\n\t\tfor(int i=0; i<n; i++) {\n\t\t\tlist.add(new Pair(scr.nextInt(), i+1));\n\t\t}\n\t\tCollections.sort(list);\n\t\tArrayList<Pair> withoutFirst = new ArrayList<Pair>(list);\n\t\tint idx = withoutFirst.remove(0).index;\n\t\tint distance = withoutFirst.get(1).value - withoutFirst.get(0).value;\n\t\tboolean found = true;\n\t\tfor (int i=2; i<withoutFirst.size(); i++) {\n\t\t\tif (withoutFirst.get(i).value - withoutFirst.get(i-1).value != distance) {\n\t\t\t\tfound = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!found) {\n\t\t\tArrayList<Pair> withoutSecond = new ArrayList<Pair>(list);\n\t\t\tidx = withoutSecond.remove(1).index;\n\t\t\tdistance = withoutSecond.get(1).value - withoutSecond.get(0).value;\n\t\t\tfound = true;\n\t\t\tfor (int i=2; i<withoutSecond.size(); i++) {\n\t\t\t\tif (withoutSecond.get(i).value - withoutSecond.get(i-1).value != distance) {\n\t\t\t\t\tfound = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tSystem.out.println(idx);\n\t\t\tscr.close();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tif (!found) {\n\t\t\tdistance = list.get(1).value - list.get(0).value;\n\t\t\tfound = false;\t\t\t\n\t\t\tfor (int i=2; i<list.size(); i++) {\n\t\t\t\tif (!found && list.get(i).value - list.get(i-1).value != distance) {\n\t\t\t\t\tfound = true;\n\t\t\t\t\tidx = list.remove(i).index;\t\t\t\t\t\n\t\t\t\t\ti--;\n\t\t\t\t} else if (found && list.get(i).value - list.get(i-1).value != distance) {\n\t\t\t\t\tidx = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(idx);\n\t\t} else {\n\t\t\tSystem.out.println(idx);\n\t\t}\n\t\t\n\t\t\n\t\tscr.close();\n\t}\n\n}\n", "label": 5}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic final class D1185 {\n\tpublic static int check(int pos, ArrayList<Pair> temp) {\n\t    ArrayList<Pair> arr = new ArrayList<>();\n\t    for(int i = 0;i < temp.size(); i++) {\n\t    \tif(i == pos) {\n\t    \t\tcontinue;\n\t    \t}\n\t    \tarr.add(temp.get(i));\n\t    }\n\t    int d = arr.get(1).val - arr.get(0).val;\n\t    for(int i = 0;i < arr.size() - 1; i++) {\n\t    \tif(arr.get(i+1).val - arr.get(i).val != d) {\n\t    \t\treturn 0;\n\t    \t}\n\t    }\n\t    System.out.println(temp.get(pos).index);\n\t    return 1;\n\t}\n\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringBuilder str = new StringBuilder();\n\t\t\t\t\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\t\n\t\t\tString[] split = br.readLine().split(\" \");\n\t\t\tArrayList<Pair> a = new ArrayList<>();\n\t\t\t\n\t\t\tfor(int i = 0;i < n; i++) {\n\t\t\t\tPair p = new Pair();\n\t\t\t\tp.index = i+1;\n\t\t\t\tp.val = Integer.parseInt(split[i]);\n\t\t\t\ta.add(p);\n\t\t\t}\n\t\t\tif(n == 2 || n ==3) {\n\t\t\t\tSystem.out.println(1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t\t\n\t\t\t\tCollections.sort(a);\n\t\t\t\t\n\t\t\t\tif(check(0,a) == 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif(check(n-1,a) == 1) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\tint d = 0;\n\t\t\t\t\tfor(int i = 0;i < n-1; i++) {\n\t\t\t\t\t\td = Math.max(d, a.get(i+1).val - a.get(i).val );\n\t\t\t\t\t}\n\t\t\t\t\tint cnt = 0;\n\t\t\t\t\tfor(int i = 0 ;i < n - 1; i++)\n\t\t\t        if (a.get(i+1).val - a.get(i).val != d) {\n\t\t\t            if(check(i,a) == 1) {\n\t\t\t            \treturn;\n\t\t\t            }\n\t\t\t            if(check(i+1,a) == 1) {\n\t\t\t            \treturn;\n\t\t\t            }\n\t\t\t            cnt++;\n\t\t\t            if (cnt > 2)\n\t\t\t                break;\n\t\t\t        }\n\n\t\t\t   System.out.println(-1);\n\t\t\n\t}\n\tstatic class Pair implements Comparable<Pair> {\n\t\tint val;\n\t\tint index;\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn (this.val - o.val);\n\t\t}\n\t}\n\t\n}\n", "label": 5}
{"src": "import java.util.*;\npublic class Main{\n    public static void main(String[] args){\n        Scanner sc=new Scanner(System.in);\n        int len=sc.nextInt();\n        if(len<=2){\n            System.out.println(1);\n            return;\n        }\n        int[][] A=new int[len][2];\n        for(int i=0;i<len;i++){\n            A[i][0]=sc.nextInt();\n            A[i][1]=i+1;\n        }\n        Arrays.sort(A,new Comparator<int[]>(){\n            public int compare(int[] a,int[] b){\n                return a[0]-b[0];\n            }\n        });\n        int d1=A[1][0]-A[0][0];\n        int d2=A[2][0]-A[0][0];\n        int d3=A[2][0]-A[1][0];\n        // System.out.println(d1);System.out.println(d2);System.out.println(d3);\n        int index=A[0][1];\n        boolean f=false;\n        for(int i=2;i<len;i++){\n            if(A[i][0]-A[i-1][0]!=d1){\n                // System.out.println(A[i][0]);\n                if(index==A[0][1]){\n                    index=A[i][1];\n                    if(i==len-1||A[i+1][0]-A[i-1][0]==d1){\n                        i++;\n                    }else{\n                        f=true;\n                        break;\n                    }\n                }else{\n                    f=true;\n                }\n            }\n        }\n        if(!f){\n            System.out.println(index);\n            return;\n        } \n        \n        f=false;\n        index=A[1][1];\n        for(int i=3;i<len;i++){\n            if(A[i][0]-A[i-1][0]!=d2){\n                f=true;\n            }\n        }\n        if(!f){\n            System.out.println(index);\n            return;\n        }\n        \n        f=false;\n        index=A[0][1];\n        for(int i=3;i<len;i++){\n            if(A[i][0]-A[i-1][0]!=d3){\n                f=true;\n            }\n        }\n        if(!f){\n            System.out.println(index);\n            return;\n        }\n        System.out.println(-1);\n    }\n}", "label": 5}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\npublic class D {\n\n    static class FastReader {\n        StringTokenizer str;\n        BufferedReader br;\n\n        FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            if (str == null || !str.hasMoreTokens()) {\n                try {\n                    str = new StringTokenizer(br.readLine());\n                } catch (Exception e) {\n                    return \"\";\n                }\n            }\n            return str.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int a[] = new int[n];\n            for (int i = 0; i < n; i++) {\n                a[i] = nextInt();\n            }\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long a[] = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static class Pair {\n        int val, pos;\n\n        Pair(int a, int b) {\n            val = a;\n            pos = b;\n        }\n    }\n\n    public static void main(String args[]) throws Exception {\n\n        FastReader fr = new FastReader();\n        int n = fr.nextInt();\n        Pair b[] = new Pair[n];\n        for (int i = 0; i < n; i++) {\n            b[i] = new Pair(fr.nextInt(), i + 1);\n        }\n        Arrays.sort(b, (x, y) -> (x.val - y.val));\n\n        int d1 = b[1].val - b[0].val, d2 = Integer.MIN_VALUE, d3 = Integer.MIN_VALUE, d4 = Integer.MIN_VALUE;\n        for (int i = 2; i < n; i++) {\n            if (b[i].val - b[i - 1].val != d1) {\n                d2 = b[i].val - b[i - 1].val;\n                break;\n            }\n        }\n        if (d2 == Integer.MIN_VALUE) {\n            System.out.print(b[0].pos);\n            System.exit(0);\n        }\n\n        for (int i = 2; i < n; i++) {\n            if (b[i].val - b[i - 1].val != d1 && b[i].val - b[i - 1].val != d2) {\n                d3 = b[i].val - b[i - 1].val;\n                break;\n            }\n        }\n\n        if (d3 != Integer.MIN_VALUE) {\n            for (int i = 2; i < n; i++) {\n                if (b[i].val - b[i - 1].val != d1 && b[i].val - b[i - 1].val != d2 && b[i].val - b[i - 1].val != d3) {\n                    d4 = b[i].val - b[i - 1].val;\n                    break;\n                }\n            }\n            if (d4 != Integer.MIN_VALUE) {\n                System.out.print(\"-1\");\n                System.exit(0);\n            }\n        }\n\n        boolean c1 = true, c2 = true, c3 = true;\n        int p1 = -1, p2 = -1, p3 = -1;\n\n        for (int i = 1; i < n; i++) {\n            if (b[i].val - b[i - 1].val != d1) {\n                if (p1 != -1) {\n                    c1 = false;\n                    break;\n                } else if (i == n - 1) {\n                    p1 = n - 1;\n                    break;\n                } else if (i == 1 && b[i + 1].val - b[i].val == d1) {\n                    p1 = 0;\n                }else if (b[i + 1].val - b[i - 1].val == d1) {\n                    p1 = i;\n                    i++;\n                } else {\n                    c1 = false;\n                    break;\n                }\n            }\n        }\n\n        for (int i = 1; i < n; i++) {\n            if (b[i].val - b[i - 1].val != d2) {\n                if (p2 != -1) {\n                    c2 = false;\n                    break;\n                } else if (i == n - 1) {\n                    p2 = n - 1;\n                    break;\n                } else if (i == 1 && b[i + 1].val - b[i].val == d2) {\n                    p2 = 0;\n                } else if (b[i + 1].val - b[i - 1].val == d2) {\n                    p2 = i;\n                    i++;\n                } else {\n                    c2 = false;\n                    break;\n                }\n            }\n        }\n\n        if (d3 == Integer.MIN_VALUE)\n            c3 = false;\n\n        for (int i = 1; i < n; i++) {\n            if (b[i].val - b[i - 1].val != d3) {\n                if (p3 != -1) {\n                    c3 = false;\n                    break;\n                } else if (i == n - 1) {\n                    p3 = n - 1;\n                    break;\n                } else if (i == 1 && b[i + 1].val - b[i].val == d3) {\n                    p3 = 0;\n                } else if (b[i + 1].val - b[i - 1].val == d3) {\n                    p3 = i;\n                    i++;\n                } else {\n                    c3 = false;\n                    break;\n                }\n            }\n        }\n\n         /* for (int i = 1; i < n; i++) {\n            if (b[i] - b[i - 1] != d1) {\n                if (p1 != -1) {\n                    if (!(p1 == i - 1 && b[i] - b[i - 2] == d1))\n                        c1 = false;\n                } else\n                    p1 = i;\n            }\n\n            /*if (b[i] - b[i - 1] != d2) {\n                if (p2 != i - 1 && p2 != -1)\n                    c2 = false;\n                else if (p2 != i - 1)\n                    p2 = i;\n\n            if (b[i] - b[i - 1] != d2) {\n                if (p2 != -1) {\n                    if (!(p2 == i - 1 && b[i] - b[i - 2] == d2))\n                        c2 = false;\n                } else\n                    p2 = i;\n            }\n        }*/\n\n        String opt;\n        if (!c1 && !c2 && !c3) {\n            opt = \"-1\";\n        } else if (c1) {\n            opt = \"\" + (p1 == -1 ? 1 : b[p1].pos);\n        } else if (c2){\n            opt = \"\" + (p2 == -1 ? 1 : b[p2].pos);\n        } else {\n            opt = \"\" + (p3 == -1 ? 1 : b[p3].pos);\n        }\n\n        System.out.print(opt);\n    }\n}", "label": 5}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main2 {\n\n    private FastScanner scanner = new FastScanner();\n\n    public static void main(String[] args) {\n        new Main2().solve();\n    }\n\n    private void solve() {\n        int n = scanner.nextInt();\n\n        int a[][] = new int[n][2];\n\n        for (int i = 0; i < n; i++) {\n            a[i][0] = scanner.nextInt();\n            a[i][1] = i;\n        }\n\n        Arrays.sort(a, Comparator.comparingInt(o -> o[0]));\n\n        long d[] = new long[n - 1];\n\n        for (int i = 0; i < n - 1; i++) {\n            d[i] = (long) a[i + 1][0] - (long) a[i][0];\n        }\n\n        for (int j = 0; j < Math.min(n - 1, 3); j++) {\n\n            long cur_d = d[j];\n\n            boolean ok = true;\n            for (int i = 1; i < n - 1; i++) {\n                ok &= d[i] == cur_d;\n            }\n            if (ok) {\n                System.out.println(a[0][1] + 1);\n                return;\n            }\n\n            ok = true;\n            for (int i = 0; i < n - 2; i++) {\n                ok &= d[i] == cur_d;\n            }\n            if (ok) {\n                System.out.println(a[n - 1][1] + 1);\n                return;\n            }\n\n            int ans = -1;\n\n            for (int i = 0; i < n - 1; i++) {\n                if (d[i] == cur_d) {\n                    continue;\n                }\n\n                if (ans == -1 && i < n - 2 && (d[i] + d[i + 1]) == cur_d) {\n                    ans = a[i + 1][1] + 1;\n                    i++;\n                } else {\n                    ans = -1;\n                    break;\n                }\n            }\n            if (ans != -1) {\n                System.out.println(ans);\n                return;\n            }\n        }\n        System.out.println(-1);\n}\n\n    boolean check(char s[]) {\n        int b = 0;\n        for (char c : s) {\n            if (c == '0') {\n                b++;\n            } else {\n                if (b <= 0) {\n                    return false;\n                }\n                b--;\n            }\n        }\n        return true;\n    }\n\n    char[] reverse(char[] c) {\n        char nc[] = new char[c.length];\n        for (int i = 0; i < c.length; i++) {\n            nc[c.length - i - 1] = c[i];\n        }\n        return nc;\n    }\n\nclass Pair {\n    int c, f;\n}\n\nclass FastScanner {\n    BufferedReader reader;\n    StringTokenizer tokenizer;\n\n    FastScanner() {\n        reader = new BufferedReader(new InputStreamReader(System.in), 32768);\n        tokenizer = null;\n    }\n\n    String next() {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            try {\n                tokenizer = new StringTokenizer(reader.readLine());\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n        return tokenizer.nextToken();\n\n    }\n\n    int nextInt() {\n        return Integer.parseInt(next());\n    }\n\n    Integer[] nextA(int n) {\n        Integer a[] = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            a[i] = scanner.nextInt();\n        }\n        return a;\n    }\n\n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n\n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n\n    public String nextLine() {\n        try {\n            return reader.readLine();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n}", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class B {\n\n\tstatic int cannot=Integer.MAX_VALUE;\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint n=sc.nextInt();\n\t\tif(n==2) {\n\t\t\tSystem.out.println(1);\n\t\t\treturn ;\n\t\t}\n\t\tInteger[]indices=new Integer[n];\n\t\tint []a=new int [n];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ta[i]=sc.nextInt();\n\t\t\tindices[i]=i;\n\t\t}\n\t\tArrays.sort(indices,Comparator.comparingInt(i->a[i]));\n\t\tint[]pref=new int [n],suf=new int [n];\n\t\tpref[1]=a[indices[1]]-a[indices[0]];\n\t\tfor(int i=2;i<n;i++) {\n\t\t\tint d1=a[indices[i]]-a[indices[i-1]];\n\t\t\tif(d1==pref[i-1])\n\t\t\t\tpref[i]=d1;\n\t\t\telse\n\t\t\t\tpref[i]=cannot;\n\t\t}\n\t\tsuf[n-2]=a[indices[n-1]]-a[indices[n-2]];\n\t\tfor(int i=n-3;i>=0;i--) {\n\t\t\tint d1=a[indices[i+1]]-a[indices[i]];\n\t\t\tif(d1==suf[i+1])\n\t\t\t\tsuf[i]=d1;\n\t\t\telse\n\t\t\t\tsuf[i]=cannot;\n\t\t}\n\t\tint ans=-1;\n\t\tfor(int i=1;i<n-1;i++) {\n\t\t\tint d=a[indices[i+1]]-a[indices[i-1]];\n\t\t\tboolean left=d==pref[i-1] || i==1;\n\t\t\tboolean right=d==suf[i+1]||i==n-2;\n\t\t\tif(left && right)\n\t\t\t\tans=indices[i]+1;\n\t\t}\n\t\tif(suf[1]!=cannot) {\n\t\t\tans=indices[0]+1;\n\t\t}\n\t\tif(pref[n-2]!=cannot)\n\t\t\tans=indices[n-1]+1;\n\t\tout.println(ans);\n\t\tout.close();\n\n\t}\n\n\tstatic class Scanner {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tScanner(String fileName) throws FileNotFoundException {\n\t\t\tbr = new BufferedReader(new FileReader(fileName));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\n\t\tint nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tboolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\n\t}\n\n}", "label": 5}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.text.*;\npublic class Main{\n    //SOLUTION BEGIN\n    //Into the Hardware Mode\n    void pre() throws Exception{}\n    void solve(int TC) throws Exception{\n        int n = ni();\n        long[][] a = new long[n][];\n        for(int i = 0; i< n; i++)a[i] = new long[]{i+1, nl()};\n        Arrays.sort(a, (long[] l1, long[] l2) -> Long.compare(l1[1], l2[1]));\n        if(n<=3){\n            pn(1);return;\n        }\n        long d = a[2][1]-a[1][1];\n        boolean f = true;\n        for(int i = 3; i< n && f; i++)if(a[i][1]-a[i-1][1] != d)f = false;\n        if(f){\n            pn(a[0][0]);\n            return;\n        }\n        d = a[2][1]-a[0][1];\n        f = true;\n        for(int i = 3; i< n && f; i++)if(a[i][1]-a[i-1][1] != d)f = false;\n        if(f){\n            pn(a[1][0]);\n            return;\n        }\n        d = a[1][1]-a[0][1];\n        long prev = a[1][1];\n        f = false;\n        long ind = a[n-1][0];\n        for(int i = 2; i< n; i++){\n            if(prev+d != a[i][1]){\n                if(f){\n                    pn(-1);\n                    return;\n                }else{ f = true; ind = a[i][0];}\n            }else prev+=d;\n        }\n        pn(ind);\n    }\n    //SOLUTION END\n    void hold(boolean b)throws Exception{if(!b)throw new Exception(\"Hold right there, Sparky!\");}\n    long mod = (long)1e9+7, IINF = (long)1e18;\n    final int INF = (int)1e9, MX = (int)2e5+5;\n    DecimalFormat df = new DecimalFormat(\"0.00000000000\");\n    double PI = 3.141592653589793238462643383279502884197169399, eps = 1e-8;\n    static boolean multipleTC = false, memory = false;\n    FastReader in;PrintWriter out;\n    void run() throws Exception{\n        in = new FastReader();\n        out = new PrintWriter(System.out);\n        //Solution Credits: Taranpreet Singh\n        int T = (multipleTC)?ni():1;\n        pre();for(int t = 1; t<= T; t++)solve(t);\n        out.flush();\n        out.close();\n    }\n    public static void main(String[] args) throws Exception{\n        if(memory)new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();}}}, \"1\", 1 << 28).start();\n        else new Main().run();\n    }\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}\n    void p(Object o){out.print(o);}\n    void pn(Object o){out.println(o);}\n    void pni(Object o){out.println(o);out.flush();}\n    String n()throws Exception{return in.next();}\n    String nln()throws Exception{return in.nextLine();}\n    int ni()throws Exception{return Integer.parseInt(in.next());}\n    long nl()throws Exception{return Long.parseLong(in.next());}\n    double nd()throws Exception{return Double.parseDouble(in.next());}\n\n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        String next() throws Exception{\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    throw new Exception(e.toString());\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() throws Exception{\n            String str = \"\";\n            try{   \n                str = br.readLine();\n            }catch (IOException e){\n                throw new Exception(e.toString());\n            }  \n            return str;\n        }\n    }\n}", "label": 5}
{"src": "import static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\nimport java.util.*;\nimport java.io.*;\n\npublic class A {\n\n    void main() throws Exception\n    {\n        Scanner sc = new Scanner(System.in);\n        PrintWriter out = new PrintWriter(System.out) ;\n        int n = sc.nextInt() ;\n        int [] a = new int [n] ;\n        TreeMap<Integer,Integer> map = new TreeMap<>();\n        for(int i = 0 ; i < n ;i++)\n            map.put(a[i] = sc.nextInt() , i + 1);\n        if(n == 2)\n        {\n            System.out.println(1);\n            return;\n        }\n        shuffle(a);\n        sort(a);\n        long [] f = new long [3] ;\n        f[0] = a[1] - a[0] ;\n        f[1] = a[2] - a[1] ;\n        f[2] = a[2] - a[0] ;\n        for(int j = 0 ; j < 3 ; j++)\n        {\n            long c = f[j] ;\n            long start = j == 1 ? a[1] : a[0] ;\n            long factor = 1 ;\n            long cnt = j == 1 ? 1 : 0;\n            int idx = 0 ;\n            for(int i = (j == 1 ? 2 : 1) ;i < n ; i++)\n            {\n\n                if(start + c * factor == a[i])\n                    factor ++ ;\n                else {\n                    cnt++;\n                    idx = i ;\n                }\n            }\n            if(cnt < 2)\n            {\n                System.out.println(map.get(a[idx]));\n                return;\n            }\n        }\n        out.println(-1);\n\n        out.flush();\n        out.close();\n    }\n    static void shuffle(int[] a)\n    {\n        int n = a.length;\n        for (int i = 0; i < n; i++)\n        {\n            int r = i + (int) (Math.random() * (n - i));\n            int tmp = a[i];\n            a[i] = a[r];\n            a[r] = tmp;\n        }\n    }\n\n    class Scanner\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        Scanner(InputStream in)\n        {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        Scanner(String path) throws Exception{\n            br = new BufferedReader((new FileReader(path))) ;\n        }\n        String next() throws Exception\n        {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        int nextInt() throws Exception { return Integer.parseInt(next()); }\n\n        long nextLong() throws Exception { return Long.parseLong(next()); }\n\n        double nextDouble() throws Exception { return Double.parseDouble(next());}\n    }\n\n    public static void main (String [] args) throws Exception {(new A()).main();}\n\n}", "label": 5}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.util.LinkedList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DLishniiElement solver = new DLishniiElement();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DLishniiElement {\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            List<Item> a = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                a.add(new Item(in.nextInt(), i + 1));\n            }\n            a.sort(Comparator.comparingInt(x -> x.val));\n            Map<Long, Integer> ct = new HashMap<>();\n            for (int i = 1; i < n; i++) {\n                long diff = a.get(i).val - a.get(i - 1).val;\n                ct.putIfAbsent(diff, 0);\n                ct.put(diff, ct.get(diff) + 1);\n\n                if (ct.size() > 3) {\n                    out.println(-1);\n                    return;\n                }\n            }\n            if (ct.size() == 1) {\n                out.println(a.get(0).idx);\n                return;\n            }\n            LinkedList<Long> remove = new LinkedList<>();\n            LinkedList<Long> add = new LinkedList<>();\n            for (int i = 0; i < n; i++) {\n                if (i != 0) {\n                    remove.add(a.get(i).val * 1L - a.get(i - 1).val);\n                }\n                if (i != n - 1) {\n                    remove.add(a.get(i + 1).val * 1L - a.get(i).val);\n                }\n                if (i != 0 && i != n - 1) {\n                    add.add(a.get(i + 1).val * 1L - a.get(i - 1).val);\n                }\n                for (Long val : remove) {\n                    ct.put(val, ct.get(val) - 1);\n                    if (ct.get(val) == 0) {\n                        ct.remove(val);\n                    }\n                }\n                for (Long val : add) {\n                    ct.putIfAbsent(val, 0);\n                    ct.put(val, ct.get(val) + 1);\n                }\n                if (ct.size() == 1) {\n                    out.println(a.get(i).idx);\n                    return;\n                }\n                for (Long val : remove) {\n                    ct.putIfAbsent(val, 0);\n                    ct.put(val, ct.get(val) + 1);\n                }\n                for (Long val : add) {\n                    ct.put(val, ct.get(val) - 1);\n                    if (ct.get(val) == 0) {\n                        ct.remove(val);\n                    }\n                }\n                remove.clear();\n                add.clear();\n            }\n            out.println(-1);\n        }\n\n        class Item {\n\n            int val;\n            int idx;\n\n            public Item(int val, int idx) {\n                this.val = val;\n                this.idx = idx;\n            }\n        }\n    }\n\n    static class InputReader {\n\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n    }\n}\n\n", "label": 5}
{"src": "//package com.company;\nimport java.util.*;\npublic class Main {\n\n    public static void main(String[] args) {\n        // write your code here\n        Scanner s=new Scanner(System.in);StringBuilder sb=new StringBuilder();\n         int n=s.nextInt();Student[] a=new Student[n];\n   for(int i=0;i<n;i++){\n       a[i]=new Student(s.nextInt(),i);\n   }Arrays.sort(a,new Sortbyroll());\n   if(n>2){long d=a[2].x-a[1].x;int flag=0;\n   for(int i=2;i<n;i++){\n       if(a[i].x-a[i-1].x!=d){\n           flag=1;break;\n       }\n   }\n    if(flag==1){\n       d=a[2].x-a[0].x;flag=0;\n       for(int i=3;i<n;i++){\n           if(a[i].x-a[i-1].x!=d){\n               flag=1;break;\n           }\n       }if(flag==1){\n           d=a[1].x-a[0].x;int ignore=0;flag=0;int ind=0;\n           for(int i=2;i<n;i++){\n               if(a[i].x-a[i-1].x!=d){\n                   if(ignore==0){\n                       ignore=1;//ind=i;\n                       if(i+1<n&&a[i+1].x-a[i-1].x!=d){\n                           if(a[i].x-a[i-2].x!=d){\n                               flag=1;break;\n                           }else{\n                               ind=a[i-1].y;\n                           }\n                       }else {ind=a[i].y;i+=1;}\n                   }else{\n                       flag=1;break;\n                   }\n               }\n           }if(ignore==0){\n                System.out.println(-1);\n            }else if(ignore==1&&flag==1){\n              //  System.out.println(\"JI\");\n                System.out.println(-1);\n            }else\n                System.out.println(ind+1);\n        }else{        //        System.out.println(\"JI\");\n\n            System.out.println(a[1].y+1);\n        }\n    }else{         //       System.out.println(\"JI\");\n\n        System.out.println(a[0].y+1);\n    }\n   }else{          //      System.out.println(\"JI\");\n\n       System.out.println(a[1].y+1);\n   }\n\n\n    }static int[] vis;static int count;\n    static void dfs(int i,HashMap<Integer,Integer> [] val,ArrayList<Integer> []a) {\n            vis[i]=1;count++;\n            if(a[i]!=null){\n                for(int j:a[i]){\n                    if(vis[j]==0&&val[j].get(i)!=1){\n                        dfs(j,val,a);\n                    }\n                }\n\n            }\n    }\n}\n\n\nclass Student\n{\n    int x,y;\n//    String name, address;\n\n    // Constructor\n    public Student(int x,int y)\n    {\n        this.x = x;\n        this.y=y;\n    }\n\n    // Used to print student details in main()\n    public String toString()\n    {\n        return this.x + \" \" +this.y;\n    }\n}\n\nclass Sortbyroll implements Comparator<Student>\n{\n    // Used for sorting in ascending order of\n    // roll number\n    public int compare(Student a, Student b)\n    {\n        return  a.x-b.x;\n    }\n}", "label": 5}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class CFP {\n\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        \n        int length = scan.nextInt();\n        if (length < 4) {\n            System.out.println(1);\n            return;\n        }\n        \n        int[] input = new int[length];\n        for (int i=0; i<length; i++) {\n            input[i] = scan.nextInt(); \n        }\n        \n        int[] progression = Arrays.copyOf(input, length);\n        Arrays.sort(progression);\n        \n        int[] difference = new int[length-1];\n        for (int i=0; i<length-1; i++) {\n            difference[i] = progression[i+1] - progression[i];\n        }\n        \n        int answer = -2;\n        if (length == 4) {\n            int d1 = progression[1] - progression[0];\n            int d2 = progression[2] - progression[1];\n            int d3 = progression[3] - progression[2];\n            if (       d1 == d2 && d2 == d3\n                    || d1 != d2 && d2 == d3) {\n                answer = 0;\n            } else if (d1+d2 == d3) {\n                answer = 1;\n            } else if (d2+d3 == d1) {\n                answer = 2;\n            } else if (d1 == d2 && d2 != d3) {\n                answer = 3;\n            } else {\n                answer = -1;\n            }\n        } else {\n            int diff = difference[1] > difference[2] ? difference[1] : difference[2];\n            if (diff < difference[3]) diff = difference[3];\n            \n            int i = 1;\n            if (difference[0] != diff) {\n                if (difference[1] == diff) {\n                    answer = 0;\n                } else if (difference[0]+difference[1] == diff) {\n                    answer = 1;\n                    i = 2;\n                } else {\n                    answer = -1;\n                    i = length;\n                }\n            }\n            for (; i<length-2; i++) {\n                if (difference[i] != diff) {\n                    if (answer == -2 && difference[i]+difference[++i] == diff) {\n                        answer = i;\n                    } else {\n                        answer = -1;\n                        break;\n                    }\n                }\n            }\n            if (answer != -1 && i == length-2 && difference[i] != diff) {\n                if (answer == -2) {\n                    answer = length-1;\n                } else {\n                    answer = -1;\n                }\n            }\n        }\n        \n        if (answer == -1) {\n            System.out.println(-1);\n            return;\n        } else if (answer == -2) {\n            answer = progression[0];\n        } else {\n            answer = progression[answer];\n        }\n        \n        for (int i=0; i<length; i++) {\n            if (input[i] == answer) {\n                System.out.println(i+1);\n                return;\n            }\n        }\n    }\n}\n", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\npublic class ExtraElement {\n\n\tpublic static void main(String[] args) throws IOException{\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tint N = Integer.parseInt(br.readLine());\n\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\tPair[] arr = new Pair[N];\n\t\tfor(int i = 1; i <= N; ++i) {\n\t\t\tint cur = Integer.parseInt(st.nextToken());\n\t\t\tarr[i-1] = new Pair(cur,i);\n\t\t}\n\t\tArrays.sort(arr);\n\t\tHashMap<Integer,Integer> multi = new HashMap<Integer,Integer>();\n\t\tfor(int i = 1; i < N; ++i) {\n\t\t\tPair a = arr[i], b = arr[i-1];\n\t\t\tint c = a.a-b.a;\n\t\t\tif(multi.containsKey(c)) {\n\t\t\t\tmulti.replace(c, multi.get(c)+1);\n\t\t\t}else {\n\t\t\t\tmulti.put(c, 1);\n\t\t\t}\n\t\t}\n\t\tif(multi.size()==1) {\n\t\t\tSystem.out.println(arr[0].b);\n\t\t\treturn;\n\t\t}\n\t\tfor(int i = 0; i < N; ++i) {\n\t\t\tint add1 = -1, rem1 = -1, rem2 = -1;\n\t\t\tif(i==0) {\n\t\t\t\tPair a = arr[i], b = arr[i+1];\n\t\t\t\trem1 = b.a-a.a;\n\t\t\t\tmulti.replace(rem1, multi.get(rem1)-1);\n\t\t\t\tif(multi.get(rem1)==0) {\n\t\t\t\t\tmulti.remove(rem1);\n\t\t\t\t}\n\t\t\t\tif(multi.size()==1) {\n\t\t\t\t\tSystem.out.println(arr[i].b);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}else if(i==N-1) {\n\t\t\t\tPair a = arr[i], b = arr[i-1];\n\t\t\t\trem1 = a.a-b.a;\n\t\t\t\tmulti.replace(rem1, multi.get(rem1)-1);\n\t\t\t\tif(multi.get(rem1)==0) {\n\t\t\t\t\tmulti.remove(rem1);\n\t\t\t\t}\n\t\t\t\tif(multi.size()==1) {\n\t\t\t\t\tSystem.out.println(arr[i].b);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tPair les = arr[i-1], mor = arr[i+1], cur = arr[i];\n\t\t\t\trem1 = cur.a-les.a; rem2 = mor.a-cur.a; add1 = mor.a-les.a;\n\t\t\t\tmulti.replace(rem1, multi.get(rem1)-1);\n\t\t\t\tif(multi.get(rem1)==0) {\n\t\t\t\t\tmulti.remove(rem1);\n\t\t\t\t}\n\t\t\t\tmulti.replace(rem2, multi.get(rem2)-1);\n\t\t\t\tif(multi.get(rem2)==0) {\n\t\t\t\t\tmulti.remove(rem2);\n\t\t\t\t}\n\t\t\t\tif(multi.containsKey(add1)) {\n\t\t\t\t\tmulti.replace(add1, multi.get(add1)+1);\n\t\t\t\t}else {\n\t\t\t\t\tmulti.put(add1, 1);\n\t\t\t\t}\n\t\t\t\tif(multi.size()==1) {\n\t\t\t\t\tSystem.out.println(arr[i].b);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(add1 != -1) {\n\t\t\t\tmulti.replace(add1, multi.get(add1)-1);\n\t\t\t\tif(multi.get(add1)==0) {\n\t\t\t\t\tmulti.remove(add1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(rem1 != -1) {\n\t\t\t\tif(multi.containsKey(rem1)) {\n\t\t\t\t\tmulti.replace(rem1, multi.get(rem1)+1);\n\t\t\t\t}else {\n\t\t\t\t\tmulti.put(rem1, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(rem2 != -1) {\n\t\t\t\tif(multi.containsKey(rem2)) {\n\t\t\t\t\tmulti.replace(rem2, multi.get(rem2)+1);\n\t\t\t\t}else {\n\t\t\t\t\tmulti.put(rem2, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"-1\");\n\t}\n\tpublic static class Pair implements Comparable<Pair> {\n\t\tint a, b;\n\t\tpublic Pair(int a, int b) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(ExtraElement.Pair o) {\n\t\t\t// TODO Auto-generated method stub\n\t\t\treturn a-o.a;\n\t\t}\n\t}\n\n}\n", "label": 5}
{"src": "import java.io.*;\nimport java.math.*;\nimport java.util.*;\nimport java.util.stream.*;\nimport java.lang.management.*;\nimport static java.lang.Math.abs;\nimport static java.lang.Math.min;\nimport static java.lang.Math.max;\nimport static java.lang.Math.sqrt;\nimport static java.lang.Integer.signum;\n\n@SuppressWarnings(\"unchecked\")\npublic class P1185D {\n\n  Map<Integer, Integer> dc = new HashMap();\n\n  int bi [][];\n\n  void add(int i, int j) {\n    int d = abs(bi[i][0] - bi[j][0]);\n    dc.put(d, dc.getOrDefault(d, 0) + 1);\n  }\n\n  void rem(int i, int j) {\n    int d = abs(bi[i][0] - bi[j][0]), c = dc.get(d) - 1;\n    if (c > 0) { dc.put(d, c); } else { dc.remove(d); }\n  }\n\n  boolean ok() {\n    return (dc.size() <= 1);\n  }\n\n  public void run() throws Exception {\n    int n = nextInt() - 1;\n    bi = new int [n + 1][2];\n    for (int i = 0; i <= n; bi[i][0] = nextInt(), bi[i][1] = i + 1, i++);\n\n    shuffle(bi);\n    Arrays.sort(bi, new Comparator<int []>() {\n      @Override public int compare(int [] a, int [] b) {\n        return (a[0] - b[0]);\n      }\n    });\n\n    for (int i = 1; i <= n; add(i, i - 1), i++);\n\n    rem(0, 1);\n    if (ok()) { println(bi[0][1]); return; }\n    add(0, 1);\n\n    rem(n, n - 1);\n    if (ok()) { println(bi[n][1]); return; }\n    add(n - 1, n);\n\n    for (int i = 1; i < n; i++) {\n      rem(i, i - 1);\n      rem(i + 1, i);\n      add(i - 1, i + 1);\n      if (ok()) { println(bi[i][1]); return; }\n      add(i, i - 1);\n      add(i + 1, i);\n      rem(i - 1, i + 1);\n    }\n\n    println(-1);\n  }\n\n  public static void main(String... args) throws Exception {\n    br = new BufferedReader(new InputStreamReader(System.in));\n    pw = new PrintWriter(new BufferedOutputStream(System.out));\n    new P1185D().run();\n    br.close();\n    pw.close();\n    System.err.println(\"\\n[Time : \" + (System.currentTimeMillis() - startTime) + \" ms]\");\n    long gct = 0, gcc = 0;\n    for (GarbageCollectorMXBean garbageCollectorMXBean : ManagementFactory.getGarbageCollectorMXBeans()) {\n      gct += garbageCollectorMXBean.getCollectionTime();\n      gcc += garbageCollectorMXBean.getCollectionCount();\n    }\n    System.err.println(\"[GC time : \" + gct + \" ms, count = \" + gcc + \"]\");\n  }\n\n  static long startTime = System.currentTimeMillis();\n  static BufferedReader br;\n  static PrintWriter pw;\n  StringTokenizer stok;\n\n  String nextToken() throws IOException {\n    while (stok == null || !stok.hasMoreTokens()) {\n      String s = br.readLine();\n      if (s == null) { return null; }\n      stok = new StringTokenizer(s);\n    }\n    return stok.nextToken();\n  }\n\n  void print(byte b) { print(\"\" + b); }\n  void print(int i) { print(\"\" + i); }\n  void print(long l) { print(\"\" + l); }\n  void print(double d) { print(\"\" + d); }\n  void print(char c) { print(\"\" + c); }\n  void print(Object o) {\n    if (o instanceof int[]) { print(Arrays.toString((int [])o));\n    } else if (o instanceof long[]) { print(Arrays.toString((long [])o));\n    } else if (o instanceof char[]) { print(Arrays.toString((char [])o));\n    } else if (o instanceof byte[]) { print(Arrays.toString((byte [])o));\n    } else if (o instanceof short[]) { print(Arrays.toString((short [])o));\n    } else if (o instanceof boolean[]) { print(Arrays.toString((boolean [])o));\n    } else if (o instanceof float[]) { print(Arrays.toString((float [])o));\n    } else if (o instanceof double[]) { print(Arrays.toString((double [])o));\n    } else if (o instanceof Object[]) { print(Arrays.toString((Object [])o));\n    } else { print(\"\" + o); }\n  }\n  void printsp(int [] a) { for (int i = 0, n = a.length; i < n; print(a[i] + \" \"), i++); }\n  void print(String s) { pw.print(s); }\n  void println() { println(\"\"); }\n  void println(byte b) { println(\"\" + b); }\n  void println(int i) { println(\"\" + i); }\n  void println(long l) { println(\"\" + l); }\n  void println(double d) { println(\"\" + d); }\n  void println(char c) { println(\"\" + c); }\n  void println(Object o) { print(o); println(); }\n  void println(String s) { pw.println(s); }\n  int nextInt() throws IOException { return Integer.parseInt(nextToken()); }\n  long nextLong() throws IOException { return Long.parseLong(nextToken()); }\n  double nextDouble() throws IOException { return Double.parseDouble(nextToken()); }\n  char nextChar() throws IOException { return (char) (br.read()); }\n  String next() throws IOException { return nextToken(); }\n  String nextLine() throws IOException { return br.readLine(); }\n  int [] readInt(int size) throws IOException {\n    int [] array = new int [size];\n    for (int i = 0; i < size; i++) { array[i] = nextInt(); }\n    return array;\n  }\n  long [] readLong(int size) throws IOException {\n    long [] array = new long [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLong(); }\n    return array;\n  }\n  double [] readDouble(int size) throws IOException {\n    double [] array = new double [size];\n    for (int i = 0; i < size; i++) { array[i] = nextDouble(); }\n    return array;\n  }\n  String [] readLines(int size) throws IOException {\n    String [] array = new String [size];\n    for (int i = 0; i < size; i++) { array[i] = nextLine(); }\n    return array;\n  }\n\n  int gcd(int a, int b) {\n    if (a == 0) return Math.abs(b); if (b == 0) return Math.abs(a);\n    a = Math.abs(a); b = Math.abs(b);\n    int az = Integer.numberOfTrailingZeros(a), bz = Integer.numberOfTrailingZeros(b);\n    a >>>= az; b >>>= bz;\n    while (a != b) {\n      if (a > b) { a -= b; a >>>= Integer.numberOfTrailingZeros(a); }\n            else { b -= a; b >>>= Integer.numberOfTrailingZeros(b); }\n    }\n    return (a << Math.min(az, bz));\n  }\n\n  long gcd(long a, long b) {\n    if (a == 0) return Math.abs(b); if (b == 0) return Math.abs(a);\n    a = Math.abs(a); b = Math.abs(b);\n    int az = Long.numberOfTrailingZeros(a), bz = Long.numberOfTrailingZeros(b);\n    a >>>= az; b >>>= bz;\n    while (a != b) {\n      if (a > b) { a -= b; a >>>= Long.numberOfTrailingZeros(a); }\n            else { b -= a; b >>>= Long.numberOfTrailingZeros(b); }\n    }\n    return (a << Math.min(az, bz));\n  }\n\n  void shuffle(int [] a) { // RANDOM shuffle\n    Random r = new Random();\n    for (int i = a.length - 1, j, t; i >= 0; j = r.nextInt(a.length), t = a[i], a[i] = a[j], a[j] = t, i--);\n  }\n\n  void shuffle(int [] a, int m) { // QUICK shuffle\n    for (int i = 0, n = a.length, j = m % n, t; i < n; t = a[i], a[i] = a[j], a[j] = t, i++, j = (i * m) % n);\n  }\n\n  void shuffle(long [] a) {\n    Random r = new Random();\n    for (int i = a.length - 1; i >= 0; i--) {\n      int j = r.nextInt(a.length);\n      long t = a[i]; a[i] = a[j]; a[j] = t;\n    }\n  }\n\n  void shuffle(Object [] a) {\n    Random r = new Random();\n    for (int i = a.length - 1; i >= 0; i--) {\n      int j = r.nextInt(a.length);\n      Object t = a[i]; a[i] = a[j]; a[j] = t;\n    }\n  }\n\n  int [] sort(int [] a) {\n    final int SHIFT = 16, MASK = (1 << SHIFT) - 1, SIZE = (1 << SHIFT) + 1;\n    int n = a.length, ta [] = new int [n], ai [] = new int [SIZE];\n    for (int i = 0; i < n; ai[(a[i] & MASK) + 1]++, i++);\n    for (int i = 1; i < SIZE; ai[i] += ai[i - 1], i++);\n    for (int i = 0; i < n; ta[ai[a[i] & MASK]++] = a[i], i++);\n    int [] t = a; a = ta; ta = t;\n    ai = new int [SIZE];\n    for (int i = 0; i < n; ai[(a[i] >> SHIFT) + 1]++, i++);\n    for (int i = 1; i < SIZE; ai[i] += ai[i - 1], i++);\n    for (int i = 0; i < n; ta[ai[a[i] >> SHIFT]++] = a[i], i++);\n    return ta;\n  }\n\n  void flush() {\n    pw.flush();\n  }\n\n  void pause() {\n    flush(); System.console().readLine();\n  }\n}", "label": 5}
{"src": "import java.util.*;\nimport java.io.*;\n//import java.lang.*;\n\npublic class ranjan{\n\n    public static Read cin;\n    //public static InputReader cin;\n    public static PrintWriter cout;\n    public static boolean[] safe;\n\tpublic static int[][] memo;\n    public static final long bil = (long)1e9+7;\n    public static int fileread = 0; \n    \n    public static void main(String ...arg) throws IOException\n    {\n        /*console writer*/\n        cout = new PrintWriter(new BufferedOutputStream(System.out));\n        /*Debug Reader*/\n        //Scan cin =new Scan();\n        if(fileread == 1)\n        {\n            try\n            {\n            cin = new Read(new FileInputStream(new File(\"in2.txt\")));\n            //cin = new InputReader(new FileInputStream(new File(\"in2.txt\")));\n            }\n            catch (IOException error){}\n        }\n        else{\n            cin = new Read(System.in);\n            //cin = new InputReader(System.in);\n        }\n\n\t\tint n = cin.nextInt();\n        Pair[] arr = new    Pair[n];\n        for(int i=0;i<n;i++) \n            arr[i] = new Pair(cin.nextInt(),i);\n        Arrays.sort(arr,new Comparator<Pair>(){\n            @Override\n            public int compare(Pair x,Pair y)\n            {\n                return x.a - y.a;\n            }\n        });\n        //edges case\n        if(n<=2)\n        {\n            cout.print(1);\n            cout.close();\n            return;\n        }\n        int d = arr[2].a - arr[1].a;\n        //check if already AP by removing first element\n        boolean ap1 = true;\n        for(int i=2;i<n;i++)\n        {\n            if(d != arr[i].a - arr[i-1].a)\n            {\n                ap1 = false;\n                break;\n            }\n        }\n        if(ap1)\n        {\n            cout.print(arr[0].b+1);\n            cout.close();\n            return;\n        }\n        //check if already AP by removing secong element\n        d = arr[2].a - arr[0].a;\n        boolean ap2 = true;\n        for(int i=3;i<n;i++)\n        {\n            if(d != arr[i].a - arr[i-1].a)\n            {\n                ap2 = false;\n                break;\n            }\n        }\n        if(ap2)\n        {\n            cout.print(arr[1].b+1);\n            cout.close();\n            return;\n        }\n        //main body\n        d = arr[1].a - arr[0].a;\n        for(int i=1;i<n;i++)\n        {\n            if(d!= arr[i].a - arr[i-1].a)\n            {\n                boolean ans = ( i+1>=n ||d == arr[i+1].a-arr[i-1].a);\n                for(int j=i+2;j<n;j++)\n                {\n                    if(arr[j].a - arr[j-1].a != d)\n                        ans = false;\n                }\n                if(ans)\n                    cout.print(arr[i].b+1);\n                else\n                    cout.print(-1);\n                break;\n            }\n        }\n\t\tcout.close();\n    }\n\n\n\tprivate static class Pair{\n\t\tpublic int a,b;\n\t\tpublic Pair(int a,int b)\n\t\t{\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t}\t\n\t}\n\n\n    /*public static void seive(int size)\n    {\n        prime[0] = prime[1] = false;\n        int p = 2;\n        while(p*p<= size)\n        {\n            if(prime[p])\n            {\n                for(int i=p*p;i<size;i += p)\n                    prime[i] = false;\n            }\n            p++;\n        }\n    }*/\n\n\n    public static <K, V> V getOrDefault(HashMap<K,V> map, K key, V defaultValue) {\n        return map.containsKey(key) ? map.get(key) : defaultValue;\n    }\n    \n    static void reverseArray(int intArray[], int size) \n    { \n        int i, temp; \n        for (i = 0; i < size / 2; i++) { \n            temp = intArray[i]; \n            intArray[i] = intArray[size - i - 1]; \n            intArray[size - i - 1] = temp; \n        }  \n    } \n\n    public static long mod_pow(long x,long n,long mod) {\n        long res=1;\n        while(n>0) {\n            if((n&1)==1)res=res*x%mod;\n            x=x*x%mod;\n            n>>=1;\n        }\n        return res;\n    }\n    public static int gcd(int n1, int n2) \n    {\n        int r;\n        while (n2 != 0) \n        {\n            r = n1 % n2;\n            n1 = n2;\n            n2 = r;\n        }\n        return n1;\n    }\n \n    /*public static int lcm(int n1, int n2) \n    {\n        int answer = (n1 * n2) / (gcd(n1, n2));\n        return answer;\n    }*/\n\n\n    static class InputReader {\n        final InputStream is;\n        final byte[] buf = new byte[1024];\n        int pos;\n        int size;\n \n        public InputReader(InputStream is) {\n            this.is = is;\n        }\n \n        public int nextInt() {\n            int c = read();\n            while (isWhitespace(c))\n                c = read();\n            int sign = 1;\n            if (c == '-') {\n                sign = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9')\n                    throw new InputMismatchException();\n                res = res * 10 + c - '0';\n                c = read();\n            } while (!isWhitespace(c));\n            return res * sign;\n        }\n \n        int read() {\n            if (size == -1)\n                throw new InputMismatchException();\n            if (pos >= size) {\n                pos = 0;\n                try {\n                    size = is.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (size <= 0)\n                    return -1;\n            }\n            return buf[pos++] & 255;\n        }\n \n        static boolean isWhitespace(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n \n    }\n\nstatic class RecursionLimiter {\n    public static long maxLevel = 100000L;\n\n    public static void emerge() {\n        if (maxLevel == 0)\n            return;\n        try {\n            throw new IllegalStateException(\"Too deep, emerging\");\n        } catch (IllegalStateException e) {\n            if (e.getStackTrace().length > maxLevel + 1)\n                throw e;\n        }\n    }\n}\n\n\nstatic class Scan {\n        private byte[] buf=new byte[1024];\n        private int index;\n        private InputStream in;\n        private int total;\n        public Scan()\n        {\n            in=System.in;\n        }\n        public int scan()throws IOException\n        {\n            if(total<0)\n            throw new InputMismatchException();\n            if(index>=total)\n            {\n                index=0;\n                total=in.read(buf);\n                if(total<=0)\n                return -1;\n            }\n            return buf[index++];\n        }\n        public int scanInt()throws IOException\n        {\n            int integer=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n))\n            {\n                if(n>='0'&&n<='9')\n                {\n                    integer*=10;\n                    integer+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            return neg*integer;\n        }\n        public double scanDouble()throws IOException\n        {\n            double doub=0;\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            int neg=1;\n            if(n=='-')\n            {\n                neg=-1;\n                n=scan();\n            }\n            while(!isWhiteSpace(n)&&n!='.')\n            {\n                if(n>='0'&&n<='9')\n                {\n                    doub*=10;\n                    doub+=n-'0';\n                    n=scan();\n                }\n                else throw new InputMismatchException();\n            }\n            if(n=='.')\n            {\n                n=scan();\n                double temp=1;\n                while(!isWhiteSpace(n))\n                {\n                    if(n>='0'&&n<='9')\n                    {\n                        temp/=10;\n                        doub+=(n-'0')*temp;\n                        n=scan();\n                    }\n                    else throw new InputMismatchException();\n                }\n            }\n            return doub*neg;\n        }\n        public String scanString()throws IOException\n        {\n            StringBuilder sb=new StringBuilder();\n            int n=scan();\n            while(isWhiteSpace(n))\n            n=scan();\n            while(!isWhiteSpace(n))\n            {\n                sb.append((char)n);\n                n=scan();\n            }\n            return sb.toString();\n        }\n        private boolean isWhiteSpace(int n)\n        {\n            if(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n            return true;\n            return false;\n        }\n    }\n\n}\n\nclass Read\n{\n    private BufferedReader br;\n    private StringTokenizer st;\n\n    public Read(InputStream is)\n    { br = new BufferedReader(new InputStreamReader(is)); }\n\n    String next()\n    {\n        while (st == null || !st.hasMoreElements())\n        {\n            try {st = new StringTokenizer(br.readLine());}\n            catch(IOException e)\n                {e.printStackTrace();}\n        }\n        return st.nextToken();\n    }\n\n    int nextInt()\n    { return Integer.parseInt(next()); }\n\n    long nextLong()\n    { return Long.parseLong(next()); }\n\n    double nextDouble()\n    { return Double.parseDouble(next()); }\n\n    String nextLine()\n    {\n        String str = \"\";\n        try {str = br.readLine();}\n        catch(IOException e)\n            {e.printStackTrace();}\n        return str;\n    }\n}\n\n\n", "label": 5}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.HashMap;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.InputStreamReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        Scanner in = new Scanner(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DExtraElement solver = new DExtraElement();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DExtraElement {\n        public void solve(int testNumber, Scanner sc, PrintWriter pw) {\n            int n = sc.nextInt();\n            int[] arr = new int[n];\n            for (int i = 0; i < n; i++)\n                arr[i] = sc.nextInt();\n            Integer[] sort = new Integer[n];\n            for (int i = 0; i < n; i++)\n                sort[i] = i;\n            Arrays.sort(sort, (a, b) -> arr[a] - arr[b]);\n            HashMap<Integer, Integer> map = new HashMap<>();\n            for (int i = 0; i < n - 1; i++)\n                map.put(arr[sort[i + 1]] - arr[sort[i]], map.getOrDefault(arr[sort[i + 1]] - arr[sort[i]], 0) + 1);\n            for (int i = 0; i < n; i++) {\n                int temp = -1, temp2 = -1;\n                boolean remove = false;\n                if (i > 0) {\n                    int diff = arr[sort[i]] - arr[sort[i - 1]];\n                    temp = map.get(diff);\n                    map.replace(diff, temp - 1);\n                    if (map.get(diff) == 0)\n                        map.remove(diff);\n                }\n                if (i < n - 1) {\n                    int diff = arr[sort[i + 1]] - arr[sort[i]];\n                    temp2 = map.get(diff);\n                    map.replace(diff, temp2 - 1);\n                    if (map.get(diff) == 0)\n                        map.remove(diff);\n                }\n                if (i + 1 < n && i - 1 >= 0) {\n                    map.put(arr[sort[i + 1]] - arr[sort[i - 1]], map.getOrDefault(arr[sort[i + 1]] - arr[sort[i - 1]], 0) + 1);\n                    remove = true;\n                }\n                if (map.size() <= 1) {\n                    pw.println(sort[i] + 1);\n                    return;\n                }\n                if (temp != -1)\n                    map.put(arr[sort[i]] - arr[sort[i - 1]], map.getOrDefault(arr[sort[i]] - arr[sort[i - 1]], 0) + 1);\n                if (temp2 != -1)\n                    map.put(arr[sort[i + 1]] - arr[sort[i]], map.getOrDefault(arr[sort[i + 1]] - arr[sort[i]], 0) + 1);\n                if (remove) {\n                    map.put(arr[sort[i + 1]] - arr[sort[i - 1]], map.getOrDefault(arr[sort[i + 1]] - arr[sort[i - 1]], 1) - 1);\n                    if (map.get(arr[sort[i + 1]] - arr[sort[i - 1]]) == 0)\n                        map.remove(arr[sort[i + 1]] - arr[sort[i - 1]]);\n                }\n            }\n            pw.println(-1);\n        }\n\n    }\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() {\n            while (st == null || !st.hasMoreTokens()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return st.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n", "label": 5}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.HashSet;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author Aman Kumar Singh\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        DExtraElement solver = new DExtraElement();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class DExtraElement {\n        PrintWriter out;\n        InputReader in;\n        final Comparator<Pair> com = new Comparator<Pair>() {\n            public int compare(Pair a, Pair b) {\n                if (Integer.compare(a.x, b.x) != 0)\n                    return Integer.compare(a.x, b.x);\n                else\n                    return Integer.compare(a.y, b.y);\n            }\n        };\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            this.out = out;\n            this.in = in;\n            int n = ni();\n            int[] arr = new int[n];\n            int i = 0;\n            Pair[] hola = new Pair[n];\n            for (i = 0; i < n; i++) {\n                arr[i] = ni();\n                hola[i] = new Pair(arr[i], i);\n            }\n            Arrays.sort(hola, com);\n            for (i = 0; i < n; i++)\n                arr[i] = hola[i].x;\n            if (n <= 3) {\n                pn(1);\n                return;\n            }\n            HashSet<Integer> hset1 = new HashSet<>();\n            HashSet<Integer> hset2 = new HashSet<>();\n            int[] sz1 = new int[n];\n            int[] sz2 = new int[n];\n            int[] val1 = new int[n];\n            int[] val2 = new int[n];\n            for (i = 0; i < n - 1; i++) {\n                hset1.add(arr[i] - arr[i + 1]);\n                val1[i + 1] = arr[i] - arr[i + 1];\n                sz1[i + 1] = hset1.size();\n            }\n            for (i = n - 2; i >= 0; i--) {\n                hset2.add(arr[i] - arr[i + 1]);\n                val2[i] = arr[i] - arr[i + 1];\n                sz2[i] = hset2.size();\n            }\n            //pn(Arrays.toString(sz1));\n            //pn(Arrays.toString(sz2));\n            //pn(Arrays.toString(val1));\n            //pn(Arrays.toString(val2));\n            if (hset1.size() > 3)\n                pn(-1);\n            else {\n                for (i = 0; i < n; i++) {\n                    if (i == 0) {\n                        if (sz2[i + 1] == 1) {\n                            pn(hola[i].y + 1);\n                            return;\n                        }\n                    } else if (i == n - 1) {\n                        if (sz1[i - 1] == 1) {\n                            pn(hola[i].y + 1);\n                            return;\n                        }\n                    } else if (i == 1) {\n                        if (sz2[i + 1] == 1 && val2[i + 1] == arr[i - 1] - arr[i + 1]) {\n                            pn(hola[i].y + 1);\n                            return;\n                        }\n                    } else if (i == n - 2) {\n                        if (sz1[i - 1] == 1 && val1[i - 1] == arr[i - 1] - arr[i + 1]) {\n                            pn(hola[i].y + 1);\n                            return;\n                        }\n                        //pn(sz1[i - 1] +\" \"+val1[i] +\" \"+(arr[i - 1] - arr[i + 1]));\n                    } else {\n                        if (sz1[i - 1] == 1 && sz2[i + 1] == 1) {\n                            if (val1[i - 1] == val2[i + 1] && (val1[i - 1] == arr[i - 1] - arr[i + 1])) {\n                                pn(hola[i].y + 1);\n                                return;\n                            }\n                        }\n                    }\n                }\n                pn(-1);\n            }\n        }\n\n        int ni() {\n            return in.nextInt();\n        }\n\n        void pn(Object o) {\n            out.println(o);\n        }\n\n        class Pair {\n            int x;\n            int y;\n\n            Pair(int p, int q) {\n                x = p;\n                y = q;\n            }\n\n        }\n\n    }\n\n    static class InputReader {\n        private InputStream stream;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public InputReader(InputStream stream) {\n            this.stream = stream;\n        }\n\n        public int read() {\n            if (numChars == -1)\n                throw new UnknownError();\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = stream.read(buf);\n                } catch (IOException e) {\n                    throw new UnknownError();\n                }\n                if (numChars <= 0)\n                    return -1;\n            }\n            return buf[curChar++];\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c))\n                c = read();\n            StringBuffer res = new StringBuffer();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n\n            return res.toString();\n        }\n\n        private boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n    }\n}\n\n", "label": 5}
{"src": "// This template code suggested by KT BYTE Computer Science Academy\n//   for use in reading and writing files for USACO problems.\n\n// https://content.ktbyte.com/problem.java\n\nimport java.util.*;\nimport java.io.*;\n\npublic class ExtraElement {\n\n    static StreamTokenizer in;\n\n    static int nextInt() throws IOException {\n        in.nextToken();\n        return (int) in.nval;\n    }\n\n    public static void main(String[] args) throws Exception {\n        in = new StreamTokenizer(new BufferedReader(new InputStreamReader(System.in)));\n        PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\n        int n = nextInt();\n\n        Index[] elems = new Index[n];\n\n        for (int i = 0; i < n; i++) {\n            elems[i] = new Index(nextInt(), i);\n        }\n\n        Arrays.sort(elems);\n\n        boolean works = true;\n\n        if (elems.length > 2) {\n            int diff = elems[2].val - elems[1].val;\n            int indexToRemove = elems[0].index;\n\n            for (int i = 2; i < n; i++) {\n                if (elems[i].val - elems[i-1].val == diff) continue;\n\n                works = false;\n                break;\n            }\n\n            if (works) {\n                out.println(indexToRemove+1);\n                out.close();\n                return;\n            }\n\n            works = true;\n\n            diff = elems[2].val - elems[0].val;\n            indexToRemove = elems[1].index;\n\n            for (int i = 3; i < n; i++) {\n                if (elems[i].val - elems[i-1].val == diff) continue;\n\n                works = false;\n                break;\n            }\n\n            if (works) {\n                out.println(indexToRemove+1);\n                out.close();\n                return;\n            }\n        }\n\n        works = true;\n\n        int diff = elems[1].val - elems[0].val;\n\n        int indexToRemove = -1;\n\n        for (int i = 1; i < n; i++) {\n            if (indexToRemove != -1 && indexToRemove == elems[i-1].index) {\n                if (elems[i].val - elems[i-2].val == diff) continue;\n            }\n\n            if (elems[i].val - elems[i-1].val == diff) continue;\n\n            if (i != n-1) {\n                if (!(elems[i+1].val - elems[i-1].val == diff && indexToRemove == -1)) {\n                    works = false;\n                    break;\n                }\n            }\n\n            indexToRemove = elems[i].index;\n        }\n\n        if (works) {\n            out.println(Math.max(indexToRemove+1, 1));\n            out.close();\n            return;\n        }\n\n        else {\n            out.println(-1);\n        }\n\n        out.close();\n    }\n\n    static class Index implements Comparable<Index> {\n        int val, index;\n\n        Index(int val, int index) {\n            this.val = val;\n            this.index = index;\n        }\n\n        @Override\n        public int compareTo(Index o) {\n            return this.val - o.val;\n        }\n    }\n}\n\n\n", "label": 5}
{"src": "import java.io.*;\nimport java.math.BigInteger;\nimport java.util.*;\n\npublic class l {\n    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////                                                                                                               /////////\n////////                                                                                                               /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMMMM      MMMMMM      OOO      OOO        SSSS   SSS     EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEE           MMMM MMM  MMM MMMM    OOO          OOO    SSSS       SSS   EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM  MMMMMM  MMMM   OOO            OOO   SSSS             EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM  OOO              OOO   SSSSSSS         EEEEE          /////////\n////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO      SSSSSS       EEEEEEEEEEE    /////////\n////////   HHHHHHHHHHHHHHHH  EEEEEEEEEEE     MMMM          MMMM  OOO              OOO         SSSSSSS   EEEEEEEEEEE    /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM   OOO            OOO              SSSS  EEEEE          /////////\n////////   HHHH        HHHH  EEEEE           MMMM          MMMM    OOO          OOO     SSS       SSSS  EEEEE          /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM      OOO      OOO        SSS    SSSS    EEEEEEEEEEEEE  /////////\n////////   HHHH        HHHH  EEEEEEEEEEEEE   MMMM          MMMM         OOOOOO             SSSSSSS      EEEEEEEEEEEEE  /////////\n////////                                                                                                               /////////\n////////                                                                                                               /////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    static long mod= (int) (1e9 +9);\n    static int n;\n    static StringBuilder sol;\n    static class pair implements Comparable<pair>{\n        int num,idx;\n        public pair(int a,int b){\n            num=a;\n            idx=b;\n        }\n        @Override\n        public int compareTo(pair pair) {\n            return num-pair.num;\n        }\n    }\n    public static void main(String[] args) throws IOException {\n        Scanner sc = new Scanner(System.in);\n        //  FileWriter f = new FileWriter(\"C:\\\\Users\\\\Ibrahim\\\\out.txt\");\n        PrintWriter pw = new PrintWriter(System.out);\n        int n = sc.nextInt();\n        pair[]inp= new pair[n];\n        for (int i =0;i<n;i++){\n            inp[i]= new pair(sc.nextInt(),i);\n        }\n        Arrays.sort(inp);\n        int[]one= new int[n];\n        one[0]=inp[0].num;\n        one[1]=inp[1].num;\n        int pre=1;\n        int next=2;\n        int c=one[1]-one[0];\n        for (int i =2;i<n;i++){\n            one[i]=inp[i].num-one[0];\n            if (one[i]!=1l*c*i){\n                next=i;\n                break;\n            }\n            pre=i;\n        }\n        if (pre==n-1){\n            pw.println(inp[n-1].idx+1);\n            pw.flush();return;\n        }\n        //pw.println(pre+\" \"+next);\n        int[]a1=new int[n-1];\n        int[]a2= new int[n-1];\n        int idx1=0;\n        int idx2=0;\n        for (int i =0;i<one.length;i++){\n            if (i!=pre){\n                a1[idx1++]=inp[i].num;\n            }\n            if (i!=next){\n                a2[idx2++]=inp[i].num;\n            }\n        }\n        boolean is=true;\n        c=a1[1]-a1[0];\n        for (int i =2;i<n-1;i++){\n            a1[i]-=a1[0];\n            if (a1[i]!=1l*c*i){\n              is=false;\n            }\n        }\n        if (is){\n            pw.println(inp[pre].idx+1);\n            pw.flush();\n            return;\n        }\n        is=true;\n        c=a2[1]-a2[0];\n        for (int i =2;i<n-1;i++){\n            a2[i]-=a2[0];\n            if (a2[i]!=1l*c*i){\n                is=false;\n            }\n        }\n        if (is){\n            pw.println(inp[next].idx+1);\n            pw.flush();\n            return;\n        }\n        pre=0;\n        idx1=0;\n        is=true;\n        for (int i =0;i<one.length;i++){\n            if (i!=pre){\n                a1[idx1++]=inp[i].num;\n            }\n        }\n        c=a1[1]-a1[0];\n        for (int i =2;i<n-1;i++){\n            a1[i]-=a1[0];\n            if (a1[i]!=1l*c*i){\n                is=false;\n            }\n        }\n        if (is){\n            pw.println(inp[pre].idx+1);\n            pw.flush();\n            return;\n        }\n        pw.println(-1);\n        pw.flush();\n    }\n\n\n\n    static class Scanner {\n        StringTokenizer st;\n        BufferedReader br;\n\n        public Scanner(FileReader r) {\n            br = new BufferedReader(r);\n        }\n\n        public Scanner(InputStream s) {\n            br = new BufferedReader(new InputStreamReader(s));\n        }\n\n        public String next() throws IOException {\n            while (st == null || !st.hasMoreTokens())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        public int nextInt() throws IOException {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() throws IOException {\n            return Long.parseLong(next());\n        }\n\n        public String nextLine() throws IOException {\n            return br.readLine();\n        }\n\n        public double nextDouble() throws IOException {\n            String x = next();\n            StringBuilder sb = new StringBuilder(\"0\");\n            double res = 0, f = 1;\n            boolean dec = false, neg = false;\n            int start = 0;\n            if (x.charAt(0) == '-') {\n                neg = true;\n                start++;\n            }\n            for (int i = start; i < x.length(); i++)\n                if (x.charAt(i) == '.') {\n                    res = Long.parseLong(sb.toString());\n                    sb = new StringBuilder(\"0\");\n                    dec = true;\n                } else {\n                    sb.append(x.charAt(i));\n                    if (dec)\n                        f *= 10;\n                }\n            res += Long.parseLong(sb.toString()) / f;\n            return res * (neg ? -1 : 1);\n        }\n\n        public boolean ready() throws IOException {\n            return br.ready();\n        }\n\n\n    }\n}", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.lang.*;\n\npublic class GFG {\n\tpublic static void main (String[] args) {\n\tPrintWriter pw=new PrintWriter(System.out);\n\tScanner sc=new Scanner(System.in);\n            int n=sc.nextInt();\n            int[] a=new int[n];\n\t\t   HashMap<Integer,Integer> map=new HashMap<Integer,Integer>();\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\ta[i]=sc.nextInt();\n\t\t\tmap.put(a[i],i);\n\t\t}\n\t\tArrays.sort(a);\n\t\t  int a1=a[0];\n\t\t  int b1=a[1];\n\t\t  int c1=b1-a1;\n\t\t  int i1=1,count=0,s=map.get(a[0]);\n\t\t  for(int i=1;i<n;i++){\n\t\t      if(a[i]!=a1+c1*i1){\n\t\t          s=map.get(a[i]);\n\t\t          count++;\n\t\t          if(count==2)\n\t\t          break;\n\t\t         \n\t\t      }\n\t\t      else\n\t\t      i1++;\n\t\t  }\n\t\tif(count<=1){\n\t\tpw.print(s+1);\n\t\t    \n\t\t}\n\t\telse{\n\t\t   \n\t\t     a1=a[1];\n\t\t     b1=a[2];\n\t\t     c1=b1-a1;\n\t\t  s=map.get(a[0])+1;\n\t\t  if(n>2){\n\t\t   for(int i=1;i<n;i++){\n\t\t       if(a[i]!=a1+c1*(i-1)){\n\t\t           s=-1;\n\t\t           break;\n\t\t       }\n\t\t   }\n\t\t   if(s==-1){\n\t\t         a1=a[0];\n\t\t     b1=a[2];\n\t\t     c1=b1-a1;\n\t\t  s=map.get(a[1])+1;\n\t\t     for(int i=2;i<n;i++){\n\t\t       if(a[i]!=a1+c1*(i-1)){\n\t\t           s=-1;\n\t\t           break;\n\t\t       }\n\t\t   }\n\t\t    \n\t\t       \n\t\t   }\n\t\t   \n\t\t   \n\t\t   \n\t\t   \n\t\t  }\n\t\t  pw.println(s);\n\t\t  \n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\n\t\tpw.close();\n\t}\n}", "label": 5}
{"src": "//start\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner mi=new Scanner(System.in);\n\t\tint n=mi.nextInt();\n\t\tint[] b=new int[n];\n\t\tMap<Integer,Integer> index=new HashMap<Integer,Integer>();\n\t\tfor(int i=0 ; i<n ; ++i) {\n\t\t\tb[i]=mi.nextInt();\n\t\t\tindex.put(b[i] , i+1);  //+1\n\t\t}\n\t\tif(n<=3) {p(\"n<=3\"); System.out.println(1); return;} \n\t\t\n\t\tArrays.sort(b);\n\t\tint diff1=b[1]-b[0];\n\t\tint diff2=-1;\n\t\tint diff3=-1;\n\t\tboolean found_diff2=false;\n\t\tint ii=-1;\n\t\tfor(int i=1 ; i<n-1 ; ++i) {\n\t\t\tif(diff1 != b[i+1]-b[i]) {\n\t\t\t\tfound_diff2=true;\n\t\t\t\tdiff2=b[i+1]-b[i];\n\t\t\t\tif(i==n-2) {\n\t\t\t\t\tp(\"ii==n-2\");\n\t\t\t\t\tSystem.out.println(index.get(b[n-1]));\n\t\t\t\t\treturn;\n\t\t\t\t}else {\n\t\t\t\t\tdiff3=b[i+2]-b[i+1];\n\t\t\t\t}\n\t\t\t\tii=i;\n\t\t\t\tbreak;  //forgot\n\t\t\t}\n\t\t}\n\t\tif(! found_diff2) {\n\t\t\tp(\"! found_diff2\");\n\t\t\tSystem.out.println(index.get(b[0]));\n\t\t\treturn;\n\t\t}\n\t\tp(\"diff1=\"+diff1+\" , diff2=\"+diff2+\" , diff3=\"+diff3);\n\t\t\n\t\tint diff=-1;\n\t\tif(diff1==diff2+diff3) {\n\t\t\tdiff=diff1;\n\t\t\tp(\"diff1 == diff2+diff3 . diff=diff1=\"+diff);\n\t\t}else if(diff3==diff1+diff2) {\n\t\t\tif(ii!=1) {  //add after 1 WA\n\t\t\t\t//if(ii==2 && n==5 && diff1*2==diff2) {  // n==4 -> 2 WA -> n==5 -> deprecate ii==2 case\n\t\t\t\t\t//System.out.println(index.get(b[1]));\n\t\t\t\t//}else {\n\t\t\t\t\tp(\"diff3 == diff1+diff2 . ii!=1\");\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t//}\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tdiff=diff3;\n\t\t\tp(\"diff3 == diff1+diff2 . diff=diff3=\"+diff3);\n\t\t}else {\n\t\t\t//System.out.println(-1);\n\t\t\t//return;\n\t\t\t\n\t\t\t//modified after 2 WA\n\t\t\tif(ii==1 && diff2==diff3) {\n\t\t\t\tp(\"ii==1 && diff2==diff3\");\n\t\t\t\tdiff=diff3;\n\t\t\t\tboolean valid=true;\n\t\t\t\tfor(int i=ii+2 ; i<n-1 ; ++i) {\n\t\t\t\t\tif(b[i+1]-b[i]!=diff) {\n\t\t\t\t\t\tvalid=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp(\"valid=\"+valid);\n\t\t\t\tif(valid) {\n\t\t\t\t\tSystem.out.println(index.get(b[0]));\n\t\t\t\t}else {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t}\n\t\t\t}else if(ii==2 && diff2==diff3) {  //add after 3 WA and then see data_51 on CF\n\t\t\t\tp(\"ii==2 && diff2==diff3\");\n\t\t\t\tdiff=diff3;\n\t\t\t\tboolean valid=true;\n\t\t\t\tfor(int i=ii+2 ; i<n-1 ; ++i) {\n\t\t\t\t\tif(b[i+1]-b[i]!=diff) {\n\t\t\t\t\t\tvalid=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tp(\"valid=\"+valid);\n\t\t\t\tif(valid) {\n\t\t\t\t\tSystem.out.println(index.get(b[1]));\n\t\t\t\t}else {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t}\n\t\t\t}else {\n\t\t\t\tp(\"(1)\");\n\t\t\t\tSystem.out.println(-1);\n\t\t\t}\n\t\t\treturn;  //forgot\n\t\t}\n\t\t\n\t\tboolean valid=true;\n\t\tfor(int i=ii+2 ; i<n-1 ; ++i) {\n\t\t\tif(b[i+1]-b[i]!=diff) {\n\t\t\t\tvalid=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tp(\"valid=\"+valid);\n\t\tif(valid) {\n\t\t\tif(diff1+diff2==diff3) {\n\t\t\t\tSystem.out.println(index.get(b[1]));  //add after 2 WA\n\t\t\t}else {\n\t\t\t\tSystem.out.println(index.get(b[ii+1]));\n\t\t\t}\n\t\t\t\n\t\t}else {\n\t\t\tSystem.out.println(-1);\n\t\t}\n\t}\n\n\tpublic static void p(String s) {\n\t\t//System.out.println(s);\n\t}\n}\n//end", "label": 5}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Random;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\n\npublic class Main1 {\n\n\tstatic FastReader input = new FastReader();\n\tstatic PrintWriter out = new PrintWriter(System.out);\n\tstatic int n;\n\tstatic int[] a;\n\tstatic final int INF = Integer.MAX_VALUE;\n\n\tstatic void shuffle() {\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tint r = i + (int) (Math.random() * (n - i));\n\t\t\tint tmp = a[i];\n\t\t\ta[i] = a[r];\n\t\t\ta[r] = tmp;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tn = input.nextInt();\n\t\ta = new int[n];\n\t\tTreeMap<Integer, Integer> map = new TreeMap<>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ta[i] = input.nextInt();\n\t\t\tmap.put(a[i], i + 1);\n\t\t}\n\n\t\tshuffle();\n\t\tArrays.sort(a);\n\n\t\tif (n == 2) {\n\t\t\tSystem.out.println(1);\n\t\t} else {\n\t\t\tboolean isArith1 = true;\n\t\t\tint diff = a[2] - a[1];\n\n\t\t\tfor (int i = 3; i < n; i++) {\n\t\t\t\tif (a[i] - a[i - 1] != diff) {\n\t\t\t\t\tisArith1 = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tboolean isArith2 = true;\n\t\t\tdiff = a[1] - a[0];\n\t\t\tfor (int i = 2; i < n - 1; i++) {\n\t\t\t\tif (a[i] - a[i - 1] != diff) {\n\t\t\t\t\tisArith2 = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (isArith1 || isArith2) {\n\t\t\t\tSystem.out.println(isArith1 ? map.get(a[0]) : map.get(a[n - 1]));\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tint d = (a[n - 1] - a[0]) / (n - 2);\n\n\t\t\t\tint indx = -1;\n\t\t\t\tfor (int i = 1; i < n - 1; i++) {\n\t\t\t\t\tif (a[i + 1] - a[i - 1] == d) {\n\t\t\t\t\t\tindx = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tboolean isArth3 = true;\n\t\t\t\tfor (int i = 1; i < n; i++) {\n\t\t\t\t\tif (i == indx || i - 1 == indx)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (a[i] - a[i - 1] != d) {\n\t\t\t\t\t\tisArth3 = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isArth3) {\n\t\t\t\t\tSystem.out.println(map.get(a[indx]));\n\t\t\t\t} else {\n\t\t\t\t\tSystem.out.println(-1);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t}\n\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt() throws NumberFormatException, IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nextLong() throws NumberFormatException, IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() throws NumberFormatException, IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() throws IOException {\n\t\t\tString str = \"\";\n\t\t\tstr = br.readLine();\n\t\t\treturn str;\n\t\t}\n\t}\n\n}", "label": 5}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Main\n{\n\tstatic final int MAX = 111;\n\tstatic int[] o = new int[MAX];\n\t\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\t\n\t\tint n = in.nextInt();\n\t\tPair p[] = new Pair[n];\n\t\t\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tp[i] = new Pair(in.nextLong(), i + 1);\n\t\t\t\n\t\tArrays.sort(p, new Comparator<Pair>() {\n\t\t\tpublic int compare(Pair o1, Pair o2) {\n\t\t\t\tif(o1.element < o2.element)\n\t\t\t\t\treturn -1;\n\t\t\t\t\n\t\t\t\tif(o1.element > o2.element)\n\t\t\t\t\treturn 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\t\t\n\t\tif(n == 2)\n\t\t{\n\t\t\tout.println(\"1\");\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong diff = p[1].element - p[0].element;\n\t\tint flag = 0;\n\t\tint idx = -1;\n\t\tlong last = p[1].element;\n\t\t\n\t\tfor(int i = 2; i < n; i++)\n\t\t{\n\t\t\tif(p[i].element - last != diff)\n\t\t\t{\n\t\t\t\tflag++;\n\t\t\t\tidx = p[i].index;\n\t\t\t}\n\t\t\telse\n\t\t\t\tlast = p[i].element;\n\t\t}\n\t\t\n\t\tif(flag == 0)\n\t\t{\n\t\t\tout.println(p[n - 1].index);\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\telse if(flag == 1)\n\t\t{\n\t\t\tout.println(idx);\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdiff = p[2].element - p[0].element;\n\t\tflag = 0;\n\t\tlast = p[2].element;\n\t\t\n\t\tfor(int i = 3; i < n; i++)\n\t\t{\n\t\t\tif(p[i].element - last != diff)\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tlast = p[i].element;\n\t\t}\n\t\t\n\t\tif(flag == 0)\n\t\t{\n\t\t\tout.println(p[1].index);\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tdiff = p[2].element - p[1].element;\n\t\tflag = 0;\n\t\tlast = p[2].element;\n\t\t\n\t\tfor(int i = 3; i < n; i++)\n\t\t{\n\t\t\tif(p[i].element - last != diff)\n\t\t\t{\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tlast = p[i].element;\n\t\t}\n\t\t\n\t\tif(flag == 0)\n\t\t{\n\t\t\tout.println(p[0].index);\n\t\t\tout.close();\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tout.println(\"-1\");\n\t\tout.close();\n\t}\n\t\n\tstatic class Pair\n\t{\n\t\tlong element;\n\t\tint index;\n\t\t\n\t\tPair(long a, int b)\n\t\t{\n\t\t\telement = a;\n\t\t\tindex = b;\n\t\t}\n\t}\n\t\n\tstatic class InputReader\n\t{\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\t\t\n\t\tpublic InputReader(InputStream stream)\n\t\t{\n\t\t\treader = new BufferedReader(new InputStreamReader(stream), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\t\t\n\t\tpublic String next()\n\t\t{\n\t\t\twhile(tokenizer == null || !tokenizer.hasMoreTokens())\n\t\t\t{\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t}\n\t\t\t\tcatch(IOException e)\n\t\t\t\t{\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\t\n\t\tpublic int nextInt()\n\t\t{\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\t\n\t\tpublic long nextLong()\n\t\t{\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n}", "label": 5}
{"src": "import java.io.*; \nimport java.math.*;\nimport java.util.*;\nimport java.awt.Point;\n \npublic class Main {\n\t//static final long MOD = 998244353L;\n\tstatic final long INF = -1000000000000000007L;\n\t//static final long MOD = 1000000007L;\n\t//static final int INF = 1000000007;\n\t\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter pw = new PrintWriter(System.out);\n\t\tint N = sc.ni();\n\t\tint[][] nums = new int[N][2];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tnums[i] = new int[]{sc.ni(),i};\n\t\t}\n\t\tnums = sort(nums);\n\t\tHashMap<Integer,Integer> diffs = new HashMap<Integer,Integer>();\n\t\tfor (int i = 0; i < N-1; i++) {\n\t\t\tint diff = nums[i+1][0]-nums[i][0];\n\t\t\tdiffs.put(diff,diffs.getOrDefault(diff,0)+1);\n\t\t}\n\t\tint ans = -1;\n\t\tif (N > 2) {\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tif (i == 0 || i == N-1) {\n\t\t\t\t\tint d = 0;\n\t\t\t\t\tif (i==0) {\n\t\t\t\t\t\td = nums[1][0]-nums[0][0];\n\t\t\t\t\t} else {\n\t\t\t\t\t\td = nums[N-1][0]-nums[N-2][0];\n\t\t\t\t\t}\n\t\t\t\t\tdiffs.replace(d,diffs.get(d),diffs.get(d)-1);\n\t\t\t\t\tdiffs.remove(d,0);\n\t\t\t\t\tif (diffs.size() == 1) {\n\t\t\t\t\t\tans = nums[i][1]+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdiffs.put(d, diffs.getOrDefault(d,0)+1);\n\t\t\t\t} else {\n\t\t\t\t\tint d1 = nums[i][0]-nums[i-1][0];\n\t\t\t\t\tint d2 = nums[i+1][0]-nums[i][0];\n\t\t\t\t\tint d3 = d1+d2;\n\t\t\t\t\tdiffs.replace(d1,diffs.get(d1),diffs.get(d1)-1);\n\t\t\t\t\tdiffs.remove(d1,0);\n\t\t\t\t\tdiffs.replace(d2,diffs.get(d2),diffs.get(d2)-1);\n\t\t\t\t\tdiffs.remove(d2,0);\n\t\t\t\t\tdiffs.put(d3, diffs.getOrDefault(d3,0)+1);\n\t\t\t\t\tif (diffs.size() == 1) {\n\t\t\t\t\t\tans = nums[i][1]+1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tdiffs.put(d1, diffs.getOrDefault(d1,0)+1);\n\t\t\t\t\tdiffs.put(d2, diffs.getOrDefault(d2,0)+1);\n\t\t\t\t\tdiffs.replace(d3,diffs.get(d3),diffs.get(d3)-1);\n\t\t\t\t\tdiffs.remove(d3,0);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tans = 1;\n\t\t}\n\t\tpw.println(ans);\n\t\tpw.close();\n \t}\n    \n    public static int[][] sort(int[][] array) {\n    \t//Sort an array (immune to quicksort TLE)\n\t\tRandom rgen = new Random();\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t    int randomPosition = rgen.nextInt(array.length);\n\t\t    int[] temp = array[i];\n\t\t    array[i] = array[randomPosition];\n\t\t    array[randomPosition] = temp;\n\t\t}\n\t\tArrays.sort(array, new Comparator<int[]>() {\n\t\t\t  @Override\n        \t  public int compare(int[] arr1, int[] arr2) {\n\t\t\t\t  return arr1[0]-arr2[0]; //ascending order\n\t          }\n\t\t});\n\t\treturn array;\n\t}\n    \n    public static long[][] sort(long[][] array) {\n    \t//Sort an array (immune to quicksort TLE)\n\t\tRandom rgen = new Random();\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t    int randomPosition = rgen.nextInt(array.length);\n\t\t    long[] temp = array[i];\n\t\t    array[i] = array[randomPosition];\n\t\t    array[randomPosition] = temp;\n\t\t}\n\t\tArrays.sort(array, new Comparator<long[]>() {\n\t\t\t  @Override\n\t\t\t  //Descending order\n        \t  public int compare(long[] arr1, long[] arr2) {\n\t\t\t\t  if (arr2[0] < arr1[0])\n\t\t\t\t\t  return -1;\n\t\t\t\t  if (arr2[0] > arr1[0])\n\t\t\t\t\t  return 1;\n\t\t\t\t  return 0;\n\t          }\n\t\t});\n\t\treturn array;\n\t}\n    \n    static class FastScanner { \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastScanner() { \n            br = new BufferedReader(new InputStreamReader(System.in)); \n        } \n  \n        String next() { \n            while (st == null || !st.hasMoreElements()) { \n                try { \n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException  e) { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int ni() { \n            return Integer.parseInt(next()); \n        } \n  \n        long nl() { \n            return Long.parseLong(next()); \n        } \n  \n        double nd() { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() { \n            String str = \"\"; \n            try { \n                str = br.readLine(); \n            } catch (IOException e) {\n                e.printStackTrace(); \n            } \n            return str; \n        }\n    }\n}", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class P568D {\n\n    public static void main(String args[]){\n         Reader s = new Reader();\n         int n = s.nextInt();\n         int a[][] = new int[n+2][2];\n\n         if(n==2){\n             System.out.println(1);\n             return;\n         }\n         for(int i=1;i<=n;i++){\n             a[i][0] = s.nextInt();\n             a[i][1] = i;\n         }\n\n         a[n+1][0] = Integer.MAX_VALUE;\n         a[0][0] = Integer.MIN_VALUE;\n         Arrays.sort(a, new Comparator<int[]>() {\n             @Override\n             public int compare(int[] o1, int[] o2) {\n                 if(o1[0] < o2[0]){\n                     return -1;\n                 }\n                 if(o1[0] > o2[0]){\n                     return 1;\n                 }\n                 return 0;\n             }\n         });\n         a[0][0] = 0;\n         a[n+1][0] = 0;\n         int pre[] = new int[n+2];\n         int suf[] = new int[n+2];\n         pre[1] = 1;\n         pre[2] = 2;\n         suf[n-1] = 2;\n         suf[n] = 1;\n\n         for(int i=3;i<=n;i++){\n             if((a[i][0]-a[i-1][0]) == (a[i-1][0]-a[i-2][0])){\n                 pre[i] = 1 + pre[i-1];\n             }\n             else{\n                 pre[i] = 2;\n             }\n         }\n\n         for(int i=n-2;i>0;i--){\n             if((a[i+1][0]-a[i][0]) == (a[i+2][0]-a[i+1][0])){\n                 suf[i] = 1 + suf[i+1];\n             }\n             else{\n                 suf[i] = 2;\n             }\n         }\n\n         for(int i=0;i<=n;i++){\n            // System.out.println(a[i][0]+\" \"+pre[i]+\" \"+suf[i]);\n         }\n\n         for(int i=1;i<=n;i++){\n             if((pre[i-1] + suf[i+1]) == n-1 ){\n\n             //   System.out.println(a[i][0]+\" \"+a[i][1]);\n                int d = a[i+1][0] - a[i-1][0];\n                if(i==1){\n                    d = a[n][0] - a[n-1][0];\n                }\n                else if(i==n){\n                    d = a[2][0] - a[1][0];\n                }\n                boolean flag = false;\n                for(int j=2;j<i;j++){\n                    if((a[j][0] - a[j-1][0]) != d){\n                        flag = true;\n                        break;\n                    }\n                }\n\n                for(int j=i+2;j<=n;j++){\n                    if((a[j][0] - a[j-1][0]) != d){\n                        flag = true;\n                        break;\n                    }\n                }\n                if(!flag){\n                    System.out.println(a[i][1]);\n                    return;\n                }\n\n             }\n         }\n\n        System.out.println(-1);\n\n\n\n    }\n    static class Reader {\n\n        private InputStream mIs;\n        private byte[] buf = new byte[1024];\n        private int curChar;\n        private int numChars;\n\n        public Reader() {\n            this(System.in);\n        }\n\n        public Reader(InputStream is) {\n            mIs = is;\n        }\n\n        public int read() {\n            if (numChars == -1) {\n                throw new InputMismatchException();\n\n            }\n            if (curChar >= numChars) {\n                curChar = 0;\n                try {\n                    numChars = mIs.read(buf);\n                } catch (IOException e) {\n                    throw new InputMismatchException();\n                }\n                if (numChars <= 0) {\n                    return -1;\n                }\n            }\n            return buf[curChar++];\n        }\n\n        public String nextLine() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isEndOfLine(c));\n            return res.toString();\n        }\n\n        public String next() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            StringBuilder res = new StringBuilder();\n            do {\n                res.appendCodePoint(c);\n                c = read();\n            } while (!isSpaceChar(c));\n            return res.toString();\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        public long nextLong() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            long res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public int nextInt() {\n            int c = read();\n            while (isSpaceChar(c)) {\n                c = read();\n            }\n            int sgn = 1;\n            if (c == '-') {\n                sgn = -1;\n                c = read();\n            }\n            int res = 0;\n            do {\n                if (c < '0' || c > '9') {\n                    throw new InputMismatchException();\n                }\n                res *= 10;\n                res += c - '0';\n                c = read();\n            } while (!isSpaceChar(c));\n            return res * sgn;\n        }\n\n        public boolean isSpaceChar(int c) {\n            return c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n        }\n\n        public boolean isEndOfLine(int c) {\n            return c == '\\n' || c == '\\r' || c == -1;\n        }\n\n    }\n\n}\n", "label": 5}
{"src": "import java.util.*;\nimport java.io.*;\npublic class Solution{\n\n\tpublic static Integer INT(String s){\n\t\treturn Integer.parseInt(s);\n\t}\n\n\tpublic static Long LONG(String s){\n\t\treturn Long.parseLong(s);\n\t}\n\n\t//====================================================================================================================\n\n\n\tpublic static int search(int b[], int item){\n\n\t\tfor(int i=0; i<b.length; i++)\n\t\t\tif(b[i]==item)\n\t\t\t\treturn i+1;\n\n\t\treturn -1;\n\t}\n\n\tpublic static int check(int a[], int a0, int a1, int item, int count){\n\n\t\tint c=2, d=a[a1]-a[a0];\n\n\t\tfor(int i=a1; i<a.length; i++){\n\n\t\t\tif(a[a0]+(c-1)*d==a[i])\n\t\t\t\tc+=1;\n\t\t\telse{\n\t\t\t\tcount+=1;\n\t\t\t\titem=a[i];\n\t\t\t}\n\n\t\t}\n\n\t\tif(count==1)\n\t\t\treturn item;\n\n\t\treturn Integer.MIN_VALUE;\n\t}\n\n\tpublic static void main(String args[])throws IOException{\n\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\tScanner in=new Scanner(System.in);\tStringBuffer out=new StringBuffer();\n\n\t\tint n=INT(br.readLine());\n\n\t\tint b[]=new int[n];\n\t\tint a[]=new int[n];\n\t\tString line[]=br.readLine().split(\"\\\\s\");\n\n\t\tfor(int i=0; i<n; i++)\n\t\t\ta[i]=b[i]=INT(line[i]);\n\n\t\tif(n==2){\n\t\t\tSystem.out.println(\"1\");\n\t\t\treturn;\n\t\t}\n\n\t\tArrays.sort(a);\n\n\t\tint item=check(a, 0, 1, -1, 0);\n\n\t\tif(item==Integer.MIN_VALUE)\n\t\t\titem=check(a, 1, 2, a[0], 1);\n\n\t\tif(item==Integer.MIN_VALUE)\n\t\t\titem=check(a, 0, 2, a[1], 1);\n\n\n\t\tif(item==Integer.MIN_VALUE)\n\t\t\tSystem.out.println(\"-1\");\n\t\telse\n\t\t\tSystem.out.println(search(b, item));\n\t}\n}", "label": 5}
{"src": "import java.util.*;\n\npublic class Great_Graphs {\n    public static void main(String[] args) throws java.lang.Exception{\n        Scanner input = new Scanner(System.in);\n        int t = input.nextInt();\n        for(int i=0;i<t;i++){\n            int n = input.nextInt();\n            Long[] d = new Long[n];\n            for(int j=0;j<n;j++){\n                d[j] = input.nextLong();\n            }\n            Arrays.sort(d);\n            long[] prefsum = new long[n];\n            prefsum[0] = d[0];\n            for(int j=1;j<n;j++){\n                prefsum[j] = prefsum[j-1]+d[j];\n            }\n\n            if(n<=2){\n                System.out.println(0);\n                continue;\n            }\n            long ans = 0;\n            long mul = 1;\n            for(int j=2;j<n;j++){\n                ans += (mul*d[j])-prefsum[j-2];\n                mul++;\n            }\n            ans = -ans;\n            System.out.println(ans);\n        }\n    }\n}\n", "label": 5}
{"src": "//1540A\nimport java.util.*;\npublic class GreatGraphs {\n\tpublic static void main(String[]args) {\n\t\tScanner s = new Scanner(System.in);\n\t\tint t = s.nextInt();\n\t\twhile(t-->0) {\n\t\t\tint n = s.nextInt();\n\t\t\tlong excess = 0;\n\t\t\tlong [] arr = new long[n];\n\t\t\tfor(int i = 0; i<n; i++) {\n\t\t\t\tarr[i]=s.nextLong();\n\t\t\t\texcess = Math.max(excess, arr[i]); //maximum value of the array\n\t\t\t}\n\t\t\tArrays.sort(arr);\n\t\t\tlong [] arr0 = new long[n];\n\t\t\tlong ans = excess;\n\t\t\tarr0[0]=0;\n\t\t\tfor(int i = 1; i<n; i++) {\n\t\t\t\tarr0[i]=(long)arr0[i-1]-(long)i*(long)(arr[i]-arr[i-1]);\n\t\t\t\tans+=arr0[i];\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t\ts.close();\n\t}\n}\n", "label": 5}
{"src": "import java.util.Scanner;\npublic class Main {\n    public static void main(String[] args) {\n        Scanner input = new Scanner(System.in);\n        int t = input.nextInt();\n        for(int i=0;i<t;i++){\n            int n = input.nextInt();\n            long[] array = new long[n];\n            long[] t1 = new long[n];\n            for (int j=0;j<n;j++){\n                array[j] = input.nextLong();\n            }\n            //long begin = System.currentTimeMillis();\n            fn1(array,t1,0,n-1);\n\n            //long end = System.currentTimeMillis();\n            //System.out.println(begin-end);\n//            for(int k=0;k<n;k++){\n//                System.out.println(array[k]);\n//            }\n            long answer = 0;\n            long count = 0;\n            long pre = 0;\n            for (int j=2;j<n;j++){\n                long x = array[j-1] - array[j];\n                long temp = pre + count * x + array[j-2] - array[j];\n                answer = answer+pre + count * x + array[j-2] - array[j];\n                pre = temp;\n\n                count++;\n            }\n            System.out.println(answer);\n        }\n    }\n    public static void fn(long[] array,int begin, int end) {\n        if (begin < end) {\n            long normal = array[begin];\n            int high = end;\n            int low = begin;\n            while (low < high) {\n                while (low < high && array[high] >= normal)\n                    high--;\n                array[low] = array[high];\n                while (low < high && array[low] <= normal)\n                    low++;\n                array[high] = array[low];\n\n            }\n            array[low] = normal;\n            fn(array, begin, low-1);\n            fn(array, low + 1, end);\n        }\n    }\n    public static void fn1(long[] a,long[]b,int left,int right){\n        if(left<right){\n            int mid = (left+right)/2;\n            fn1(a,b,left,mid);\n            fn1(a,b,mid+1,right);\n            fn2(a,b,left,mid,mid+1,right);\n        }\n    }\n    public static void fn2(long[] a,long[] b,int i,int a2,int j,int b2){\n        int k=i;\n        int z=i;\n        while(i<=a2&&j<=b2){\n            if(a[i]>a[j]){\n                b[k]=a[j];\n                j++;\n                k++;\n            }\n            else {\n                b[k]=a[i];\n                i++;\n                k++;\n            }\n        }\n        while(i<=a2){\n            b[k]=a[i];\n            i++;\n            k++;\n        }\n        while(j<=b2){\n            b[k]=a[j];\n            j++;\n            k++;\n        }\n        for(int m=z;m<=b2;m++) {\n            a[m] = b[m];\n        }\n    }\n}", "label": 5}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.security.cert.CollectionCertStoreParameters;\nimport java.util.*;\n\n\nimport static javax.swing.UIManager.get;\n\n\n\n\npublic class Main {\n\n\n   static class Pair implements Comparable<Pair>{\n        int x=0,y=0;\n        public Pair(int x1,int y1)\n        { x=x1;\n            y=y1;\n        }\n\n\n        @Override\n        public int compareTo(Pair o) {\n            return this.x-o.x;\n        }\n    }\n\n\n\n    public static void main(String[] args) throws IOException {\n        FastReader sc = new FastReader();\n\n        int t = sc.nextInt();\n        while (t-- > 0) {\n      int n=sc.nextInt();\n         long[] d =new long[n];\n         for(int i=0;i<n;i++)\n             d[i]=sc.nextLong();\n         Arrays.sort(d);\n         long ans=d[n-1];\n         long neg[] = new long[n];\n         for(int i=1;i<n;i++)\n         {   neg[i] = neg[i-1]+i*(d[i]-d[i-1]);\n             ans-=neg[i];\n         }\n\n         System.out.println(ans);\n\n        }\n\n                                                               }\n\n\n\n//Things to check when u r getting wrong answer\n// 1-  check the flow of the code\n//2- If ur stuck read the problem once again\n//3- before submitting always check the output format of ur code\n//4- don't check standings until problem B is done\n//5- if u r thinking ur concept is correct but still u r getting wrong answer try to implement it in another way\n\n//All the functions\n\n\n\nstatic void debug(String s)\n{ System.out.println(s);\n\n}\n\n//collections.sort use merge sort instead of quick sort but arrays.sort use quicksort whose worst time complexity is O(n^2)\nstatic int[] sort(int[] a)\n{         ArrayList<Integer> list = new ArrayList<>();\n     for(int i=0;i<a.length;i++)\n         list.add(a[i]);\n\n     Collections.sort(list);\n     int ind=0;\n     for(int x:list)\n         a[ind++]=x;\n     return a;\n\n}\n\n    //function to print an array for debugging\n    static void print(int[] a) {\n        for (int i = 0; i < a.length; i++)\n            System.out.print(a[i] + \" \");\n        System.out.println();\n    }\n\n    static void printc(char[] a) {\n        for (int i = 0; i < a.length; i++)\n            System.out.print(a[i] + \" \");\n        System.out.println();\n    }\n\n\n    //normal gcd function, always put the greater number as a and the smaller number as b\n    static int gcd(int a, int b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n\n    }\n\n\n    //Input Reader to read faster input\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n\n        int[] readArray(int n)\n        {  int[] a = new int[n];\n            for(int i=0;i<n;i++)\n            a[i]=nextInt();\n\n            return a;\n        }\n    }\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "label": 5}
{"src": "import java.util.*;\npublic class Main1540A {\n    public static void main(String[] args) {\n        Scanner in=new Scanner(System.in);\n        int t=in.nextInt();\n        long[] d=new long[100010];\n//        long[] a=new long[100010];\n//        long[] b=new long[100010];\n        long[] cut=new long[100010];\n        long sum;\n        for(int i=0;i<t;i++){\n            int n=in.nextInt();\n            \n            sum=0;\n            for(int j=1;j<=n;j++){\n                d[j]=in.nextLong();\n            }\n\n            Arrays.sort(d,1,n+1);\n//            a[k]=d[1];\n//            b[1]=1;\n//            for(int j=2;j<=n;j++){\n//                if(d[j]==a[k]){\n//                    b[k]++;\n//                }else{\n//                    k++;\n//                    a[k]=d[j];\n//                    b[k]=1;\n//                }\n//            }\n//            for(int j=3;j<=k;j++){\n//                for(int p=2;p<=j-1;p++){\n//                    sum-=(a[j]-a[j-p])*b[j];\n//                }\n//            }\n\n\n//            if(k<3){\n//                sum=0;\n//            }\n//            cut[1]=a[1]*b[1];\n//            int c=1;\n//            long w=b[1];//\u8bb0\u5f55\u4e2a\u6570\u7684\u603b\u548c\n//            for(int j=3;j<=k;j++){\n//                sum-=(a[j]*w-cut[c])*b[j];\n//                c++;\n//                cut[c]=cut[c-1]+a[c]*b[c];//\u8fd9\u91cc\u4e5f\u8981\u4e2a\u6570\n//                w+=b[c];\n//            }\n            cut[1]=d[1];\n            int c=1;\n            for(int j=3;j<=n;j++){\n                sum-=d[j]*(j-2)-cut[c];\n                c++;\n                cut[c]=cut[c-1]+d[c];//\u8fd9\u91cc\u4e5f\u8981\u4e2a\u6570\n\n            }\n            if(n<3){\n                sum=0;\n            }\n\n\n\n            System.out.println(sum);\n\n\n        }\n    }\n}\n", "label": 5}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.text.*;\n\npublic class CF_1540_A{\n    //SOLUTION BEGIN\n    void pre() throws Exception{}\n    void solve(int TC) throws Exception{\n        int N = ni();\n        long[] D = new long[N];\n        for(int i = 0; i< N; i++)D[i] = nl();\n        if(N == 1){\n            pn(0);\n            return;\n        }\n        Random R = new Random();\n        for(int i = 0; i< N; i++){\n            int x = R.nextInt(N-1)+1, y = 1+R.nextInt(N-1);\n            long v = D[x];\n            D[x] = D[y];\n            D[y] = v;\n        }\n        Arrays.sort(D, 1, N);\n        long ans = D[N-1];\n        long sum = 0;\n        for(int i = 0; i< N; i++){\n            ans += sum-i*D[i];\n            sum += D[i];\n        }\n        pn(ans);\n    }\n    //SOLUTION END\n    void hold(boolean b)throws Exception{if(!b)throw new Exception(\"Hold right there, Sparky!\");}\n    void exit(boolean b){if(!b)System.exit(0);}\n    static void dbg(Object... o){System.err.println(Arrays.deepToString(o));}\n    final long IINF = (long)1e17;\n    final int INF = (int)1e9+2;\n    DecimalFormat df = new DecimalFormat(\"0.00000000000\");\n    double PI = 3.141592653589793238462643383279502884197169399, eps = 1e-8;\n    static boolean multipleTC = true, memory = true, fileIO = false;\n    FastReader in;PrintWriter out;\n    void run() throws Exception{\n        long ct = System.currentTimeMillis();\n        if (fileIO) {\n            in = new FastReader(\"\");\n            out = new PrintWriter(\"\");\n        } else {\n            in = new FastReader();\n            out = new PrintWriter(System.out);\n        }\n        //Solution Credits: Taranpreet Singh\n        int T = multipleTC? ni():1;\n        pre();\n        for (int t = 1; t <= T; t++) solve(t);\n        out.flush();\n        out.close();\n        System.err.println(System.currentTimeMillis() - ct);\n    }\n    public static void main(String[] args) throws Exception{\n        if(memory)new Thread(null, new Runnable() {public void run(){try{new CF_1540_A().run();}catch(Exception e){e.printStackTrace();System.exit(1);}}}, \"1\", 1 << 28).start();\n        else new CF_1540_A().run();\n    }\n    int[][] make(int n, int e, int[] from, int[] to, boolean f){\n        int[][] g = new int[n][];int[]cnt = new int[n];\n        for(int i = 0; i< e; i++){\n            cnt[from[i]]++;\n            if(f)cnt[to[i]]++;\n        }\n        for(int i = 0; i< n; i++)g[i] = new int[cnt[i]];\n        for(int i = 0; i< e; i++){\n            g[from[i]][--cnt[from[i]]] = to[i];\n            if(f)g[to[i]][--cnt[to[i]]] = from[i];\n        }\n        return g;\n    }\n    int[][][] makeS(int n, int e, int[] from, int[] to, boolean f){\n        int[][][] g = new int[n][][];int[]cnt = new int[n];\n        for(int i = 0; i< e; i++){\n            cnt[from[i]]++;\n            if(f)cnt[to[i]]++;\n        }\n        for(int i = 0; i< n; i++)g[i] = new int[cnt[i]][];\n        for(int i = 0; i< e; i++){\n            g[from[i]][--cnt[from[i]]] = new int[]{to[i], i, 0};\n            if(f)g[to[i]][--cnt[to[i]]] = new int[]{from[i], i, 1};\n        }\n        return g;\n    }\n    int find(int[] set, int u){return set[u] = (set[u] == u?u:find(set, set[u]));}\n    int digit(long s){int ans = 0;while(s>0){s/=10;ans++;}return ans;}\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}\n    void p(Object... o){for(Object oo:o)out.print(oo+\" \");}\n    void pn(Object... o){for(int i = 0; i< o.length; i++)out.print(o[i]+(i+1 < o.length?\" \":\"\\n\"));}\n    void pni(Object... o){for(Object oo:o)out.print(oo+\" \");out.println();out.flush();}\n    String n()throws Exception{return in.next();}\n    String nln()throws Exception{return in.nextLine();}\n    int ni()throws Exception{return Integer.parseInt(in.next());}\n    long nl()throws Exception{return Long.parseLong(in.next());}\n    double nd()throws Exception{return Double.parseDouble(in.next());}\n\n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        String next() throws Exception{\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    throw new Exception(e.toString());\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() throws Exception{\n            String str;\n            try{\n                str = br.readLine();\n            }catch (IOException e){\n                throw new Exception(e.toString());\n            }\n            return str;\n        }\n    }\n}", "label": 5}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class Codeforces {\n    static FastReader sc=new FastReader();\n\tstatic PrintWriter out=new PrintWriter(System.out);\n\tstatic long mod=1000000007;\n\tstatic long mod1=998244353;\n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\t// your code goes here\n\t\tint t=I();\n\t\twhile(t-->0)\n\t\t{\n\t\t\tint n=I();\n\t\t\tlong a[]=new long[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ta[i]=L();\n\t\t\t}\n\t\t\tsort(a);\n\t\t\tlong ans=a[n-1];\n\t\t\tlong b[]=new long[n];\n\t\t\tb[0]=a[0];\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tb[i]=b[i-1]+i*(a[i]-a[i-1]);\n\t\t\t\tans-=b[i];\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\tout.close();\n\t}\n\tpublic static long kadane(long a[],int n)\n\t{\n\t\tlong max_sum=Long.MIN_VALUE,max_end=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tmax_end+=a[i];\n\t\t\tif(max_sum<max_end){max_sum=max_end;}\n\t\t\tif(max_end<0){max_end=0;}\n\t\t}\n\t\treturn max_sum;\n\t}\n\tpublic static void DFS(ArrayList<Integer> arr[],int s,boolean visited[])\n\t{\n\t\tvisited[s]=true;\n\t\tfor(int i:arr[s]){\n\t\t\tif(!visited[i]){\n\t\t\t\tDFS(arr,i,visited);\n\t\t\t}\n\t\t}\n\t}\n\tpublic static int BS(long a[],long x,int ii,int jj)\n\t{\n\t\t// int n=a.length;\n\t\tint mid=0;\n\t\tint i=ii,j=jj;\n\t\twhile(i<j)\n\t\t{\n\t\t\tmid=(i+j)/2;\n\t\t\tif(a[mid]>x)\n\t\t\tj=mid-1;\n\t\t\telse if(a[mid]<x)\n\t\t\ti=mid+1;\n\t\t\telse return mid;\n\t\t}\n\t\tif(a[i]>x)\n\t\treturn i-1;\n\t\treturn i;\n\t}\n\tpublic static ArrayList<Integer> prime(int n)\n\t{\n\t    ArrayList<Integer> arr=new ArrayList<>();\n\t    boolean prime[] = new boolean[n + 1];\n        for (int i = 0; i <= n; i++)\n        prime[i] = true;\n        for (int p = 2; p * p <= n; p++)\n        {\n            if (prime[p] == true)\n            {\n                for (int i = p * p; i <= n; i += p)\n                prime[i] = false;\n            }\n        }\n        for (int i = 2; i <= n; i++)\n        {\n            if (prime[i] == true)\n            arr.add(i);\n        }\n        return arr;\n\t}\n\tpublic static HashSet<Integer> primeSet(int n)\n\t{\n\t    HashSet<Integer> arr=new HashSet<>();\n\t    boolean prime[] = new boolean[n + 1];\n        for (int i = 0; i <= n; i++)\n        prime[i] = true;\n        for (int p = 2; p * p <= n; p++)\n        {\n            if (prime[p] == true)\n            {\n                for (int i = p * p; i <= n; i += p)\n                prime[i] = false;\n            }\n        }\n        for (int i = 2; i <= n; i++)\n        {\n            if (prime[i] == true)\n            arr.add(i);\n        }\n        return arr;\n\t}\n\n\t// Fenwick / BinaryIndexed  Tree  USE IT - FenwickTree ft1=new FenwickTree(n);\n\tpublic static class FenwickTree\n\t{\n\t\tlong farr[];\n\t\tint n;\n\t\tpublic FenwickTree(int c)\n\t\t{\n\t\t\tn=c+1;\n\t\t\tfarr=new long[n];\n\t\t}\n\t\tpublic void update_range(int l,int r,long p)\n\t\t{\n\t\t\tupdate(l,p);\n\t\t\tupdate(r+1,(-1)*p);\n\t\t}\n\t\tpublic void update(int x,long p)\n\t\t{\n\t\t\tfor(;x<n;x+=x&(-x))\n\t\t\t{\n\t\t\t\tfarr[x]+=p;\n\t\t\t}\n\t\t}\n\t\tpublic long get(int x)\n\t\t{\n\t\t\tlong ans=0;\n\t\t\tfor(;x>0;x-=x&(-x))\n\t\t\t{\n\t\t\t\tans=ans+farr[x];\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\t}\n\n\t//Disjoint Set Union\n\tpublic static class DSU\n\t{\n\t    static int par[],rank[];\n\t    public DSU(int c)\n\t    {\n\t        par=new int[c+1];\n\t        rank=new int[c+1];\n\t        for(int i=0;i<=c;i++)\n\t        {\n\t            par[i]=i;\n\t            rank[i]=0;\n\t        }\n\t    }\n\t    public static int find(int a)\n\t    {\n\t        if(a==par[a])\n\t        return a;\n\t        return par[a]=find(par[a]);\n\t    }\n\t    public static void union(int a,int b)\n\t    {\n\t        int a_rep=find(a),b_rep=find(b);\n\t        if(a_rep==b_rep)\n\t        return;\n\t        if(rank[a_rep]<rank[b_rep])\n\t        par[a_rep]=b_rep;\n\t        else if(rank[a_rep]>rank[b_rep])\n\t        par[b_rep]=a_rep;\n\t        else\n\t        {\n\t            par[b_rep]=a_rep;\n\t            rank[a_rep]++;\n\t        }\n\t    }\n\t}\n\n\t//SEGMENT TREE CODE\n\n\t// public static void segmentUpdate(int si,int ss,int se,int qs,int qe,long x)\n\t// {\n\t// \tif(ss>qe || se<qs)return;\n\t// \tif(qs<=ss && qe>=se)\n\t// \t{\n\t// \t\tseg[si][0]+=1L;\n\t// \t\tseg[si][1]+=x*x;\n\t// \t\tseg[si][2]+=2*x;\n\t// \t\treturn;\n\t// \t}\n\t// \tint mid=(ss+se)/2;\n\t// \tsegmentUpdate(2*si+1,ss,mid,qs,qe,x);\n\t// \tsegmentUpdate(2*si+2,mid+1,se,qs,qe,x);\n\t// }\n\t// public static long segmentGet(int si,int ss,int se,int x,long f,long s,long t,long a[])\n\t// {\n\t// \tif(ss==se && ss==x)\n\t// \t{\n\t// \t\tf+=seg[si][0];\n\t// \t\ts+=seg[si][1];\n\t// \t\tt+=seg[si][2];\n\t// \t\tlong ans=a[x]+(f*((long)x+1L)*((long)x+1L))+s+(t*((long)x+1L));\n\t// \t\treturn ans;\n\t// \t}\n\t// \tint mid=(ss+se)/2;\n\t// \tif(x>mid){\n\t// \t\treturn segmentGet(2*si+2,mid+1,se,x,f+seg[si][0],s+seg[si][1],t+seg[si][2],a);\n\t// \t}else{\n\t// \t\treturn segmentGet(2*si+1,ss,mid,x,f+seg[si][0],s+seg[si][1],t+seg[si][2],a);\n\t// \t}\n\t// }\n\n\tpublic static class pair\n    {\n    \tint a;\n    \tint b;\n    \tpublic pair(int val,int index)\n    \t{\n    \t    a=val;\n    \t    b=index;\n    \t}\n    }\n\tpublic static class myComp implements Comparator<pair>\n\t{\n\t\t//sort in ascending order.\n\t\t// public int compare(pair p1,pair p2)\n\t\t// {\n\t\t// \tif(p1.a==p2.a)\n    \t//     return 0;\n    \t//     else if(p1.a<p2.a)\n    \t//     return -1;\n    \t//     else\n    \t//     return 1;\n\t\t// }\n\t\t//sort in descending order.\n\t\tpublic int compare(pair p1,pair p2)\n    \t{\n    \t    if(p1.a==p2.a)\n    \t    return 0;\n    \t    else if(p1.a<p2.a)\n    \t    return 1;\n    \t    else\n    \t    return -1;\n    \t}\n\t}\n    public static class myComp1 implements Comparator<pair1>\n    {\n\t\t//sort in ascending order.\n    \tpublic int compare(pair1 p1,pair1 p2)\n    \t{\n    \t    if(p1.a==p2.a)\n    \t    return 0;\n    \t    else if(p1.a<p2.a)\n    \t    return -1;\n    \t    else\n    \t    return 1;\n    \t}\n\t\t//sort in descending order.\n\t\t// public int compare(pair p1,pair p2)\n    \t// {\n    \t//     if(p1.a==p2.a)\n    \t//     return 0;\n    \t//     else if(p1.a<p2.a)\n    \t//     return 1;\n    \t//     else\n    \t//     return -1;\n    \t// }\n    }\n\tpublic static class pair1\n    {\n    \tlong a;\n    \tlong b;\n    \tpublic pair1(long val,long index)\n    \t{\n    \t    a=val;\n    \t    b=index;\n    \t}\n    }\n    public static ArrayList<pair1> mergeIntervals(ArrayList<pair1> arr)\n\t{\n\t    //****************use this in main function-Collections.sort(arr,new myComp1());\n\t    ArrayList<pair1> a1=new ArrayList<>();\n\t    if(arr.size()<=1)\n\t    return arr;\n\t    a1.add(arr.get(0));\n\t    int i=1,j=0;\n\t    while(i<arr.size())\n\t    {\n\t        if(a1.get(j).b<arr.get(i).a)\n\t        {\n\t           a1.add(arr.get(i));\n\t           i++;\n\t           j++;\n\t        }\n\t        else if(a1.get(j).b>arr.get(i).a && a1.get(j).b>=arr.get(i).b)\n\t        {\n\t            i++;\n\t        }\n\t        else if(a1.get(j).b>=arr.get(i).a)\n\t        {\n\t            long a=a1.get(j).a;\n\t            long b=arr.get(i).b;\n\t            a1.remove(j);\n\t            a1.add(new pair1(a,b));\n\t            i++;\n\t        }\n\t    }\n\t    return a1;\n\t}\n\tpublic static boolean palindrome(String s,int n)\n\t{\n\t\tfor(int i=0;i<=n/2;i++){\n\t\t\tif(s.charAt(i)!=s.charAt(n-i-1)){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tpublic static long countDigit(long n)\n\t{\n\t    long sum=0;\n\t    while(n!=0)\n\t    {\n\t        sum++;\n\t        n=n/10;\n\t    }\n\t    return sum;\n\t}\n\tpublic static long digitSum(long n)\n\t{\n\t    long sum=0;\n\t    while(n!=0)\n\t    {\n\t        sum=sum+n%10;\n\t        n=n/10;\n\t    }\n\t    return sum;\n\t}\n\tpublic static long gcd(long a,long b)\n\t{\n\t    if(b==0)\n\t    return a;\n\t    else\n\t    return gcd(b,a%b);\n\t}\n\tpublic static int gcd(int a,int b)\n\t{\n\t    if(b==0)\n\t    return a;\n\t    else\n\t    return gcd(b,a%b);\n\t}\n\tpublic static void printArray(long a[])\n\t{\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tout.print(a[i]+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static void printArray(ArrayList<Long> arr)\n\t{\n\t\tfor(int i=0;i<arr.size();i++){\n\t\t\tout.print(arr.get(i)+\" \");\n\t\t}\n\t\tout.println();\n\t}\n\tpublic static long pwr(long m,long n)\n\t{\n\t\tlong res=1;\n\t\tm=m%mod;\n\t\tif(m==0)\n\t\treturn 0;\n\t\twhile(n>0)\n\t\t{\n\t\t\tif((n&1)!=0)\n\t\t\t{\n\t\t\t\tres=(res*m)%mod;\n\t\t\t}\n\t\t\tn=n>>1;\n\t\t\tm=(m*m)%mod;\n\t\t}\n\t\treturn res;\n\t}\n\tpublic static void sort(int[] A)\n\t{\n        int n = A.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i)\n\t\t{\n            int tmp = A[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            A[i] = A[randomPos];\n            A[randomPos] = tmp;\n        }\n        Arrays.sort(A);\n    }\n    public static void sort(long[] A)\n\t{\n\t    int n = A.length;\n        Random rnd = new Random();\n        for(int i=0; i<n; ++i)\n\t\t{\n            long tmp = A[i];\n            int randomPos = i + rnd.nextInt(n-i);\n            A[i] = A[randomPos];\n            A[randomPos] = tmp;\n        }\n\t    Arrays.sort(A);\n\t}\n\tpublic static int I(){return sc.I();}\n    public static long L(){return sc.L();}\n    public static String S(){return sc.S();}\n    public static double D(){return sc.D();}\n}\nclass FastReader {  \n    BufferedReader br;\n    StringTokenizer st;\n    public FastReader(){\n        br = new BufferedReader(new InputStreamReader(System.in));\n    }\n    String next(){\n        while (st == null || !st.hasMoreElements()){\n            try {\n                st = new StringTokenizer(br.readLine());\n            }\n            catch (IOException e){\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n    int I(){ \n        return Integer.parseInt(next());\n    }\n    long L(){ \n        return Long.parseLong(next());\n    }\n    double D(){\n         return Double.parseDouble(next());\n    }\n    String S(){\n        String str = \"\";\n        try \n        {\n            str = br.readLine();\n        }\n        catch (IOException e)\n        {\n            e.printStackTrace();\n        }\n        return str;\n    }\n}\n", "label": 5}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class hello {\n    public static void main(String[] args) {\n\n        Scanner scn = new Scanner(System.in);\n\n        int t = scn.nextInt();\n\n        while(t-->0)\n        {\n            int n = scn.nextInt();\n            long a[] = new long[n];\n\n            for(int i = 0;i < n;i++)\n                a[i] = scn.nextLong();\n\n            \n            Arrays.sort(a);\n            \n            long pref[] = new long[n];\n\n            pref[0] = 0;\n\n            long sum = 0;\n            for(int i = 1;i < n;i++)\n            {\n                pref[i] = pref[i-1] + a[i]; \n                if(i > 1)\n                {\n                    sum += pref[i-2] - ((i-1)*a[i]);\n                }\n            }\n            \n            System.out.println(sum);\n        }\n\n        scn.close();\n    }\n}", "label": 5}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class A1540 {\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int T = in.nextInt();\n        StringBuilder output = new StringBuilder();\n        for (int t=0; t<T; t++) {\n            int N = in.nextInt();\n            Integer[] A = new Integer[N];\n            for (int n=0; n<N; n++) {\n                A[n] = in.nextInt();\n            }\n            Arrays.sort(A);\n            long answer = 0;\n            long sumBack = 0;\n            for (int n=1; n<N; n++) {\n                long toLast = A[n]-A[n-1];\n                sumBack += toLast*n;\n                answer += toLast - sumBack;\n            }\n            output.append(answer).append('\\n');\n        }\n        System.out.print(output);\n    }\n\n}\n", "label": 5}
{"src": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.StringTokenizer;\n\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner fs=new FastScanner();\n\t\tint T=fs.nextInt();\n\t\tfor (int tt=0; tt<T; tt++) {\n\t\t\tint n=fs.nextInt();\n\t\t\tint[] a=fs.readArray(n);\n\t\t\tsort(a);\n\t\t\tlong ans=0;\n\t\t\tlong nBefore=0;\n\t\t\tlong sumBefore=0;\n\t\t\tfor (int i=1; i<n; i++) {\n\t\t\t\tans+=a[i]-a[i-1];\n\t\t\t\tnBefore++;\n\t\t\t\tsumBefore+=a[i-1];\n\t\t\t\tans-=a[i]*nBefore - sumBefore;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic void sort(int[] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n\t\n\tstatic class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\n\t\n}\n", "label": 5}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class Main{\n    static class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next(){\n            while(st ==  null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch(IOException e){\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt(){\n            return Integer.parseInt(next());\n        }\n        long nextLong(){\n            return Long.parseLong(next());\n        }\n        String nextLine(){\n            String sr = \"\";\n            try{\n                sr = br.readLine();\n            }\n            catch(IOException e){\n                e.printStackTrace();\n            }\n            return sr;\n        }\n    }\n  \n\tpublic static void main (String[] args) throws java.lang.Exception\n\t{\n\t\tFastReader ft = new FastReader();\n\t    BufferedWriter out = new BufferedWriter(new OutputStreamWriter(System.out));\n\t    int t = ft.nextInt();\n\t    while(t-->0){\n\t    int n = ft.nextInt();\n\t    long a[] = new long[n];\n\t    for(int i = 0;i < n;i++)\n\t    a[i] = ft.nextLong();\n\t    Arrays.sort(a);\n\t    long ans = a[n-1];\n\t    long neg[] = new long[n];\n\t    for(int i = 1;i < n;i++)\n\t    {\n\t        neg[i] = neg[i-1]+i*(a[i]-a[i-1]);\n\t        ans -= neg[i];\n\t    }\n\t    out.write(ans+\"\\n\");}\n\t    out.flush();\n\t}\n}", "label": 5}
{"src": "import java.io.*;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\nimport java.util.List;\n import java.util.*;\n public class realfast implements Runnable \n  {\n    private static final int INF = (int) 1e9;\n    long in= 1000000007;\n    long fac[]= new long[1000001];\n    long inv[]=new long[1000001];\n    public  void solve() throws IOException \n    {\n\n        //int t = readInt();\n\n        int t = readInt();\n        for(int f =0;f<t;f++)\n        {\n            int n = readInt();\n            ArrayList<Integer> arr = new ArrayList<Integer>();\n            for(int i =0;i<n;i++)\n            {\n                 int a= readInt();\n                 arr.add(a);\n            }\n            Collections.sort(arr);\n            long ans=0;\n            long sum=0;\n            for(int i =1;i<n;i++)\n            {\n                 long a= arr.get(i)-arr.get(i-1);\n\n                 long pal = i;\n                 pal= (pal)*(n-i);\n                 pal--;\n                 pal= pal*a;\n                 pal=-pal;\n\n\n                 sum=sum+pal;\n                 ans=ans+sum;\n\n\n            }\n            out.println(sum);\n        }\n\n        \n\n\n         \n\n\n\n        \n\n\n\n    }\n    \n    public int value (int seg[], int left , int right ,int index, int l, int r)\n    {\n            \n            if(left>right)\n            {\n              return -100000000;\n            }\n            if(right<l||left>r)\n                return -100000000;\n            if(left>=l&&right<=r)\n                return seg[index];\n            int mid = left+(right-left)/2;\n            int val = value(seg,left,mid,2*index+1,l,r);\n            int val2 = value(seg,mid+1,right,2*index+2,l,r);\n            return Math.max(val,val2);\n\n    }\n   \n    public int gcd(int a , int b )\n    {\n      if(a<b)\n      {\n        int t =a;\n        a=b;\n        b=t;\n      }\n      if(a%b==0)\n        return b ;\n      return gcd(b,a%b);\n    }\n    public long pow(long n , long p,long m)\n    {\n         if(p==0)\n            return 1;\n        long val = pow(n,p/2,m);;\n        val= (val*val)%m;\n        if(p%2==0)\n            return val;\n        else\n            return (val*n)%m;\n    }\n    \n    \n    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n    public static void main(String[] args) {\n        new Thread(null, new realfast(), \"\", 128 * (1L << 20)).start();\n    }\n \n    private static final boolean ONLINE_JUDGE = System.getProperty(\"ONLINE_JUDGE\") != null;\n    private BufferedReader reader;\n    private StringTokenizer tokenizer;\n    private PrintWriter out;\n \n    @Override\n    public void run() {\n        try {\n            if (ONLINE_JUDGE || !new File(\"input.txt\").exists()) {\n                reader = new BufferedReader(new InputStreamReader(System.in));\n                out = new PrintWriter(System.out);\n            } else {\n                reader = new BufferedReader(new FileReader(\"input.txt\"));\n                out = new PrintWriter(\"output.txt\");\n            }\n            solve();\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        } finally {\n            try {\n                reader.close();\n            } catch (IOException e) {\n                // nothing\n            }\n            out.close();\n        }\n    }\n \n    private String readString() throws IOException {\n        while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n            tokenizer = new StringTokenizer(reader.readLine());\n        }\n        return tokenizer.nextToken();\n    }\n \n    @SuppressWarnings(\"unused\")\n    private int readInt() throws IOException {\n        return Integer.parseInt(readString());\n    }\n \n    @SuppressWarnings(\"unused\")\n    private long readLong() throws IOException {\n        return Long.parseLong(readString());\n    }\n \n    @SuppressWarnings(\"unused\")\n    private double readDouble() throws IOException {\n        return Double.parseDouble(readString());\n    }\n}\nclass edge implements Comparable<edge>{\n    int u ;\n    int v;\n    \n    edge(int u, int v)\n    {\n       this.u=u;\n       this.v=v;\n    }\n    public int compareTo(edge e)\n    {\n        return this.v-e.v;\n    }\n}", "label": 5}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\n \npublic final class Solution{\n\n   public static void main (String[] args) throws Exception\n   {\n      BufferedWriter op = new BufferedWriter(\n            new OutputStreamWriter(System.out));\n    \n     Scanner sc= new Scanner(System.in);\n     int t=sc.nextInt();\n     while(t-->0)\n     {\n     int n=sc.nextInt();\n     int[] pre= new int[n];\n   \n     \n    for(int i=0;i<n;i++){\n        int no=sc.nextInt();\n        pre[i]=no;\n    }\n      if(n<=2){\n         op.write(0+\"\\n\");\n         continue;\n     }\n    Arrays.sort(pre);\n    // int [] ar= new int[n];\n    // ar[0]=pre[0];\n    // for(int i=1;i<n;i++){\n    //     ar[i]=pre[i]-ar[i-1];\n    // }\n   long sum=0;\n\n   long ans=0;\n\n    for (int i = n - 1; i >= 0; i--){\n            sum +=(( (long)i * pre[i]) -( (long)(n - 1 - i)\n                                  * pre[i]));\n            }\n             \n     \n      for(int i=1;i<n;i++){\n          sum-=pre[i]-pre[i-1];\n      }   \n    \n\n    op.write(\"-\"+sum+\"\\n\");\n    // op.write(\"-\"+ans+\"\\n\");\n    \n\n    \n\n      \n     \n    \n\n     } \n     op.flush();\n\n     \n    }\n   \n \n \n}\n\n\n\n \n \n class Reader {\n        final private int BUFFER_SIZE = 1 << 16;\n        private DataInputStream din;\n        private byte[] buffer;\n        private int bufferPointer, bytesRead;\n \n        public Reader()\n        {\n            din = new DataInputStream(System.in);\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n \n        public Reader(String file_name) throws IOException\n        {\n            din = new DataInputStream(\n                new FileInputStream(file_name));\n            buffer = new byte[BUFFER_SIZE];\n            bufferPointer = bytesRead = 0;\n        }\n \n        public String readLine() throws IOException\n        {\n            byte[] buf = new byte[64]; // line length\n            int cnt = 0, c;\n            while ((c = read()) != -1) {\n                if (c == '\\n') {\n                    if (cnt != 0) {\n                        break;\n                    }\n                    else {\n                        continue;\n                    }\n                }\n                buf[cnt++] = (byte)c;\n            }\n            return new String(buf, 0, cnt);\n        }\n \n        public int nextInt() throws IOException\n        {\n            int ret = 0;\n            byte c = read();\n            while (c <= ' ') {\n                c = read();\n            }\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n \n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        public long nextLong() throws IOException\n        {\n            long ret = 0;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        public double nextDouble() throws IOException\n        {\n            double ret = 0, div = 1;\n            byte c = read();\n            while (c <= ' ')\n                c = read();\n            boolean neg = (c == '-');\n            if (neg)\n                c = read();\n \n            do {\n                ret = ret * 10 + c - '0';\n            } while ((c = read()) >= '0' && c <= '9');\n \n            if (c == '.') {\n                while ((c = read()) >= '0' && c <= '9') {\n                    ret += (c - '0') / (div *= 10);\n                }\n            }\n \n            if (neg)\n                return -ret;\n            return ret;\n        }\n \n        private void fillBuffer() throws IOException\n        {\n            bytesRead = din.read(buffer, bufferPointer = 0,\n                                 BUFFER_SIZE);\n            if (bytesRead == -1)\n                buffer[0] = -1;\n        }\n \n        private byte read() throws IOException\n        {\n            if (bufferPointer == bytesRead)\n                fillBuffer();\n            return buffer[bufferPointer++];\n        }\n \n        public void close() throws IOException\n        {\n            if (din == null)\n                return;\n            din.close();\n        }\n    }\n       //  BufferedWriter op = new BufferedWriter(\n        //     new OutputStreamWriter(System.out));", "label": 5}
{"src": "import java.util.*;\n\nimport java.io.*;\n\npublic class Test {\n\tstatic class Scan {\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int index;\n\t\tprivate InputStream in;\n\t\tprivate int total;\n\n\t\tpublic Scan() {\n\t\t\tin = System.in;\n\t\t}\n\n\t\tpublic int scan() throws IOException {\n\t\t\tif (total < 0)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (index >= total) {\n\t\t\t\tindex = 0;\n\t\t\t\ttotal = in.read(buf);\n\t\t\t\tif (total <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[index++];\n\t\t}\n\n\t\tpublic int scanInt() throws IOException {\n\t\t\tint integer = 0;\n\t\t\tint n = scan();\n\t\t\twhile (isWhiteSpace(n))\n\t\t\t\tn = scan();\n\t\t\tint neg = 1;\n\t\t\tif (n == '-') {\n\t\t\t\tneg = -1;\n\t\t\t\tn = scan();\n\t\t\t}\n\t\t\twhile (!isWhiteSpace(n)) {\n\t\t\t\tif (n >= '0' && n <= '9') {\n\t\t\t\t\tinteger *= 10;\n\t\t\t\t\tinteger += n - '0';\n\t\t\t\t\tn = scan();\n\t\t\t\t} else\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\treturn neg * integer;\n\t\t}\n\n\t\tpublic double scanDouble() throws IOException {\n\t\t\tdouble doub = 0;\n\t\t\tint n = scan();\n\t\t\twhile (isWhiteSpace(n))\n\t\t\t\tn = scan();\n\t\t\tint neg = 1;\n\t\t\tif (n == '-') {\n\t\t\t\tneg = -1;\n\t\t\t\tn = scan();\n\t\t\t}\n\t\t\twhile (!isWhiteSpace(n) && n != '.') {\n\t\t\t\tif (n >= '0' && n <= '9') {\n\t\t\t\t\tdoub *= 10;\n\t\t\t\t\tdoub += n - '0';\n\t\t\t\t\tn = scan();\n\t\t\t\t} else\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (n == '.') {\n\t\t\t\tn = scan();\n\t\t\t\tdouble temp = 1;\n\t\t\t\twhile (!isWhiteSpace(n)) {\n\t\t\t\t\tif (n >= '0' && n <= '9') {\n\t\t\t\t\t\ttemp /= 10;\n\t\t\t\t\t\tdoub += (n - '0') * temp;\n\t\t\t\t\t\tn = scan();\n\t\t\t\t\t} else\n\t\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn doub * neg;\n\t\t}\n\n\t\tpublic String scanString() throws IOException {\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint n = scan();\n\t\t\twhile (isWhiteSpace(n))\n\t\t\t\tn = scan();\n\t\t\twhile (!isWhiteSpace(n)) {\n\t\t\t\tsb.append((char) n);\n\t\t\t\tn = scan();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tprivate boolean isWhiteSpace(int n) {\n\t\t\tif (n == ' ' || n == '\\n' || n == '\\r' || n == '\\t' || n == -1)\n\t\t\t\treturn true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tstatic class Print {\n\t\tprivate final BufferedWriter bw;\n\n\t\tpublic Print() {\n\t\t\tthis.bw = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\t}\n\n\t\tpublic void print(Object object) throws IOException {\n\t\t\tbw.append(\"\" + object);\n\t\t}\n\n\t\tpublic void println(Object object) throws IOException {\n\t\t\tprint(object);\n\t\t\tbw.append(\"\\n\");\n\t\t}\n\n\t\tpublic void close() throws IOException {\n\t\t\tbw.close();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) throws IOException{\n        Scanner scan = new Scanner(System.in);\n        Print print = new Print();\n        int testcases = scan.nextInt();\n        while(testcases-->0){\n\t\t\tint n = scan.nextInt();\n\t\t\tint array[] = new int[n];\n\t\t\t\n\t\t\tlong sum = 0;\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tarray[i] = scan.nextInt();\n\t\t\t\tsum += array[i];\n\t\t\t}\n\t\t\tArrays.sort(array);\n\t\t\tlong diff = 0;\n\t\t\tlong ans = sum;\n\t\t\tfor(int i=1; i<n; i++){\n\t\t\t\tdiff = array[i]-array[i-1];\n\t\t\t\tsum = sum - diff*(n-i);\n\t\t\t\tans += sum;\n\t\t\t}\n\t\t\tprint.println(array[n-1]-ans);\n        }\n\t\tprint.close();\n    }\n\n\tstatic long gcd(long a, long b){\n\t\tif(b == 0)\n\t\t\treturn a;\n\t\treturn gcd(b, a%b);\n\t}\n\n}\n", "label": 5}
{"src": "import java.util.*;\nimport java.io.*;\n\npublic class CodeForces {\n\n    public void run() {\n        try {\n            BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n            int q = Integer.parseInt(br.readLine());\n            StringBuilder sb = new StringBuilder();\n            while (q-- > 0){\n                int n = Integer.parseInt(br.readLine());\n                long[] d = new long[n];\n                StringTokenizer st = new StringTokenizer(br.readLine());\n                for (int i = 0; i < n; i++) {\n                    d[i] = Long.parseLong(st.nextToken());\n                }\n                Arrays.sort(d);\n                long ans = 0;\n                long[] f = new long[n];\n                for (int i = 2; i < n; i++) {\n                    f[i] = d[i - 2] - d[i] + (i - 2) * (d[i-1] - d[i]) + f[i-1];\n                    ans += f[i];\n                }\n                sb.append(ans);\n                sb.append(\"\\n\");\n            }\n            System.out.print(sb.toString());\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    public static void main(String[] args) {\n        new CodeForces().run();\n    }\n}\n\n\n", "label": 5}
{"src": "import java.io.PrintWriter;\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class solution { \n    public static void main(String args[]){ \n    \tScanner s=new Scanner(System.in);\n\t\tPrintWriter out=new PrintWriter(System.out);\n\t\tint t=s.nextInt();\n\t\tfor(int tt=0;tt<t;tt++) {\n\t\t\tint n=s.nextInt();\n\t\t\tlong a[]=new long[n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\ta[i]=s.nextInt();\n\t\t\t}\n\t\t\tsort(a);\n\t\t\tlong b[]=new long[n-1];\n\t\t\tfor(int i=0;i<n-1;i++) {\n\t\t\t\tb[i]=a[i+1]-a[i];\n\t\t\t}\n\t\t\tlong ans=0;\n\t\t\tn--;\n\t\t\tfor(int i=0;i<n/2;i++) {\n\t\t\t\tans-=((i+1)*(long)(n-i)*(b[i]+b[n-i-1]))-b[i]-b[n-i-1];\n\t\t\t}\n\t\t\tif(n%2!=0) {\n\t\t\t\tans-=((n/2+1)*(long)(n-n/2)*b[n/2])-b[n/2];\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t\tout.close();\n\t\ts.close();\n    } \n   \n    static void sort(long [] a) {\n\t\tArrayList<Long> l=new ArrayList<>();\n\t\tfor (long i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n    static void sort(int [] a) {\n\t\tArrayList<Integer> l=new ArrayList<>();\n\t\tfor (int i:a) l.add(i);\n\t\tCollections.sort(l);\n\t\tfor (int i=0; i<a.length; i++) a[i]=l.get(i);\n\t}\n    static int gcd(int a, int b){\n      if (b == 0)\n        return a;\n      return gcd(b, a % b);\n    }\n    static long[][] sortcol(long a[][],int c) {\n\t\tArrays.sort(a, (x, y) -> {\n\t\t\tif(x[c]>y[c]) {\n\t\t\t\treturn 1;\n\t\t\t}else if(x[c]<y[c]) {\n\t\t\t\treturn -1;\n\t\t\t}else {\n\t\t\t\tif(x[0]>y[0]) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}{\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn a;\n\t}\n    public static void printb(boolean ans) {\n    \tif(ans) {\n    \t\tSystem.out.println(\"Yes\");\n    \t}else {\n    \t\tSystem.out.println(\"No\");\n    \t}\n    }\n    static class FastScanner {\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st=new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tint[] readArray(int n) {\n\t\t\tint[] a=new int[n];\n\t\t\tfor (int i=0; i<n; i++) a[i]=nextInt();\n\t\t\treturn a;\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n    static class Pair implements Comparable<Pair>{\n    \tint a , b; \n    \tPair(int x , int y){\n    \t\ta=x;\n    \t\tb=y;\n    \t}\n    \tpublic int compareTo(Pair o) {\n    \t\treturn a != o.a ? a - o.a : b - o.b;\n    \t}\n    }\n}\n", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class GreatGraphs {\n  public static void main(String[] args) throws IOException {\n    FastReader fr = new FastReader();\n    PrintWriter pr = new PrintWriter(new OutputStreamWriter(System.out));\n    int t = fr.nextInt();\n\n    while (t-- > 0) {\n      int n = fr.nextInt();\n\n      int[] arr = new int[n];\n\n      int zeroes = 0;\n\n      for (int i = 0; i < n; i++) {\n        int a = fr.nextInt();\n        arr[i] = a;\n        if (a == 0) zeroes++;\n      }\n\n      Arrays.sort(arr);\n\n      long ans = 0;\n      long prevDif = 0;\n\n      for (int i = 1; i < n; i++) {\n        // forward addition\n        ans += arr[i] - arr[i-1];   \n        // backward addition\n        long sum = arr[i] - arr[i-1];\n        long dif = (sum * i + prevDif);\n        prevDif = dif;\n        \n        ans -= dif;        \n      }\n\n      pr.println(ans);\n    }\n\n    pr.close();\n  }\n\n  static class Pair {\n    int x, y;\n\n    public Pair(int x, int y) {\n      this.x = x;\n      this.y = y;\n    }\n  }\n\n  static int toInt(String s) {\n    return Integer.parseInt(s);\n  }\n\n  // MERGE SORT IMPLEMENTATION\n  void sort(int[] arr, int l, int r) {\n    if (l < r) {\n      int m = l + (r - l) / 2;\n\n      sort(arr, l, m);\n      sort(arr, m + 1, r);\n\n      // call merge\n      merge(arr, l, m, r);\n    }\n  }\n\n  void merge(int[] arr, int l, int m, int r) {\n    // find sizes\n    int len1 = m - l + 1;\n    int len2 = r - m;\n\n    int[] L = new int[len1];\n    int[] R = new int[len2];\n\n    // push to copies\n    for (int i = 0; i < L.length; i++)\n      L[i] = arr[l + i];\n    for (int i = 0; i < R.length; i++) {\n      R[i] = arr[m + 1 + i];\n    }\n\n    // fill in new array\n    int i = 0, j = 0;\n    int k = l;\n    while (i < len1 && j < len2) {\n      if (L[i] < R[i]) {\n        arr[k] = L[i];\n        i++;\n      } else {\n        arr[k] = R[i];\n        j++;\n      }\n      k++;\n    }\n\n    // add remaining elements\n    while (i < len1) {\n      arr[k] = L[i];\n      i++;\n      k++;\n    }\n\n    while (j < len2) {\n      arr[k] = R[j];\n      j++;\n      k++;\n    }\n  }\n\n  static class FastReader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    public FastReader() throws FileNotFoundException {\n      br = new BufferedReader(new InputStreamReader(System.in));\n    }\n\n    String next() {\n      while (st == null || !st.hasMoreElements()) {\n        try {\n          st = new StringTokenizer(br.readLine());\n        } catch (IOException e) {\n          e.printStackTrace();\n        }\n      }\n      return st.nextToken();\n    }\n\n    int nextInt() {\n      return Integer.parseInt(next());\n    }\n\n    long nextLong() {\n      return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    String nextLine() {\n      String str = \"\";\n      try {\n        str = br.readLine();\n      } catch (IOException e) {\n        e.printStackTrace();\n      }\n      return str;\n    }\n  }\n}\n", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\n \npublic class GreatGraphs {\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tstatic StringTokenizer st;\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tint t = readInt();\n\t\t\n\t\twhile (t-- > 0) {\n\t\t\tint n = readInt();\n\t\t\tInteger[] d = new Integer[n];\n\t\t\tfor (int i = 0; i < n; i ++) d[i] = readInt();\n\t\t\tArrays.parallelSort(d);\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 1; i < n; i ++) {\n\t\t\t\tlong diff = d[i] - d[i - 1];\n\t\t\t\tans -= (long)(n - i) * i * diff;\n\t\t\t\tans += diff;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n \n\tstatic String next() throws IOException {\n\t\twhile (st == null || !st.hasMoreTokens()) \n\t\t\tst = new StringTokenizer(br.readLine().trim());\n\t\treturn st.nextToken();\n\t}\n\tstatic long readLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\tstatic int readInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\tstatic double readDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\tstatic char readCharacter() throws IOException {\n\t\treturn next().charAt(0);\n\t}\n\tstatic String readLine() throws IOException {\n\t\treturn br.readLine().trim();\n\t}\n}", "label": 5}
{"src": "import java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.util.Arrays;\n\npublic class GreatGraphs {\n\t\n\tprivate static BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));\n    private static BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(System.out));\n\t\n\tprivate static void solve(int n, int[] d) throws Exception {\n\t\tlong ans = 0, sum = 0;\n\t\tArrays.sort(d);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tans -=  (long) i * d[i] - sum;\n// \t\t\tSystem.out.println(ans + \" \" + sum);\n\t\t\tsum += d[i];\n\t\t}\n\t\tans += d[n - 1];\n\t\t\n\t\twriter.write(\"\" + ans + \"\\n\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint t = Integer.parseInt(reader.readLine());\n\t\twhile (t-- != 0) {\n\t\t\tint n = Integer.parseInt(reader.readLine());\n\t\t\tint[] d = Arrays.asList(reader.readLine().split(\" \")).stream()\n\t\t\t\t\t.mapToInt(Integer::parseInt).toArray();\n\t\t\tsolve(n, d);\n\t\t}\n\t\twriter.close();\n\t\treader.close();\n\t}\n\n}\n", "label": 5}
{"src": "import java.util.*;\n\npublic class file\n{\n    public static void main(String[] args1)\n    {\n        Scanner sc = new Scanner(System.in);\n        int t = sc.nextInt();\n        while(t!=0)\n        {\n            int n = sc.nextInt();\n            long[] arr = new long[n];\n            for(int i = 0;i < arr.length;i++)\n            {\n                arr[i] = sc.nextLong();\n            }\n            Arrays.sort(arr);\n            long sum = arr[n-1];\n            long[] neg  = new long[n];\n            neg[0] = 0;\n            for(int i = 1;i < n;i++)\n            {\n                neg[i] = (long)(neg[i-1] + i * (arr[i]- arr[i-1]));\n                sum-=neg[i];\n            }\n            System.out.println(sum+\"\");\n            t--;\n        }\n    }\n}", "label": 5}
{"src": "import java.io.*;\nimport java.lang.*;\nimport java.util.*;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport static java.lang.System.out;\n\n// number of prime numbers less then or equal to x are  -->  x/ln(x)\npublic class great_graphs {\n    static class FastScanner {\n        InputStreamReader is;\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastScanner() {\n            is = new InputStreamReader(System.in);\n            br = new BufferedReader(is);\n        }\n\n        String next() throws Exception {\n            while (st == null || !st.hasMoreElements())\n                st = new StringTokenizer(br.readLine());\n            return st.nextToken();\n        }\n\n        int nextInt() throws Exception {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() throws Exception {\n            return Long.parseLong(next());\n        }\n\n        int[] readArray(int num) throws Exception {\n            int arr[] = new int[num];\n            for (int i = 0; i < num; i++)\n                arr[i] = nextInt();\n            return arr;\n        }\n\n        String nextLine() throws Exception {\n            return br.readLine();\n        }\n    }\n\n    public static boolean power_of_two(int a) {\n        if ((a & (a - 1)) == 0) {\n            return true;\n        }\n        return false;\n    }\n\n    static boolean PS(double x) {\n        if (x >= 0) {\n            double i = Math.sqrt(x);\n            if (i % 1 != 0) {\n                return false;\n            }\n            return ((i * i) == x);\n        }\n        return false;\n    }\n\n    public static int[] ia(int n) {\n        int ar[] = new int[n];\n        return ar;\n    }\n\n    public static long[] la(int n) {\n        long ar[] = new long[n];\n        return ar;\n    }\n\n    public static void print(int ans, int t) {\n        System.out.println(\"Case\" + \" \" + \"#\" + t + \":\" + \" \" + ans);\n    }\n\n    static long mod = 1000000007;\n    static int max = Integer.MIN_VALUE;\n    static int min = Integer.MAX_VALUE;\n\n    public static void sort(long[] arr) {// because Arrays.sort() uses quicksort which is dumb//Collections.sort() uses\n                                         // merge sort\n        ArrayList<Long> ls = new ArrayList<Long>();\n        for (long x : arr)\n            ls.add(x);\n        Collections.sort(ls);\n        for (int i = 0; i < arr.length; i++)\n            arr[i] = ls.get(i);\n    }\n\n    public static void main(String args[]) throws java.lang.Exception {\n        FastScanner sc = new FastScanner();\n        int t = sc.nextInt();\n        while (t-- > 0) {\n            int n = sc.nextInt();\n            long ar[] = new long[n];\n            for (int i = 0; i < n; i++) {\n                ar[i] = sc.nextInt();\n            }\n            sort(ar);\n            long sum = 0;\n            long ans = 0;\n            for (int i = 1; i < n; i++) {\n                ans += ar[i] - ar[i - 1];\n                ans += sum - (i * ar[i]);\n                sum += ar[i];\n            }\n            System.out.println(ans);\n        }\n    }\n}", "label": 5}
{"src": "import java.util.*;\n\nimport java.io.*;\n\npublic class cf {\n  static Reader sc = new Reader();\n  static PrintWriter out = new PrintWriter(System.out);\n  static long mod = (long) 1e9 + 7;\n\n  public static void main(String[] args) {\n    int tc = sc.ni();\n    while (tc-- > 0) {\n      int n = sc.ni();\n      int[] a = sc.nai(n);\n\n      sort(a);\n      long res = 0;\n\n      for (int i = 0; i < n - 1; i++) {\n        long diff = a[i + 1] - a[i];\n        res += diff;\n        res -= (diff * (i + 1) * (n - i - 1));\n      }\n\n      out.println(res);\n\n    }\n    out.close();\n\n  }\n\n  public static long pow(long a, long b, long m) {\n    if (b == 0) {\n      return 1;\n    }\n    if (b % 2 == 0) {\n      return pow((a * a) % m, b / 2, m) % m;\n    } else {\n      return (a * pow((a * a) % m, b / 2, m)) % m;\n    }\n  }\n\n  // snippets\n\n  static class Pair implements Comparable<Pair> {\n    int x;\n    int y;\n\n    Pair(int x, int y) {\n      this.x = x;\n      this.y = y;\n\n    }\n\n    @Override\n    public int compareTo(Pair o) {\n      if (this.x > o.x)\n        return 1;\n      else if (this.x < o.x)\n        return -1;\n      else {\n        if (this.y > o.y)\n          return 1;\n        else if (this.y < o.y)\n          return -1;\n        else\n          return 0;\n      }\n    }\n\n    public int hashCode() {\n      int ans = 1;\n      ans = x * 31 + y * 13;\n      return ans;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) {\n        return true;\n      }\n      if (o == null) {\n        return false;\n      }\n      if (this.getClass() != o.getClass()) {\n        return false;\n      }\n      Pair other = (Pair) o;\n      if (this.x == other.x && this.y == other.y) {\n        return true;\n      }\n      return false;\n    }\n\n  }\n\n  static void add_map(HashMap<Integer, Integer> map, int v) {\n    if (!map.containsKey(v)) {\n      map.put(v, 1);\n    } else {\n      map.put(v, map.get(v) + 1);\n    }\n  }\n\n  static void remove_map(HashMap<Integer, Integer> map, int v) {\n    if (map.containsKey(v)) {\n      map.put(v, map.get(v) - 1);\n      if (map.get(v) == 0)\n        map.remove(v);\n    }\n  }\n\n  static int gcd(int a, int b) {\n    if (b == 0)\n      return a;\n    return gcd(b, a % b);\n  }\n\n  static long gcd(long a, long b) {\n    if (b == 0)\n      return a;\n    return gcd(b, a % b);\n  }\n\n  static void sort(int[] arr) {\n    // shuffle\n    Random rand = new Random();\n    for (int i = 0; i < arr.length; i++) {\n      int j = rand.nextInt(i + 1);\n      int tmp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = tmp;\n    }\n    Arrays.sort(arr);\n  }\n\n  static void sort(long[] arr) {\n    // shuffle\n    Random rand = new Random();\n    for (int i = 0; i < arr.length; i++) {\n      int j = rand.nextInt(i + 1);\n      long tmp = arr[i];\n      arr[i] = arr[j];\n      arr[j] = tmp;\n    }\n    Arrays.sort(arr);\n  }\n\n  static boolean isPrime(int n) {\n    if (n <= 1)\n      return false;\n    if (n <= 3)\n      return true;\n    if (n % 2 == 0 || n % 3 == 0)\n      return false;\n    double sq = Math.sqrt(n);\n\n    for (int i = 5; i <= sq; i = i + 6)\n      if (n % i == 0 || n % (i + 2) == 0)\n        return false;\n    return true;\n  }\n\n  static boolean isPrime(long n) {\n    if (n <= 1)\n      return false;\n    if (n <= 3)\n      return true;\n    if (n % 2 == 0 || n % 3 == 0)\n      return false;\n    double sq = Math.sqrt(n);\n\n    for (int i = 5; i <= sq; i = i + 6)\n      if (n % i == 0 || n % (i + 2) == 0)\n        return false;\n    return true;\n  }\n\n  static void print_arr(int A[]) {\n    for (int i : A) {\n      System.out.print(i + \" \");\n    }\n    System.out.println();\n  }\n\n  static void print_arr(long A[]) {\n    for (long i : A) {\n      System.out.print(i + \" \");\n    }\n    System.out.println();\n  }\n\n  static void print_arr(char A[]) {\n    for (char i : A) {\n      System.out.print(i + \" \");\n    }\n    System.out.println();\n  }\n\n  static int min(int a, int b) {\n    return Math.min(a, b);\n  }\n\n  static int min(int a, int b, int c) {\n    return Math.min(a, Math.min(b, c));\n  }\n\n  static int min(int a, int b, int c, int d) {\n    return Math.min(a, Math.min(b, Math.min(c, d)));\n  }\n\n  static int max(int a, int b) {\n    return Math.max(a, b);\n  }\n\n  static int max(int a, int b, int c) {\n    return Math.max(a, Math.max(b, c));\n  }\n\n  static int max(int a, int b, int c, int d) {\n    return Math.max(a, Math.max(b, Math.max(c, d)));\n  }\n\n  static long min(long a, long b) {\n    return Math.min(a, b);\n  }\n\n  static long min(long a, long b, long c) {\n    return Math.min(a, Math.min(b, c));\n  }\n\n  static long min(long a, long b, long c, long d) {\n    return Math.min(a, Math.min(b, Math.min(c, d)));\n  }\n\n  static long max(long a, long b) {\n    return Math.max(a, b);\n  }\n\n  static long max(long a, long b, long c) {\n    return Math.max(a, Math.max(b, c));\n  }\n\n  static long max(long a, long b, long c, long d) {\n    return Math.max(a, Math.max(b, Math.max(c, d)));\n  }\n\n  static int max(int A[]) {\n    int max = Integer.MIN_VALUE;\n    for (int i = 0; i < A.length; i++) {\n      max = Math.max(max, A[i]);\n    }\n    return max;\n  }\n\n  static int min(int A[]) {\n    int min = Integer.MAX_VALUE;\n    for (int i = 0; i < A.length; i++) {\n      min = Math.min(min, A[i]);\n    }\n    return min;\n  }\n\n  static long max(long A[]) {\n    long max = Long.MIN_VALUE;\n    for (int i = 0; i < A.length; i++) {\n      max = Math.max(max, A[i]);\n    }\n    return max;\n  }\n\n  static long min(long A[]) {\n    long min = Long.MAX_VALUE;\n    for (int i = 0; i < A.length; i++) {\n      min = Math.min(min, A[i]);\n    }\n    return min;\n  }\n\n  static long sum(int A[]) {\n    long sum = 0;\n    for (int i : A) {\n      sum += i;\n    }\n    return sum;\n  }\n\n  static long sum(long A[]) {\n    long sum = 0;\n    for (long i : A) {\n      sum += i;\n    }\n    return sum;\n  }\n\n  static ArrayList<Integer> sieve(int n) {\n    ArrayList<Integer> primes = new ArrayList<>();\n    boolean[] isPrime = new boolean[n];\n    Arrays.fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i * i <= n; i++) {\n      if (isPrime[i]) {\n        for (int j = i * i; j < n; j += i) {\n          isPrime[j] = false;\n        }\n      }\n    }\n    for (int i = 2; i < n; i++) {\n      if (isPrime[i])\n        primes.add(i);\n    }\n    return primes;\n  }\n\n  static class Reader {\n    BufferedReader br;\n    StringTokenizer st;\n\n    Reader() {\n      br = new BufferedReader(new InputStreamReader(System.in));\n      st = new StringTokenizer(\"\");\n    }\n\n    Reader(File f) throws FileNotFoundException {\n      br = new BufferedReader(new FileReader(f));\n      st = new StringTokenizer(\"\");\n    }\n\n    String next() {\n      while (!st.hasMoreTokens())\n        try {\n          st = new StringTokenizer(br.readLine());\n        } catch (IOException e) {\n        }\n      return st.nextToken();\n    }\n\n    int ni() {\n      return Integer.parseInt(next());\n    }\n\n    long nl() {\n      return Long.parseLong(next());\n    }\n\n    double nextDouble() {\n      return Double.parseDouble(next());\n    }\n\n    int[] nai(int n) {\n      int[] a = new int[n];\n      for (int i = 0; i < n; i++)\n        a[i] = ni();\n      return a;\n    }\n\n    long[] nal(int n) {\n      long[] a = new long[n];\n      for (int i = 0; i < n; i++)\n        a[i] = nl();\n      return a;\n    }\n  }\n\n}", "label": 5}
{"src": "import java.util.*;import java.io.*;import java.math.*;\npublic class Main\n{\n    public static void process()throws IOException\n    {\n        int n=ni();\n        long[]A=nal(n);\n        Arrays.sort(A);\n        long ans = A[n-1];\n        long sum =0;\n        for(int i=1;i<n;i++)\n            A[i]+=A[i-1];\n        for(int i=n-1;i>0;i--){\n            sum=sum+(i+1)*(A[i]-A[i-1])-A[i];\n        }\n        pn(ans-sum);\n    }\n    \n    static AnotherReader sc;\n    static PrintWriter out;\n    public static void main(String[]args)throws IOException\n    {\n        boolean oj = System.getProperty(\"ONLINE_JUDGE\") != null;\n        if(oj){sc=new AnotherReader();out=new PrintWriter(System.out);}\n        else{sc=new AnotherReader(100);out=new PrintWriter(\"output.txt\");}\n        int t=1;\n        t=ni();\n        while(t-- > 0) {process();}\n        out.flush();out.close();  \n    }\n\n    static void pn(Object o){out.println(o);}\n    static void p(Object o){out.print(o);}\n    static void pni(Object o){out.println(o);out.flush();}\n    static int ni()throws IOException{return sc.nextInt();}\n    static long nl()throws IOException{return sc.nextLong();}\n    static double nd()throws IOException{return sc.nextDouble();}\n    static String nln()throws IOException{return sc.nextLine();}\n    static int[] nai(int N)throws IOException{int[]A=new int[N];for(int i=0;i!=N;i++){A[i]=ni();}return A;}\n    static long[] nal(int N)throws IOException{long[]A=new long[N];for(int i=0;i!=N;i++){A[i]=nl();}return A;}\n    static long gcd(long a, long b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int gcd(int a, int b)throws IOException{return (b==0)?a:gcd(b,a%b);}\n    static int bit(long n)throws IOException{return (n==0)?0:(1+bit(n&(n-1)));}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n    static class AnotherReader{BufferedReader br; StringTokenizer st;\n    AnotherReader()throws FileNotFoundException{\n    br=new BufferedReader(new InputStreamReader(System.in));}\n    AnotherReader(int a)throws FileNotFoundException{\n    br = new BufferedReader(new FileReader(\"input.txt\"));}\n    String next()throws IOException{\n    while (st == null || !st.hasMoreElements()) {try{\n    st = new StringTokenizer(br.readLine());}\n    catch (IOException  e){ e.printStackTrace(); }}\n    return st.nextToken(); } int nextInt() throws IOException{\n    return Integer.parseInt(next());}\n    long nextLong() throws IOException\n    {return Long.parseLong(next());}\n    double nextDouble()throws IOException { return Double.parseDouble(next()); }\n    String nextLine() throws IOException{ String str = \"\"; try{\n    str = br.readLine();} catch (IOException e){\n    e.printStackTrace();} return str;}}\n   \n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n}", "label": 5}
{"src": "\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\nimport java.math.BigInteger;\n\n\npublic class CF {\n\tprivate static FS sc = new FS();\n\t\n\tprivate static class FS {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tStringTokenizer st = new StringTokenizer(\"\");\n\t\tString next() {\n\t\t\twhile (!st.hasMoreTokens())\n\t\t\t\ttry {\n\t\t\t\t\tst=new StringTokenizer(br.readLine());\t\t\t\t               \n\t            } catch (IOException e) {}\n\t\t\treturn st.nextToken();\n\t\t}\n\t\t\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t}\n\t\n\tprivate static class extra {\n\t\t\n\t\tstatic int[] intArr(int size) {\n\t\t\tint[] a = new int[size];\n\t\t\tfor(int i = 0; i < size; i++) a[i] = sc.nextInt();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tstatic long[] longArr(int size) {\n\t\t\tlong[] a = new long[size];\n\t\t\tfor(int i = 0; i < size; i++) a[i] = sc.nextLong();\n\t\t\treturn a;\n\t\t}\n\t\t\n\t\tstatic long intSum(int[] a) {\n\t\t\tlong sum = 0; \n\t\t\tfor(int i = 0; i < a.length; i++) {\n\t\t\t\tsum += a[i];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tstatic long longSum(long[] a) {\n\t\t\tlong sum = 0; \n\t\t\tfor(int i = 0; i < a.length; i++) {\n\t\t\t\tsum += a[i];\n\t\t\t}\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\tstatic LinkedList[] graphD(int vertices, int edges) {\n\t\t\tLinkedList<Integer>[] temp = new LinkedList[vertices+1];\n\t\t\tfor(int i = 0; i <= vertices; i++) temp[i] = new LinkedList<>();\n\t\t\tfor(int i = 0; i < edges; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\ttemp[x].add(y);\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n\t\t\n\t\tstatic LinkedList[] graphUD(int vertices, int edges) {\n\t\t\tLinkedList<Integer>[] temp = new LinkedList[vertices+1];\n\t\t\tfor(int i = 0; i <= vertices; i++) temp[i] = new LinkedList<>();\n\t\t\tfor(int i = 0; i < edges; i++) {\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tint y = sc.nextInt();\n\t\t\t\ttemp[x].add(y);\n\t\t\t\ttemp[y].add(x);\n\t\t\t}\n\t\t\treturn temp;\n\t\t}\n\t\t\n\t\tstatic void printG(LinkedList[] temp) {\n\t\t\tfor(LinkedList<Integer> aa:temp) System.out.println(aa);\n\t\t}\n\t\t\n\t}\n\t\n\tstatic LinkedList<Integer>[] temp;\n\tstatic int mod = (int)Math.pow(10, 9) + 7;\n\t\n\tpublic static void main(String[] args) {\n\t\tint t = sc.nextInt();\n//\t\tint t = 1;\n\t\tStringBuilder ret = new StringBuilder();\n\t\twhile(t-- > 0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] a = extra.intArr(n);\n\t\t\tArrays.sort(a);\n\t\t\tlong ans = 0;\n\t\t\tfor(int i = 0; i < n-1; i++) {\n\t\t\t\tans += a[i+1]-a[i];\n\t\t\t}\n\t\t\tlong x = 1, y = n-1;\n\t\t\tfor(int i = n-1; i >= 1; i--) {\n\t\t\t\tans -= (x*y)*1L*(a[i]-a[i-1]);\n\t\t\t\tx++;\n\t\t\t\ty--;\n\t\t\t}\n\t\t\tret.append(ans + \"\\n\");\n \t\t}\n\t\tSystem.out.println(ret);\n\t}\n\t\n\t\n}\n\n", "label": 5}
{"src": "//package Codeforces;\n\nimport java.io.*;\nimport java.util.*;\n\npublic class GreatGraphs\n{\n\tpublic static void main(String[] args)throws Exception{ new GreatGraphs().run();} \n\tlong mod=1000000000+7;\n//\tint[][] ar;\n\tvoid solve() throws Exception\n\t{\n\t\t\n\t\t\n\t\tfor(int tt=ni();tt>0;tt--){\n\n\t\t\t//int n = ni();\n\t\t\t\n\t\t\tint n = ni();\n\t\t\t\n\t\t\tint[] a = new int[n];\n\t\t\t//long sum=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\ta[i]= ni();\n\t\t\t\t\n\t\t\t}\n\t\t\truffleSort(a);\n\t\t\tlong ans=0;\n\t\t\tlong sum=0;\n//\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\tout.print(a[i]+\" \");\n//\t\t\t}\n\t\t\tfor(int i=0;i<n-1;i++){\n\t\t\t\tsum+=a[i];\n\t\t\t\tlong tmp = (i+1);\n\t\t\t\ttmp*=a[i+1];\n\t\t\t\ttmp*=-1;\n\t\t\t\t//out.println(\"tmp: \"+tmp);\n\t\t\t\t\n\t\t\t\tans+=(tmp+sum);\n\t\t\t\t//out.println(\"ans: \"+ans);\n\t\t\t\t\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tans+=a[n-1];\n\t\t\tout.println(ans);\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tint getAns(ArrayList<Integer> x,int n){\n\t\t\n\t\tif(x.size()==0) return Integer.MAX_VALUE;\n\t\tint cnt=0;\n\t\tfor(int i=0;i<x.size()-1;i++) if(x.get(i)+1 != x.get(i+1)) cnt++;\n\t\tif(x.get(0)!=0) cnt++;\n\t\tif(x.get(x.size()-1)!=n-1)cnt++;\n\t\treturn cnt;\n\t}\n\t\n\tboolean issubset(int[] a,int k){\n\t\tint n = a.length;\n\t\tboolean[][]dp = new boolean[n+1][k+1];\n\t\t\n\t\tfor(int i=0;i<=n;i++){\n\t\t\tfor(int j=0;j<=k;j++){\n\t\t\t\tif(i==0) {dp[i][j] = false;continue;}\n\t\t\t\tif(j==0){dp[i][j]= true; continue;}\n\t\t\t\tif(a[i-1]<=j){\n\t\t\t\t\tdp[i][j] = dp[i][j-a[i-1]] || dp[i-1][j];\n\t\t\t\t}else{\n\t\t\t\t\tdp[i][j] = dp[i-1][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dp[n][k];\n\t}\n\t\n\t void ruffleSort(int[] a) {\n\t\t//ruffle\n\t\tint n=a.length;\n\t\tRandom r=new Random();\n\t\tfor (int i=0; i<a.length; i++) {\n\t\t\tint oi=r.nextInt(n), temp=a[i];\n\t\t\ta[i]=a[oi];\n\t\t\ta[oi]=temp;\n\t\t}\n\t\t\n\t\t//then sort\n\t\tArrays.sort(a);\n\t}\n\n\t\n\t/*FAST INPUT OUTPUT & METHODS BELOW*/\n\t\n\tprivate byte[] buf=new byte[1024];\n\tprivate int index;\n\tprivate InputStream in;\n\tprivate int total;\n\tprivate SpaceCharFilter filter;\n\tPrintWriter out;\n\t\n\tint min(int... ar){int min=Integer.MAX_VALUE;for(int i:ar)min=Math.min(min, i);return min;}\n\tlong min(long... ar){long min=Long.MAX_VALUE;for(long i:ar)min=Math.min(min, i);return min;}\n\tint max(int... ar) {int max=Integer.MIN_VALUE;for(int i:ar)max=Math.max(max, i);return max;}\n\tlong max(long... ar) {long max=Long.MIN_VALUE;for(long i:ar)max=Math.max(max, i);return max;}\n\t\n\tvoid shuffle(int a[]) {\n\t\tArrayList<Integer> al = new ArrayList<>();\n\t\tfor(int i=0;i<a.length;i++) \n\t\t\tal.add(a[i]);\n\t\t\n\t\tCollections.sort(al);\n\t\tfor(int i=0;i<a.length;i++) \n\t\t\ta[i]=al.get(i);\n\t}\n\tlong lcm(long a,long b)\n\t{\n\t\treturn (a*b)/(gcd(a,b));\n\t}\n\t\n\tint gcd(int a, int b) \n\t{ \n\t\tif (a == 0) \n\t\t\treturn b; \n\t\treturn gcd(b%a, a); \n\t} \n\tlong gcd(long a, long b) \n\t{ \n\t\tif (a == 0) \n\t\t\treturn b; \n\t\treturn gcd(b%a, a); \n\t}\n\t/* for (1/a)%mod = ( a^(mod-2) )%mod  ----> use expo to calc -->(a^(mod-2)) */\n\tlong expo(long p,long q)  /*  (p^q)%mod   */\n\t{\n\t\tlong z = 1;\n\t\twhile (q>0) {\n\t\t\tif (q%2 == 1) {\n\t\t\t\tz = (z * p)%mod;\n\t\t\t}\n\t\t\tp = (p*p)%mod;\n\t\t\tq >>= 1;\n\t\t}\n\t\treturn z;\n\t}\n\tvoid run()throws Exception\n\t{\n\t\tin=System.in; out = new PrintWriter(System.out);\n\t\tsolve();\n\t\tout.flush();\n\t}\n\tprivate int scan()throws IOException\n\t{\n\t\tif(total<0)\n\t\t\tthrow new InputMismatchException();\n\t\tif(index>=total)\n\t\t{\n\t\t\tindex=0;\n\t\t\ttotal=in.read(buf);\n\t\t\tif(total<=0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn buf[index++];\n\t}\n\tprivate int ni() throws IOException \n\t{\n\t\tint c = scan();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = scan();\n\t\tint sgn = 1;\n\t\tif (c == '-') {\n\t\t\tsgn = -1;\n\t\t\tc = scan();\n\t\t}\n\t\tint res = 0;\n\t\tdo {\n\t\t\tif (c < '0' || c > '9')\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tres *= 10;\n\t\t\tres += c - '0';\n\t\t\tc = scan();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res * sgn;\n\t}\n\tprivate long nl() throws IOException \n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = scan()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = scan();\n\t\t}\n\t\t\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = scan();\n\t\t}\n\t}\n\tprivate double nd() throws IOException{\n\t\treturn Double.parseDouble(ns());\n\t}\n\tprivate String ns() throws IOException {\n\t\tint c = scan();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = scan();\n\t\tStringBuilder res = new StringBuilder();\n\t\tdo {\n\t\t\tif (Character.isValidCodePoint(c))\n\t\t\t\tres.appendCodePoint(c);\n\t\t\tc = scan();\n\t\t} while (!isSpaceChar(c));\n\t\treturn res.toString();\n\t}\n\tprivate String nss() throws IOException\n\t{\n\t\tBufferedReader br=new BufferedReader(new InputStreamReader(System.in));\n\t\treturn br.readLine();\n\t}\n\tprivate char nc() throws IOException \n\t{\n\t\tint c = scan();\n\t\twhile (isSpaceChar(c))\n\t\t\tc = scan();\n\t\treturn (char) c;\n\t}\n\tprivate boolean isWhiteSpace(int n)\n\t{\n\t\tif(n==' '||n=='\\n'||n=='\\r'||n=='\\t'||n==-1)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\tprivate boolean isSpaceChar(int c) {\n\t\tif (filter != null)\n\t\t\treturn filter.isSpaceChar(c);\n\t\treturn isWhiteSpace(c);\n\t}\n\tprivate interface SpaceCharFilter {\n\t\tpublic boolean isSpaceChar(int ch);\n\t}\n}\n\n\n", "label": 5}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Arrays;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.io.UncheckedIOException;\nimport java.io.Closeable;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        Thread thread = new Thread(null, new TaskAdapter(), \"\", 1 << 29);\n        thread.start();\n        thread.join();\n    }\n\n    static class TaskAdapter implements Runnable {\n        @Override\n        public void run() {\n            InputStream inputStream = System.in;\n            OutputStream outputStream = System.out;\n            FastInput in = new FastInput(inputStream);\n            FastOutput out = new FastOutput(outputStream);\n            AGreatGraphs solver = new AGreatGraphs();\n            int testCount = Integer.parseInt(in.next());\n            for (int i = 1; i <= testCount; i++)\n                solver.solve(i, in, out);\n            out.close();\n        }\n    }\n\n    static class AGreatGraphs {\n        public void solve(int testNumber, FastInput in, FastOutput out) {\n            int n = in.ri();\n            int[] d = in.ri(n);\n            Randomized.shuffle(d);\n            Arrays.sort(d);\n            long ans = d[n - 1];\n            LongPreSum lps = new LongPreSum(i -> d[i], n);\n            for (int i = 0; i < n; i++) {\n                ans += (long) d[i] * (n - i - 1) - lps.post(i + 1);\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class FastInput {\n        private final InputStream is;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 13);\n        private byte[] buf = new byte[1 << 13];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastInput(InputStream is) {\n            this.is = is;\n        }\n\n        public void populate(int[] data) {\n            for (int i = 0; i < data.length; i++) {\n                data[i] = readInt();\n            }\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    bufLen = -1;\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public String next() {\n            return readString();\n        }\n\n        public int ri() {\n            return readInt();\n        }\n\n        public int[] ri(int n) {\n            int[] ans = new int[n];\n            populate(ans);\n            return ans;\n        }\n\n        public int readInt() {\n            boolean rev = false;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                rev = next == '-';\n                next = read();\n            }\n\n            int val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 - next + '0';\n                next = read();\n            }\n\n            return rev ? val : -val;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n    }\n\n    static interface IntToLongFunction {\n        long apply(int x);\n\n    }\n\n    static class LongPreSum {\n        private long[] pre;\n        private int n;\n\n        public LongPreSum(int n) {\n            pre = new long[n];\n        }\n\n        public void populate(IntToLongFunction a, int n) {\n            this.n = n;\n            if (n == 0) {\n                return;\n            }\n            pre[0] = a.apply(0);\n            for (int i = 1; i < n; i++) {\n                pre[i] = pre[i - 1] + a.apply(i);\n            }\n        }\n\n        public LongPreSum(IntToLongFunction a, int n) {\n            this(n);\n            populate(a, n);\n        }\n\n        public long intervalSum(int l, int r) {\n            return prefix(r) - prefix(l - 1);\n        }\n\n        public long prefix(int i) {\n            i = Math.min(i, n - 1);\n            if (i < 0) {\n                return 0;\n            }\n            return pre[i];\n        }\n\n        public long post(int i) {\n            return prefix(n) - prefix(i - 1);\n        }\n\n        public String toString() {\n            StringBuilder ans = new StringBuilder();\n            for (int i = 0; i < n; i++) {\n                ans.append(intervalSum(i, i)).append(',');\n            }\n            if (ans.length() > 0) {\n                ans.setLength(ans.length() - 1);\n            }\n            return ans.toString();\n        }\n\n    }\n\n    static class Randomized {\n        public static void shuffle(int[] data) {\n            shuffle(data, 0, data.length);\n        }\n\n        public static void shuffle(int[] data, int from, int to) {\n            to--;\n            for (int i = from; i <= to; i++) {\n                int s = nextInt(i, to);\n                int tmp = data[i];\n                data[i] = data[s];\n                data[s] = tmp;\n            }\n        }\n\n        public static int nextInt(int l, int r) {\n            return RandomWrapper.INSTANCE.nextInt(l, r);\n        }\n\n    }\n\n    static class FastOutput implements AutoCloseable, Closeable, Appendable {\n        private static final int THRESHOLD = 32 << 10;\n        private final Writer os;\n        private StringBuilder cache = new StringBuilder(THRESHOLD * 2);\n\n        public FastOutput append(CharSequence csq) {\n            cache.append(csq);\n            return this;\n        }\n\n        public FastOutput append(CharSequence csq, int start, int end) {\n            cache.append(csq, start, end);\n            return this;\n        }\n\n        private void afterWrite() {\n            if (cache.length() < THRESHOLD) {\n                return;\n            }\n            flush();\n        }\n\n        public FastOutput(Writer os) {\n            this.os = os;\n        }\n\n        public FastOutput(OutputStream os) {\n            this(new OutputStreamWriter(os));\n        }\n\n        public FastOutput append(char c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput append(long c) {\n            cache.append(c);\n            afterWrite();\n            return this;\n        }\n\n        public FastOutput println(long c) {\n            return append(c).println();\n        }\n\n        public FastOutput println() {\n            return append('\\n');\n        }\n\n        public FastOutput flush() {\n            try {\n//            boolean success = false;\n//            if (stringBuilderValueField != null) {\n//                try {\n//                    char[] value = (char[]) stringBuilderValueField.get(cache);\n//                    os.write(value, 0, cache.length());\n//                    success = true;\n//                } catch (Exception e) {\n//                }\n//            }\n//            if (!success) {\n                os.append(cache);\n//            }\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n            return this;\n        }\n\n        public void close() {\n            flush();\n            try {\n                os.close();\n            } catch (IOException e) {\n                throw new UncheckedIOException(e);\n            }\n        }\n\n        public String toString() {\n            return cache.toString();\n        }\n\n    }\n\n    static class RandomWrapper {\n        private Random random;\n        public static final RandomWrapper INSTANCE = new RandomWrapper();\n\n        public RandomWrapper() {\n            this(new Random());\n        }\n\n        public RandomWrapper(Random random) {\n            this.random = random;\n        }\n\n        public RandomWrapper(long seed) {\n            this(new Random(seed));\n        }\n\n        public int nextInt(int l, int r) {\n            return random.nextInt(r - l + 1) + l;\n        }\n\n    }\n}\n\n", "label": 5}
{"src": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args){\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        solve(in, out);\n        out.close();\n    }\n\n    static String reverse(String s) {\n        return (new StringBuilder(s)).reverse().toString();\n    }\n\n    static void sieveOfEratosthenes(int n, int factors[], ArrayList<Integer> ar) \n    { \n        factors[1]=1;\n        int p;\n        for(p = 2; p*p <=n; p++) \n        { \n            if(factors[p] == 0) \n            { \n                ar.add(p);\n                factors[p]=p;\n                for(int i = p*p; i <= n; i += p) \n                    if(factors[i]==0)\n                        factors[i] = p; \n            } \n        } \n        for(;p<=n;p++){\n            if(factors[p] == 0) \n            { \n                factors[p] = p;\n                ar.add(p);\n            } \n        }\n    }\n\n    static void sort(int ar[]) {\n        int n = ar.length;\n        ArrayList<Integer> a = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            a.add(ar[i]);\n        Collections.sort(a);\n        for (int i = 0; i < n; i++)\n            ar[i] = a.get(i);\n    }\n\n    static void sort1(long ar[]) {\n        int n = ar.length;\n        ArrayList<Long> a = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n            a.add(ar[i]);\n        Collections.sort(a);\n        for (int i = 0; i < n; i++)\n            ar[i] = a.get(i);\n    }\n\n    static long ncr(long n, long r, long mod) {\n        if (r == 0)\n            return 1;\n        long val = ncr(n - 1, r - 1, mod);\n        val = (n * val) % mod;\n        val = (val * modInverse(r, mod)) % mod;\n        return val;\n    }\n\n    static int findMax(int a[], int n, int vis[], int i, int d){\n        if(i>=n)\n            return 0;\n        if(vis[i]==1)\n            return findMax(a, n, vis, i+1, d);\n        int max = 0;\n        for(int j=i+1;j<n;j++){\n            if(Math.abs(a[i]-a[j])>d||vis[j]==1)\n                continue;\n            vis[j] = 1;\n            max = Math.max(max, 1 + findMax(a, n, vis, i+1, d));\n            vis[j] = 0;\n        }\n        return max;\n    }\n\n    static void findSub(ArrayList<ArrayList<Integer>> ar, int n, ArrayList<Integer> a, int i){\n        if(i==n){\n            ArrayList<Integer> b = new ArrayList<Integer>();\n            for(int y:a){\n                b.add(y);\n            }\n            ar.add(b);\n            return;\n        }\n        for(int j=0;j<n;j++){\n            if(j==i)\n                continue;\n            a.set(i,j);\n            findSub(ar, n, a, i+1);\n        }\n    }\n\n    public static void solve(InputReader sc, PrintWriter pw){\n        int i, j = 0;\n        // int t = 1; \n        int t = sc.nextInt();\n        u: while (t-- > 0) {\n            int n = sc.nextInt();\n            long ans = 0;\n            long a[] = new long[n+1];\n            long sum[] = new long[n+1];\n            for(i=0;i<n;i++){\n                a[i+1] = sc.nextInt();\n            }\n            sort1(a);\n\n            for(i=1;i<=n;i++){\n                sum[i] = sum[i-1] + a[i];\n                ans -= a[i]*(i-1) - sum[i-1];\n                ans += a[i] - a[i-1];\n            }\n            pw.println(ans);\n        }\n    }\n\n    static void assignAnc(ArrayList<Integer> ar[],int sz[], int pa[] ,int curr, int par){\n        sz[curr] = 1;\n        pa[curr] = par;\n        for(int v:ar[curr]){\n            if(par==v)\n                continue;\n            assignAnc(ar, sz, pa, v, curr);\n            sz[curr] += sz[v];\n        }\n    }\n\n    static int findLCA(int a, int b, int par[][], int depth[]){\n        if(depth[a]>depth[b]){\n            a = a^b;\n            b = a^b;\n            a = a^b;\n        }\n        int diff = depth[b] - depth[a];\n        for(int i=19;i>=0;i--){\n            if((diff&(1<<i))>0){\n                b = par[b][i];\n            }\n        }\n        if(a==b)\n            return a;\n        for(int i=19;i>=0;i--){\n            if(par[b][i]!=par[a][i]){\n                b = par[b][i];\n                a = par[a][i];\n            }\n        }\n        return par[a][0];\n    }\n\n    static void formArrayForBinaryLifting(int n, int par[][]){\n        for(int j=1;j<20;j++){\n            for(int i=0;i<n;i++){\n                if(par[i][j-1]==-1)\n                    continue;\n                par[i][j] = par[par[i][j-1]][j-1];\n            }\n        }\n    }\n\n    static long lcm(int a, int b){\n        return a*b/gcd(a,b);\n    }\n\n    static class Pair1 {\n        long a;\n        long b;\n        \n        Pair1(long a, long b) {\n            this.a = a;\n            this.b = b;\n        }\n    }\n\n    static class Pair implements Comparable<Pair> {\n        int a;\n        int b;\n        // int c;\n        \n        Pair(int a, int b) {\n            this.a = a;\n            this.b = b;\n            // this.c = c;\n        }\n \n        public int compareTo(Pair p) {\n            // if(a!=p.a)\n            //     return a-p.a;\n            return b-p.b;\n            // return p.c - c;\n        }\n    }\n\n    static boolean isPrime(int n) { \n        if (n <= 1) \n            return false; \n        if (n <= 3) \n            return true; \n        if (n % 2 == 0 ||  n % 3 == 0) \n            return false; \n        for (int i = 5; i * i <= n; i = i + 6) \n            if (n % i == 0 || n % (i + 2) == 0) \n                return false; \n        return true; \n    } \n\n    static long gcd(long a, long b) {\n        if (b == 0)\n            return a;\n        return gcd(b, a % b);\n    }\n\n    static long fast_pow(long base, long n, long M) {\n        if (n == 0)\n            return 1;\n        if (n == 1)\n            return base % M;\n        long halfn = fast_pow(base, n / 2, M);\n        if (n % 2 == 0)\n            return (halfn * halfn) % M;\n        else\n            return (((halfn * halfn) % M) * base) % M;\n    }\n\n    static long modInverse(long n, long M) {\n        return fast_pow(n, M - 2, M);\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 9992768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        public long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class Main{\n\tstatic void main() throws Exception{\n\t\tint n=sc.nextInt();\n\t\tint[]in=sc.intSortedArr(n);\n\t\tlong sum=0;\n\t\tlong ans=in[n-1];\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tans+=(sum-in[i]*1l*i);\n\t\t\tsum+=in[i];\n\t\t}\n\t\tpw.println(ans);\n\t}\n\tpublic static void main(String[] args) throws Exception{\n\t\tsc=new MScanner(System.in);\n\t\tpw = new PrintWriter(System.out);\n\t\tint tc=1;\n        tc=sc.nextInt();\n\t\tfor(int i=1;i<=tc;i++) {\n//\t\t\tpw.printf(\"Case #%d: \", i);\n\t\t\tmain();\n\t\t}\n\t\t\n\t\tpw.flush();\n\t}\n\tstatic PrintWriter pw;\n\tstatic MScanner sc;\n\tstatic class MScanner {\n\t\tStringTokenizer st;\n\t\tBufferedReader br;\n\t\tpublic MScanner(InputStream system) {\n\t\t\tbr = new BufferedReader(new InputStreamReader(system));\n\t\t}\n\t \n\t\tpublic MScanner(String file) throws Exception {\n\t\t\tbr = new BufferedReader(new FileReader(file));\n\t\t}\n\t \n\t\tpublic String next() throws IOException {\n\t\t\twhile (st == null || !st.hasMoreTokens())\n\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\treturn st.nextToken();\n\t\t}\n\t\tpublic int[] intArr(int n) throws IOException {\n\t        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        return in;\n\t\t}\n\t\tpublic long[] longArr(int n) throws IOException {\n\t        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        return in;\n\t\t}\n\t\tpublic int[] intSortedArr(int n) throws IOException {\n\t        int[]in=new int[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        shuffle(in);\n\t        Arrays.sort(in);\n\t        return in;\n\t\t}\n\t\tpublic long[] longSortedArr(int n) throws IOException {\n\t        long[]in=new long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        shuffle(in);\n\t        Arrays.sort(in);\n\t        return in;\n\t\t}\n\t\tpublic Integer[] IntegerArr(int n) throws IOException {\n\t        Integer[]in=new Integer[n];for(int i=0;i<n;i++)in[i]=nextInt();\n\t        return in;\n\t\t}\n\t\tpublic Long[] LongArr(int n) throws IOException {\n\t        Long[]in=new Long[n];for(int i=0;i<n;i++)in[i]=nextLong();\n\t        return in;\n\t\t}\n\t\tpublic String nextLine() throws IOException {\n\t\t\treturn br.readLine();\n\t\t}\n\t \n\t\tpublic int nextInt() throws IOException {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t \n\t\tpublic double nextDouble() throws IOException {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t \n\t\tpublic char nextChar() throws IOException {\n\t\t\treturn next().charAt(0);\n\t\t}\n\t \n\t\tpublic long nextLong() throws IOException {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t \n\t\tpublic boolean ready() throws IOException {\n\t\t\treturn br.ready();\n\t\t}\n\t \n\t\tpublic void waitForInput() throws InterruptedException {\n\t\t\tThread.sleep(3000);\n\t\t}\n\t\t\n\t}\n\tstatic void dbg(int[]in) {\n\t\tSystem.out.println(Arrays.toString(in));\n\t}\n\tstatic void dbg(long[]in) {\n\t\tSystem.out.println(Arrays.toString(in));\n\t}\n\tstatic void sort(int[]in) {\n\t\tshuffle(in);\n\t\tArrays.sort(in);\n\t}\n\tstatic void sort(long[]in) {\n\t\tshuffle(in);\n\t\tArrays.sort(in);\n\t}\n\tstatic void shuffle(int[]in) {\n\t\tfor(int i=0;i<in.length;i++) {\n\t\t\tint idx=(int)(Math.random()*in.length);\n\t\t\tint tmp=in[i];\n\t\t\tin[i]=in[idx];\n\t\t\tin[idx]=tmp;\n\t\t}\n\t}\n\tstatic void shuffle(long[]in) {\n\t\tfor(int i=0;i<in.length;i++) {\n\t\t\tint idx=(int)(Math.random()*in.length);\n\t\t\tlong tmp=in[i];\n\t\t\tin[i]=in[idx];\n\t\t\tin[idx]=tmp;\n\t\t}\n\t}\n}", "label": 5}
{"src": "\nimport java.util.*;\nimport java.lang.*;\nimport java.io.*;\n\npublic class GreatGraphs {\n    public static void main(String[] args) throws java.lang.Exception {\n        // your code goes here\n        try {\n            // Scanner sc=new Scanner(System.in);\n            FastReader sc = new FastReader();\n            int t =sc.nextInt();\n            while (t-- > 0) {\n                int n=sc.nextInt();\n                long[] arr=new long[n];\n                for(int i=0;i<n;i++){\n                    arr[i]=sc.nextLong();\n                }\n                Arrays.sort(arr);\n                long sum=arr[n-1];\n                long[] pathVal=new long[n];\n                for(int i=1;i<n;i++){\n                    pathVal[i]=pathVal[i-1]+i*(arr[i]-arr[i-1]);\n                    sum+=(-pathVal[i]);\n                }\n                System.out.println(sum);\n            }\n        } catch (Exception e) {\n            return;\n        }\n\n    }\n    \n\n    static int BS(int[] arr, int l, int r, int element) {\n        int low = l;\n        int high = r;\n        while (high - low > 1) {\n            int mid = low + (high - low) / 2;\n            if (arr[mid] < element) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        if (arr[low] == element) {\n            return low;\n        } else if (arr[high] == element) {\n            return high;\n        }\n        return -1;\n    }\n\n    static int lower_bound(int[] arr, int l, int r, int element) {\n        int low = l;\n        int high = r;\n        while (high - low > 1) {\n            int mid = low + (high - low) / 2;\n            if (arr[mid] < element) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        if (arr[low] >= element) {\n            return low;\n        } else if (arr[high] >= element) {\n            return high;\n        }\n        return -1;\n    }\n\n    static int upper_bound(int[] arr, int l, int r, int element) {\n        int low = l;\n        int high = r;\n        while (high - low > 1) {\n            int mid = low + (high - low) / 2;\n            if (arr[mid] <= element) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        if (arr[low] > element) {\n            return low;\n        } else if (arr[high] > element) {\n            return high;\n        }\n        return -1;\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        String nextLine() {\n            String s = \"\";\n            try {\n                s = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return s;\n        }\n\n        Long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n\n/*\n * public static boolean lie(int n,int m,int k){ if(n==1 && m==1 && k==0){\n * return true; } if(n<1 || m<1 || k<0){ return false; } boolean\n * tc=lie(n-1,m,k-m); boolean lc=lie(n,m-1,k-n); if(tc || lc){ return true; }\n * return false; }\n */\n\n\n", "label": 5}
{"src": "\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tFastScanner fs = new FastScanner();\n\t\tjava.io.PrintWriter out = new java.io.PrintWriter(System.out);\n\t\tsolve(fs, out);\n\t\tout.flush();\n\t}\n\n\tpublic void solve(FastScanner fs, java.io.PrintWriter out) {\n\t\tint t = fs.nextInt();\n\t\twhile(t --> 0) {\n\t\t\tint n = fs.nextInt();\n\t\t\tint[] d = new int[n];\n\t\t\tfor (int i = 0;i < n;++ i) d[i] = fs.nextInt();\n\t\t\tArrays.sort(d);\n\t\t\tlong sum = 0, ans = d[n - 1];\n\t\t\tfor (int i = 0;i < n;++ i) {\n\t\t\t\tsum += d[i];\n\t\t\t\tans += sum - (i + 1L) * d[i];\n\t\t\t}\n\t\t\tout.println(ans);\n\t\t}\n\t}\n}\n\nclass FastScanner {\n\n\tprivate final java.io.InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[8192];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) return true;\n\t\tptr = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (java.io.IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn buflen > 0;\n\t}\n\n\tprivate byte readByte() {\n\t\treturn hasNextByte() ? buffer[ptr++ ] : -1;\n\t}\n\n\tprivate static boolean isPrintableChar(byte c) {\n\t\treturn 32 < c || c < 0;\n\t}\n\n\tprivate static boolean isNumber(int c) {\n\t\treturn '0' <= c && c <= '9';\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++ ;\n\t\treturn hasNextByte();\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext()) throw new java.util.NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile (isPrintableChar(b = readByte()))\n\t\t\tsb.appendCodePoint(b);\n\t\treturn sb.toString();\n\t}\n\n\tpublic final char nextChar() {\n\t\tif (!hasNext()) throw new java.util.NoSuchElementException();\n\t\treturn (char)readByte();\n\t}\n\n\tpublic final long nextLong() {\n\t\tif (!hasNext()) throw new java.util.NoSuchElementException();\n\t\tlong n = 0;\n\t\ttry {\n\t\t\tbyte b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\twhile (isNumber(b = readByte()))\n\t\t\t\t\tn = n * 10 + '0' - b;\n\t\t\t\treturn n;\n\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\tdo\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\twhile (isNumber(b = readByte()));\n\t\t} catch (java.util.NoSuchElementException e) {}\n\t\treturn n;\n\t}\n\n\tpublic final int nextInt() {\n\t\tif (!hasNext()) throw new java.util.NoSuchElementException();\n\t\tint n = 0;\n\t\ttry {\n\t\t\tbyte b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\twhile (isNumber(b = readByte()))\n\t\t\t\t\tn = n * 10 + '0' - b;\n\t\t\t\treturn n;\n\t\t\t} else if (!isNumber(b)) throw new NumberFormatException();\n\t\t\tdo\n\t\t\t\tn = n * 10 + b - '0';\n\t\t\twhile (isNumber(b = readByte()));\n\t\t} catch (java.util.NoSuchElementException e) {}\n\t\treturn n;\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n\nclass Arrays {\n\n\tpublic static void sort(final int[] array) {\n\t\tsort(array, 0, array.length);\n\t}\n\n\tpublic static void sort(final int[] array, int fromIndex, int toIndex) {\n\t\tif (toIndex - fromIndex  <= 512) {\n\t\t\tjava.util.Arrays.sort(array, fromIndex, toIndex);\n\t\t\treturn;\n\t\t}\n\t\tsort(array, fromIndex, toIndex, 0, new int[array.length]);\n\t}\n\n\tprivate static final void sort(int[] a, final int from, final int to, final int l, final int[] bucket) {\n\t\tif (to - from  <= 512) {\n\t\t\tjava.util.Arrays.sort(a, from, to);\n\t\t\treturn;\n\t\t}\n\t\tfinal int BUCKET_SIZE = 256;\n\t\tfinal int INT_RECURSION = 4;\n\t\tfinal int MASK = 0xff;\n\t\tfinal int shift = l << 3;\n\t\tfinal int[] cnt = new int[BUCKET_SIZE + 1];\n\t\tfinal int[] put = new int[BUCKET_SIZE];\n\t\tfor (int i = from; i < to; i++) ++ cnt[(a[i] >>> shift & MASK) + 1];\n\t\tfor (int i = 0; i < BUCKET_SIZE; i++) cnt[i + 1] += cnt[i];\n\t\tfor (int i = from; i < to; i++) {\n\t\t\tint bi = a[i] >>> shift & MASK;\n\t\t\tbucket[cnt[bi] + put[bi]++] = a[i];\n\t\t}\n\t\tfor (int i = BUCKET_SIZE - 1, idx = from; i >= 0; i--) {\n\t\t\tint begin = cnt[i];\n\t\t\tint len = cnt[i + 1] - begin;\n\t\t\tSystem.arraycopy(bucket, begin, a, idx, len);\n\t\t\tidx += len;\n\t    }\n\t\tfinal int nxtL = l + 1;\n\t\tif (nxtL < INT_RECURSION) {\n\t\t\tsort(a, from, to, nxtL, bucket);\n\t\t\tif (l == 0) {\n\t\t\t\tint lft, rgt;\n\t\t\t\tlft = from - 1; rgt = to;\n\t\t\t\twhile (rgt - lft > 1) {\n\t\t\t\t\tint mid = lft + rgt >> 1;\n\t\t\t\t\tif (a[mid] < 0) lft = mid;\n\t\t\t\t\telse rgt = mid;\n\t\t\t\t}\n\t\t\t\treverse(a, from, rgt);\n\t\t\t\treverse(a, rgt, to);\n\t        }\n\t    }\n\t}\n\n\tpublic static void sort(final long[] array) {\n\t\tsort(array, 0, array.length);\n\t}\n\n\tpublic static void sort(final long[] array, int fromIndex, int toIndex) {\n\t\tif (toIndex - fromIndex  <= 512) {\n\t\t\tjava.util.Arrays.sort(array, fromIndex, toIndex);\n\t\t\treturn;\n\t\t}\n\t\tsort(array, fromIndex, toIndex, 0, new long[array.length]);\n\t}\n\n\tprivate static final void sort(long[] a, final int from, final int to, final int l, final long[] bucket) {\n\t\tfinal int BUCKET_SIZE = 256;\n\t\tfinal int LONG_RECURSION = 8;\n\t\tfinal int MASK = 0xff;\n\t\tfinal int shift = l << 3;\n\t\tfinal int[] cnt = new int[BUCKET_SIZE + 1];\n\t\tfinal int[] put = new int[BUCKET_SIZE];\n\t\tfor (int i = from; i < to; i++) ++ cnt[(int) ((a[i] >>> shift & MASK) + 1)];\n\t\tfor (int i = 0; i < BUCKET_SIZE; i++) cnt[i + 1] += cnt[i];\n\t\tfor (int i = from; i < to; i++) {\n\t\t\tint bi = (int) (a[i] >>> shift & MASK);\n\t\t\tbucket[cnt[bi] + put[bi]++] = a[i];\n\t\t}\n\t\tfor (int i = BUCKET_SIZE - 1, idx = from; i >= 0; i--) {\n\t\t\tint begin = cnt[i];\n\t\t\tint len = cnt[i + 1] - begin;\n\t\t\tSystem.arraycopy(bucket, begin, a, idx, len);\n\t\t\tidx += len;\n\t    }\n\t\tfinal int nxtL = l + 1;\n\t\tif (nxtL < LONG_RECURSION) {\n\t\t\tsort(a, from, to, nxtL, bucket);\n\t\t\tif (l == 0) {\n\t\t\t\tint lft, rgt;\n\t\t\t\tlft = from - 1; rgt = to;\n\t\t\t\twhile (rgt - lft > 1) {\n\t\t\t\t\tint mid = lft + rgt >> 1;\n\t\t\t\t\tif (a[mid] < 0) lft = mid;\n\t\t\t\t\telse rgt = mid;\n\t\t\t\t}\n\t\t\t\treverse(a, from, rgt);\n\t\t\t\treverse(a, rgt, to);\n\t        }\n\t    }\n\t}\n\n\tpublic static void reverse(int[] array) {\n\t\treverse(array, 0, array.length);\n\t}\n\n\tpublic static void reverse(int[] array, int fromIndex, int toIndex) {\n\t\tfor (-- toIndex;fromIndex < toIndex;++ fromIndex, -- toIndex) {\n\t\t\tint swap = array[fromIndex];\n\t\t\tarray[fromIndex] = array[toIndex];\n\t\t\tarray[toIndex] = swap;\n\t\t}\n\t}\n\n\tpublic static void reverse(long[] array) {\n\t\treverse(array, 0, array.length);\n\t}\n\n\tpublic static void reverse(long[] array, int fromIndex, int toIndex) {\n\t\tfor (-- toIndex;fromIndex < toIndex;++ fromIndex, -- toIndex) {\n\t\t\tlong swap = array[fromIndex];\n\t\t\tarray[fromIndex] = array[toIndex];\n\t\t\tarray[toIndex] = swap;\n\t\t}\n\t}\n}\n\nclass IntMath {\n\n\tpublic static int gcd(int a, int b) {\n\t\twhile (a != 0)\n\t\t\tif ((b %= a) != 0) a %= b;\n\t\t\telse return a;\n\t\treturn b;\n\t}\n\n\tpublic static int gcd(int... array) {\n\t\tint ret = array[0];\n\t\tfor (int i = 1; i < array.length; ++i)\n\t\t\tret = gcd(ret, array[i]);\n\t\treturn ret;\n\t}\n\n\tpublic static long gcd(long a, long b) {\n\t\twhile (a != 0)\n\t\t\tif ((b %= a) != 0) a %= b;\n\t\t\telse return a;\n\t\treturn b;\n\t}\n\n\tpublic static long gcd(long... array) {\n\t\tlong ret = array[0];\n\t\tfor (int i = 1; i < array.length; ++i)\n\t\t\tret = gcd(ret, array[i]);\n\t\treturn ret;\n\t}\n\n\tpublic static long lcm(long a, long b) {\n\t\treturn a / gcd(a, b) * b;\n\t}\n\n\tpublic static int pow(int a, int b) {\n\t\tint ans = 1;\n\t\tfor (int mul = a; b > 0; b >>= 1, mul *= mul)\n\t\t\tif ((b & 1) != 0) ans *= mul;\n\t\treturn ans;\n\t}\n\n\tpublic static long pow(long a, long b) {\n\t\tlong ans = 1;\n\t\tfor (long mul = a; b > 0; b >>= 1, mul *= mul)\n\t\t\tif ((b & 1) != 0) ans *= mul;\n\t\treturn ans;\n\t}\n\n\tpublic static int pow(int a, long b, int mod) {\n\t\tif (b < 0) b = b % (mod - 1) + mod - 1;\n\t\tlong ans = 1;\n\t\tfor (long mul = a; b > 0; b >>= 1, mul = mul * mul % mod)\n\t\t\tif ((b & 1) != 0) ans = ans * mul % mod;\n\t\treturn (int)ans;\n\t}\n\n\tpublic static int pow(long a, long b, int mod) {\n\t\treturn pow((int)(a % mod), b, mod);\n\t}\n\n\tpublic static int floorsqrt(long n) {\n\t\treturn (int)Math.sqrt(n + 0.1);\n\t}\n\n\tpublic static int ceilsqrt(long n) {\n\t\treturn n <= 1 ? (int)n : (int)Math.sqrt(n - 0.1) + 1;\n\t}\n}\n", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\n\npublic class A{\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\t// br = new BufferedReader(new FileReader(\".in\"));\n\t\t// out = new PrintWriter(new FileWriter(\".out\"));\n\t\t//new Thread(null, new (), \"peepee\", 1<<28).start();\n\t\t\n\t\t\n\t\tint t =readInt();\n\t\twhile(t-->0) {\n\t\t\tint n =readInt();\n\t\t\tLong[] a  = new  Long[n];\n\t\t\tfor (int i = 0; i  < n; i++) a[i] =readLong();\n\t\t\tArrays.sort(a);\n\t\t\tlong cost = a[n-1];\n\t\t\t// This is so obvious yet so hard wtf\n\t\t\tlong cum = 0;\n\t\t\tlong cum2 = 0;\n\t\t\tfor (int i = n-2; i >=0; i--) {\n\t\t\t\tcum2+=a[i+1]-a[i];\n\t\t\t\tcum+=cum2;\n\t\t\t}\n\t\t\tfor (int i = n-1; i > 0; i--) {\n\t\t\t\tlong sub  = a[i]-a[i-1];\n\t\t\t\tcost-=cum;\n\t\t\t\tcum-=sub*(i);\n\t\t\t}\n\t\t\tout.println(cost);\n\t\t}\n\t\tout.close();\n\t}\n\t\n\tstatic BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\tstatic PrintWriter out = new PrintWriter(new BufferedOutputStream(System.out));\n\tstatic StringTokenizer st = new StringTokenizer(\"\");\n\tstatic String read() throws IOException{return st.hasMoreTokens() ? st.nextToken():(st = new StringTokenizer(br.readLine())).nextToken();}\n\tstatic int readInt() throws IOException{return Integer.parseInt(read());}\n\tstatic long readLong() throws IOException{return Long.parseLong(read());}\n\tstatic double readDouble() throws IOException{return Double.parseDouble(read());}\n\t\n}", "label": 5}
{"src": "//package Codeforces.CF728;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.StringTokenizer;\n\npublic class C {\n\n    static final int mod = (int) 1e4 + 1;\n\n    private static void solve(int t) {\n        int n = fs.nextInt();\n//        initalApp(n);\n        long arr[] = new long[n];\n        long max = 0;\n        for (int i = 0; i < n; i++) {\n            arr[i] = fs.nextLong();\n            max = Math.max(max, arr[i]);\n        }\n        Arrays.sort(arr);\n//        optimized(n, arr);\n        long ans = 0;\n        long sum = 0;\n        for (int i = 0; i < n; i++) {\n            ans -= (long) i * arr[i] - sum;\n            sum += arr[i];\n        }\n        ans += max;\n        System.out.println(ans);\n    }\n\n    private static void optimized(int n, long[] arr) {\n        long negSum = 0;\n        long posSum = 0;\n        for (int i = 1; i < n; i++) {\n            long currPath = arr[i] - arr[i - 1];\n            posSum += currPath;\n            negSum += (long) (i * (n - i)) * currPath;\n        }\n        System.out.println(posSum - negSum);\n    }\n\n    private static void initalApp(int n) {\n        int negArr[] = new int[n];\n        PriorityQueue<Integer> pq = new PriorityQueue<>();\n        for (int i = 0; i < n; i++) {\n            Integer a = fs.nextInt();\n            pq.offer(a);\n        }\n        int idx = 0;\n        long negSum = 0;\n        long posSum = 0;\n        long prev = 0;\n        pq.poll();\n\n        while (!pq.isEmpty()) {\n            Integer num = pq.poll();\n            negArr[++idx] = num;\n            posSum += num - prev;\n            prev = num;\n            if (idx > 0)\n                negSum += idx * (n - idx) * (negArr[idx] - negArr[idx - 1]);\n        }\n        System.out.println(posSum - negSum);\n    }\n\n\n    static int lowerBound(int[] a, int low, int high, int element) {\n        while (low < high) {\n            int middle = low + (high - low) / 2;\n            if (element > a[middle]) {\n                low = middle + 1;\n            } else {\n                high = middle;\n            }\n        }\n        return low;\n    }\n\n    static int upperBound(int[] a, int low, int high, int element) {\n        while (low < high) {\n            int middle = low + (high - low) / 2;\n            if (a[middle] > element) {\n                high = middle;\n            } else {\n                low = middle + 1;\n            }\n        }\n        return low;\n    }\n\n\n    public static void main(String[] args) {\n        fs = new FastScanner();\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        int t = fs.nextInt();\n        for (int i = 1; i <= t; i++) solve(t);\n        out.close();\n//        System.err.println( System.currentTimeMillis() - s + \"ms\" );\n    }\n\n    static boolean DEBUG = true;\n    static PrintWriter out;\n    static FastScanner fs;\n\n    static void trace(Object... o) {\n        if (!DEBUG) return;\n        System.err.println(Arrays.deepToString(o));\n    }\n\n    static void pl(Object o) {\n        out.println(o);\n    }\n\n    static void p(Object o) {\n        out.print(o);\n    }\n\n    static long gcd(long a, long b) {\n        return (b == 0) ? a : gcd(b, a % b);\n    }\n\n    static int gcd(int a, int b) {\n        return (b == 0) ? a : gcd(b, a % b);\n    }\n\n    static void sieveOfEratosthenes(int n, int factors[]) {\n        factors[1] = 1;\n        for (int p = 2; p * p <= n; p++) {\n            if (factors[p] == 0) {\n                factors[p] = p;\n                for (int i = p * p; i <= n; i += p)\n                    factors[i] = p;\n            }\n        }\n    }\n\n    static long mul(long a, long b) {\n        return a * b % mod;\n    }\n\n    static long fact(int x) {\n        long ans = 1;\n        for (int i = 2; i <= x; i++) ans = mul(ans, i);\n        return ans;\n    }\n\n    static long fastPow(long base, long exp) {\n        if (exp == 0) return 1;\n        long half = fastPow(base, exp / 2);\n        if (exp % 2 == 0) return mul(half, half);\n        return mul(half, mul(half, base));\n    }\n\n    static long modInv(long x) {\n        return fastPow(x, mod - 2);\n    }\n\n    static long nCk(int n, int k) {\n        return mul(fact(n), mul(modInv(fact(k)), modInv(fact(n - k))));\n    }\n\n    static class FastScanner {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(\"\");\n\n        public String next() {\n            while (!st.hasMoreElements())\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] readArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n    }\n}\n", "label": 5}
{"src": "import java.util.*;\n\npublic class GreatGraphs {\n\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tScanner sc = new Scanner(System.in);\n\t\tint T = sc.nextInt();\n\t\tfor(int t=0;t<T;t++) {\n\t\t\tint n= sc.nextInt();\n\t\t\tint[] d = new int[n];\n\t\t\td[0] = sc.nextInt();\n\t\t\t//int min = Integer.MAX_VALUE;\n\t\t\t//long sum = 0;\n\t\t\tfor(int i=1;i<n;i++) {\n\t\t\t\td[i] = sc.nextInt();\n\t\t\t\t//sum = sum + d[i];\n\t\t\t}\n\t\t\tArrays.sort(d);\n\t\t\tlong ans = d[n-1];\n\t\t\tlong sum = 0;\n\t\t\tfor(int i=1;i<n;i++) {\n\t\t\t\tans = ans + sum - (long)((long)i*(long)d[i]);\n\t\t\t\tsum = sum + d[i];\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\n}\n", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\n\n\n\n\n\n\n\n\n\npublic class Main {\n\n\n\n\tpublic static void main(String args[]) {\n\n\t\tScanner sc = new Scanner(System.in);\n\t\tint t = sc.nextInt();\n\t\twhile(t-- > 0){\n\t\t\tint n = sc.nextInt();\n\t\t\tlong maxi = 0;\n\t\t\t//ArrayList<Integer>a = new ArrayList<>(n);\n\t\t\tlong [] a = new long [n];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tlong x = sc.nextInt();\n\t\t\t\ta[i] = x;\n\t\t\t\tmaxi = Math.max(maxi, a[i]);\n\t\t\t}\n\t\t\t//ArrayList<Integer>dp = new ArrayList<>(n);\n\t\t\tlong [] dp = new long [n];\t\t\t\n\t\t\tlong sum = 0;\n\t\t\tArrays.sort(a);\n\t\t\tdp[0] = 0;\n\t\t\tfor(int i=1;i<n;i++) {\n\t\t\t\tdp[i] = dp[i-1] - i*(a[i] - a[i-1]);\n\t\t\t\tsum += dp[i];\n\t\t\t}\n\t\t\tsum += maxi;\n\t\t\tSystem.out.println(sum);\n\n\t\t}\n\t}\n\n\t\n\n\n\n\n\n\n\n\n\t\t\n\n\t\n\n\n\n};", "label": 5}
{"src": "import java.util.*;\nimport java.io.*;\npublic class A {\n\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tint T = sc.nextInt();\n\t\twhile(T-->0) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint[] arr = new int[n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tarr[i] = sc.nextInt();\n\t\t\t}\n\t\t\tsort(arr);\n\t\t\tlong[] brr = new long[n-1];\n\t\t\tfor(int i = 0; i < n-1; i++) {\n\t\t\t\tbrr[i] = arr[i+1] - arr[i];\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tlong fac = n-1;\n\t\t\tlong k = n-3;\n\t\t\tfor(int i = 0; i < (n-1)/2; i++) {\n\t\t\t\tres += (brr[i] + brr[n-i-2]) * fac;\n\t\t\t\tfac += k; k -= 2;\n\t\t\t}\n\t\t\tif(n % 2 == 0) {\n\t\t\t\tres += brr[n/2-1] * fac;\n\t\t\t}\n\t\t\tSystem.out.println(-res + arr[n-1]);\n\t\t}\t\n\t\t\n\t}\n\tstatic void sort(int[] arr) {\n\t\tRandom r = new Random();\n\t\tfor(int i = 0; i < arr.length; i++) {\n\t\t\tint ind = r.nextInt(arr.length);\n\t\t\tint aux = arr[ind]; arr[ind] = arr[i]; arr[i] = aux; \n\t\t}\n\t\tArrays.sort(arr);\n\t}\n\tstatic class FastScanner {\n\t\tpublic BufferedReader reader;\n\t\tpublic StringTokenizer tokenizer;\n\t\tpublic FastScanner() {\n\t\t\treader = new BufferedReader(new InputStreamReader(System.in), 32768);\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic String next() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch(IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t}\n\t\n\n}\n", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n\n\npublic class Main\n {\n//     class Reader \n//     {\n//         final private int BUFFER_SIZE = 1 << 100000000;\n//         private DataInputStream din;\n//         private byte[] buffer;\n//         private int bufferPointer, bytesRead;\n \n//         public Reader()\n//         {\n//             din = new DataInputStream(System.in);\n//             if (System.getProperty(\"ONLINE_JUDGE\") == null) \n//             {\n//             try \n//             {\n//                 System.setOut(new PrintStream(new FileOutputStream(\"output.txt\")));\n//                 din = new DataInputStream(new FileInputStream(\"input.txt\"));\n//             }\n//               catch (Exception e) {\n//             }\n//         }\n//             buffer = new byte[BUFFER_SIZE];\n//             bufferPointer = bytesRead = 0;\n//         }\n \n//         public Reader(String file_name) throws IOException\n//         {\n//             din = new DataInputStream(\n//                 new FileInputStream(file_name));\n//             buffer = new byte[BUFFER_SIZE];\n//             bufferPointer = bytesRead = 0;\n//         }\n \n//         public String readLine() throws IOException\n//         {\n//             byte[] buf = new byte[100000000]; // line length\n//             int cnt = 0, c;\n//             while ((c = read()) != -1) {\n//                 if (c == '\\n') {\n//                     if (cnt != 0) {\n//                         break;\n//                     }\n//                     else {\n//                         continue;\n//                     }\n//                 }\n//                 buf[cnt++] = (byte)c;\n//             }\n//             return new String(buf, 0, cnt);\n//         }\n \n//         public int nextInt() throws IOException\n//         {\n//             int ret = 0;\n//             byte c = read();\n//             while (c <= ' ') {\n//                 c = read();\n//             }\n//             boolean neg = (c == '-');\n//             if (neg)\n//                 c = read();\n//             do {\n//                 ret = ret * 10 + c - '0';\n//             } while ((c = read()) >= '0' && c <= '9');\n \n//             if (neg)\n//                 return -ret;\n//             return ret;\n//         }\n \n//         public long nextLong() throws IOException\n//         {\n//             long ret = 0;\n//             byte c = read();\n//             while (c <= ' ')\n//                 c = read();\n//             boolean neg = (c == '-');\n//             if (neg)\n//                 c = read();\n//             do {\n//                 ret = ret * 10 + c - '0';\n//             } while ((c = read()) >= '0' && c <= '9');\n//             if (neg)\n//                 return -ret;\n//             return ret;\n//         }\n \n//         public double nextDouble() throws IOException\n//         {\n//             double ret = 0, div = 1;\n//             byte c = read();\n//             while (c <= ' ')\n//                 c = read();\n//             boolean neg = (c == '-');\n//             if (neg)\n//                 c = read();\n \n//             do {\n//                 ret = ret * 10 + c - '0';\n//             } while ((c = read()) >= '0' && c <= '9');\n \n//             if (c == '.') {\n//                 while ((c = read()) >= '0' && c <= '9') {\n//                     ret += (c - '0') / (div *= 10);\n//                 }\n//             }\n \n//             if (neg)\n//                 return -ret;\n//             return ret;\n//         }\n \n//         private void fillBuffer() throws IOException\n//         {\n//             bytesRead = din.read(buffer, bufferPointer = 0,\n//                                  BUFFER_SIZE);\n//             if (bytesRead == -1)\n//                 buffer[0] = -1;\n//         }\n \n//         private byte read() throws IOException\n//         {\n//             if (bufferPointer == bytesRead)\n//                 fillBuffer();\n//             return buffer[bufferPointer++];\n//         }\n \n//         public void close() throws IOException\n//         {\n//             if (din == null)\n//                 return;\n//             din.close();\n//         }\n\n//     }\n    \npublic String ns() throws IOException\n    {\n        return(read.nextLine());\n    }\n    public String wrd() throws IOException\n    {\n        return(read.next());\n    }\n    public int ni() throws IOException\n    {\n        return(read.nextInt());\n    }\n    public double nd() throws IOException\n    {\n        return(read.nextDouble());\n    }\n    public long nl() throws IOException\n    {\n        return(read.nextLong());\n    }\n    public int[] ai(int n) throws IOException\n    {\n        int arr[] = new int[n];\n        for(int i = 0; i<n; i++)\n            arr[i] = read.nextInt();\n        return(arr);\n    }\n    public double[] ad(int n) throws IOException\n    {\n        double arr[] = new double[n];\n        for(int i = 0; i<n; i++)\n            arr[i] = read.nextDouble();\n        return(arr);\n    }\n    public long[] al(int n) throws IOException\n    {\n        long arr[] = new long[n];\n        for(int i = 0; i<n; i++)\n            arr[i] = read.nextLong();\n        return(arr);\n    }\n\n// Reader read;\n\n    class FastReader \n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new InputStreamReader(System.in));\n            if (System.getProperty(\"ONLINE_JUDGE\") == null) \n            {\n                 try \n                {\n                    InputStream inputStream = new FileInputStream(\"input.txt\");\n                    InputStreamReader inputStreamReader = new InputStreamReader(inputStream);\n                    System.setOut(new PrintStream(new FileOutputStream(\"output.txt\")));\n                     br = new BufferedReader(inputStreamReader);\n                }\n               catch (Exception e) \n               {\n                e.printStackTrace();\n               }\n            }\n        }\n\n    String next()\n    {\n        while (st == null || !st.hasMoreElements()) \n        {\n            try \n            {\n                st = new StringTokenizer(br.readLine());\n            }\n            catch (IOException e) \n            {\n                e.printStackTrace();\n            }\n        }\n        return st.nextToken();\n    }\n\n    int nextInt() { return Integer.parseInt(next()); }\n\n    long nextLong() { return Long.parseLong(next()); }\n\n    double nextDouble(){return Double.parseDouble(next());}\n\n    String nextLine()\n    {\n        String str = \"\";\n        try \n        {\n            str = br.readLine();\n        }\n        catch (IOException e) \n        {\n            e.printStackTrace();\n        }\n        return str;\n        }\n    }\npublic static void main(String[] args) throws IOException\n    \n    {\n        Main obj = new Main();\n        obj.solve();\n        //obj.read = new Reader();\n        \n    }\n    public int getParent(int parent[], int src)\n    {\n        if(parent[src] != src)\n        {\n            int ultimateparent = getParent(parent, parent[src]);\n            parent[src] = ultimateparent;\n            return ultimateparent;\n        }\n        return src;\n    }\n\n    public boolean union(int i, int j, int parent[] , int rank[])\n    {\n\n        int root1 = getParent(parent, i);\n        int root2 = getParent(parent, j);\n        if(root1 == root2)\n            return false;\n\n        if(rank[root1] == rank[root2])\n        {\n            parent[root1] = root2;\n            rank[root2]++ ;\n        }\n        else if(rank[root1] > rank[root2])\n        {\n            parent[root2] = root1;\n        }\n        else // rank[root2] > rank[root1]\n        {\n            parent[root1] = root2;\n        }\n        return true;\n    }\n\n\n    public int log(long x)\n    {\n        return (int) (Math.log(x) / Math.log(2) + 1e-10);\n    }\n\n    public long binomial1(long n, long r)\n    {\n        // when   n-r > r\n        long ans = 1;\n        for(long i = (n-r+1); i<=n; i++)\n            ans *= i;\n\n        for(long i = 2; i<=r; i++)\n            ans /= i;\n\n        return ans;\n    }\n    public long binomial2(long n, long r)\n    {\n        //when   r > n-r\n        long ans = 1;\n        for(long i = r+1; i<=n; i++)\n            ans *= i;\n\n        for(long i = 2; i<=(n-r); i++)\n            ans /= i;\n\n        return ans; \n    }\n\n    public long binomial(int n, int r, long dp[][])\n    {\n        // if(n-r > r)\n        //     return(binomial1(n, r));\n        // else\n        //     return(binomial2(n, r));\n        if(dp[n][r] != 0l)\n            return dp[n][r];\n        if(r == 0)\n            return 1;\n        if(n < r)\n            return 0;\n        dp[n][r] = ( ((n*1l)* binomial(n-1, r-1, dp) )/ r);\n        return(dp[n][r]);\n        \n    }\n    long gcd (long a, long b) \n    {\n        //System.out.print(\"GCD OF \"+a+\" , \"+b+\" = \");\n      long r, i;\n      while(b!=0)\n      {\n        r = a % b;\n        a = b;\n        b = r;\n      }\n      //System.out.println(\" \"+a);\n      return a;\n    }\n    public int getParent(int root, int parent[])\n    {\n        if(parent[root] == root)\n        {\n            return(root);\n        }\n        parent[root] = getParent(parent[root], parent);\n        return(parent[root]);\n    }\n\n    public void buildtree(long segmentTree[], int idx, int start, int end, long arr[])\n    {\n        if(start == end)\n        {\n            segmentTree[idx] = arr[start];\n            return;\n        }\n\n        int mid = (end + start)/2;\n\n        buildtree(segmentTree, 2*idx, start, mid, arr);\n        buildtree(segmentTree, 2*idx + 1, mid+1, end, arr);\n\n        segmentTree[idx] = gcd(segmentTree[2*idx] , segmentTree[2*idx +1]);\n    }\n\n    public long query(long segmentTree[] , int idx, int start, int end, int querystart, int queryend)\n    {\n        if(start >= querystart && end <= queryend)\n            return(segmentTree[idx]);\n        else if(end < querystart || start > queryend)\n            return 0;\n        else\n        {\n            int mid = (end + start)/2;\n            long leftQuery = query(segmentTree, 2*idx, start, mid, querystart, queryend);\n            long rightQuery = query(segmentTree, 2*idx + 1, mid+1, end, querystart, queryend);\n            return(gcd(leftQuery , rightQuery));\n        }\n    }\n\n    void reverse(char arr[])\n    {\n        int mid = arr.length/2;\n        int len = arr.length;\n\n        for(int i = 0; i<mid; i++)\n        {\n            char temp = arr[i];\n            arr[i] = arr[len - i - 1];\n            arr[len - i - 1] = temp;\n        }}\n    String reverse(String s)\n    {\n        StringBuilder sb = new StringBuilder(s);\n        return(sb.reverse().toString());\n    }\n\n    class Trie\n    {\n        Trie children[];\n        int count;\n\n        Trie()\n        {\n            children = new Trie[2];\n            count = 0;\n        }\n    }\n\n    void insertTrie(Trie head, char arr[])\n    {\n        int idx = 0;\n        Trie curr = head;\n        while( idx < arr.length)\n        {\n            int mod = (arr[idx]-'0')%2;\n            if(curr.children[mod] == null)\n            {\n                curr.children[mod] = new Trie();\n            }\n            curr = curr.children[mod];\n            curr.count++;\n            idx++;\n\n        }\n    }\n\n    void removeTrie(Trie head, char arr[])\n    {\n        int idx = 0;\n        Trie curr = head;\n        while( idx < arr.length)\n        {\n            int mod = (arr[idx]-'0')%2;\n            curr = curr.children[mod];\n            curr.count--;\n            idx++;\n        }\n    }\n\n    int query(Trie head, char pattern[])\n    {\n        int idx = 0;\n        Trie curr = head;\n\n        while( idx < pattern.length)\n        {\n            int mod = (pattern[idx]-'0');\n            if(curr.children[mod] == null)\n                return 0;\n            curr = curr.children[mod];\n            idx++;\n        }\n        return (curr == null ? 0 : curr.count);\n    }\n\n\n    void sieveOfEratosthenes(boolean prime[], int n)\n    {\n        //boolean prime[] = new boolean[n + 1];\n        for (int i = 0; i <= n; i++)\n            prime[i] = true;\n \n        for (int p = 2; p * p <= n; p++)\n        {\n            if (prime[p] == true)\n            {\n                for (int i = p * p; i <= n; i += p)\n                    prime[i] = false;\n            }\n        } }\n    long power(long x, long y, long p) \n    {\n         \n        long res = 1;\n        x = x % p;\n \n        while (y > 0) {\n             \n            // If y is odd, multiply x with result\n            if ((y & 1) == 1)\n                res = (res * x) % p;\n         \n            // y must be even now\n            y = y >> 1; // y = y/2\n            x = (x * x) % p;\n        }\n         \n        return res;\n    }\n    boolean miillerTest(long d, long n) \n    {\n         \n        // Pick a random number in [2..n-2]\n        // Corner cases make sure that n > 4\n        long a = 2 + (int)(Math.random() % (n - 4));\n     \n        // Compute a^d % n\n        long x = power(a, d, n);\n     \n        if (x == 1 || x == n - 1)\n            return true;\n     \n        // Keep squaring x while one of the\n        // following doesn't happen\n        // (i) d does not reach n-1\n        // (ii) (x^2) % n is not 1\n        // (iii) (x^2) % n is not n-1\n        while (d != n - 1) {\n            x = (x * x) % n;\n            d *= 2;\n         \n            if (x == 1)\n                return false;\n            if (x == n - 1)\n                return true;\n        }\n     \n        // Return composite\n        return false;\n    }\n    boolean isPrime(long n, int k) \n    {\n         \n        // Corner cases\n        if (n <= 1 || n == 4)\n            return false;\n        if (n <= 3)\n            return true;\n     \n        // Find r such that n = 2^d * r + 1\n        // for some r >= 1\n        long d = n - 1;\n         \n        while (d % 2 == 0)\n            d /= 2;\n     \n        // Iterate given nber of 'k' times\n        for (long i = 0; i < k; i++)\n            if (!miillerTest(d, n))\n                return false;\n     \n        return true;\n    }\n\n    ArrayList<Long> allDivisors(long n)\n    {\n        ArrayList<Long> list = new ArrayList<>();\n\n        for (long i = 2; i <= Math.sqrt(n); i++) \n        {\n            if (n % i == 0) \n            {\n                 if (n / i == i)\n                {\n                    list.add(i);\n                }\n                else \n                {\n                    list.add(i);\n                    list.add(n/i);\n                }\n            }\n        }\n\n        return(list);\n    }\n\n\n    public boolean isPalindrome(char arr[], int startIndex, int endIndex) \n    {\n        for(int i = startIndex, j = endIndex; i <= j; i++, j--) \n                {\n                    if (arr[i] != arr[j]) \n                        return false;\n                }\n        return true;\n    }\n\npublic int longestPalindrome(char arr[], int left, int right) \n{\n    int n = right - left + 1;\n    int longestLen = 0;\n    int longestIndex = 0;\n    \n    for(int currentIndex = left; currentIndex < n; currentIndex++) \n    {\n        if(isPalindrome(arr,currentIndex - longestLen, currentIndex))\n        {\n            longestLen += 1;\n            longestIndex = currentIndex;\n        } \n        else if(currentIndex - longestLen - 1 >= 0 && isPalindrome(arr, currentIndex - longestLen - 1, currentIndex)) \n        {\n            longestLen += 2;\n            longestIndex = currentIndex;\n        }   \n    }\n    longestIndex++;\n    return(longestLen);\n}\n\n//--------------------------------------------------------------------------------------------------------------\n\n\n\n    long MODULO = 1000000007;\n    FastReader read;\n    StringBuilder sb;\n    public void solve() throws IOException\n    {\n        sb = new StringBuilder();\n        read = new FastReader();\n\n        int tt = ni();\n        for(int t = 0; t < tt; t++)\n        {\n\n\n            int n = ni();\n\n            int arr[] = new int[n];\n            for(int i = 0; i<n; i++)\n            {\n                arr[i] = ni();\n            }\n            Arrays.sort(arr);\n\n            long total = 0;\n            long prev;\n            long curr;\n            prev = 0;\n            for(int i = 1; i<n; i++)\n            {\n                curr = prev + ((i)*1l * (arr[i] - arr[i-1]));\n                total -= curr;\n                prev = curr;\n            }\n            total += arr[n-1];\n            sb.append(total).append(\"\\n\");\n\n\n            \n        }\n\n\n        System.out.println(sb.toString());\n\n\n\n\n\n\n\n        \n\n\n\n\n\n\n\n\n        \n\n        \n\n    }\n\n\n\n}", "label": 5}
{"src": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.util.*;\n\npublic class A_Great_Graphs\n{\n    static class FastReader\n    {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader()\n        {\n            br = new BufferedReader(new\n                     InputStreamReader(System.in));\n        }\n\n        String next()\n        {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException  e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine()\n        {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n\n    \n\n    \n\n\n    public static void main(String[] args)\n    {\n        FastReader sc=new FastReader();\n        //PrintWriter out = new PrintWriter(System.out);\n        int t =  sc.nextInt();\n        while(t-->0){\n            int n =  sc.nextInt();\n\n            long arr[] =  new long[n];\n\n            for(int i=0;i<n;i++){\n                arr[i]=sc.nextLong();\n            }\n\n            // ArrayList<ArrayList<Integer>> adj  =  new ArrayList<>();\n\n            // for(int i=0;i<n;i++){\n            //     adj.add(new ArrayList<>());\n            // }\n\n            // for(int i=0;i<n;i++){\n            //     for(int j=0;j<n;j++){\n            //         adj.get(i).add(arr[j]-arr[i]);\n            //     }\n            // }\n\n            // // for(int i=0;i<n;i++){\n            // //     for(int j=0;j<n;j++){\n            // //         System.out.print(adj.get(i).get(j) + \" \");\n            // //     }\n            // // }\n\n\n            Arrays.sort(arr);\n\n           long sum =arr[n-1];\n            long neg[] =  new long[n];\n\n            neg[0]=0;\n\n            for(int i=1;i<n;i++){\n\n                   neg[i]=neg[i-1] + i*(arr[i]-arr[i-1]);\n                    sum-=neg[i];\n                \n            }\n\n            //System.out.println();\n\n             System.out.println(sum);\n\n\n        }\n\n       \n\n       \n       \n\n\n    }\n\n    // static int dfs(int i,int j,int cost){\n\n\n\n    // }\n}", "label": 5}
{"src": "//package codeforces;\t\nimport java.io.*;\nimport java.util.*;\npublic class Solution {\n\tstatic class FastReader {\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tpublic FastReader() {\n\t\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t\t}\n\n\t\tString next() {\n\t\t\twhile (st == null || !st.hasMoreElements()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(br.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint ni() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tlong nl() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nd() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tString str = \"\";\n\t\t\ttry {\n\t\t\t\tstr = br.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\treturn str;\n\t\t}\n\t}\n\n\t\n\tpublic static void main(String[] args) throws java.lang.Exception {\n\t\tFastReader fr = new FastReader();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\tint t = fr.ni();\n\t\twhile(t-->0) {\n\t\t\tint n = fr.ni();\n\t\t\tLong arr [] = new Long[n];\n\t\t\tlong sum = 0;\n\t\t\tLong pre [] = new Long [n];\n\t\t\tfor(int i = 0 ; i < n ; i++) {\n\t\t\t\tarr[i] = fr.nl();\n\t\t\t}\n\t\t\tArrays.sort(arr);\n\t\t\tfor(int i = 0 ; i < n ; i++) {\n\t\t\t\tsum+= arr[i];\n\t\t\t\tpre[i] = sum;\n\t\t\t}\n\t\t\tlong ans = 0;\n\t\t\tint i = n-1;\n\t\t\twhile(i >= 0) {\n\t\t\t\tif(i-2 >= 0) {\n\t\t\t\t\tlong temp = arr[i]*(i-1);\n\t\t\t\t\tans += (temp - pre[i-2]);\n\t\t\t\t}else break;\n\t\t\t\ti--;\n\t\t\t}\n\t\t\tout.println(0-ans);\n\t\t\t\n\t\t}\n\t\tout.close();\n\t}\n\t\n}", "label": 5}
{"src": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class cf1540a {\n\n    public static void main(String[] args) throws IOException {\n        int t = ri();\n        while (t --> 0) {\n            int n = ri(), d[] = ria(n);\n            rsort(d);\n            long pre[] = new long[n + 1], ans = 0;\n            for (int i = 0; i < n; ++i) {\n                pre[i + 1] = pre[i] + d[i];\n            }\n            for (int i = 1; i < n; ++i) {\n                ans += (long) (i - 1) * d[i] - pre[i - 1];\n            }\n            prln(-ans);\n        }\n        close();\n    }\n\n    static BufferedReader __i = new BufferedReader(new InputStreamReader(System.in));\n    static PrintWriter __o = new PrintWriter(new OutputStreamWriter(System.out));\n    static StringTokenizer input;\n    static Random __r = new Random();\n\n    // references\n    // IBIG = 1e9 + 7\n    // IMAX ~= 2e9\n    // LMAX ~= 9e18\n\n    // constants\n    static final int IBIG = 1000000007;\n    static final int IMAX = 2147483647;\n    static final long LMAX = 9223372036854775807L;\n    // math util\n    static int minof(int a, int b, int c) {return min(a, min(b, c));}\n    static int minof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); int min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static long minof(long a, long b, long c) {return min(a, min(b, c));}\n    static long minof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return min(x[0], x[1]); if (x.length == 3) return min(x[0], min(x[1], x[2])); long min = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] < min) min = x[i]; return min;}\n    static int maxof(int a, int b, int c) {return max(a, max(b, c));}\n    static int maxof(int... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); int max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static long maxof(long a, long b, long c) {return max(a, max(b, c));}\n    static long maxof(long... x) {if (x.length == 1) return x[0]; if (x.length == 2) return max(x[0], x[1]); if (x.length == 3) return max(x[0], max(x[1], x[2])); long max = x[0]; for (int i = 1; i < x.length; ++i) if (x[i] > max) max = x[i]; return max;}\n    static int powi(int a, int b) {if (a == 0) return 0; int ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static long powl(long a, int b) {if (a == 0) return 0; long ans = 1; while (b > 0) {if ((b & 1) > 0) ans *= a; a *= a; b >>= 1;} return ans;}\n    static int fli(double d) {return (int) d;}\n    static int cei(double d) {return (int) ceil(d);}\n    static long fll(double d) {return (long) d;}\n    static long cel(double d) {return (long) ceil(d);}\n    static int gcd(int a, int b) {return b == 0 ? a : gcd(b, a % b);}\n    static long gcd(long a, long b) {return b == 0 ? a : gcd(b, a % b);}\n    static int[] exgcd(int a, int b) {if (b == 0) return new int[] {1, 0}; int[] y = exgcd(b, a % b); return new int[] {y[1], y[0] - y[1] * (a / b)};}\n    static long[] exgcd(long a, long b) {if (b == 0) return new long[] {1, 0}; long[] y = exgcd(b, a % b); return new long[] {y[1], y[0] - y[1] * (a / b)};}\n    static int randInt(int min, int max) {return __r.nextInt(max - min + 1) + min;}\n    static long mix(long x) {x += 0x9e3779b97f4a7c15L; x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9L; x = (x ^ (x >> 27)) * 0x94d049bb133111ebL; return x ^ (x >> 31);}\n    // array util\n    static void reverse(int[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {int swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(long[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {long swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(double[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {double swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void reverse(char[] a) {for (int i = 0, n = a.length, half = n / 2; i < half; ++i) {char swap = a[i]; a[i] = a[n - i - 1]; a[n - i - 1] = swap;}}\n    static void shuffle(int[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); int swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(long[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); long swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void shuffle(double[] a) {int n = a.length - 1; for (int i = 0; i < n; ++i) {int ind = randInt(i, n); double swap = a[i]; a[i] = a[ind]; a[ind] = swap;}}\n    static void rsort(int[] a) {shuffle(a); sort(a);}\n    static void rsort(long[] a) {shuffle(a); sort(a);}\n    static void rsort(double[] a) {shuffle(a); sort(a);}\n    static int[] copy(int[] a) {int[] ans = new int[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static long[] copy(long[] a) {long[] ans = new long[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static double[] copy(double[] a) {double[] ans = new double[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    static char[] copy(char[] a) {char[] ans = new char[a.length]; for (int i = 0; i < a.length; ++i) ans[i] = a[i]; return ans;}\n    // input\n    static void r() throws IOException {input = new StringTokenizer(rline());}\n    static int ri() throws IOException {return Integer.parseInt(rline());}\n    static long rl() throws IOException {return Long.parseLong(rline());}\n    static double rd() throws IOException {return Double.parseDouble(rline());}\n    static int[] ria(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni(); return a;}\n    static void ria(int[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = ni();}\n    static int[] riam1(int n) throws IOException {int[] a = new int[n]; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1; return a;}\n    static void riam1(int[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = ni() - 1;}\n    static long[] rla(int n) throws IOException {long[] a = new long[n]; r(); for (int i = 0; i < n; ++i) a[i] = nl(); return a;}\n    static void rla(long[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = nl();}\n    static double[] rda(int n) throws IOException {double[] a = new double[n]; r(); for (int i = 0; i < n; ++i) a[i] = nd(); return a;}\n    static void rda(double[] a) throws IOException {int n = a.length; r(); for (int i = 0; i < n; ++i) a[i] = nd();}\n    static char[] rcha() throws IOException {return rline().toCharArray();}\n    static void rcha(char[] a) throws IOException {int n = a.length, i = 0; for (char c : rline().toCharArray()) a[i++] = c;}\n    static String rline() throws IOException {return __i.readLine();}\n    static String n() {return input.nextToken();}\n    static int rni() throws IOException {r(); return ni();}\n    static int ni() {return Integer.parseInt(n());}\n    static long rnl() throws IOException {r(); return nl();}\n    static long nl() {return Long.parseLong(n());}\n    static double rnd() throws IOException {r(); return nd();}\n    static double nd() {return Double.parseDouble(n());}\n    // output\n    static void pr(int i) {__o.print(i);}\n    static void prln(int i) {__o.println(i);}\n    static void pr(long l) {__o.print(l);}\n    static void prln(long l) {__o.println(l);}\n    static void pr(double d) {__o.print(d);}\n    static void prln(double d) {__o.println(d);}\n    static void pr(char c) {__o.print(c);}\n    static void prln(char c) {__o.println(c);}\n    static void pr(char[] s) {__o.print(new String(s));}\n    static void prln(char[] s) {__o.println(new String(s));}\n    static void pr(String s) {__o.print(s);}\n    static void prln(String s) {__o.println(s);}\n    static void pr(Object o) {__o.print(o);}\n    static void prln(Object o) {__o.println(o);}\n    static void prln() {__o.println();}\n    static void pryes() {prln(\"yes\");}\n    static void pry() {prln(\"Yes\");}\n    static void prY() {prln(\"YES\");}\n    static void prno() {prln(\"no\");}\n    static void prn() {prln(\"No\");}\n    static void prN() {prln(\"NO\");}\n    static boolean pryesno(boolean b) {prln(b ? \"yes\" : \"no\"); return b;};\n    static boolean pryn(boolean b) {prln(b ? \"Yes\" : \"No\"); return b;}\n    static boolean prYN(boolean b) {prln(b ? \"YES\" : \"NO\"); return b;}\n    static void prln(int... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(long... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static void prln(double... a) {for (int i = 0, len = a.length - 1; i < len; pr(a[i]), pr(' '), ++i); if (a.length > 0) prln(a[a.length - 1]); else prln();}\n    static <T> void prln(Collection<T> c) {int n = c.size() - 1; Iterator<T> iter = c.iterator(); for (int i = 0; i < n; pr(iter.next()), pr(' '), ++i); if (n >= 0) prln(iter.next()); else prln();}\n    static void h() {prln(\"hlfd\"); flush();}\n    static void flush() {__o.flush();}\n    static void close() {__o.close();}\n}", "label": 5}
{"src": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.min;\nimport static java.lang.Math.abs;\nimport static java.lang.Math.max;\npublic class EdA {\n\tstatic long[] mods = {1000000007, 998244353, 1000000009};\n\tstatic long mod = mods[0];\n\tpublic static MyScanner sc;\n    public static PrintWriter out;\n\tpublic static void main(String[] largewang) throws Exception{\n\t\t// TODO Auto-generated method stub\n \t\tsc = new MyScanner();\n \t\tout = new PrintWriter(System.out);\n \t\tint t = sc.nextInt();\n \t\twhile (t-->0) {\n \t\t\tint n = sc.nextInt();\n \t\t\tint[] arr =readArrayInt(n);\n \t\t\tsort(arr);\n \t\t\tlong sum = 0;\n \t\t\tfor(int j = 1;j<n;j++){\n \t\t\t\tint left = j;\n \t\t\t\tint right = n-j;\n \t\t\t\tsum -= (long)left*(long)right*(long)(arr[j]-arr[j-1]);\n \t\t\t}\n \t\t\tfor(int j = 1;j<n;j++){\n \t\t\t\tsum += (arr[j] - arr[j-1]);\n \t\t\t}\n \t\t\tout.println(sum);\n \t\t}\n \t\tout.close();\n \t\t\n \t}\n\t\n\tpublic static void sort(int[] array){\n\t\tArrayList<Integer> copy = new ArrayList<>();\n\t\tfor (int i : array)\n\t\t\tcopy.add(i);\n\t\tCollections.sort(copy);\n\t\tfor(int i = 0;i<array.length;i++)\n\t\t\tarray[i] = copy.get(i);\n\t}\n\tstatic String[] readArrayString(int n){\n\t\tString[] array = new String[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.next();\n\t\treturn array;\n\t}\n\tstatic int[] readArrayInt(int n){\n    \tint[] array = new int[n];\n    \tfor(int j = 0;j<n;j++)\n    \t\tarray[j] = sc.nextInt();\n    \treturn array;\n    }\n\tstatic int[] readArrayInt1(int n){\n\t\tint[] array = new int[n+1];\n\t\tfor(int j = 1;j<=n;j++){\n\t\t\tarray[j] = sc.nextInt();\n\t\t}\n\t\treturn array;\n\t}\n\tstatic long[] readArrayLong(int n){\n\t\tlong[] array = new long[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextLong();\n\t\treturn array;\n\t}\n\tstatic double[] readArrayDouble(int n){\n\t\tdouble[] array = new double[n];\n\t\tfor(int j =0 ;j<n;j++)\n\t\t\tarray[j] = sc.nextDouble();\n\t\treturn array;\n\t}\n\tstatic int minIndex(int[] array){\n\t\tint minValue = Integer.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(long[] array){\n\t\tlong minValue = Long.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic int minIndex(double[] array){\n\t\tdouble minValue = Double.MAX_VALUE;\n\t\tint minIndex = -1;\n\t\tfor(int j = 0;j<array.length;j++){\n\t\t\tif (array[j] < minValue){\n\t\t\t\tminValue = array[j];\n\t\t\t\tminIndex = j;\n\t\t\t}\n\t\t}\n\t\treturn minIndex;\n\t}\n\tstatic long power(long x, long y){\n\t\tif (y == 0)\n\t\t\treturn 1;\n\t\tif (y%2 == 1)\n\t\t\treturn (x*power(x, y-1))%mod;\n\t\treturn power((x*x)%mod, y/2)%mod;\n\t}\n\tstatic void verdict(boolean a){\n        out.println(a ? \"YES\" : \"NO\");\n    }\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } \n                catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n        String nextLine() {\n            String str = \"\";\n            try{\n                str = br.readLine();\n            } \n            catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n        \n    }\t\n}\n\n//StringJoiner sj = new StringJoiner(\" \"); \n//sj.add(strings)\n//sj.toString() gives string of those stuff w spaces or whatever that sequence is", "label": 5}
{"src": "import java.io.BufferedOutputStream;\nimport java.io.BufferedReader;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.math.BigInteger;\nimport java.util.Arrays;\nimport java.util.Locale;\nimport java.util.Random;\nimport java.util.StringTokenizer;\n\npublic class Solution implements Runnable {\n\t\n\tprivate PrintStream out;\n\tprivate BufferedReader in;\n\tprivate StringTokenizer st;\n\t\n\tpublic void solve() throws IOException {\n\t\tlong time0 = System.currentTimeMillis();\n\t\t\n\t\tint t = nextInt();\n\t\tfor (int test = 1; test <= t; test++) {\n\t\t\tint n = nextInt();\n\t\t\tint[] d = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\td[i] = nextInt();\n\t\t\t}\n\t\t\tBigInteger answer = solve(n, d);\n\t\t\tout.println(answer);\n\t\t}\n\t\t\n\t\tSystem.err.println(\"time: \" + (System.currentTimeMillis() - time0));\n\t}\n\t\n\tprivate BigInteger solve(int n, int[] d) {\n\t\tRandom rnd = new Random();\n\t\tfor (int i = 0; i < n / 100; i++) {\n\t\t\tint u = rnd.nextInt(n);\n\t\t\tint v = rnd.nextInt(n);\n\t\t\tint tmp = d[u];\n\t\t\td[u] = d[v];\n\t\t\td[v] = tmp;\n\t\t}\n\t\tArrays.sort(d);\n\t\tlong sum = 0;\n\t\tBigInteger answer = BigInteger.ZERO;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tBigInteger appendix = BigInteger.valueOf((d[i] - d[i - 1]) - (i * (long) d[i] - sum));\n\t\t\tanswer = answer.add(appendix);\n\t\t\tsum += d[i];\n\t\t}\n\t\treturn answer;\n\t}\n\n\tpublic double nextDouble() throws IOException {\n\t\treturn Double.parseDouble(next());\n\t}\n\t\n\tpublic long nextLong() throws IOException {\n\t\treturn Long.parseLong(next());\n\t}\n\t\n\tpublic int nextInt() throws IOException {\n\t\treturn Integer.parseInt(next());\n\t}\n\t\n\tpublic String next() throws IOException {\n\t\twhile (!st.hasMoreTokens()) {\n\t\t\tString line = in.readLine();\n\t\t\tif (line == null) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tst = new StringTokenizer(line);\n\t\t}\n\t\treturn st.nextToken();\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tsolve();\n\t\t\tout.close();\n\t\t} catch (Throwable e) {\n\t\t\tthrow new RuntimeException(e);\n\t\t}\n\t}\n\t\n\tpublic Solution(String name) throws IOException {\n\t\tLocale.setDefault(Locale.US);\n\t\tif (name == null) {\n\t\t\tin = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tout = new PrintStream(new BufferedOutputStream(System.out));\n\t\t} else {\n\t\t\tin = new BufferedReader(new InputStreamReader(new FileInputStream(name + \".in\")));\n\t\t\tout = new PrintStream(new BufferedOutputStream(new FileOutputStream(name + \".out\")));\n\t\t}\n\t\tst = new StringTokenizer(\"\");\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tnew Thread(new Solution(null)).start();\n\t}\n}\n", "label": 5}
{"src": "import java.util.*;\nimport java.io.*;\nimport java.math.*;\n\n/* Name of the class has to be \"Main\" only if the class is public. */\npublic class Coder {\n  static int n;\n  static long a[];\n  static StringBuilder str = new StringBuilder(\"\");\n \n  static void solve() {\n      if(n<=2) str.append(\"0\").append(\"\\n\");\n      else{\n          Arrays.sort(a);\n          long pre[] = new long[n];\n          pre[0]=a[0];\n          long ans=0;\n          for(int i=1;i<n;i++){\n              ans+=a[i]-a[i-1];\n              ans+=pre[i-1]-(i*a[i]);\n              pre[i]=pre[i-1]+a[i];\n          }\n          str.append(ans).append(\"\\n\");\n      }\n  }\n\n  public static void main(String[] args) throws java.lang.Exception {\n    BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n    int t = Integer.parseInt(bf.readLine().trim());\n    while (t-- > 0) {\n    //   bf.readLine();\n      n = Integer.parseInt(bf.readLine().trim());\n      a=new long[n];\n      String s[] = bf.readLine().trim().split(\"\\\\s+\");\n      for(int i=0;i<n;i++) a[i] = Long.parseLong(s[i]);\n      solve();\n    }\n    System.out.print(str);\n  }\n}", "label": 5}
{"src": "import java.util.*;\nimport java.lang.*;\nimport java.io.*;\npublic class a {\n    static final int mod = 1000000007;\n    static FastReader sc = new FastReader();\n    static PrintWriter out = new PrintWriter(System.out);\n    public static void main (String[] args) throws java.lang.Exception {        \n        int t = sc.nextInt();        \n        while(t-->0) {\n            int n = sc.nextInt();\n            long arr[] = new long[n];\n            for(int i = 0 ;i < n; i++)\n                arr[i] = sc.nextInt();\n            Arrays.sort(arr);\n            long sum = arr[n-1];\n            long neg[] = new long[n];\n            neg[0] = 0 ;\n            for(int i = 1 ; i < n; i++) {\n                neg[i] = neg[i-1] - i * (arr[i]-arr[i-1]);\n                sum += neg[i];\n            }   \n            out.println(sum);\n        }\n        out.flush();\n    }\n}\nclass FastReader{ \n     \n        BufferedReader br; \n        StringTokenizer st; \n  \n        public FastReader() \n        { \n            br = new BufferedReader(new\n                     InputStreamReader(System.in)); \n        } \n  \n        String next() \n        { \n            while (st == null || !st.hasMoreElements()) \n            { \n                try\n                { \n                    st = new StringTokenizer(br.readLine()); \n                } \n                catch (IOException  e) \n                { \n                    e.printStackTrace(); \n                } \n            } \n            return st.nextToken(); \n        } \n  \n        int nextInt() \n        { \n            return Integer.parseInt(next()); \n        } \n  \n        long nextLong() \n        { \n            return Long.parseLong(next()); \n        } \n  \n        double nextDouble() \n        { \n            return Double.parseDouble(next()); \n        } \n  \n        String nextLine() \n        { \n            String str = \"\"; \n            try\n            { \n                str = br.readLine(); \n            } \n            catch (IOException e) \n            { \n                e.printStackTrace(); \n            } \n            return str; \n        } \n    }", "label": 5}
{"src": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n  public static void main(String[] args) {\n    Scanner sc = new Scanner(System.in);\n\n    int t = sc.nextInt();\n    for (int tc = 0; tc < t; ++tc) {\n      int n = sc.nextInt();\n      int[] d = new int[n];\n      for (int i = 0; i < d.length; ++i) {\n        d[i] = sc.nextInt();\n      }\n\n      System.out.println(solve(d));\n    }\n\n    sc.close();\n  }\n\n  static long solve(int[] d) {\n    int[] sorted = Arrays.stream(d).boxed().sorted().mapToInt(x -> x).toArray();\n\n    long result = sorted[sorted.length - 1];\n    long prefixSum = 0;\n    for (int i = 0; i < sorted.length; ++i) {\n      result -= (long) sorted[i] * i - prefixSum;\n      prefixSum += sorted[i];\n    }\n\n    return result;\n  }\n}\n", "label": 5}
{"src": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.StringTokenizer;\n\npublic class A_GreatGraphs_1400 {\n    public static void main(String[] args) {\n        MyScanner sc = new MyScanner();\n        out = new PrintWriter(new BufferedOutputStream(System.out));\n        int t = sc.nextInt();\n        while(t-->0) {\n            int N = sc.nextInt();\n            int[] arr = new int[N];\n            for(int i = 0; i < N; i++) {\n                arr[i] = sc.nextInt();\n            }\n            Arrays.sort(arr);\n            // 1 -> N: straight line from 1 -> N\n            long ans = arr[N-1];\n            // N -> 1: connections between every single pasture\n            long[] connections = new long[N-1];\n            long curSumConnections = 0; // find sum of all connections to current i\n            for(int i = 0; i < N-1; i++) {\n                connections[i] = arr[i+1] - arr[i];\n                curSumConnections += connections[i]*(N-1-i);\n            }\n            ans -= curSumConnections;\n            for(int i = 0; i < N-1; i++) {\n                curSumConnections -= (connections[i])*(N-1-i);\n                ans -= curSumConnections;\n            }\n            System.out.println(ans);\n        }\n\n\n        out.close();\n    }\n\n    public static PrintWriter out;\n\n    public static class MyScanner {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public MyScanner() {\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements()) {\n                try {\n                    st = new StringTokenizer(br.readLine());\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble() {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine(){\n            String str = \"\";\n            try {\n                str = br.readLine();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            return str;\n        }\n\n    }\n    static class Pair {\n        public int x,y;\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n}\n", "label": 5}
